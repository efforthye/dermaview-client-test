import { ipcMain, app, BrowserWindow, protocol, dialog } from "electron";
import fs from "node:fs";
import path$1 from "node:path";
import { fileURLToPath } from "node:url";
import SQlite3, { SqliteError } from "better-sqlite3";
import * as assert from "node:assert";
import assert__default from "node:assert";
import require$$0$2 from "util";
import require$$0$1, { Readable } from "stream";
import require$$1 from "path";
import require$$3 from "http";
import require$$4 from "https";
import require$$0$3 from "url";
import require$$0$4 from "fs";
import require$$0$5 from "crypto";
import require$$5 from "assert";
import require$$1$1 from "tty";
import require$$0$6 from "os";
import zlib from "zlib";
import require$$2$1, { EventEmitter } from "events";
import require$$0$7 from "buffer";
import require$$0$8 from "string_decoder";
import require$$0$9 from "constants";
const IPC_CALLS = {
  INITIALIZE_DATABASE: "initialize-database",
  CHECK_DB_HEALTH: "check-db-health",
  CREATE_USER: "create-user",
  LIST_USERS: "list-users",
  UPLOAD_IMAGES: "upload-images",
  LIST_IMAGES: "list-images",
  SIGN_IN: "signIn",
  SIGN_UP: "signUp"
};
const USER_SQL = `
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    password TEXT NOT NULL,
    role TEXT CHECK (role IN ('admin', 'user')) NOT NULL DEFAULT 'user'
);
`;
class Image {
}
const IMAGE_SQL = `
CREATE TABLE IF NOT EXISTS images (
    digest TEXT PRIMARY KEY,
    patientId TEXT NOT NULL,
    patientName TEXT NOT NULL,
    uploadedAt TEXT NOT NULL,
    disease TEXT NOT NULL,
    department TEXT NOT NULL
);`;
const IMAGE_BOOKMARK_SQL = `
CREATE TABLE IF NOT EXISTS image_bookmarks (
    userId INTEGER NOT NULL,
    digest TEXT NOT NULL,
    PRIMARY KEY (userId, digest),
    FOREIGN KEY (userId) REFERENCES users(id),
    FOREIGN KEY (digest) REFERENCES images(digest)
);`;
function searchImages(query, queryField) {
  assert__default.ok(conn, "Database connection is not established");
  if (!queryField || !query) {
    const images2 = conn.prepare(`SELECT * FROM images;`).all();
    return images2;
  }
  const fields = Object.keys(new Image());
  if (!fields.includes(queryField)) {
    console.error(`Invalid query field: ${queryField}`);
    return [];
  }
  const images = conn.prepare(`SELECT * FROM images WHERE ${queryField} LIKE '%${query}%';`).all();
  console.log(images);
  return images;
}
let conn;
function setConnection(databasePath) {
  if (!conn) {
    conn = new SQlite3(databasePath);
  } else {
    console.log("Connection is cached.");
  }
}
ipcMain.handle(IPC_CALLS.CHECK_DB_HEALTH, async () => {
  try {
    assert.ok(conn, "Database connection is not established");
    return true;
  } catch (e) {
    return false;
  }
});
ipcMain.handle(IPC_CALLS.INITIALIZE_DATABASE, async () => {
  return ensureTables();
});
const ensureTables = () => {
  assert.ok(conn, "Database connection is not established");
  const tables = conn.prepare(`SELECT name FROM sqlite_master WHERE type='table';`).all();
  const isUserTableExistedBefore = tables.some(
    (table2) => table2.name === "users"
  );
  createUserTable(isUserTableExistedBefore);
  createImageTable();
  createImageBookmarkTable();
};
const createUserTable = (isUserTableExistedBefore) => {
  assert.ok(conn, "Database connection is not established");
  conn.exec(USER_SQL);
  conn.exec(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_users_name ON users (name);
    `);
  if (!isUserTableExistedBefore) {
    conn.exec(`
            INSERT INTO users (name, password, role) VALUES ('admin', 'admin', 'admin');
        `);
  }
};
const createImageTable = () => {
  assert.ok(conn, "Database connection is not established");
  conn.exec(IMAGE_SQL);
  conn.exec(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_images_digest ON images (digest);
    `);
};
const createImageBookmarkTable = () => {
  assert.ok(conn, "Database connection is not established");
  conn.exec(IMAGE_BOOKMARK_SQL);
  conn.exec(`
        CREATE UNIQUE INDEX IF NOT EXISTS idx_users ON image_bookmarks (userId, digest);
    `);
};
ipcMain.handle(
  IPC_CALLS.CREATE_USER,
  async (event, role, name, password) => {
    assert.ok(conn, "Database connection is not established");
    const admin = conn.prepare(
      `
        SELECT * FROM users WHERE role = "admin";
    `
    ).get();
    console.log(admin);
    if (admin && role === "admin") {
      return "Admin already exists";
    }
    const result = conn.exec(`
        INSERT INTO users (name, password, role) VALUES ('${name}', '${password}', '${role}');
    `);
    console.log(result);
    return result;
  }
);
ipcMain.handle(
  IPC_CALLS.LIST_USERS,
  async () => {
    assert.ok(conn, "Database connection is not established");
    const users = conn.prepare(`SELECT * FROM users;`).all();
    console.log(users);
    return users;
  }
);
ipcMain.handle(
  IPC_CALLS.LIST_IMAGES,
  async (event, query, queryField) => {
    return searchImages(query, queryField);
  }
);
ipcMain.handle(
  IPC_CALLS.UPLOAD_IMAGES,
  async (event, images) => {
    assert.ok(conn, "Database connection is not established");
    const stmt = conn.prepare(`
            INSERT INTO images (digest, patientId, patientName, uploadedAt, disease, department) VALUES (@digest, @patientId, @patientName, @uploadedAt, @disease, @department);
        `);
    const result = images.map((image2) => {
      return stmt.run(image2);
    });
    console.log(result);
    return result;
  }
);
ipcMain.handle(
  IPC_CALLS.SIGN_IN,
  async (event, name, password) => {
    assert.ok(conn, "Database connection is not established");
    try {
      const user = conn.prepare(
        `
            SELECT * FROM users WHERE name = '${name}' AND password = '${password}';
        `
      ).get();
      return user;
    } catch (e) {
      console.error(e);
      if (e instanceof SqliteError && e.message.includes("no such table")) {
        ensureTables();
      }
    }
  }
);
ipcMain.handle(
  IPC_CALLS.SIGN_UP,
  async (event, name, password) => {
    assert.ok(conn, "Database connection is not established");
    const result = conn.exec(`
        INSERT INTO users (name, password) VALUES ('${name}', '${password}');
    `);
    console.log(result);
    return result;
  }
);
const ensureAllTableExists = () => {
  assert.ok(conn, "Database connection is not established");
  ensureTables();
};
const getCreationTime = async (filePath) => {
  try {
    const stat = fs.statSync(filePath);
    console.log(stat);
    return stat.birthtime;
  } catch (error2) {
    console.error(`Error reading metadata for ${filePath}:`, error2);
    return /* @__PURE__ */ new Date();
  }
};
function bind$1(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const { iterator, toStringTag } = Symbol;
const kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type2) => {
  type2 = type2.toLowerCase();
  return (thing) => kindOf(thing) === type2;
};
const typeOfTest = (type2) => (thing) => typeof thing === type2;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits$1 = (constructor, superConstructor, props2, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props2 && Object.assign(constructor.prototype, props2);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props2;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props2 = Object.getOwnPropertyNames(sourceObj);
    i = props2.length;
    while (i-- > 0) {
      prop = props2[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const isIterable = (thing) => thing != null && isFunction(thing[iterator]);
const utils$2 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits: inherits$1,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};
function AxiosError$1(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils$2.inherits(AxiosError$1, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$2.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError$1.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError$1.from = (error2, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$2.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError$1.call(axiosError, error2.message, code, config, request, response);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var delayed_stream;
var hasRequiredDelayed_stream;
function requireDelayed_stream() {
  if (hasRequiredDelayed_stream) return delayed_stream;
  hasRequiredDelayed_stream = 1;
  var Stream = require$$0$1.Stream;
  var util2 = require$$0$2;
  delayed_stream = DelayedStream;
  function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
  }
  util2.inherits(DelayedStream, Stream);
  DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for (var option in options) {
      delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
      delayedStream._handleEmit(arguments);
      return realEmit.apply(source, arguments);
    };
    source.on("error", function() {
    });
    if (delayedStream.pauseStream) {
      source.pause();
    }
    return delayedStream;
  };
  Object.defineProperty(DelayedStream.prototype, "readable", {
    configurable: true,
    enumerable: true,
    get: function() {
      return this.source.readable;
    }
  });
  DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
  };
  DelayedStream.prototype.resume = function() {
    if (!this._released) {
      this.release();
    }
    this.source.resume();
  };
  DelayedStream.prototype.pause = function() {
    this.source.pause();
  };
  DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
      this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
  };
  DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
  };
  DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
      this.emit.apply(this, args);
      return;
    }
    if (args[0] === "data") {
      this.dataSize += args[1].length;
      this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
  };
  DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
      return;
    }
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    this._maxDataSizeExceeded = true;
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this.emit("error", new Error(message));
  };
  return delayed_stream;
}
var combined_stream;
var hasRequiredCombined_stream;
function requireCombined_stream() {
  if (hasRequiredCombined_stream) return combined_stream;
  hasRequiredCombined_stream = 1;
  var util2 = require$$0$2;
  var Stream = require$$0$1.Stream;
  var DelayedStream = requireDelayed_stream();
  combined_stream = CombinedStream;
  function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
  }
  util2.inherits(CombinedStream, Stream);
  CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for (var option in options) {
      combinedStream[option] = options[option];
    }
    return combinedStream;
  };
  CombinedStream.isStreamLike = function(stream2) {
    return typeof stream2 !== "function" && typeof stream2 !== "string" && typeof stream2 !== "boolean" && typeof stream2 !== "number" && !Buffer.isBuffer(stream2);
  };
  CombinedStream.prototype.append = function(stream2) {
    var isStreamLike = CombinedStream.isStreamLike(stream2);
    if (isStreamLike) {
      if (!(stream2 instanceof DelayedStream)) {
        var newStream = DelayedStream.create(stream2, {
          maxDataSize: Infinity,
          pauseStream: this.pauseStreams
        });
        stream2.on("data", this._checkDataSize.bind(this));
        stream2 = newStream;
      }
      this._handleErrors(stream2);
      if (this.pauseStreams) {
        stream2.pause();
      }
    }
    this._streams.push(stream2);
    return this;
  };
  CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
  };
  CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
      this._pendingNext = true;
      return;
    }
    this._insideLoop = true;
    try {
      do {
        this._pendingNext = false;
        this._realGetNext();
      } while (this._pendingNext);
    } finally {
      this._insideLoop = false;
    }
  };
  CombinedStream.prototype._realGetNext = function() {
    var stream2 = this._streams.shift();
    if (typeof stream2 == "undefined") {
      this.end();
      return;
    }
    if (typeof stream2 !== "function") {
      this._pipeNext(stream2);
      return;
    }
    var getStream = stream2;
    getStream((function(stream3) {
      var isStreamLike = CombinedStream.isStreamLike(stream3);
      if (isStreamLike) {
        stream3.on("data", this._checkDataSize.bind(this));
        this._handleErrors(stream3);
      }
      this._pipeNext(stream3);
    }).bind(this));
  };
  CombinedStream.prototype._pipeNext = function(stream2) {
    this._currentStream = stream2;
    var isStreamLike = CombinedStream.isStreamLike(stream2);
    if (isStreamLike) {
      stream2.on("end", this._getNext.bind(this));
      stream2.pipe(this, { end: false });
      return;
    }
    var value = stream2;
    this.write(value);
    this._getNext();
  };
  CombinedStream.prototype._handleErrors = function(stream2) {
    var self2 = this;
    stream2.on("error", function(err) {
      self2._emitError(err);
    });
  };
  CombinedStream.prototype.write = function(data2) {
    this.emit("data", data2);
  };
  CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
      return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
    this.emit("pause");
  };
  CombinedStream.prototype.resume = function() {
    if (!this._released) {
      this._released = true;
      this.writable = true;
      this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
    this.emit("resume");
  };
  CombinedStream.prototype.end = function() {
    this._reset();
    this.emit("end");
  };
  CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit("close");
  };
  CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
  };
  CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
      return;
    }
    var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
    this._emitError(new Error(message));
  };
  CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self2 = this;
    this._streams.forEach(function(stream2) {
      if (!stream2.dataSize) {
        return;
      }
      self2.dataSize += stream2.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
      this.dataSize += this._currentStream.dataSize;
    }
  };
  CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit("error", err);
  };
  return combined_stream;
}
var mimeTypes = {};
const require$$0 = {
  "application/1d-interleaved-parityfec": { "source": "iana" },
  "application/3gpdash-qoe-report+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/3gpp-ims+xml": { "source": "iana", "compressible": true },
  "application/3gpphal+json": { "source": "iana", "compressible": true },
  "application/3gpphalforms+json": { "source": "iana", "compressible": true },
  "application/a2l": { "source": "iana" },
  "application/ace+cbor": { "source": "iana" },
  "application/activemessage": { "source": "iana" },
  "application/activity+json": { "source": "iana", "compressible": true },
  "application/alto-costmap+json": { "source": "iana", "compressible": true },
  "application/alto-costmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-directory+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcost+json": { "source": "iana", "compressible": true },
  "application/alto-endpointcostparams+json": { "source": "iana", "compressible": true },
  "application/alto-endpointprop+json": { "source": "iana", "compressible": true },
  "application/alto-endpointpropparams+json": { "source": "iana", "compressible": true },
  "application/alto-error+json": { "source": "iana", "compressible": true },
  "application/alto-networkmap+json": { "source": "iana", "compressible": true },
  "application/alto-networkmapfilter+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamcontrol+json": { "source": "iana", "compressible": true },
  "application/alto-updatestreamparams+json": { "source": "iana", "compressible": true },
  "application/aml": { "source": "iana" },
  "application/andrew-inset": { "source": "iana", "extensions": ["ez"] },
  "application/applefile": { "source": "iana" },
  "application/applixware": { "source": "apache", "extensions": ["aw"] },
  "application/at+jwt": { "source": "iana" },
  "application/atf": { "source": "iana" },
  "application/atfx": { "source": "iana" },
  "application/atom+xml": { "source": "iana", "compressible": true, "extensions": ["atom"] },
  "application/atomcat+xml": { "source": "iana", "compressible": true, "extensions": ["atomcat"] },
  "application/atomdeleted+xml": { "source": "iana", "compressible": true, "extensions": ["atomdeleted"] },
  "application/atomicmail": { "source": "iana" },
  "application/atomsvc+xml": { "source": "iana", "compressible": true, "extensions": ["atomsvc"] },
  "application/atsc-dwd+xml": { "source": "iana", "compressible": true, "extensions": ["dwd"] },
  "application/atsc-dynamic-event-message": { "source": "iana" },
  "application/atsc-held+xml": { "source": "iana", "compressible": true, "extensions": ["held"] },
  "application/atsc-rdt+json": { "source": "iana", "compressible": true },
  "application/atsc-rsat+xml": { "source": "iana", "compressible": true, "extensions": ["rsat"] },
  "application/atxml": { "source": "iana" },
  "application/auth-policy+xml": { "source": "iana", "compressible": true },
  "application/bacnet-xdd+zip": { "source": "iana", "compressible": false },
  "application/batch-smtp": { "source": "iana" },
  "application/bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/beep+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/calendar+json": { "source": "iana", "compressible": true },
  "application/calendar+xml": { "source": "iana", "compressible": true, "extensions": ["xcs"] },
  "application/call-completion": { "source": "iana" },
  "application/cals-1840": { "source": "iana" },
  "application/captive+json": { "source": "iana", "compressible": true },
  "application/cbor": { "source": "iana" },
  "application/cbor-seq": { "source": "iana" },
  "application/cccex": { "source": "iana" },
  "application/ccmp+xml": { "source": "iana", "compressible": true },
  "application/ccxml+xml": { "source": "iana", "compressible": true, "extensions": ["ccxml"] },
  "application/cdfx+xml": { "source": "iana", "compressible": true, "extensions": ["cdfx"] },
  "application/cdmi-capability": { "source": "iana", "extensions": ["cdmia"] },
  "application/cdmi-container": { "source": "iana", "extensions": ["cdmic"] },
  "application/cdmi-domain": { "source": "iana", "extensions": ["cdmid"] },
  "application/cdmi-object": { "source": "iana", "extensions": ["cdmio"] },
  "application/cdmi-queue": { "source": "iana", "extensions": ["cdmiq"] },
  "application/cdni": { "source": "iana" },
  "application/cea": { "source": "iana" },
  "application/cea-2018+xml": { "source": "iana", "compressible": true },
  "application/cellml+xml": { "source": "iana", "compressible": true },
  "application/cfw": { "source": "iana" },
  "application/city+json": { "source": "iana", "compressible": true },
  "application/clr": { "source": "iana" },
  "application/clue+xml": { "source": "iana", "compressible": true },
  "application/clue_info+xml": { "source": "iana", "compressible": true },
  "application/cms": { "source": "iana" },
  "application/cnrp+xml": { "source": "iana", "compressible": true },
  "application/coap-group+json": { "source": "iana", "compressible": true },
  "application/coap-payload": { "source": "iana" },
  "application/commonground": { "source": "iana" },
  "application/conference-info+xml": { "source": "iana", "compressible": true },
  "application/cose": { "source": "iana" },
  "application/cose-key": { "source": "iana" },
  "application/cose-key-set": { "source": "iana" },
  "application/cpl+xml": { "source": "iana", "compressible": true, "extensions": ["cpl"] },
  "application/csrattrs": { "source": "iana" },
  "application/csta+xml": { "source": "iana", "compressible": true },
  "application/cstadata+xml": { "source": "iana", "compressible": true },
  "application/csvm+json": { "source": "iana", "compressible": true },
  "application/cu-seeme": { "source": "apache", "extensions": ["cu"] },
  "application/cwt": { "source": "iana" },
  "application/cybercash": { "source": "iana" },
  "application/dart": { "compressible": true },
  "application/dash+xml": { "source": "iana", "compressible": true, "extensions": ["mpd"] },
  "application/dash-patch+xml": { "source": "iana", "compressible": true, "extensions": ["mpp"] },
  "application/dashdelta": { "source": "iana" },
  "application/davmount+xml": { "source": "iana", "compressible": true, "extensions": ["davmount"] },
  "application/dca-rft": { "source": "iana" },
  "application/dcd": { "source": "iana" },
  "application/dec-dx": { "source": "iana" },
  "application/dialog-info+xml": { "source": "iana", "compressible": true },
  "application/dicom": { "source": "iana" },
  "application/dicom+json": { "source": "iana", "compressible": true },
  "application/dicom+xml": { "source": "iana", "compressible": true },
  "application/dii": { "source": "iana" },
  "application/dit": { "source": "iana" },
  "application/dns": { "source": "iana" },
  "application/dns+json": { "source": "iana", "compressible": true },
  "application/dns-message": { "source": "iana" },
  "application/docbook+xml": { "source": "apache", "compressible": true, "extensions": ["dbk"] },
  "application/dots+cbor": { "source": "iana" },
  "application/dskpp+xml": { "source": "iana", "compressible": true },
  "application/dssc+der": { "source": "iana", "extensions": ["dssc"] },
  "application/dssc+xml": { "source": "iana", "compressible": true, "extensions": ["xdssc"] },
  "application/dvcs": { "source": "iana" },
  "application/ecmascript": { "source": "iana", "compressible": true, "extensions": ["es", "ecma"] },
  "application/edi-consent": { "source": "iana" },
  "application/edi-x12": { "source": "iana", "compressible": false },
  "application/edifact": { "source": "iana", "compressible": false },
  "application/efi": { "source": "iana" },
  "application/elm+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/elm+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.cap+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/emergencycalldata.comment+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.control+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.deviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.ecall.msd": { "source": "iana" },
  "application/emergencycalldata.providerinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.serviceinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.subscriberinfo+xml": { "source": "iana", "compressible": true },
  "application/emergencycalldata.veds+xml": { "source": "iana", "compressible": true },
  "application/emma+xml": { "source": "iana", "compressible": true, "extensions": ["emma"] },
  "application/emotionml+xml": { "source": "iana", "compressible": true, "extensions": ["emotionml"] },
  "application/encaprtp": { "source": "iana" },
  "application/epp+xml": { "source": "iana", "compressible": true },
  "application/epub+zip": { "source": "iana", "compressible": false, "extensions": ["epub"] },
  "application/eshop": { "source": "iana" },
  "application/exi": { "source": "iana", "extensions": ["exi"] },
  "application/expect-ct-report+json": { "source": "iana", "compressible": true },
  "application/express": { "source": "iana", "extensions": ["exp"] },
  "application/fastinfoset": { "source": "iana" },
  "application/fastsoap": { "source": "iana" },
  "application/fdt+xml": { "source": "iana", "compressible": true, "extensions": ["fdt"] },
  "application/fhir+json": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fhir+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/fido.trusted-apps+json": { "compressible": true },
  "application/fits": { "source": "iana" },
  "application/flexfec": { "source": "iana" },
  "application/font-sfnt": { "source": "iana" },
  "application/font-tdpfr": { "source": "iana", "extensions": ["pfr"] },
  "application/font-woff": { "source": "iana", "compressible": false },
  "application/framework-attributes+xml": { "source": "iana", "compressible": true },
  "application/geo+json": { "source": "iana", "compressible": true, "extensions": ["geojson"] },
  "application/geo+json-seq": { "source": "iana" },
  "application/geopackage+sqlite3": { "source": "iana" },
  "application/geoxacml+xml": { "source": "iana", "compressible": true },
  "application/gltf-buffer": { "source": "iana" },
  "application/gml+xml": { "source": "iana", "compressible": true, "extensions": ["gml"] },
  "application/gpx+xml": { "source": "apache", "compressible": true, "extensions": ["gpx"] },
  "application/gxf": { "source": "apache", "extensions": ["gxf"] },
  "application/gzip": { "source": "iana", "compressible": false, "extensions": ["gz"] },
  "application/h224": { "source": "iana" },
  "application/held+xml": { "source": "iana", "compressible": true },
  "application/hjson": { "extensions": ["hjson"] },
  "application/http": { "source": "iana" },
  "application/hyperstudio": { "source": "iana", "extensions": ["stk"] },
  "application/ibe-key-request+xml": { "source": "iana", "compressible": true },
  "application/ibe-pkg-reply+xml": { "source": "iana", "compressible": true },
  "application/ibe-pp-data": { "source": "iana" },
  "application/iges": { "source": "iana" },
  "application/im-iscomposing+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/index": { "source": "iana" },
  "application/index.cmd": { "source": "iana" },
  "application/index.obj": { "source": "iana" },
  "application/index.response": { "source": "iana" },
  "application/index.vnd": { "source": "iana" },
  "application/inkml+xml": { "source": "iana", "compressible": true, "extensions": ["ink", "inkml"] },
  "application/iotp": { "source": "iana" },
  "application/ipfix": { "source": "iana", "extensions": ["ipfix"] },
  "application/ipp": { "source": "iana" },
  "application/isup": { "source": "iana" },
  "application/its+xml": { "source": "iana", "compressible": true, "extensions": ["its"] },
  "application/java-archive": { "source": "apache", "compressible": false, "extensions": ["jar", "war", "ear"] },
  "application/java-serialized-object": { "source": "apache", "compressible": false, "extensions": ["ser"] },
  "application/java-vm": { "source": "apache", "compressible": false, "extensions": ["class"] },
  "application/javascript": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["js", "mjs"] },
  "application/jf2feed+json": { "source": "iana", "compressible": true },
  "application/jose": { "source": "iana" },
  "application/jose+json": { "source": "iana", "compressible": true },
  "application/jrd+json": { "source": "iana", "compressible": true },
  "application/jscalendar+json": { "source": "iana", "compressible": true },
  "application/json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["json", "map"] },
  "application/json-patch+json": { "source": "iana", "compressible": true },
  "application/json-seq": { "source": "iana" },
  "application/json5": { "extensions": ["json5"] },
  "application/jsonml+json": { "source": "apache", "compressible": true, "extensions": ["jsonml"] },
  "application/jwk+json": { "source": "iana", "compressible": true },
  "application/jwk-set+json": { "source": "iana", "compressible": true },
  "application/jwt": { "source": "iana" },
  "application/kpml-request+xml": { "source": "iana", "compressible": true },
  "application/kpml-response+xml": { "source": "iana", "compressible": true },
  "application/ld+json": { "source": "iana", "compressible": true, "extensions": ["jsonld"] },
  "application/lgr+xml": { "source": "iana", "compressible": true, "extensions": ["lgr"] },
  "application/link-format": { "source": "iana" },
  "application/load-control+xml": { "source": "iana", "compressible": true },
  "application/lost+xml": { "source": "iana", "compressible": true, "extensions": ["lostxml"] },
  "application/lostsync+xml": { "source": "iana", "compressible": true },
  "application/lpf+zip": { "source": "iana", "compressible": false },
  "application/lxf": { "source": "iana" },
  "application/mac-binhex40": { "source": "iana", "extensions": ["hqx"] },
  "application/mac-compactpro": { "source": "apache", "extensions": ["cpt"] },
  "application/macwriteii": { "source": "iana" },
  "application/mads+xml": { "source": "iana", "compressible": true, "extensions": ["mads"] },
  "application/manifest+json": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["webmanifest"] },
  "application/marc": { "source": "iana", "extensions": ["mrc"] },
  "application/marcxml+xml": { "source": "iana", "compressible": true, "extensions": ["mrcx"] },
  "application/mathematica": { "source": "iana", "extensions": ["ma", "nb", "mb"] },
  "application/mathml+xml": { "source": "iana", "compressible": true, "extensions": ["mathml"] },
  "application/mathml-content+xml": { "source": "iana", "compressible": true },
  "application/mathml-presentation+xml": { "source": "iana", "compressible": true },
  "application/mbms-associated-procedure-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-deregister+xml": { "source": "iana", "compressible": true },
  "application/mbms-envelope+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk+xml": { "source": "iana", "compressible": true },
  "application/mbms-msk-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-protection-description+xml": { "source": "iana", "compressible": true },
  "application/mbms-reception-report+xml": { "source": "iana", "compressible": true },
  "application/mbms-register+xml": { "source": "iana", "compressible": true },
  "application/mbms-register-response+xml": { "source": "iana", "compressible": true },
  "application/mbms-schedule+xml": { "source": "iana", "compressible": true },
  "application/mbms-user-service-description+xml": { "source": "iana", "compressible": true },
  "application/mbox": { "source": "iana", "extensions": ["mbox"] },
  "application/media-policy-dataset+xml": { "source": "iana", "compressible": true, "extensions": ["mpf"] },
  "application/media_control+xml": { "source": "iana", "compressible": true },
  "application/mediaservercontrol+xml": { "source": "iana", "compressible": true, "extensions": ["mscml"] },
  "application/merge-patch+json": { "source": "iana", "compressible": true },
  "application/metalink+xml": { "source": "apache", "compressible": true, "extensions": ["metalink"] },
  "application/metalink4+xml": { "source": "iana", "compressible": true, "extensions": ["meta4"] },
  "application/mets+xml": { "source": "iana", "compressible": true, "extensions": ["mets"] },
  "application/mf4": { "source": "iana" },
  "application/mikey": { "source": "iana" },
  "application/mipc": { "source": "iana" },
  "application/missing-blocks+cbor-seq": { "source": "iana" },
  "application/mmt-aei+xml": { "source": "iana", "compressible": true, "extensions": ["maei"] },
  "application/mmt-usd+xml": { "source": "iana", "compressible": true, "extensions": ["musd"] },
  "application/mods+xml": { "source": "iana", "compressible": true, "extensions": ["mods"] },
  "application/moss-keys": { "source": "iana" },
  "application/moss-signature": { "source": "iana" },
  "application/mosskey-data": { "source": "iana" },
  "application/mosskey-request": { "source": "iana" },
  "application/mp21": { "source": "iana", "extensions": ["m21", "mp21"] },
  "application/mp4": { "source": "iana", "extensions": ["mp4s", "m4p"] },
  "application/mpeg4-generic": { "source": "iana" },
  "application/mpeg4-iod": { "source": "iana" },
  "application/mpeg4-iod-xmt": { "source": "iana" },
  "application/mrb-consumer+xml": { "source": "iana", "compressible": true },
  "application/mrb-publish+xml": { "source": "iana", "compressible": true },
  "application/msc-ivr+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msc-mixer+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/msword": { "source": "iana", "compressible": false, "extensions": ["doc", "dot"] },
  "application/mud+json": { "source": "iana", "compressible": true },
  "application/multipart-core": { "source": "iana" },
  "application/mxf": { "source": "iana", "extensions": ["mxf"] },
  "application/n-quads": { "source": "iana", "extensions": ["nq"] },
  "application/n-triples": { "source": "iana", "extensions": ["nt"] },
  "application/nasdata": { "source": "iana" },
  "application/news-checkgroups": { "source": "iana", "charset": "US-ASCII" },
  "application/news-groupinfo": { "source": "iana", "charset": "US-ASCII" },
  "application/news-transmission": { "source": "iana" },
  "application/nlsml+xml": { "source": "iana", "compressible": true },
  "application/node": { "source": "iana", "extensions": ["cjs"] },
  "application/nss": { "source": "iana" },
  "application/oauth-authz-req+jwt": { "source": "iana" },
  "application/oblivious-dns-message": { "source": "iana" },
  "application/ocsp-request": { "source": "iana" },
  "application/ocsp-response": { "source": "iana" },
  "application/octet-stream": { "source": "iana", "compressible": false, "extensions": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"] },
  "application/oda": { "source": "iana", "extensions": ["oda"] },
  "application/odm+xml": { "source": "iana", "compressible": true },
  "application/odx": { "source": "iana" },
  "application/oebps-package+xml": { "source": "iana", "compressible": true, "extensions": ["opf"] },
  "application/ogg": { "source": "iana", "compressible": false, "extensions": ["ogx"] },
  "application/omdoc+xml": { "source": "apache", "compressible": true, "extensions": ["omdoc"] },
  "application/onenote": { "source": "apache", "extensions": ["onetoc", "onetoc2", "onetmp", "onepkg"] },
  "application/opc-nodeset+xml": { "source": "iana", "compressible": true },
  "application/oscore": { "source": "iana" },
  "application/oxps": { "source": "iana", "extensions": ["oxps"] },
  "application/p21": { "source": "iana" },
  "application/p21+zip": { "source": "iana", "compressible": false },
  "application/p2p-overlay+xml": { "source": "iana", "compressible": true, "extensions": ["relo"] },
  "application/parityfec": { "source": "iana" },
  "application/passport": { "source": "iana" },
  "application/patch-ops-error+xml": { "source": "iana", "compressible": true, "extensions": ["xer"] },
  "application/pdf": { "source": "iana", "compressible": false, "extensions": ["pdf"] },
  "application/pdx": { "source": "iana" },
  "application/pem-certificate-chain": { "source": "iana" },
  "application/pgp-encrypted": { "source": "iana", "compressible": false, "extensions": ["pgp"] },
  "application/pgp-keys": { "source": "iana", "extensions": ["asc"] },
  "application/pgp-signature": { "source": "iana", "extensions": ["asc", "sig"] },
  "application/pics-rules": { "source": "apache", "extensions": ["prf"] },
  "application/pidf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pidf-diff+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/pkcs10": { "source": "iana", "extensions": ["p10"] },
  "application/pkcs12": { "source": "iana" },
  "application/pkcs7-mime": { "source": "iana", "extensions": ["p7m", "p7c"] },
  "application/pkcs7-signature": { "source": "iana", "extensions": ["p7s"] },
  "application/pkcs8": { "source": "iana", "extensions": ["p8"] },
  "application/pkcs8-encrypted": { "source": "iana" },
  "application/pkix-attr-cert": { "source": "iana", "extensions": ["ac"] },
  "application/pkix-cert": { "source": "iana", "extensions": ["cer"] },
  "application/pkix-crl": { "source": "iana", "extensions": ["crl"] },
  "application/pkix-pkipath": { "source": "iana", "extensions": ["pkipath"] },
  "application/pkixcmp": { "source": "iana", "extensions": ["pki"] },
  "application/pls+xml": { "source": "iana", "compressible": true, "extensions": ["pls"] },
  "application/poc-settings+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/postscript": { "source": "iana", "compressible": true, "extensions": ["ai", "eps", "ps"] },
  "application/ppsp-tracker+json": { "source": "iana", "compressible": true },
  "application/problem+json": { "source": "iana", "compressible": true },
  "application/problem+xml": { "source": "iana", "compressible": true },
  "application/provenance+xml": { "source": "iana", "compressible": true, "extensions": ["provx"] },
  "application/prs.alvestrand.titrax-sheet": { "source": "iana" },
  "application/prs.cww": { "source": "iana", "extensions": ["cww"] },
  "application/prs.cyn": { "source": "iana", "charset": "7-BIT" },
  "application/prs.hpub+zip": { "source": "iana", "compressible": false },
  "application/prs.nprend": { "source": "iana" },
  "application/prs.plucker": { "source": "iana" },
  "application/prs.rdf-xml-crypt": { "source": "iana" },
  "application/prs.xsf+xml": { "source": "iana", "compressible": true },
  "application/pskc+xml": { "source": "iana", "compressible": true, "extensions": ["pskcxml"] },
  "application/pvd+json": { "source": "iana", "compressible": true },
  "application/qsig": { "source": "iana" },
  "application/raml+yaml": { "compressible": true, "extensions": ["raml"] },
  "application/raptorfec": { "source": "iana" },
  "application/rdap+json": { "source": "iana", "compressible": true },
  "application/rdf+xml": { "source": "iana", "compressible": true, "extensions": ["rdf", "owl"] },
  "application/reginfo+xml": { "source": "iana", "compressible": true, "extensions": ["rif"] },
  "application/relax-ng-compact-syntax": { "source": "iana", "extensions": ["rnc"] },
  "application/remote-printing": { "source": "iana" },
  "application/reputon+json": { "source": "iana", "compressible": true },
  "application/resource-lists+xml": { "source": "iana", "compressible": true, "extensions": ["rl"] },
  "application/resource-lists-diff+xml": { "source": "iana", "compressible": true, "extensions": ["rld"] },
  "application/rfc+xml": { "source": "iana", "compressible": true },
  "application/riscos": { "source": "iana" },
  "application/rlmi+xml": { "source": "iana", "compressible": true },
  "application/rls-services+xml": { "source": "iana", "compressible": true, "extensions": ["rs"] },
  "application/route-apd+xml": { "source": "iana", "compressible": true, "extensions": ["rapd"] },
  "application/route-s-tsid+xml": { "source": "iana", "compressible": true, "extensions": ["sls"] },
  "application/route-usd+xml": { "source": "iana", "compressible": true, "extensions": ["rusd"] },
  "application/rpki-ghostbusters": { "source": "iana", "extensions": ["gbr"] },
  "application/rpki-manifest": { "source": "iana", "extensions": ["mft"] },
  "application/rpki-publication": { "source": "iana" },
  "application/rpki-roa": { "source": "iana", "extensions": ["roa"] },
  "application/rpki-updown": { "source": "iana" },
  "application/rsd+xml": { "source": "apache", "compressible": true, "extensions": ["rsd"] },
  "application/rss+xml": { "source": "apache", "compressible": true, "extensions": ["rss"] },
  "application/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "application/rtploopback": { "source": "iana" },
  "application/rtx": { "source": "iana" },
  "application/samlassertion+xml": { "source": "iana", "compressible": true },
  "application/samlmetadata+xml": { "source": "iana", "compressible": true },
  "application/sarif+json": { "source": "iana", "compressible": true },
  "application/sarif-external-properties+json": { "source": "iana", "compressible": true },
  "application/sbe": { "source": "iana" },
  "application/sbml+xml": { "source": "iana", "compressible": true, "extensions": ["sbml"] },
  "application/scaip+xml": { "source": "iana", "compressible": true },
  "application/scim+json": { "source": "iana", "compressible": true },
  "application/scvp-cv-request": { "source": "iana", "extensions": ["scq"] },
  "application/scvp-cv-response": { "source": "iana", "extensions": ["scs"] },
  "application/scvp-vp-request": { "source": "iana", "extensions": ["spq"] },
  "application/scvp-vp-response": { "source": "iana", "extensions": ["spp"] },
  "application/sdp": { "source": "iana", "extensions": ["sdp"] },
  "application/secevent+jwt": { "source": "iana" },
  "application/senml+cbor": { "source": "iana" },
  "application/senml+json": { "source": "iana", "compressible": true },
  "application/senml+xml": { "source": "iana", "compressible": true, "extensions": ["senmlx"] },
  "application/senml-etch+cbor": { "source": "iana" },
  "application/senml-etch+json": { "source": "iana", "compressible": true },
  "application/senml-exi": { "source": "iana" },
  "application/sensml+cbor": { "source": "iana" },
  "application/sensml+json": { "source": "iana", "compressible": true },
  "application/sensml+xml": { "source": "iana", "compressible": true, "extensions": ["sensmlx"] },
  "application/sensml-exi": { "source": "iana" },
  "application/sep+xml": { "source": "iana", "compressible": true },
  "application/sep-exi": { "source": "iana" },
  "application/session-info": { "source": "iana" },
  "application/set-payment": { "source": "iana" },
  "application/set-payment-initiation": { "source": "iana", "extensions": ["setpay"] },
  "application/set-registration": { "source": "iana" },
  "application/set-registration-initiation": { "source": "iana", "extensions": ["setreg"] },
  "application/sgml": { "source": "iana" },
  "application/sgml-open-catalog": { "source": "iana" },
  "application/shf+xml": { "source": "iana", "compressible": true, "extensions": ["shf"] },
  "application/sieve": { "source": "iana", "extensions": ["siv", "sieve"] },
  "application/simple-filter+xml": { "source": "iana", "compressible": true },
  "application/simple-message-summary": { "source": "iana" },
  "application/simplesymbolcontainer": { "source": "iana" },
  "application/sipc": { "source": "iana" },
  "application/slate": { "source": "iana" },
  "application/smil": { "source": "iana" },
  "application/smil+xml": { "source": "iana", "compressible": true, "extensions": ["smi", "smil"] },
  "application/smpte336m": { "source": "iana" },
  "application/soap+fastinfoset": { "source": "iana" },
  "application/soap+xml": { "source": "iana", "compressible": true },
  "application/sparql-query": { "source": "iana", "extensions": ["rq"] },
  "application/sparql-results+xml": { "source": "iana", "compressible": true, "extensions": ["srx"] },
  "application/spdx+json": { "source": "iana", "compressible": true },
  "application/spirits-event+xml": { "source": "iana", "compressible": true },
  "application/sql": { "source": "iana" },
  "application/srgs": { "source": "iana", "extensions": ["gram"] },
  "application/srgs+xml": { "source": "iana", "compressible": true, "extensions": ["grxml"] },
  "application/sru+xml": { "source": "iana", "compressible": true, "extensions": ["sru"] },
  "application/ssdl+xml": { "source": "apache", "compressible": true, "extensions": ["ssdl"] },
  "application/ssml+xml": { "source": "iana", "compressible": true, "extensions": ["ssml"] },
  "application/stix+json": { "source": "iana", "compressible": true },
  "application/swid+xml": { "source": "iana", "compressible": true, "extensions": ["swidtag"] },
  "application/tamp-apex-update": { "source": "iana" },
  "application/tamp-apex-update-confirm": { "source": "iana" },
  "application/tamp-community-update": { "source": "iana" },
  "application/tamp-community-update-confirm": { "source": "iana" },
  "application/tamp-error": { "source": "iana" },
  "application/tamp-sequence-adjust": { "source": "iana" },
  "application/tamp-sequence-adjust-confirm": { "source": "iana" },
  "application/tamp-status-query": { "source": "iana" },
  "application/tamp-status-response": { "source": "iana" },
  "application/tamp-update": { "source": "iana" },
  "application/tamp-update-confirm": { "source": "iana" },
  "application/tar": { "compressible": true },
  "application/taxii+json": { "source": "iana", "compressible": true },
  "application/td+json": { "source": "iana", "compressible": true },
  "application/tei+xml": { "source": "iana", "compressible": true, "extensions": ["tei", "teicorpus"] },
  "application/tetra_isi": { "source": "iana" },
  "application/thraud+xml": { "source": "iana", "compressible": true, "extensions": ["tfi"] },
  "application/timestamp-query": { "source": "iana" },
  "application/timestamp-reply": { "source": "iana" },
  "application/timestamped-data": { "source": "iana", "extensions": ["tsd"] },
  "application/tlsrpt+gzip": { "source": "iana" },
  "application/tlsrpt+json": { "source": "iana", "compressible": true },
  "application/tnauthlist": { "source": "iana" },
  "application/token-introspection+jwt": { "source": "iana" },
  "application/toml": { "compressible": true, "extensions": ["toml"] },
  "application/trickle-ice-sdpfrag": { "source": "iana" },
  "application/trig": { "source": "iana", "extensions": ["trig"] },
  "application/ttml+xml": { "source": "iana", "compressible": true, "extensions": ["ttml"] },
  "application/tve-trigger": { "source": "iana" },
  "application/tzif": { "source": "iana" },
  "application/tzif-leap": { "source": "iana" },
  "application/ubjson": { "compressible": false, "extensions": ["ubj"] },
  "application/ulpfec": { "source": "iana" },
  "application/urc-grpsheet+xml": { "source": "iana", "compressible": true },
  "application/urc-ressheet+xml": { "source": "iana", "compressible": true, "extensions": ["rsheet"] },
  "application/urc-targetdesc+xml": { "source": "iana", "compressible": true, "extensions": ["td"] },
  "application/urc-uisocketdesc+xml": { "source": "iana", "compressible": true },
  "application/vcard+json": { "source": "iana", "compressible": true },
  "application/vcard+xml": { "source": "iana", "compressible": true },
  "application/vemmi": { "source": "iana" },
  "application/vividence.scriptfile": { "source": "apache" },
  "application/vnd.1000minds.decision-model+xml": { "source": "iana", "compressible": true, "extensions": ["1km"] },
  "application/vnd.3gpp-prose+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-prose-pc3ch+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp-v2x-local-service-information": { "source": "iana" },
  "application/vnd.3gpp.5gnas": { "source": "iana" },
  "application/vnd.3gpp.access-transfer-events+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.bsf+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gmop+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.gtpc": { "source": "iana" },
  "application/vnd.3gpp.interworking-data": { "source": "iana" },
  "application/vnd.3gpp.lpp": { "source": "iana" },
  "application/vnd.3gpp.mc-signalling-ear": { "source": "iana" },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-payload": { "source": "iana" },
  "application/vnd.3gpp.mcdata-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-signalling": { "source": "iana" },
  "application/vnd.3gpp.mcdata-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcdata-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-floor-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-signed+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcptt-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-location-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-service-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-ue-config+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mcvideo-user-profile+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.mid-call+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ngap": { "source": "iana" },
  "application/vnd.3gpp.pfcp": { "source": "iana" },
  "application/vnd.3gpp.pic-bw-large": { "source": "iana", "extensions": ["plb"] },
  "application/vnd.3gpp.pic-bw-small": { "source": "iana", "extensions": ["psb"] },
  "application/vnd.3gpp.pic-bw-var": { "source": "iana", "extensions": ["pvb"] },
  "application/vnd.3gpp.s1ap": { "source": "iana" },
  "application/vnd.3gpp.sms": { "source": "iana" },
  "application/vnd.3gpp.sms+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-ext+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.srvcc-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.state-and-event-info+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp.ussd+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.bcmcsinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.3gpp2.sms": { "source": "iana" },
  "application/vnd.3gpp2.tcap": { "source": "iana", "extensions": ["tcap"] },
  "application/vnd.3lightssoftware.imagescal": { "source": "iana" },
  "application/vnd.3m.post-it-notes": { "source": "iana", "extensions": ["pwn"] },
  "application/vnd.accpac.simply.aso": { "source": "iana", "extensions": ["aso"] },
  "application/vnd.accpac.simply.imp": { "source": "iana", "extensions": ["imp"] },
  "application/vnd.acucobol": { "source": "iana", "extensions": ["acu"] },
  "application/vnd.acucorp": { "source": "iana", "extensions": ["atc", "acutc"] },
  "application/vnd.adobe.air-application-installer-package+zip": { "source": "apache", "compressible": false, "extensions": ["air"] },
  "application/vnd.adobe.flash.movie": { "source": "iana" },
  "application/vnd.adobe.formscentral.fcdt": { "source": "iana", "extensions": ["fcdt"] },
  "application/vnd.adobe.fxp": { "source": "iana", "extensions": ["fxp", "fxpl"] },
  "application/vnd.adobe.partial-upload": { "source": "iana" },
  "application/vnd.adobe.xdp+xml": { "source": "iana", "compressible": true, "extensions": ["xdp"] },
  "application/vnd.adobe.xfdf": { "source": "iana", "extensions": ["xfdf"] },
  "application/vnd.aether.imp": { "source": "iana" },
  "application/vnd.afpc.afplinedata": { "source": "iana" },
  "application/vnd.afpc.afplinedata-pagedef": { "source": "iana" },
  "application/vnd.afpc.cmoca-cmresource": { "source": "iana" },
  "application/vnd.afpc.foca-charset": { "source": "iana" },
  "application/vnd.afpc.foca-codedfont": { "source": "iana" },
  "application/vnd.afpc.foca-codepage": { "source": "iana" },
  "application/vnd.afpc.modca": { "source": "iana" },
  "application/vnd.afpc.modca-cmtable": { "source": "iana" },
  "application/vnd.afpc.modca-formdef": { "source": "iana" },
  "application/vnd.afpc.modca-mediummap": { "source": "iana" },
  "application/vnd.afpc.modca-objectcontainer": { "source": "iana" },
  "application/vnd.afpc.modca-overlay": { "source": "iana" },
  "application/vnd.afpc.modca-pagesegment": { "source": "iana" },
  "application/vnd.age": { "source": "iana", "extensions": ["age"] },
  "application/vnd.ah-barcode": { "source": "iana" },
  "application/vnd.ahead.space": { "source": "iana", "extensions": ["ahead"] },
  "application/vnd.airzip.filesecure.azf": { "source": "iana", "extensions": ["azf"] },
  "application/vnd.airzip.filesecure.azs": { "source": "iana", "extensions": ["azs"] },
  "application/vnd.amadeus+json": { "source": "iana", "compressible": true },
  "application/vnd.amazon.ebook": { "source": "apache", "extensions": ["azw"] },
  "application/vnd.amazon.mobi8-ebook": { "source": "iana" },
  "application/vnd.americandynamics.acc": { "source": "iana", "extensions": ["acc"] },
  "application/vnd.amiga.ami": { "source": "iana", "extensions": ["ami"] },
  "application/vnd.amundsen.maze+xml": { "source": "iana", "compressible": true },
  "application/vnd.android.ota": { "source": "iana" },
  "application/vnd.android.package-archive": { "source": "apache", "compressible": false, "extensions": ["apk"] },
  "application/vnd.anki": { "source": "iana" },
  "application/vnd.anser-web-certificate-issue-initiation": { "source": "iana", "extensions": ["cii"] },
  "application/vnd.anser-web-funds-transfer-initiation": { "source": "apache", "extensions": ["fti"] },
  "application/vnd.antix.game-component": { "source": "iana", "extensions": ["atx"] },
  "application/vnd.apache.arrow.file": { "source": "iana" },
  "application/vnd.apache.arrow.stream": { "source": "iana" },
  "application/vnd.apache.thrift.binary": { "source": "iana" },
  "application/vnd.apache.thrift.compact": { "source": "iana" },
  "application/vnd.apache.thrift.json": { "source": "iana" },
  "application/vnd.api+json": { "source": "iana", "compressible": true },
  "application/vnd.aplextor.warrp+json": { "source": "iana", "compressible": true },
  "application/vnd.apothekende.reservation+json": { "source": "iana", "compressible": true },
  "application/vnd.apple.installer+xml": { "source": "iana", "compressible": true, "extensions": ["mpkg"] },
  "application/vnd.apple.keynote": { "source": "iana", "extensions": ["key"] },
  "application/vnd.apple.mpegurl": { "source": "iana", "extensions": ["m3u8"] },
  "application/vnd.apple.numbers": { "source": "iana", "extensions": ["numbers"] },
  "application/vnd.apple.pages": { "source": "iana", "extensions": ["pages"] },
  "application/vnd.apple.pkpass": { "compressible": false, "extensions": ["pkpass"] },
  "application/vnd.arastra.swi": { "source": "iana" },
  "application/vnd.aristanetworks.swi": { "source": "iana", "extensions": ["swi"] },
  "application/vnd.artisan+json": { "source": "iana", "compressible": true },
  "application/vnd.artsquare": { "source": "iana" },
  "application/vnd.astraea-software.iota": { "source": "iana", "extensions": ["iota"] },
  "application/vnd.audiograph": { "source": "iana", "extensions": ["aep"] },
  "application/vnd.autopackage": { "source": "iana" },
  "application/vnd.avalon+json": { "source": "iana", "compressible": true },
  "application/vnd.avistar+xml": { "source": "iana", "compressible": true },
  "application/vnd.balsamiq.bmml+xml": { "source": "iana", "compressible": true, "extensions": ["bmml"] },
  "application/vnd.balsamiq.bmpr": { "source": "iana" },
  "application/vnd.banana-accounting": { "source": "iana" },
  "application/vnd.bbf.usp.error": { "source": "iana" },
  "application/vnd.bbf.usp.msg": { "source": "iana" },
  "application/vnd.bbf.usp.msg+json": { "source": "iana", "compressible": true },
  "application/vnd.bekitzur-stech+json": { "source": "iana", "compressible": true },
  "application/vnd.bint.med-content": { "source": "iana" },
  "application/vnd.biopax.rdf+xml": { "source": "iana", "compressible": true },
  "application/vnd.blink-idb-value-wrapper": { "source": "iana" },
  "application/vnd.blueice.multipass": { "source": "iana", "extensions": ["mpm"] },
  "application/vnd.bluetooth.ep.oob": { "source": "iana" },
  "application/vnd.bluetooth.le.oob": { "source": "iana" },
  "application/vnd.bmi": { "source": "iana", "extensions": ["bmi"] },
  "application/vnd.bpf": { "source": "iana" },
  "application/vnd.bpf3": { "source": "iana" },
  "application/vnd.businessobjects": { "source": "iana", "extensions": ["rep"] },
  "application/vnd.byu.uapi+json": { "source": "iana", "compressible": true },
  "application/vnd.cab-jscript": { "source": "iana" },
  "application/vnd.canon-cpdl": { "source": "iana" },
  "application/vnd.canon-lips": { "source": "iana" },
  "application/vnd.capasystems-pg+json": { "source": "iana", "compressible": true },
  "application/vnd.cendio.thinlinc.clientconf": { "source": "iana" },
  "application/vnd.century-systems.tcp_stream": { "source": "iana" },
  "application/vnd.chemdraw+xml": { "source": "iana", "compressible": true, "extensions": ["cdxml"] },
  "application/vnd.chess-pgn": { "source": "iana" },
  "application/vnd.chipnuts.karaoke-mmd": { "source": "iana", "extensions": ["mmd"] },
  "application/vnd.ciedi": { "source": "iana" },
  "application/vnd.cinderella": { "source": "iana", "extensions": ["cdy"] },
  "application/vnd.cirpack.isdn-ext": { "source": "iana" },
  "application/vnd.citationstyles.style+xml": { "source": "iana", "compressible": true, "extensions": ["csl"] },
  "application/vnd.claymore": { "source": "iana", "extensions": ["cla"] },
  "application/vnd.cloanto.rp9": { "source": "iana", "extensions": ["rp9"] },
  "application/vnd.clonk.c4group": { "source": "iana", "extensions": ["c4g", "c4d", "c4f", "c4p", "c4u"] },
  "application/vnd.cluetrust.cartomobile-config": { "source": "iana", "extensions": ["c11amc"] },
  "application/vnd.cluetrust.cartomobile-config-pkg": { "source": "iana", "extensions": ["c11amz"] },
  "application/vnd.coffeescript": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document": { "source": "iana" },
  "application/vnd.collabio.xodocuments.document-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation": { "source": "iana" },
  "application/vnd.collabio.xodocuments.presentation-template": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet": { "source": "iana" },
  "application/vnd.collabio.xodocuments.spreadsheet-template": { "source": "iana" },
  "application/vnd.collection+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.doc+json": { "source": "iana", "compressible": true },
  "application/vnd.collection.next+json": { "source": "iana", "compressible": true },
  "application/vnd.comicbook+zip": { "source": "iana", "compressible": false },
  "application/vnd.comicbook-rar": { "source": "iana" },
  "application/vnd.commerce-battelle": { "source": "iana" },
  "application/vnd.commonspace": { "source": "iana", "extensions": ["csp"] },
  "application/vnd.contact.cmsg": { "source": "iana", "extensions": ["cdbcmsg"] },
  "application/vnd.coreos.ignition+json": { "source": "iana", "compressible": true },
  "application/vnd.cosmocaller": { "source": "iana", "extensions": ["cmc"] },
  "application/vnd.crick.clicker": { "source": "iana", "extensions": ["clkx"] },
  "application/vnd.crick.clicker.keyboard": { "source": "iana", "extensions": ["clkk"] },
  "application/vnd.crick.clicker.palette": { "source": "iana", "extensions": ["clkp"] },
  "application/vnd.crick.clicker.template": { "source": "iana", "extensions": ["clkt"] },
  "application/vnd.crick.clicker.wordbank": { "source": "iana", "extensions": ["clkw"] },
  "application/vnd.criticaltools.wbs+xml": { "source": "iana", "compressible": true, "extensions": ["wbs"] },
  "application/vnd.cryptii.pipe+json": { "source": "iana", "compressible": true },
  "application/vnd.crypto-shade-file": { "source": "iana" },
  "application/vnd.cryptomator.encrypted": { "source": "iana" },
  "application/vnd.cryptomator.vault": { "source": "iana" },
  "application/vnd.ctc-posml": { "source": "iana", "extensions": ["pml"] },
  "application/vnd.ctct.ws+xml": { "source": "iana", "compressible": true },
  "application/vnd.cups-pdf": { "source": "iana" },
  "application/vnd.cups-postscript": { "source": "iana" },
  "application/vnd.cups-ppd": { "source": "iana", "extensions": ["ppd"] },
  "application/vnd.cups-raster": { "source": "iana" },
  "application/vnd.cups-raw": { "source": "iana" },
  "application/vnd.curl": { "source": "iana" },
  "application/vnd.curl.car": { "source": "apache", "extensions": ["car"] },
  "application/vnd.curl.pcurl": { "source": "apache", "extensions": ["pcurl"] },
  "application/vnd.cyan.dean.root+xml": { "source": "iana", "compressible": true },
  "application/vnd.cybank": { "source": "iana" },
  "application/vnd.cyclonedx+json": { "source": "iana", "compressible": true },
  "application/vnd.cyclonedx+xml": { "source": "iana", "compressible": true },
  "application/vnd.d2l.coursepackage1p0+zip": { "source": "iana", "compressible": false },
  "application/vnd.d3m-dataset": { "source": "iana" },
  "application/vnd.d3m-problem": { "source": "iana" },
  "application/vnd.dart": { "source": "iana", "compressible": true, "extensions": ["dart"] },
  "application/vnd.data-vision.rdz": { "source": "iana", "extensions": ["rdz"] },
  "application/vnd.datapackage+json": { "source": "iana", "compressible": true },
  "application/vnd.dataresource+json": { "source": "iana", "compressible": true },
  "application/vnd.dbf": { "source": "iana", "extensions": ["dbf"] },
  "application/vnd.debian.binary-package": { "source": "iana" },
  "application/vnd.dece.data": { "source": "iana", "extensions": ["uvf", "uvvf", "uvd", "uvvd"] },
  "application/vnd.dece.ttml+xml": { "source": "iana", "compressible": true, "extensions": ["uvt", "uvvt"] },
  "application/vnd.dece.unspecified": { "source": "iana", "extensions": ["uvx", "uvvx"] },
  "application/vnd.dece.zip": { "source": "iana", "extensions": ["uvz", "uvvz"] },
  "application/vnd.denovo.fcselayout-link": { "source": "iana", "extensions": ["fe_launch"] },
  "application/vnd.desmume.movie": { "source": "iana" },
  "application/vnd.dir-bi.plate-dl-nosuffix": { "source": "iana" },
  "application/vnd.dm.delegation+xml": { "source": "iana", "compressible": true },
  "application/vnd.dna": { "source": "iana", "extensions": ["dna"] },
  "application/vnd.document+json": { "source": "iana", "compressible": true },
  "application/vnd.dolby.mlp": { "source": "apache", "extensions": ["mlp"] },
  "application/vnd.dolby.mobile.1": { "source": "iana" },
  "application/vnd.dolby.mobile.2": { "source": "iana" },
  "application/vnd.doremir.scorecloud-binary-document": { "source": "iana" },
  "application/vnd.dpgraph": { "source": "iana", "extensions": ["dpg"] },
  "application/vnd.dreamfactory": { "source": "iana", "extensions": ["dfac"] },
  "application/vnd.drive+json": { "source": "iana", "compressible": true },
  "application/vnd.ds-keypoint": { "source": "apache", "extensions": ["kpxx"] },
  "application/vnd.dtg.local": { "source": "iana" },
  "application/vnd.dtg.local.flash": { "source": "iana" },
  "application/vnd.dtg.local.html": { "source": "iana" },
  "application/vnd.dvb.ait": { "source": "iana", "extensions": ["ait"] },
  "application/vnd.dvb.dvbisl+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.dvbj": { "source": "iana" },
  "application/vnd.dvb.esgcontainer": { "source": "iana" },
  "application/vnd.dvb.ipdcdftnotifaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess": { "source": "iana" },
  "application/vnd.dvb.ipdcesgaccess2": { "source": "iana" },
  "application/vnd.dvb.ipdcesgpdd": { "source": "iana" },
  "application/vnd.dvb.ipdcroaming": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-base": { "source": "iana" },
  "application/vnd.dvb.iptv.alfec-enhancement": { "source": "iana" },
  "application/vnd.dvb.notif-aggregate-root+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-container+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-generic+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-msglist+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-ia-registration-response+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.notif-init+xml": { "source": "iana", "compressible": true },
  "application/vnd.dvb.pfr": { "source": "iana" },
  "application/vnd.dvb.service": { "source": "iana", "extensions": ["svc"] },
  "application/vnd.dxr": { "source": "iana" },
  "application/vnd.dynageo": { "source": "iana", "extensions": ["geo"] },
  "application/vnd.dzr": { "source": "iana" },
  "application/vnd.easykaraoke.cdgdownload": { "source": "iana" },
  "application/vnd.ecdis-update": { "source": "iana" },
  "application/vnd.ecip.rlp": { "source": "iana" },
  "application/vnd.eclipse.ditto+json": { "source": "iana", "compressible": true },
  "application/vnd.ecowin.chart": { "source": "iana", "extensions": ["mag"] },
  "application/vnd.ecowin.filerequest": { "source": "iana" },
  "application/vnd.ecowin.fileupdate": { "source": "iana" },
  "application/vnd.ecowin.series": { "source": "iana" },
  "application/vnd.ecowin.seriesrequest": { "source": "iana" },
  "application/vnd.ecowin.seriesupdate": { "source": "iana" },
  "application/vnd.efi.img": { "source": "iana" },
  "application/vnd.efi.iso": { "source": "iana" },
  "application/vnd.emclient.accessrequest+xml": { "source": "iana", "compressible": true },
  "application/vnd.enliven": { "source": "iana", "extensions": ["nml"] },
  "application/vnd.enphase.envoy": { "source": "iana" },
  "application/vnd.eprints.data+xml": { "source": "iana", "compressible": true },
  "application/vnd.epson.esf": { "source": "iana", "extensions": ["esf"] },
  "application/vnd.epson.msf": { "source": "iana", "extensions": ["msf"] },
  "application/vnd.epson.quickanime": { "source": "iana", "extensions": ["qam"] },
  "application/vnd.epson.salt": { "source": "iana", "extensions": ["slt"] },
  "application/vnd.epson.ssf": { "source": "iana", "extensions": ["ssf"] },
  "application/vnd.ericsson.quickcall": { "source": "iana" },
  "application/vnd.espass-espass+zip": { "source": "iana", "compressible": false },
  "application/vnd.eszigno3+xml": { "source": "iana", "compressible": true, "extensions": ["es3", "et3"] },
  "application/vnd.etsi.aoc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.asic-e+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.asic-s+zip": { "source": "iana", "compressible": false },
  "application/vnd.etsi.cug+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvcommand+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-bc+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-cod+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsad-npvr+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvservice+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvsync+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.iptvueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mcid+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.mheg5": { "source": "iana" },
  "application/vnd.etsi.overload-control-policy-dataset+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.pstn+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.sci+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.simservs+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.timestamp-token": { "source": "iana" },
  "application/vnd.etsi.tsl+xml": { "source": "iana", "compressible": true },
  "application/vnd.etsi.tsl.der": { "source": "iana" },
  "application/vnd.eu.kasparian.car+json": { "source": "iana", "compressible": true },
  "application/vnd.eudora.data": { "source": "iana" },
  "application/vnd.evolv.ecig.profile": { "source": "iana" },
  "application/vnd.evolv.ecig.settings": { "source": "iana" },
  "application/vnd.evolv.ecig.theme": { "source": "iana" },
  "application/vnd.exstream-empower+zip": { "source": "iana", "compressible": false },
  "application/vnd.exstream-package": { "source": "iana" },
  "application/vnd.ezpix-album": { "source": "iana", "extensions": ["ez2"] },
  "application/vnd.ezpix-package": { "source": "iana", "extensions": ["ez3"] },
  "application/vnd.f-secure.mobile": { "source": "iana" },
  "application/vnd.familysearch.gedcom+zip": { "source": "iana", "compressible": false },
  "application/vnd.fastcopy-disk-image": { "source": "iana" },
  "application/vnd.fdf": { "source": "iana", "extensions": ["fdf"] },
  "application/vnd.fdsn.mseed": { "source": "iana", "extensions": ["mseed"] },
  "application/vnd.fdsn.seed": { "source": "iana", "extensions": ["seed", "dataless"] },
  "application/vnd.ffsns": { "source": "iana" },
  "application/vnd.ficlab.flb+zip": { "source": "iana", "compressible": false },
  "application/vnd.filmit.zfc": { "source": "iana" },
  "application/vnd.fints": { "source": "iana" },
  "application/vnd.firemonkeys.cloudcell": { "source": "iana" },
  "application/vnd.flographit": { "source": "iana", "extensions": ["gph"] },
  "application/vnd.fluxtime.clip": { "source": "iana", "extensions": ["ftc"] },
  "application/vnd.font-fontforge-sfd": { "source": "iana" },
  "application/vnd.framemaker": { "source": "iana", "extensions": ["fm", "frame", "maker", "book"] },
  "application/vnd.frogans.fnc": { "source": "iana", "extensions": ["fnc"] },
  "application/vnd.frogans.ltf": { "source": "iana", "extensions": ["ltf"] },
  "application/vnd.fsc.weblaunch": { "source": "iana", "extensions": ["fsc"] },
  "application/vnd.fujifilm.fb.docuworks": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.binder": { "source": "iana" },
  "application/vnd.fujifilm.fb.docuworks.container": { "source": "iana" },
  "application/vnd.fujifilm.fb.jfi+xml": { "source": "iana", "compressible": true },
  "application/vnd.fujitsu.oasys": { "source": "iana", "extensions": ["oas"] },
  "application/vnd.fujitsu.oasys2": { "source": "iana", "extensions": ["oa2"] },
  "application/vnd.fujitsu.oasys3": { "source": "iana", "extensions": ["oa3"] },
  "application/vnd.fujitsu.oasysgp": { "source": "iana", "extensions": ["fg5"] },
  "application/vnd.fujitsu.oasysprs": { "source": "iana", "extensions": ["bh2"] },
  "application/vnd.fujixerox.art-ex": { "source": "iana" },
  "application/vnd.fujixerox.art4": { "source": "iana" },
  "application/vnd.fujixerox.ddd": { "source": "iana", "extensions": ["ddd"] },
  "application/vnd.fujixerox.docuworks": { "source": "iana", "extensions": ["xdw"] },
  "application/vnd.fujixerox.docuworks.binder": { "source": "iana", "extensions": ["xbd"] },
  "application/vnd.fujixerox.docuworks.container": { "source": "iana" },
  "application/vnd.fujixerox.hbpl": { "source": "iana" },
  "application/vnd.fut-misnet": { "source": "iana" },
  "application/vnd.futoin+cbor": { "source": "iana" },
  "application/vnd.futoin+json": { "source": "iana", "compressible": true },
  "application/vnd.fuzzysheet": { "source": "iana", "extensions": ["fzs"] },
  "application/vnd.genomatix.tuxedo": { "source": "iana", "extensions": ["txd"] },
  "application/vnd.gentics.grd+json": { "source": "iana", "compressible": true },
  "application/vnd.geo+json": { "source": "iana", "compressible": true },
  "application/vnd.geocube+xml": { "source": "iana", "compressible": true },
  "application/vnd.geogebra.file": { "source": "iana", "extensions": ["ggb"] },
  "application/vnd.geogebra.slides": { "source": "iana" },
  "application/vnd.geogebra.tool": { "source": "iana", "extensions": ["ggt"] },
  "application/vnd.geometry-explorer": { "source": "iana", "extensions": ["gex", "gre"] },
  "application/vnd.geonext": { "source": "iana", "extensions": ["gxt"] },
  "application/vnd.geoplan": { "source": "iana", "extensions": ["g2w"] },
  "application/vnd.geospace": { "source": "iana", "extensions": ["g3w"] },
  "application/vnd.gerber": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt": { "source": "iana" },
  "application/vnd.globalplatform.card-content-mgt-response": { "source": "iana" },
  "application/vnd.gmx": { "source": "iana", "extensions": ["gmx"] },
  "application/vnd.google-apps.document": { "compressible": false, "extensions": ["gdoc"] },
  "application/vnd.google-apps.presentation": { "compressible": false, "extensions": ["gslides"] },
  "application/vnd.google-apps.spreadsheet": { "compressible": false, "extensions": ["gsheet"] },
  "application/vnd.google-earth.kml+xml": { "source": "iana", "compressible": true, "extensions": ["kml"] },
  "application/vnd.google-earth.kmz": { "source": "iana", "compressible": false, "extensions": ["kmz"] },
  "application/vnd.gov.sk.e-form+xml": { "source": "iana", "compressible": true },
  "application/vnd.gov.sk.e-form+zip": { "source": "iana", "compressible": false },
  "application/vnd.gov.sk.xmldatacontainer+xml": { "source": "iana", "compressible": true },
  "application/vnd.grafeq": { "source": "iana", "extensions": ["gqf", "gqs"] },
  "application/vnd.gridmp": { "source": "iana" },
  "application/vnd.groove-account": { "source": "iana", "extensions": ["gac"] },
  "application/vnd.groove-help": { "source": "iana", "extensions": ["ghf"] },
  "application/vnd.groove-identity-message": { "source": "iana", "extensions": ["gim"] },
  "application/vnd.groove-injector": { "source": "iana", "extensions": ["grv"] },
  "application/vnd.groove-tool-message": { "source": "iana", "extensions": ["gtm"] },
  "application/vnd.groove-tool-template": { "source": "iana", "extensions": ["tpl"] },
  "application/vnd.groove-vcard": { "source": "iana", "extensions": ["vcg"] },
  "application/vnd.hal+json": { "source": "iana", "compressible": true },
  "application/vnd.hal+xml": { "source": "iana", "compressible": true, "extensions": ["hal"] },
  "application/vnd.handheld-entertainment+xml": { "source": "iana", "compressible": true, "extensions": ["zmm"] },
  "application/vnd.hbci": { "source": "iana", "extensions": ["hbci"] },
  "application/vnd.hc+json": { "source": "iana", "compressible": true },
  "application/vnd.hcl-bireports": { "source": "iana" },
  "application/vnd.hdt": { "source": "iana" },
  "application/vnd.heroku+json": { "source": "iana", "compressible": true },
  "application/vnd.hhe.lesson-player": { "source": "iana", "extensions": ["les"] },
  "application/vnd.hl7cda+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hl7v2+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.hp-hpgl": { "source": "iana", "extensions": ["hpgl"] },
  "application/vnd.hp-hpid": { "source": "iana", "extensions": ["hpid"] },
  "application/vnd.hp-hps": { "source": "iana", "extensions": ["hps"] },
  "application/vnd.hp-jlyt": { "source": "iana", "extensions": ["jlt"] },
  "application/vnd.hp-pcl": { "source": "iana", "extensions": ["pcl"] },
  "application/vnd.hp-pclxl": { "source": "iana", "extensions": ["pclxl"] },
  "application/vnd.httphone": { "source": "iana" },
  "application/vnd.hydrostatix.sof-data": { "source": "iana", "extensions": ["sfd-hdstx"] },
  "application/vnd.hyper+json": { "source": "iana", "compressible": true },
  "application/vnd.hyper-item+json": { "source": "iana", "compressible": true },
  "application/vnd.hyperdrive+json": { "source": "iana", "compressible": true },
  "application/vnd.hzn-3d-crossword": { "source": "iana" },
  "application/vnd.ibm.afplinedata": { "source": "iana" },
  "application/vnd.ibm.electronic-media": { "source": "iana" },
  "application/vnd.ibm.minipay": { "source": "iana", "extensions": ["mpy"] },
  "application/vnd.ibm.modcap": { "source": "iana", "extensions": ["afp", "listafp", "list3820"] },
  "application/vnd.ibm.rights-management": { "source": "iana", "extensions": ["irm"] },
  "application/vnd.ibm.secure-container": { "source": "iana", "extensions": ["sc"] },
  "application/vnd.iccprofile": { "source": "iana", "extensions": ["icc", "icm"] },
  "application/vnd.ieee.1905": { "source": "iana" },
  "application/vnd.igloader": { "source": "iana", "extensions": ["igl"] },
  "application/vnd.imagemeter.folder+zip": { "source": "iana", "compressible": false },
  "application/vnd.imagemeter.image+zip": { "source": "iana", "compressible": false },
  "application/vnd.immervision-ivp": { "source": "iana", "extensions": ["ivp"] },
  "application/vnd.immervision-ivu": { "source": "iana", "extensions": ["ivu"] },
  "application/vnd.ims.imsccv1p1": { "source": "iana" },
  "application/vnd.ims.imsccv1p2": { "source": "iana" },
  "application/vnd.ims.imsccv1p3": { "source": "iana" },
  "application/vnd.ims.lis.v2.result+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolproxy.id+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings+json": { "source": "iana", "compressible": true },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": { "source": "iana", "compressible": true },
  "application/vnd.informedcontrol.rms+xml": { "source": "iana", "compressible": true },
  "application/vnd.informix-visionary": { "source": "iana" },
  "application/vnd.infotech.project": { "source": "iana" },
  "application/vnd.infotech.project+xml": { "source": "iana", "compressible": true },
  "application/vnd.innopath.wamp.notification": { "source": "iana" },
  "application/vnd.insors.igm": { "source": "iana", "extensions": ["igm"] },
  "application/vnd.intercon.formnet": { "source": "iana", "extensions": ["xpw", "xpx"] },
  "application/vnd.intergeo": { "source": "iana", "extensions": ["i2g"] },
  "application/vnd.intertrust.digibox": { "source": "iana" },
  "application/vnd.intertrust.nncp": { "source": "iana" },
  "application/vnd.intu.qbo": { "source": "iana", "extensions": ["qbo"] },
  "application/vnd.intu.qfx": { "source": "iana", "extensions": ["qfx"] },
  "application/vnd.iptc.g2.catalogitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.conceptitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.knowledgeitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.newsmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.packageitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.iptc.g2.planningitem+xml": { "source": "iana", "compressible": true },
  "application/vnd.ipunplugged.rcprofile": { "source": "iana", "extensions": ["rcprofile"] },
  "application/vnd.irepository.package+xml": { "source": "iana", "compressible": true, "extensions": ["irp"] },
  "application/vnd.is-xpr": { "source": "iana", "extensions": ["xpr"] },
  "application/vnd.isac.fcs": { "source": "iana", "extensions": ["fcs"] },
  "application/vnd.iso11783-10+zip": { "source": "iana", "compressible": false },
  "application/vnd.jam": { "source": "iana", "extensions": ["jam"] },
  "application/vnd.japannet-directory-service": { "source": "iana" },
  "application/vnd.japannet-jpnstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-payment-wakeup": { "source": "iana" },
  "application/vnd.japannet-registration": { "source": "iana" },
  "application/vnd.japannet-registration-wakeup": { "source": "iana" },
  "application/vnd.japannet-setstore-wakeup": { "source": "iana" },
  "application/vnd.japannet-verification": { "source": "iana" },
  "application/vnd.japannet-verification-wakeup": { "source": "iana" },
  "application/vnd.jcp.javame.midlet-rms": { "source": "iana", "extensions": ["rms"] },
  "application/vnd.jisp": { "source": "iana", "extensions": ["jisp"] },
  "application/vnd.joost.joda-archive": { "source": "iana", "extensions": ["joda"] },
  "application/vnd.jsk.isdn-ngn": { "source": "iana" },
  "application/vnd.kahootz": { "source": "iana", "extensions": ["ktz", "ktr"] },
  "application/vnd.kde.karbon": { "source": "iana", "extensions": ["karbon"] },
  "application/vnd.kde.kchart": { "source": "iana", "extensions": ["chrt"] },
  "application/vnd.kde.kformula": { "source": "iana", "extensions": ["kfo"] },
  "application/vnd.kde.kivio": { "source": "iana", "extensions": ["flw"] },
  "application/vnd.kde.kontour": { "source": "iana", "extensions": ["kon"] },
  "application/vnd.kde.kpresenter": { "source": "iana", "extensions": ["kpr", "kpt"] },
  "application/vnd.kde.kspread": { "source": "iana", "extensions": ["ksp"] },
  "application/vnd.kde.kword": { "source": "iana", "extensions": ["kwd", "kwt"] },
  "application/vnd.kenameaapp": { "source": "iana", "extensions": ["htke"] },
  "application/vnd.kidspiration": { "source": "iana", "extensions": ["kia"] },
  "application/vnd.kinar": { "source": "iana", "extensions": ["kne", "knp"] },
  "application/vnd.koan": { "source": "iana", "extensions": ["skp", "skd", "skt", "skm"] },
  "application/vnd.kodak-descriptor": { "source": "iana", "extensions": ["sse"] },
  "application/vnd.las": { "source": "iana" },
  "application/vnd.las.las+json": { "source": "iana", "compressible": true },
  "application/vnd.las.las+xml": { "source": "iana", "compressible": true, "extensions": ["lasxml"] },
  "application/vnd.laszip": { "source": "iana" },
  "application/vnd.leap+json": { "source": "iana", "compressible": true },
  "application/vnd.liberty-request+xml": { "source": "iana", "compressible": true },
  "application/vnd.llamagraphics.life-balance.desktop": { "source": "iana", "extensions": ["lbd"] },
  "application/vnd.llamagraphics.life-balance.exchange+xml": { "source": "iana", "compressible": true, "extensions": ["lbe"] },
  "application/vnd.logipipe.circuit+zip": { "source": "iana", "compressible": false },
  "application/vnd.loom": { "source": "iana" },
  "application/vnd.lotus-1-2-3": { "source": "iana", "extensions": ["123"] },
  "application/vnd.lotus-approach": { "source": "iana", "extensions": ["apr"] },
  "application/vnd.lotus-freelance": { "source": "iana", "extensions": ["pre"] },
  "application/vnd.lotus-notes": { "source": "iana", "extensions": ["nsf"] },
  "application/vnd.lotus-organizer": { "source": "iana", "extensions": ["org"] },
  "application/vnd.lotus-screencam": { "source": "iana", "extensions": ["scm"] },
  "application/vnd.lotus-wordpro": { "source": "iana", "extensions": ["lwp"] },
  "application/vnd.macports.portpkg": { "source": "iana", "extensions": ["portpkg"] },
  "application/vnd.mapbox-vector-tile": { "source": "iana", "extensions": ["mvt"] },
  "application/vnd.marlin.drm.actiontoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.conftoken+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.license+xml": { "source": "iana", "compressible": true },
  "application/vnd.marlin.drm.mdcf": { "source": "iana" },
  "application/vnd.mason+json": { "source": "iana", "compressible": true },
  "application/vnd.maxar.archive.3tz+zip": { "source": "iana", "compressible": false },
  "application/vnd.maxmind.maxmind-db": { "source": "iana" },
  "application/vnd.mcd": { "source": "iana", "extensions": ["mcd"] },
  "application/vnd.medcalcdata": { "source": "iana", "extensions": ["mc1"] },
  "application/vnd.mediastation.cdkey": { "source": "iana", "extensions": ["cdkey"] },
  "application/vnd.meridian-slingshot": { "source": "iana" },
  "application/vnd.mfer": { "source": "iana", "extensions": ["mwf"] },
  "application/vnd.mfmp": { "source": "iana", "extensions": ["mfm"] },
  "application/vnd.micro+json": { "source": "iana", "compressible": true },
  "application/vnd.micrografx.flo": { "source": "iana", "extensions": ["flo"] },
  "application/vnd.micrografx.igx": { "source": "iana", "extensions": ["igx"] },
  "application/vnd.microsoft.portable-executable": { "source": "iana" },
  "application/vnd.microsoft.windows.thumbnail-cache": { "source": "iana" },
  "application/vnd.miele+json": { "source": "iana", "compressible": true },
  "application/vnd.mif": { "source": "iana", "extensions": ["mif"] },
  "application/vnd.minisoft-hp3000-save": { "source": "iana" },
  "application/vnd.mitsubishi.misty-guard.trustweb": { "source": "iana" },
  "application/vnd.mobius.daf": { "source": "iana", "extensions": ["daf"] },
  "application/vnd.mobius.dis": { "source": "iana", "extensions": ["dis"] },
  "application/vnd.mobius.mbk": { "source": "iana", "extensions": ["mbk"] },
  "application/vnd.mobius.mqy": { "source": "iana", "extensions": ["mqy"] },
  "application/vnd.mobius.msl": { "source": "iana", "extensions": ["msl"] },
  "application/vnd.mobius.plc": { "source": "iana", "extensions": ["plc"] },
  "application/vnd.mobius.txf": { "source": "iana", "extensions": ["txf"] },
  "application/vnd.mophun.application": { "source": "iana", "extensions": ["mpn"] },
  "application/vnd.mophun.certificate": { "source": "iana", "extensions": ["mpc"] },
  "application/vnd.motorola.flexsuite": { "source": "iana" },
  "application/vnd.motorola.flexsuite.adsi": { "source": "iana" },
  "application/vnd.motorola.flexsuite.fis": { "source": "iana" },
  "application/vnd.motorola.flexsuite.gotap": { "source": "iana" },
  "application/vnd.motorola.flexsuite.kmr": { "source": "iana" },
  "application/vnd.motorola.flexsuite.ttc": { "source": "iana" },
  "application/vnd.motorola.flexsuite.wem": { "source": "iana" },
  "application/vnd.motorola.iprm": { "source": "iana" },
  "application/vnd.mozilla.xul+xml": { "source": "iana", "compressible": true, "extensions": ["xul"] },
  "application/vnd.ms-3mfdocument": { "source": "iana" },
  "application/vnd.ms-artgalry": { "source": "iana", "extensions": ["cil"] },
  "application/vnd.ms-asf": { "source": "iana" },
  "application/vnd.ms-cab-compressed": { "source": "iana", "extensions": ["cab"] },
  "application/vnd.ms-color.iccprofile": { "source": "apache" },
  "application/vnd.ms-excel": { "source": "iana", "compressible": false, "extensions": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"] },
  "application/vnd.ms-excel.addin.macroenabled.12": { "source": "iana", "extensions": ["xlam"] },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": { "source": "iana", "extensions": ["xlsb"] },
  "application/vnd.ms-excel.sheet.macroenabled.12": { "source": "iana", "extensions": ["xlsm"] },
  "application/vnd.ms-excel.template.macroenabled.12": { "source": "iana", "extensions": ["xltm"] },
  "application/vnd.ms-fontobject": { "source": "iana", "compressible": true, "extensions": ["eot"] },
  "application/vnd.ms-htmlhelp": { "source": "iana", "extensions": ["chm"] },
  "application/vnd.ms-ims": { "source": "iana", "extensions": ["ims"] },
  "application/vnd.ms-lrm": { "source": "iana", "extensions": ["lrm"] },
  "application/vnd.ms-office.activex+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-officetheme": { "source": "iana", "extensions": ["thmx"] },
  "application/vnd.ms-opentype": { "source": "apache", "compressible": true },
  "application/vnd.ms-outlook": { "compressible": false, "extensions": ["msg"] },
  "application/vnd.ms-package.obfuscated-opentype": { "source": "apache" },
  "application/vnd.ms-pki.seccat": { "source": "apache", "extensions": ["cat"] },
  "application/vnd.ms-pki.stl": { "source": "apache", "extensions": ["stl"] },
  "application/vnd.ms-playready.initiator+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-powerpoint": { "source": "iana", "compressible": false, "extensions": ["ppt", "pps", "pot"] },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": { "source": "iana", "extensions": ["ppam"] },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": { "source": "iana", "extensions": ["pptm"] },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": { "source": "iana", "extensions": ["sldm"] },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": { "source": "iana", "extensions": ["ppsm"] },
  "application/vnd.ms-powerpoint.template.macroenabled.12": { "source": "iana", "extensions": ["potm"] },
  "application/vnd.ms-printdevicecapabilities+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-printing.printticket+xml": { "source": "apache", "compressible": true },
  "application/vnd.ms-printschematicket+xml": { "source": "iana", "compressible": true },
  "application/vnd.ms-project": { "source": "iana", "extensions": ["mpp", "mpt"] },
  "application/vnd.ms-tnef": { "source": "iana" },
  "application/vnd.ms-windows.devicepairing": { "source": "iana" },
  "application/vnd.ms-windows.nwprinting.oob": { "source": "iana" },
  "application/vnd.ms-windows.printerpairing": { "source": "iana" },
  "application/vnd.ms-windows.wsd.oob": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.lic-resp": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-chlg-req": { "source": "iana" },
  "application/vnd.ms-wmdrm.meter-resp": { "source": "iana" },
  "application/vnd.ms-word.document.macroenabled.12": { "source": "iana", "extensions": ["docm"] },
  "application/vnd.ms-word.template.macroenabled.12": { "source": "iana", "extensions": ["dotm"] },
  "application/vnd.ms-works": { "source": "iana", "extensions": ["wps", "wks", "wcm", "wdb"] },
  "application/vnd.ms-wpl": { "source": "iana", "extensions": ["wpl"] },
  "application/vnd.ms-xpsdocument": { "source": "iana", "compressible": false, "extensions": ["xps"] },
  "application/vnd.msa-disk-image": { "source": "iana" },
  "application/vnd.mseq": { "source": "iana", "extensions": ["mseq"] },
  "application/vnd.msign": { "source": "iana" },
  "application/vnd.multiad.creator": { "source": "iana" },
  "application/vnd.multiad.creator.cif": { "source": "iana" },
  "application/vnd.music-niff": { "source": "iana" },
  "application/vnd.musician": { "source": "iana", "extensions": ["mus"] },
  "application/vnd.muvee.style": { "source": "iana", "extensions": ["msty"] },
  "application/vnd.mynfc": { "source": "iana", "extensions": ["taglet"] },
  "application/vnd.nacamar.ybrid+json": { "source": "iana", "compressible": true },
  "application/vnd.ncd.control": { "source": "iana" },
  "application/vnd.ncd.reference": { "source": "iana" },
  "application/vnd.nearst.inv+json": { "source": "iana", "compressible": true },
  "application/vnd.nebumind.line": { "source": "iana" },
  "application/vnd.nervana": { "source": "iana" },
  "application/vnd.netfpx": { "source": "iana" },
  "application/vnd.neurolanguage.nlu": { "source": "iana", "extensions": ["nlu"] },
  "application/vnd.nimn": { "source": "iana" },
  "application/vnd.nintendo.nitro.rom": { "source": "iana" },
  "application/vnd.nintendo.snes.rom": { "source": "iana" },
  "application/vnd.nitf": { "source": "iana", "extensions": ["ntf", "nitf"] },
  "application/vnd.noblenet-directory": { "source": "iana", "extensions": ["nnd"] },
  "application/vnd.noblenet-sealer": { "source": "iana", "extensions": ["nns"] },
  "application/vnd.noblenet-web": { "source": "iana", "extensions": ["nnw"] },
  "application/vnd.nokia.catalogs": { "source": "iana" },
  "application/vnd.nokia.conml+wbxml": { "source": "iana" },
  "application/vnd.nokia.conml+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.iptv.config+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.isds-radio-presets": { "source": "iana" },
  "application/vnd.nokia.landmark+wbxml": { "source": "iana" },
  "application/vnd.nokia.landmark+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.landmarkcollection+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.n-gage.ac+xml": { "source": "iana", "compressible": true, "extensions": ["ac"] },
  "application/vnd.nokia.n-gage.data": { "source": "iana", "extensions": ["ngdat"] },
  "application/vnd.nokia.n-gage.symbian.install": { "source": "iana", "extensions": ["n-gage"] },
  "application/vnd.nokia.ncd": { "source": "iana" },
  "application/vnd.nokia.pcd+wbxml": { "source": "iana" },
  "application/vnd.nokia.pcd+xml": { "source": "iana", "compressible": true },
  "application/vnd.nokia.radio-preset": { "source": "iana", "extensions": ["rpst"] },
  "application/vnd.nokia.radio-presets": { "source": "iana", "extensions": ["rpss"] },
  "application/vnd.novadigm.edm": { "source": "iana", "extensions": ["edm"] },
  "application/vnd.novadigm.edx": { "source": "iana", "extensions": ["edx"] },
  "application/vnd.novadigm.ext": { "source": "iana", "extensions": ["ext"] },
  "application/vnd.ntt-local.content-share": { "source": "iana" },
  "application/vnd.ntt-local.file-transfer": { "source": "iana" },
  "application/vnd.ntt-local.ogw_remote-access": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_remote": { "source": "iana" },
  "application/vnd.ntt-local.sip-ta_tcp_stream": { "source": "iana" },
  "application/vnd.oasis.opendocument.chart": { "source": "iana", "extensions": ["odc"] },
  "application/vnd.oasis.opendocument.chart-template": { "source": "iana", "extensions": ["otc"] },
  "application/vnd.oasis.opendocument.database": { "source": "iana", "extensions": ["odb"] },
  "application/vnd.oasis.opendocument.formula": { "source": "iana", "extensions": ["odf"] },
  "application/vnd.oasis.opendocument.formula-template": { "source": "iana", "extensions": ["odft"] },
  "application/vnd.oasis.opendocument.graphics": { "source": "iana", "compressible": false, "extensions": ["odg"] },
  "application/vnd.oasis.opendocument.graphics-template": { "source": "iana", "extensions": ["otg"] },
  "application/vnd.oasis.opendocument.image": { "source": "iana", "extensions": ["odi"] },
  "application/vnd.oasis.opendocument.image-template": { "source": "iana", "extensions": ["oti"] },
  "application/vnd.oasis.opendocument.presentation": { "source": "iana", "compressible": false, "extensions": ["odp"] },
  "application/vnd.oasis.opendocument.presentation-template": { "source": "iana", "extensions": ["otp"] },
  "application/vnd.oasis.opendocument.spreadsheet": { "source": "iana", "compressible": false, "extensions": ["ods"] },
  "application/vnd.oasis.opendocument.spreadsheet-template": { "source": "iana", "extensions": ["ots"] },
  "application/vnd.oasis.opendocument.text": { "source": "iana", "compressible": false, "extensions": ["odt"] },
  "application/vnd.oasis.opendocument.text-master": { "source": "iana", "extensions": ["odm"] },
  "application/vnd.oasis.opendocument.text-template": { "source": "iana", "extensions": ["ott"] },
  "application/vnd.oasis.opendocument.text-web": { "source": "iana", "extensions": ["oth"] },
  "application/vnd.obn": { "source": "iana" },
  "application/vnd.ocf+cbor": { "source": "iana" },
  "application/vnd.oci.image.manifest.v1+json": { "source": "iana", "compressible": true },
  "application/vnd.oftn.l10n+json": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessdownload+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.contentaccessstreaming+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.cspg-hexbinary": { "source": "iana" },
  "application/vnd.oipf.dae.svg+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.dae.xhtml+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.mippvcontrolmessage+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.pae.gem": { "source": "iana" },
  "application/vnd.oipf.spdiscovery+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.spdlist+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.ueprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.oipf.userprofile+xml": { "source": "iana", "compressible": true },
  "application/vnd.olpc-sugar": { "source": "iana", "extensions": ["xo"] },
  "application/vnd.oma-scws-config": { "source": "iana" },
  "application/vnd.oma-scws-http-request": { "source": "iana" },
  "application/vnd.oma-scws-http-response": { "source": "iana" },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.drm-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.imd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.ltkm": { "source": "iana" },
  "application/vnd.oma.bcast.notification+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.provisioningtrigger": { "source": "iana" },
  "application/vnd.oma.bcast.sgboot": { "source": "iana" },
  "application/vnd.oma.bcast.sgdd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sgdu": { "source": "iana" },
  "application/vnd.oma.bcast.simple-symbol-container": { "source": "iana" },
  "application/vnd.oma.bcast.smartcard-trigger+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.sprov+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.bcast.stkm": { "source": "iana" },
  "application/vnd.oma.cab-address-book+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-feature-handler+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-pcc+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-subs-invite+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.cab-user-prefs+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.dcd": { "source": "iana" },
  "application/vnd.oma.dcdc": { "source": "iana" },
  "application/vnd.oma.dd2+xml": { "source": "iana", "compressible": true, "extensions": ["dd2"] },
  "application/vnd.oma.drm.risd+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.group-usage-list+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+cbor": { "source": "iana" },
  "application/vnd.oma.lwm2m+json": { "source": "iana", "compressible": true },
  "application/vnd.oma.lwm2m+tlv": { "source": "iana" },
  "application/vnd.oma.pal+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.detailed-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.final-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.groups+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.invocation-descriptor+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.poc.optimized-progress-report+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.push": { "source": "iana" },
  "application/vnd.oma.scidm.messages+xml": { "source": "iana", "compressible": true },
  "application/vnd.oma.xcap-directory+xml": { "source": "iana", "compressible": true },
  "application/vnd.omads-email+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-file+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omads-folder+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.omaloc-supl-init": { "source": "iana" },
  "application/vnd.onepager": { "source": "iana" },
  "application/vnd.onepagertamp": { "source": "iana" },
  "application/vnd.onepagertamx": { "source": "iana" },
  "application/vnd.onepagertat": { "source": "iana" },
  "application/vnd.onepagertatp": { "source": "iana" },
  "application/vnd.onepagertatx": { "source": "iana" },
  "application/vnd.openblox.game+xml": { "source": "iana", "compressible": true, "extensions": ["obgx"] },
  "application/vnd.openblox.game-binary": { "source": "iana" },
  "application/vnd.openeye.oeb": { "source": "iana" },
  "application/vnd.openofficeorg.extension": { "source": "apache", "extensions": ["oxt"] },
  "application/vnd.openstreetmap.data+xml": { "source": "iana", "compressible": true, "extensions": ["osm"] },
  "application/vnd.opentimestamps.ots": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawing+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": { "source": "iana", "compressible": false, "extensions": ["pptx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": { "source": "iana", "extensions": ["sldx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": { "source": "iana", "extensions": ["ppsx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.template": { "source": "iana", "extensions": ["potx"] },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": { "source": "iana", "compressible": false, "extensions": ["xlsx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": { "source": "iana", "extensions": ["xltx"] },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.theme+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.vmldrawing": { "source": "iana" },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": { "source": "iana", "compressible": false, "extensions": ["docx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": { "source": "iana", "extensions": ["dotx"] },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.core-properties+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": { "source": "iana", "compressible": true },
  "application/vnd.openxmlformats-package.relationships+xml": { "source": "iana", "compressible": true },
  "application/vnd.oracle.resource+json": { "source": "iana", "compressible": true },
  "application/vnd.orange.indata": { "source": "iana" },
  "application/vnd.osa.netdeploy": { "source": "iana" },
  "application/vnd.osgeo.mapguide.package": { "source": "iana", "extensions": ["mgp"] },
  "application/vnd.osgi.bundle": { "source": "iana" },
  "application/vnd.osgi.dp": { "source": "iana", "extensions": ["dp"] },
  "application/vnd.osgi.subsystem": { "source": "iana", "extensions": ["esa"] },
  "application/vnd.otps.ct-kip+xml": { "source": "iana", "compressible": true },
  "application/vnd.oxli.countgraph": { "source": "iana" },
  "application/vnd.pagerduty+json": { "source": "iana", "compressible": true },
  "application/vnd.palm": { "source": "iana", "extensions": ["pdb", "pqa", "oprc"] },
  "application/vnd.panoply": { "source": "iana" },
  "application/vnd.paos.xml": { "source": "iana" },
  "application/vnd.patentdive": { "source": "iana" },
  "application/vnd.patientecommsdoc": { "source": "iana" },
  "application/vnd.pawaafile": { "source": "iana", "extensions": ["paw"] },
  "application/vnd.pcos": { "source": "iana" },
  "application/vnd.pg.format": { "source": "iana", "extensions": ["str"] },
  "application/vnd.pg.osasli": { "source": "iana", "extensions": ["ei6"] },
  "application/vnd.piaccess.application-licence": { "source": "iana" },
  "application/vnd.picsel": { "source": "iana", "extensions": ["efif"] },
  "application/vnd.pmi.widget": { "source": "iana", "extensions": ["wg"] },
  "application/vnd.poc.group-advertisement+xml": { "source": "iana", "compressible": true },
  "application/vnd.pocketlearn": { "source": "iana", "extensions": ["plf"] },
  "application/vnd.powerbuilder6": { "source": "iana", "extensions": ["pbd"] },
  "application/vnd.powerbuilder6-s": { "source": "iana" },
  "application/vnd.powerbuilder7": { "source": "iana" },
  "application/vnd.powerbuilder7-s": { "source": "iana" },
  "application/vnd.powerbuilder75": { "source": "iana" },
  "application/vnd.powerbuilder75-s": { "source": "iana" },
  "application/vnd.preminet": { "source": "iana" },
  "application/vnd.previewsystems.box": { "source": "iana", "extensions": ["box"] },
  "application/vnd.proteus.magazine": { "source": "iana", "extensions": ["mgz"] },
  "application/vnd.psfs": { "source": "iana" },
  "application/vnd.publishare-delta-tree": { "source": "iana", "extensions": ["qps"] },
  "application/vnd.pvi.ptid1": { "source": "iana", "extensions": ["ptid"] },
  "application/vnd.pwg-multiplexed": { "source": "iana" },
  "application/vnd.pwg-xhtml-print+xml": { "source": "iana", "compressible": true },
  "application/vnd.qualcomm.brew-app-res": { "source": "iana" },
  "application/vnd.quarantainenet": { "source": "iana" },
  "application/vnd.quark.quarkxpress": { "source": "iana", "extensions": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"] },
  "application/vnd.quobject-quoxdocument": { "source": "iana" },
  "application/vnd.radisys.moml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-conn+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-audit-stream+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-conf+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-base+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-group+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-speech+xml": { "source": "iana", "compressible": true },
  "application/vnd.radisys.msml-dialog-transform+xml": { "source": "iana", "compressible": true },
  "application/vnd.rainstor.data": { "source": "iana" },
  "application/vnd.rapid": { "source": "iana" },
  "application/vnd.rar": { "source": "iana", "extensions": ["rar"] },
  "application/vnd.realvnc.bed": { "source": "iana", "extensions": ["bed"] },
  "application/vnd.recordare.musicxml": { "source": "iana", "extensions": ["mxl"] },
  "application/vnd.recordare.musicxml+xml": { "source": "iana", "compressible": true, "extensions": ["musicxml"] },
  "application/vnd.renlearn.rlprint": { "source": "iana" },
  "application/vnd.resilient.logic": { "source": "iana" },
  "application/vnd.restful+json": { "source": "iana", "compressible": true },
  "application/vnd.rig.cryptonote": { "source": "iana", "extensions": ["cryptonote"] },
  "application/vnd.rim.cod": { "source": "apache", "extensions": ["cod"] },
  "application/vnd.rn-realmedia": { "source": "apache", "extensions": ["rm"] },
  "application/vnd.rn-realmedia-vbr": { "source": "apache", "extensions": ["rmvb"] },
  "application/vnd.route66.link66+xml": { "source": "iana", "compressible": true, "extensions": ["link66"] },
  "application/vnd.rs-274x": { "source": "iana" },
  "application/vnd.ruckus.download": { "source": "iana" },
  "application/vnd.s3sms": { "source": "iana" },
  "application/vnd.sailingtracker.track": { "source": "iana", "extensions": ["st"] },
  "application/vnd.sar": { "source": "iana" },
  "application/vnd.sbm.cid": { "source": "iana" },
  "application/vnd.sbm.mid2": { "source": "iana" },
  "application/vnd.scribus": { "source": "iana" },
  "application/vnd.sealed.3df": { "source": "iana" },
  "application/vnd.sealed.csf": { "source": "iana" },
  "application/vnd.sealed.doc": { "source": "iana" },
  "application/vnd.sealed.eml": { "source": "iana" },
  "application/vnd.sealed.mht": { "source": "iana" },
  "application/vnd.sealed.net": { "source": "iana" },
  "application/vnd.sealed.ppt": { "source": "iana" },
  "application/vnd.sealed.tiff": { "source": "iana" },
  "application/vnd.sealed.xls": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.html": { "source": "iana" },
  "application/vnd.sealedmedia.softseal.pdf": { "source": "iana" },
  "application/vnd.seemail": { "source": "iana", "extensions": ["see"] },
  "application/vnd.seis+json": { "source": "iana", "compressible": true },
  "application/vnd.sema": { "source": "iana", "extensions": ["sema"] },
  "application/vnd.semd": { "source": "iana", "extensions": ["semd"] },
  "application/vnd.semf": { "source": "iana", "extensions": ["semf"] },
  "application/vnd.shade-save-file": { "source": "iana" },
  "application/vnd.shana.informed.formdata": { "source": "iana", "extensions": ["ifm"] },
  "application/vnd.shana.informed.formtemplate": { "source": "iana", "extensions": ["itp"] },
  "application/vnd.shana.informed.interchange": { "source": "iana", "extensions": ["iif"] },
  "application/vnd.shana.informed.package": { "source": "iana", "extensions": ["ipk"] },
  "application/vnd.shootproof+json": { "source": "iana", "compressible": true },
  "application/vnd.shopkick+json": { "source": "iana", "compressible": true },
  "application/vnd.shp": { "source": "iana" },
  "application/vnd.shx": { "source": "iana" },
  "application/vnd.sigrok.session": { "source": "iana" },
  "application/vnd.simtech-mindmapper": { "source": "iana", "extensions": ["twd", "twds"] },
  "application/vnd.siren+json": { "source": "iana", "compressible": true },
  "application/vnd.smaf": { "source": "iana", "extensions": ["mmf"] },
  "application/vnd.smart.notebook": { "source": "iana" },
  "application/vnd.smart.teacher": { "source": "iana", "extensions": ["teacher"] },
  "application/vnd.snesdev-page-table": { "source": "iana" },
  "application/vnd.software602.filler.form+xml": { "source": "iana", "compressible": true, "extensions": ["fo"] },
  "application/vnd.software602.filler.form-xml-zip": { "source": "iana" },
  "application/vnd.solent.sdkm+xml": { "source": "iana", "compressible": true, "extensions": ["sdkm", "sdkd"] },
  "application/vnd.spotfire.dxp": { "source": "iana", "extensions": ["dxp"] },
  "application/vnd.spotfire.sfs": { "source": "iana", "extensions": ["sfs"] },
  "application/vnd.sqlite3": { "source": "iana" },
  "application/vnd.sss-cod": { "source": "iana" },
  "application/vnd.sss-dtf": { "source": "iana" },
  "application/vnd.sss-ntf": { "source": "iana" },
  "application/vnd.stardivision.calc": { "source": "apache", "extensions": ["sdc"] },
  "application/vnd.stardivision.draw": { "source": "apache", "extensions": ["sda"] },
  "application/vnd.stardivision.impress": { "source": "apache", "extensions": ["sdd"] },
  "application/vnd.stardivision.math": { "source": "apache", "extensions": ["smf"] },
  "application/vnd.stardivision.writer": { "source": "apache", "extensions": ["sdw", "vor"] },
  "application/vnd.stardivision.writer-global": { "source": "apache", "extensions": ["sgl"] },
  "application/vnd.stepmania.package": { "source": "iana", "extensions": ["smzip"] },
  "application/vnd.stepmania.stepchart": { "source": "iana", "extensions": ["sm"] },
  "application/vnd.street-stream": { "source": "iana" },
  "application/vnd.sun.wadl+xml": { "source": "iana", "compressible": true, "extensions": ["wadl"] },
  "application/vnd.sun.xml.calc": { "source": "apache", "extensions": ["sxc"] },
  "application/vnd.sun.xml.calc.template": { "source": "apache", "extensions": ["stc"] },
  "application/vnd.sun.xml.draw": { "source": "apache", "extensions": ["sxd"] },
  "application/vnd.sun.xml.draw.template": { "source": "apache", "extensions": ["std"] },
  "application/vnd.sun.xml.impress": { "source": "apache", "extensions": ["sxi"] },
  "application/vnd.sun.xml.impress.template": { "source": "apache", "extensions": ["sti"] },
  "application/vnd.sun.xml.math": { "source": "apache", "extensions": ["sxm"] },
  "application/vnd.sun.xml.writer": { "source": "apache", "extensions": ["sxw"] },
  "application/vnd.sun.xml.writer.global": { "source": "apache", "extensions": ["sxg"] },
  "application/vnd.sun.xml.writer.template": { "source": "apache", "extensions": ["stw"] },
  "application/vnd.sus-calendar": { "source": "iana", "extensions": ["sus", "susp"] },
  "application/vnd.svd": { "source": "iana", "extensions": ["svd"] },
  "application/vnd.swiftview-ics": { "source": "iana" },
  "application/vnd.sycle+xml": { "source": "iana", "compressible": true },
  "application/vnd.syft+json": { "source": "iana", "compressible": true },
  "application/vnd.symbian.install": { "source": "apache", "extensions": ["sis", "sisx"] },
  "application/vnd.syncml+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xsm"] },
  "application/vnd.syncml.dm+wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["bdm"] },
  "application/vnd.syncml.dm+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["xdm"] },
  "application/vnd.syncml.dm.notification": { "source": "iana" },
  "application/vnd.syncml.dmddf+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmddf+xml": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["ddf"] },
  "application/vnd.syncml.dmtnds+wbxml": { "source": "iana" },
  "application/vnd.syncml.dmtnds+xml": { "source": "iana", "charset": "UTF-8", "compressible": true },
  "application/vnd.syncml.ds.notification": { "source": "iana" },
  "application/vnd.tableschema+json": { "source": "iana", "compressible": true },
  "application/vnd.tao.intent-module-archive": { "source": "iana", "extensions": ["tao"] },
  "application/vnd.tcpdump.pcap": { "source": "iana", "extensions": ["pcap", "cap", "dmp"] },
  "application/vnd.think-cell.ppttc+json": { "source": "iana", "compressible": true },
  "application/vnd.tmd.mediaflex.api+xml": { "source": "iana", "compressible": true },
  "application/vnd.tml": { "source": "iana" },
  "application/vnd.tmobile-livetv": { "source": "iana", "extensions": ["tmo"] },
  "application/vnd.tri.onesource": { "source": "iana" },
  "application/vnd.trid.tpt": { "source": "iana", "extensions": ["tpt"] },
  "application/vnd.triscape.mxs": { "source": "iana", "extensions": ["mxs"] },
  "application/vnd.trueapp": { "source": "iana", "extensions": ["tra"] },
  "application/vnd.truedoc": { "source": "iana" },
  "application/vnd.ubisoft.webplayer": { "source": "iana" },
  "application/vnd.ufdl": { "source": "iana", "extensions": ["ufd", "ufdl"] },
  "application/vnd.uiq.theme": { "source": "iana", "extensions": ["utz"] },
  "application/vnd.umajin": { "source": "iana", "extensions": ["umj"] },
  "application/vnd.unity": { "source": "iana", "extensions": ["unityweb"] },
  "application/vnd.uoml+xml": { "source": "iana", "compressible": true, "extensions": ["uoml"] },
  "application/vnd.uplanet.alert": { "source": "iana" },
  "application/vnd.uplanet.alert-wbxml": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice": { "source": "iana" },
  "application/vnd.uplanet.bearer-choice-wbxml": { "source": "iana" },
  "application/vnd.uplanet.cacheop": { "source": "iana" },
  "application/vnd.uplanet.cacheop-wbxml": { "source": "iana" },
  "application/vnd.uplanet.channel": { "source": "iana" },
  "application/vnd.uplanet.channel-wbxml": { "source": "iana" },
  "application/vnd.uplanet.list": { "source": "iana" },
  "application/vnd.uplanet.list-wbxml": { "source": "iana" },
  "application/vnd.uplanet.listcmd": { "source": "iana" },
  "application/vnd.uplanet.listcmd-wbxml": { "source": "iana" },
  "application/vnd.uplanet.signal": { "source": "iana" },
  "application/vnd.uri-map": { "source": "iana" },
  "application/vnd.valve.source.material": { "source": "iana" },
  "application/vnd.vcx": { "source": "iana", "extensions": ["vcx"] },
  "application/vnd.vd-study": { "source": "iana" },
  "application/vnd.vectorworks": { "source": "iana" },
  "application/vnd.vel+json": { "source": "iana", "compressible": true },
  "application/vnd.verimatrix.vcas": { "source": "iana" },
  "application/vnd.veritone.aion+json": { "source": "iana", "compressible": true },
  "application/vnd.veryant.thin": { "source": "iana" },
  "application/vnd.ves.encrypted": { "source": "iana" },
  "application/vnd.vidsoft.vidconference": { "source": "iana" },
  "application/vnd.visio": { "source": "iana", "extensions": ["vsd", "vst", "vss", "vsw"] },
  "application/vnd.visionary": { "source": "iana", "extensions": ["vis"] },
  "application/vnd.vividence.scriptfile": { "source": "iana" },
  "application/vnd.vsf": { "source": "iana", "extensions": ["vsf"] },
  "application/vnd.wap.sic": { "source": "iana" },
  "application/vnd.wap.slc": { "source": "iana" },
  "application/vnd.wap.wbxml": { "source": "iana", "charset": "UTF-8", "extensions": ["wbxml"] },
  "application/vnd.wap.wmlc": { "source": "iana", "extensions": ["wmlc"] },
  "application/vnd.wap.wmlscriptc": { "source": "iana", "extensions": ["wmlsc"] },
  "application/vnd.webturbo": { "source": "iana", "extensions": ["wtb"] },
  "application/vnd.wfa.dpp": { "source": "iana" },
  "application/vnd.wfa.p2p": { "source": "iana" },
  "application/vnd.wfa.wsc": { "source": "iana" },
  "application/vnd.windows.devicepairing": { "source": "iana" },
  "application/vnd.wmc": { "source": "iana" },
  "application/vnd.wmf.bootstrap": { "source": "iana" },
  "application/vnd.wolfram.mathematica": { "source": "iana" },
  "application/vnd.wolfram.mathematica.package": { "source": "iana" },
  "application/vnd.wolfram.player": { "source": "iana", "extensions": ["nbp"] },
  "application/vnd.wordperfect": { "source": "iana", "extensions": ["wpd"] },
  "application/vnd.wqd": { "source": "iana", "extensions": ["wqd"] },
  "application/vnd.wrq-hp3000-labelled": { "source": "iana" },
  "application/vnd.wt.stf": { "source": "iana", "extensions": ["stf"] },
  "application/vnd.wv.csp+wbxml": { "source": "iana" },
  "application/vnd.wv.csp+xml": { "source": "iana", "compressible": true },
  "application/vnd.wv.ssp+xml": { "source": "iana", "compressible": true },
  "application/vnd.xacml+json": { "source": "iana", "compressible": true },
  "application/vnd.xara": { "source": "iana", "extensions": ["xar"] },
  "application/vnd.xfdl": { "source": "iana", "extensions": ["xfdl"] },
  "application/vnd.xfdl.webform": { "source": "iana" },
  "application/vnd.xmi+xml": { "source": "iana", "compressible": true },
  "application/vnd.xmpie.cpkg": { "source": "iana" },
  "application/vnd.xmpie.dpkg": { "source": "iana" },
  "application/vnd.xmpie.plan": { "source": "iana" },
  "application/vnd.xmpie.ppkg": { "source": "iana" },
  "application/vnd.xmpie.xlim": { "source": "iana" },
  "application/vnd.yamaha.hv-dic": { "source": "iana", "extensions": ["hvd"] },
  "application/vnd.yamaha.hv-script": { "source": "iana", "extensions": ["hvs"] },
  "application/vnd.yamaha.hv-voice": { "source": "iana", "extensions": ["hvp"] },
  "application/vnd.yamaha.openscoreformat": { "source": "iana", "extensions": ["osf"] },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": { "source": "iana", "compressible": true, "extensions": ["osfpvg"] },
  "application/vnd.yamaha.remote-setup": { "source": "iana" },
  "application/vnd.yamaha.smaf-audio": { "source": "iana", "extensions": ["saf"] },
  "application/vnd.yamaha.smaf-phrase": { "source": "iana", "extensions": ["spf"] },
  "application/vnd.yamaha.through-ngn": { "source": "iana" },
  "application/vnd.yamaha.tunnel-udpencap": { "source": "iana" },
  "application/vnd.yaoweme": { "source": "iana" },
  "application/vnd.yellowriver-custom-menu": { "source": "iana", "extensions": ["cmp"] },
  "application/vnd.youtube.yt": { "source": "iana" },
  "application/vnd.zul": { "source": "iana", "extensions": ["zir", "zirz"] },
  "application/vnd.zzazz.deck+xml": { "source": "iana", "compressible": true, "extensions": ["zaz"] },
  "application/voicexml+xml": { "source": "iana", "compressible": true, "extensions": ["vxml"] },
  "application/voucher-cms+json": { "source": "iana", "compressible": true },
  "application/vq-rtcpxr": { "source": "iana" },
  "application/wasm": { "source": "iana", "compressible": true, "extensions": ["wasm"] },
  "application/watcherinfo+xml": { "source": "iana", "compressible": true, "extensions": ["wif"] },
  "application/webpush-options+json": { "source": "iana", "compressible": true },
  "application/whoispp-query": { "source": "iana" },
  "application/whoispp-response": { "source": "iana" },
  "application/widget": { "source": "iana", "extensions": ["wgt"] },
  "application/winhlp": { "source": "apache", "extensions": ["hlp"] },
  "application/wita": { "source": "iana" },
  "application/wordperfect5.1": { "source": "iana" },
  "application/wsdl+xml": { "source": "iana", "compressible": true, "extensions": ["wsdl"] },
  "application/wspolicy+xml": { "source": "iana", "compressible": true, "extensions": ["wspolicy"] },
  "application/x-7z-compressed": { "source": "apache", "compressible": false, "extensions": ["7z"] },
  "application/x-abiword": { "source": "apache", "extensions": ["abw"] },
  "application/x-ace-compressed": { "source": "apache", "extensions": ["ace"] },
  "application/x-amf": { "source": "apache" },
  "application/x-apple-diskimage": { "source": "apache", "extensions": ["dmg"] },
  "application/x-arj": { "compressible": false, "extensions": ["arj"] },
  "application/x-authorware-bin": { "source": "apache", "extensions": ["aab", "x32", "u32", "vox"] },
  "application/x-authorware-map": { "source": "apache", "extensions": ["aam"] },
  "application/x-authorware-seg": { "source": "apache", "extensions": ["aas"] },
  "application/x-bcpio": { "source": "apache", "extensions": ["bcpio"] },
  "application/x-bdoc": { "compressible": false, "extensions": ["bdoc"] },
  "application/x-bittorrent": { "source": "apache", "extensions": ["torrent"] },
  "application/x-blorb": { "source": "apache", "extensions": ["blb", "blorb"] },
  "application/x-bzip": { "source": "apache", "compressible": false, "extensions": ["bz"] },
  "application/x-bzip2": { "source": "apache", "compressible": false, "extensions": ["bz2", "boz"] },
  "application/x-cbr": { "source": "apache", "extensions": ["cbr", "cba", "cbt", "cbz", "cb7"] },
  "application/x-cdlink": { "source": "apache", "extensions": ["vcd"] },
  "application/x-cfs-compressed": { "source": "apache", "extensions": ["cfs"] },
  "application/x-chat": { "source": "apache", "extensions": ["chat"] },
  "application/x-chess-pgn": { "source": "apache", "extensions": ["pgn"] },
  "application/x-chrome-extension": { "extensions": ["crx"] },
  "application/x-cocoa": { "source": "nginx", "extensions": ["cco"] },
  "application/x-compress": { "source": "apache" },
  "application/x-conference": { "source": "apache", "extensions": ["nsc"] },
  "application/x-cpio": { "source": "apache", "extensions": ["cpio"] },
  "application/x-csh": { "source": "apache", "extensions": ["csh"] },
  "application/x-deb": { "compressible": false },
  "application/x-debian-package": { "source": "apache", "extensions": ["deb", "udeb"] },
  "application/x-dgc-compressed": { "source": "apache", "extensions": ["dgc"] },
  "application/x-director": { "source": "apache", "extensions": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"] },
  "application/x-doom": { "source": "apache", "extensions": ["wad"] },
  "application/x-dtbncx+xml": { "source": "apache", "compressible": true, "extensions": ["ncx"] },
  "application/x-dtbook+xml": { "source": "apache", "compressible": true, "extensions": ["dtb"] },
  "application/x-dtbresource+xml": { "source": "apache", "compressible": true, "extensions": ["res"] },
  "application/x-dvi": { "source": "apache", "compressible": false, "extensions": ["dvi"] },
  "application/x-envoy": { "source": "apache", "extensions": ["evy"] },
  "application/x-eva": { "source": "apache", "extensions": ["eva"] },
  "application/x-font-bdf": { "source": "apache", "extensions": ["bdf"] },
  "application/x-font-dos": { "source": "apache" },
  "application/x-font-framemaker": { "source": "apache" },
  "application/x-font-ghostscript": { "source": "apache", "extensions": ["gsf"] },
  "application/x-font-libgrx": { "source": "apache" },
  "application/x-font-linux-psf": { "source": "apache", "extensions": ["psf"] },
  "application/x-font-pcf": { "source": "apache", "extensions": ["pcf"] },
  "application/x-font-snf": { "source": "apache", "extensions": ["snf"] },
  "application/x-font-speedo": { "source": "apache" },
  "application/x-font-sunos-news": { "source": "apache" },
  "application/x-font-type1": { "source": "apache", "extensions": ["pfa", "pfb", "pfm", "afm"] },
  "application/x-font-vfont": { "source": "apache" },
  "application/x-freearc": { "source": "apache", "extensions": ["arc"] },
  "application/x-futuresplash": { "source": "apache", "extensions": ["spl"] },
  "application/x-gca-compressed": { "source": "apache", "extensions": ["gca"] },
  "application/x-glulx": { "source": "apache", "extensions": ["ulx"] },
  "application/x-gnumeric": { "source": "apache", "extensions": ["gnumeric"] },
  "application/x-gramps-xml": { "source": "apache", "extensions": ["gramps"] },
  "application/x-gtar": { "source": "apache", "extensions": ["gtar"] },
  "application/x-gzip": { "source": "apache" },
  "application/x-hdf": { "source": "apache", "extensions": ["hdf"] },
  "application/x-httpd-php": { "compressible": true, "extensions": ["php"] },
  "application/x-install-instructions": { "source": "apache", "extensions": ["install"] },
  "application/x-iso9660-image": { "source": "apache", "extensions": ["iso"] },
  "application/x-iwork-keynote-sffkey": { "extensions": ["key"] },
  "application/x-iwork-numbers-sffnumbers": { "extensions": ["numbers"] },
  "application/x-iwork-pages-sffpages": { "extensions": ["pages"] },
  "application/x-java-archive-diff": { "source": "nginx", "extensions": ["jardiff"] },
  "application/x-java-jnlp-file": { "source": "apache", "compressible": false, "extensions": ["jnlp"] },
  "application/x-javascript": { "compressible": true },
  "application/x-keepass2": { "extensions": ["kdbx"] },
  "application/x-latex": { "source": "apache", "compressible": false, "extensions": ["latex"] },
  "application/x-lua-bytecode": { "extensions": ["luac"] },
  "application/x-lzh-compressed": { "source": "apache", "extensions": ["lzh", "lha"] },
  "application/x-makeself": { "source": "nginx", "extensions": ["run"] },
  "application/x-mie": { "source": "apache", "extensions": ["mie"] },
  "application/x-mobipocket-ebook": { "source": "apache", "extensions": ["prc", "mobi"] },
  "application/x-mpegurl": { "compressible": false },
  "application/x-ms-application": { "source": "apache", "extensions": ["application"] },
  "application/x-ms-shortcut": { "source": "apache", "extensions": ["lnk"] },
  "application/x-ms-wmd": { "source": "apache", "extensions": ["wmd"] },
  "application/x-ms-wmz": { "source": "apache", "extensions": ["wmz"] },
  "application/x-ms-xbap": { "source": "apache", "extensions": ["xbap"] },
  "application/x-msaccess": { "source": "apache", "extensions": ["mdb"] },
  "application/x-msbinder": { "source": "apache", "extensions": ["obd"] },
  "application/x-mscardfile": { "source": "apache", "extensions": ["crd"] },
  "application/x-msclip": { "source": "apache", "extensions": ["clp"] },
  "application/x-msdos-program": { "extensions": ["exe"] },
  "application/x-msdownload": { "source": "apache", "extensions": ["exe", "dll", "com", "bat", "msi"] },
  "application/x-msmediaview": { "source": "apache", "extensions": ["mvb", "m13", "m14"] },
  "application/x-msmetafile": { "source": "apache", "extensions": ["wmf", "wmz", "emf", "emz"] },
  "application/x-msmoney": { "source": "apache", "extensions": ["mny"] },
  "application/x-mspublisher": { "source": "apache", "extensions": ["pub"] },
  "application/x-msschedule": { "source": "apache", "extensions": ["scd"] },
  "application/x-msterminal": { "source": "apache", "extensions": ["trm"] },
  "application/x-mswrite": { "source": "apache", "extensions": ["wri"] },
  "application/x-netcdf": { "source": "apache", "extensions": ["nc", "cdf"] },
  "application/x-ns-proxy-autoconfig": { "compressible": true, "extensions": ["pac"] },
  "application/x-nzb": { "source": "apache", "extensions": ["nzb"] },
  "application/x-perl": { "source": "nginx", "extensions": ["pl", "pm"] },
  "application/x-pilot": { "source": "nginx", "extensions": ["prc", "pdb"] },
  "application/x-pkcs12": { "source": "apache", "compressible": false, "extensions": ["p12", "pfx"] },
  "application/x-pkcs7-certificates": { "source": "apache", "extensions": ["p7b", "spc"] },
  "application/x-pkcs7-certreqresp": { "source": "apache", "extensions": ["p7r"] },
  "application/x-pki-message": { "source": "iana" },
  "application/x-rar-compressed": { "source": "apache", "compressible": false, "extensions": ["rar"] },
  "application/x-redhat-package-manager": { "source": "nginx", "extensions": ["rpm"] },
  "application/x-research-info-systems": { "source": "apache", "extensions": ["ris"] },
  "application/x-sea": { "source": "nginx", "extensions": ["sea"] },
  "application/x-sh": { "source": "apache", "compressible": true, "extensions": ["sh"] },
  "application/x-shar": { "source": "apache", "extensions": ["shar"] },
  "application/x-shockwave-flash": { "source": "apache", "compressible": false, "extensions": ["swf"] },
  "application/x-silverlight-app": { "source": "apache", "extensions": ["xap"] },
  "application/x-sql": { "source": "apache", "extensions": ["sql"] },
  "application/x-stuffit": { "source": "apache", "compressible": false, "extensions": ["sit"] },
  "application/x-stuffitx": { "source": "apache", "extensions": ["sitx"] },
  "application/x-subrip": { "source": "apache", "extensions": ["srt"] },
  "application/x-sv4cpio": { "source": "apache", "extensions": ["sv4cpio"] },
  "application/x-sv4crc": { "source": "apache", "extensions": ["sv4crc"] },
  "application/x-t3vm-image": { "source": "apache", "extensions": ["t3"] },
  "application/x-tads": { "source": "apache", "extensions": ["gam"] },
  "application/x-tar": { "source": "apache", "compressible": true, "extensions": ["tar"] },
  "application/x-tcl": { "source": "apache", "extensions": ["tcl", "tk"] },
  "application/x-tex": { "source": "apache", "extensions": ["tex"] },
  "application/x-tex-tfm": { "source": "apache", "extensions": ["tfm"] },
  "application/x-texinfo": { "source": "apache", "extensions": ["texinfo", "texi"] },
  "application/x-tgif": { "source": "apache", "extensions": ["obj"] },
  "application/x-ustar": { "source": "apache", "extensions": ["ustar"] },
  "application/x-virtualbox-hdd": { "compressible": true, "extensions": ["hdd"] },
  "application/x-virtualbox-ova": { "compressible": true, "extensions": ["ova"] },
  "application/x-virtualbox-ovf": { "compressible": true, "extensions": ["ovf"] },
  "application/x-virtualbox-vbox": { "compressible": true, "extensions": ["vbox"] },
  "application/x-virtualbox-vbox-extpack": { "compressible": false, "extensions": ["vbox-extpack"] },
  "application/x-virtualbox-vdi": { "compressible": true, "extensions": ["vdi"] },
  "application/x-virtualbox-vhd": { "compressible": true, "extensions": ["vhd"] },
  "application/x-virtualbox-vmdk": { "compressible": true, "extensions": ["vmdk"] },
  "application/x-wais-source": { "source": "apache", "extensions": ["src"] },
  "application/x-web-app-manifest+json": { "compressible": true, "extensions": ["webapp"] },
  "application/x-www-form-urlencoded": { "source": "iana", "compressible": true },
  "application/x-x509-ca-cert": { "source": "iana", "extensions": ["der", "crt", "pem"] },
  "application/x-x509-ca-ra-cert": { "source": "iana" },
  "application/x-x509-next-ca-cert": { "source": "iana" },
  "application/x-xfig": { "source": "apache", "extensions": ["fig"] },
  "application/x-xliff+xml": { "source": "apache", "compressible": true, "extensions": ["xlf"] },
  "application/x-xpinstall": { "source": "apache", "compressible": false, "extensions": ["xpi"] },
  "application/x-xz": { "source": "apache", "extensions": ["xz"] },
  "application/x-zmachine": { "source": "apache", "extensions": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"] },
  "application/x400-bp": { "source": "iana" },
  "application/xacml+xml": { "source": "iana", "compressible": true },
  "application/xaml+xml": { "source": "apache", "compressible": true, "extensions": ["xaml"] },
  "application/xcap-att+xml": { "source": "iana", "compressible": true, "extensions": ["xav"] },
  "application/xcap-caps+xml": { "source": "iana", "compressible": true, "extensions": ["xca"] },
  "application/xcap-diff+xml": { "source": "iana", "compressible": true, "extensions": ["xdf"] },
  "application/xcap-el+xml": { "source": "iana", "compressible": true, "extensions": ["xel"] },
  "application/xcap-error+xml": { "source": "iana", "compressible": true },
  "application/xcap-ns+xml": { "source": "iana", "compressible": true, "extensions": ["xns"] },
  "application/xcon-conference-info+xml": { "source": "iana", "compressible": true },
  "application/xcon-conference-info-diff+xml": { "source": "iana", "compressible": true },
  "application/xenc+xml": { "source": "iana", "compressible": true, "extensions": ["xenc"] },
  "application/xhtml+xml": { "source": "iana", "compressible": true, "extensions": ["xhtml", "xht"] },
  "application/xhtml-voice+xml": { "source": "apache", "compressible": true },
  "application/xliff+xml": { "source": "iana", "compressible": true, "extensions": ["xlf"] },
  "application/xml": { "source": "iana", "compressible": true, "extensions": ["xml", "xsl", "xsd", "rng"] },
  "application/xml-dtd": { "source": "iana", "compressible": true, "extensions": ["dtd"] },
  "application/xml-external-parsed-entity": { "source": "iana" },
  "application/xml-patch+xml": { "source": "iana", "compressible": true },
  "application/xmpp+xml": { "source": "iana", "compressible": true },
  "application/xop+xml": { "source": "iana", "compressible": true, "extensions": ["xop"] },
  "application/xproc+xml": { "source": "apache", "compressible": true, "extensions": ["xpl"] },
  "application/xslt+xml": { "source": "iana", "compressible": true, "extensions": ["xsl", "xslt"] },
  "application/xspf+xml": { "source": "apache", "compressible": true, "extensions": ["xspf"] },
  "application/xv+xml": { "source": "iana", "compressible": true, "extensions": ["mxml", "xhvml", "xvml", "xvm"] },
  "application/yang": { "source": "iana", "extensions": ["yang"] },
  "application/yang-data+json": { "source": "iana", "compressible": true },
  "application/yang-data+xml": { "source": "iana", "compressible": true },
  "application/yang-patch+json": { "source": "iana", "compressible": true },
  "application/yang-patch+xml": { "source": "iana", "compressible": true },
  "application/yin+xml": { "source": "iana", "compressible": true, "extensions": ["yin"] },
  "application/zip": { "source": "iana", "compressible": false, "extensions": ["zip"] },
  "application/zlib": { "source": "iana" },
  "application/zstd": { "source": "iana" },
  "audio/1d-interleaved-parityfec": { "source": "iana" },
  "audio/32kadpcm": { "source": "iana" },
  "audio/3gpp": { "source": "iana", "compressible": false, "extensions": ["3gpp"] },
  "audio/3gpp2": { "source": "iana" },
  "audio/aac": { "source": "iana" },
  "audio/ac3": { "source": "iana" },
  "audio/adpcm": { "source": "apache", "extensions": ["adp"] },
  "audio/amr": { "source": "iana", "extensions": ["amr"] },
  "audio/amr-wb": { "source": "iana" },
  "audio/amr-wb+": { "source": "iana" },
  "audio/aptx": { "source": "iana" },
  "audio/asc": { "source": "iana" },
  "audio/atrac-advanced-lossless": { "source": "iana" },
  "audio/atrac-x": { "source": "iana" },
  "audio/atrac3": { "source": "iana" },
  "audio/basic": { "source": "iana", "compressible": false, "extensions": ["au", "snd"] },
  "audio/bv16": { "source": "iana" },
  "audio/bv32": { "source": "iana" },
  "audio/clearmode": { "source": "iana" },
  "audio/cn": { "source": "iana" },
  "audio/dat12": { "source": "iana" },
  "audio/dls": { "source": "iana" },
  "audio/dsr-es201108": { "source": "iana" },
  "audio/dsr-es202050": { "source": "iana" },
  "audio/dsr-es202211": { "source": "iana" },
  "audio/dsr-es202212": { "source": "iana" },
  "audio/dv": { "source": "iana" },
  "audio/dvi4": { "source": "iana" },
  "audio/eac3": { "source": "iana" },
  "audio/encaprtp": { "source": "iana" },
  "audio/evrc": { "source": "iana" },
  "audio/evrc-qcp": { "source": "iana" },
  "audio/evrc0": { "source": "iana" },
  "audio/evrc1": { "source": "iana" },
  "audio/evrcb": { "source": "iana" },
  "audio/evrcb0": { "source": "iana" },
  "audio/evrcb1": { "source": "iana" },
  "audio/evrcnw": { "source": "iana" },
  "audio/evrcnw0": { "source": "iana" },
  "audio/evrcnw1": { "source": "iana" },
  "audio/evrcwb": { "source": "iana" },
  "audio/evrcwb0": { "source": "iana" },
  "audio/evrcwb1": { "source": "iana" },
  "audio/evs": { "source": "iana" },
  "audio/flexfec": { "source": "iana" },
  "audio/fwdred": { "source": "iana" },
  "audio/g711-0": { "source": "iana" },
  "audio/g719": { "source": "iana" },
  "audio/g722": { "source": "iana" },
  "audio/g7221": { "source": "iana" },
  "audio/g723": { "source": "iana" },
  "audio/g726-16": { "source": "iana" },
  "audio/g726-24": { "source": "iana" },
  "audio/g726-32": { "source": "iana" },
  "audio/g726-40": { "source": "iana" },
  "audio/g728": { "source": "iana" },
  "audio/g729": { "source": "iana" },
  "audio/g7291": { "source": "iana" },
  "audio/g729d": { "source": "iana" },
  "audio/g729e": { "source": "iana" },
  "audio/gsm": { "source": "iana" },
  "audio/gsm-efr": { "source": "iana" },
  "audio/gsm-hr-08": { "source": "iana" },
  "audio/ilbc": { "source": "iana" },
  "audio/ip-mr_v2.5": { "source": "iana" },
  "audio/isac": { "source": "apache" },
  "audio/l16": { "source": "iana" },
  "audio/l20": { "source": "iana" },
  "audio/l24": { "source": "iana", "compressible": false },
  "audio/l8": { "source": "iana" },
  "audio/lpc": { "source": "iana" },
  "audio/melp": { "source": "iana" },
  "audio/melp1200": { "source": "iana" },
  "audio/melp2400": { "source": "iana" },
  "audio/melp600": { "source": "iana" },
  "audio/mhas": { "source": "iana" },
  "audio/midi": { "source": "apache", "extensions": ["mid", "midi", "kar", "rmi"] },
  "audio/mobile-xmf": { "source": "iana", "extensions": ["mxmf"] },
  "audio/mp3": { "compressible": false, "extensions": ["mp3"] },
  "audio/mp4": { "source": "iana", "compressible": false, "extensions": ["m4a", "mp4a"] },
  "audio/mp4a-latm": { "source": "iana" },
  "audio/mpa": { "source": "iana" },
  "audio/mpa-robust": { "source": "iana" },
  "audio/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"] },
  "audio/mpeg4-generic": { "source": "iana" },
  "audio/musepack": { "source": "apache" },
  "audio/ogg": { "source": "iana", "compressible": false, "extensions": ["oga", "ogg", "spx", "opus"] },
  "audio/opus": { "source": "iana" },
  "audio/parityfec": { "source": "iana" },
  "audio/pcma": { "source": "iana" },
  "audio/pcma-wb": { "source": "iana" },
  "audio/pcmu": { "source": "iana" },
  "audio/pcmu-wb": { "source": "iana" },
  "audio/prs.sid": { "source": "iana" },
  "audio/qcelp": { "source": "iana" },
  "audio/raptorfec": { "source": "iana" },
  "audio/red": { "source": "iana" },
  "audio/rtp-enc-aescm128": { "source": "iana" },
  "audio/rtp-midi": { "source": "iana" },
  "audio/rtploopback": { "source": "iana" },
  "audio/rtx": { "source": "iana" },
  "audio/s3m": { "source": "apache", "extensions": ["s3m"] },
  "audio/scip": { "source": "iana" },
  "audio/silk": { "source": "apache", "extensions": ["sil"] },
  "audio/smv": { "source": "iana" },
  "audio/smv-qcp": { "source": "iana" },
  "audio/smv0": { "source": "iana" },
  "audio/sofa": { "source": "iana" },
  "audio/sp-midi": { "source": "iana" },
  "audio/speex": { "source": "iana" },
  "audio/t140c": { "source": "iana" },
  "audio/t38": { "source": "iana" },
  "audio/telephone-event": { "source": "iana" },
  "audio/tetra_acelp": { "source": "iana" },
  "audio/tetra_acelp_bb": { "source": "iana" },
  "audio/tone": { "source": "iana" },
  "audio/tsvcis": { "source": "iana" },
  "audio/uemclip": { "source": "iana" },
  "audio/ulpfec": { "source": "iana" },
  "audio/usac": { "source": "iana" },
  "audio/vdvi": { "source": "iana" },
  "audio/vmr-wb": { "source": "iana" },
  "audio/vnd.3gpp.iufp": { "source": "iana" },
  "audio/vnd.4sb": { "source": "iana" },
  "audio/vnd.audiokoz": { "source": "iana" },
  "audio/vnd.celp": { "source": "iana" },
  "audio/vnd.cisco.nse": { "source": "iana" },
  "audio/vnd.cmles.radio-events": { "source": "iana" },
  "audio/vnd.cns.anp1": { "source": "iana" },
  "audio/vnd.cns.inf1": { "source": "iana" },
  "audio/vnd.dece.audio": { "source": "iana", "extensions": ["uva", "uvva"] },
  "audio/vnd.digital-winds": { "source": "iana", "extensions": ["eol"] },
  "audio/vnd.dlna.adts": { "source": "iana" },
  "audio/vnd.dolby.heaac.1": { "source": "iana" },
  "audio/vnd.dolby.heaac.2": { "source": "iana" },
  "audio/vnd.dolby.mlp": { "source": "iana" },
  "audio/vnd.dolby.mps": { "source": "iana" },
  "audio/vnd.dolby.pl2": { "source": "iana" },
  "audio/vnd.dolby.pl2x": { "source": "iana" },
  "audio/vnd.dolby.pl2z": { "source": "iana" },
  "audio/vnd.dolby.pulse.1": { "source": "iana" },
  "audio/vnd.dra": { "source": "iana", "extensions": ["dra"] },
  "audio/vnd.dts": { "source": "iana", "extensions": ["dts"] },
  "audio/vnd.dts.hd": { "source": "iana", "extensions": ["dtshd"] },
  "audio/vnd.dts.uhd": { "source": "iana" },
  "audio/vnd.dvb.file": { "source": "iana" },
  "audio/vnd.everad.plj": { "source": "iana" },
  "audio/vnd.hns.audio": { "source": "iana" },
  "audio/vnd.lucent.voice": { "source": "iana", "extensions": ["lvp"] },
  "audio/vnd.ms-playready.media.pya": { "source": "iana", "extensions": ["pya"] },
  "audio/vnd.nokia.mobile-xmf": { "source": "iana" },
  "audio/vnd.nortel.vbk": { "source": "iana" },
  "audio/vnd.nuera.ecelp4800": { "source": "iana", "extensions": ["ecelp4800"] },
  "audio/vnd.nuera.ecelp7470": { "source": "iana", "extensions": ["ecelp7470"] },
  "audio/vnd.nuera.ecelp9600": { "source": "iana", "extensions": ["ecelp9600"] },
  "audio/vnd.octel.sbc": { "source": "iana" },
  "audio/vnd.presonus.multitrack": { "source": "iana" },
  "audio/vnd.qcelp": { "source": "iana" },
  "audio/vnd.rhetorex.32kadpcm": { "source": "iana" },
  "audio/vnd.rip": { "source": "iana", "extensions": ["rip"] },
  "audio/vnd.rn-realaudio": { "compressible": false },
  "audio/vnd.sealedmedia.softseal.mpeg": { "source": "iana" },
  "audio/vnd.vmx.cvsd": { "source": "iana" },
  "audio/vnd.wave": { "compressible": false },
  "audio/vorbis": { "source": "iana", "compressible": false },
  "audio/vorbis-config": { "source": "iana" },
  "audio/wav": { "compressible": false, "extensions": ["wav"] },
  "audio/wave": { "compressible": false, "extensions": ["wav"] },
  "audio/webm": { "source": "apache", "compressible": false, "extensions": ["weba"] },
  "audio/x-aac": { "source": "apache", "compressible": false, "extensions": ["aac"] },
  "audio/x-aiff": { "source": "apache", "extensions": ["aif", "aiff", "aifc"] },
  "audio/x-caf": { "source": "apache", "compressible": false, "extensions": ["caf"] },
  "audio/x-flac": { "source": "apache", "extensions": ["flac"] },
  "audio/x-m4a": { "source": "nginx", "extensions": ["m4a"] },
  "audio/x-matroska": { "source": "apache", "extensions": ["mka"] },
  "audio/x-mpegurl": { "source": "apache", "extensions": ["m3u"] },
  "audio/x-ms-wax": { "source": "apache", "extensions": ["wax"] },
  "audio/x-ms-wma": { "source": "apache", "extensions": ["wma"] },
  "audio/x-pn-realaudio": { "source": "apache", "extensions": ["ram", "ra"] },
  "audio/x-pn-realaudio-plugin": { "source": "apache", "extensions": ["rmp"] },
  "audio/x-realaudio": { "source": "nginx", "extensions": ["ra"] },
  "audio/x-tta": { "source": "apache" },
  "audio/x-wav": { "source": "apache", "extensions": ["wav"] },
  "audio/xm": { "source": "apache", "extensions": ["xm"] },
  "chemical/x-cdx": { "source": "apache", "extensions": ["cdx"] },
  "chemical/x-cif": { "source": "apache", "extensions": ["cif"] },
  "chemical/x-cmdf": { "source": "apache", "extensions": ["cmdf"] },
  "chemical/x-cml": { "source": "apache", "extensions": ["cml"] },
  "chemical/x-csml": { "source": "apache", "extensions": ["csml"] },
  "chemical/x-pdb": { "source": "apache" },
  "chemical/x-xyz": { "source": "apache", "extensions": ["xyz"] },
  "font/collection": { "source": "iana", "extensions": ["ttc"] },
  "font/otf": { "source": "iana", "compressible": true, "extensions": ["otf"] },
  "font/sfnt": { "source": "iana" },
  "font/ttf": { "source": "iana", "compressible": true, "extensions": ["ttf"] },
  "font/woff": { "source": "iana", "extensions": ["woff"] },
  "font/woff2": { "source": "iana", "extensions": ["woff2"] },
  "image/aces": { "source": "iana", "extensions": ["exr"] },
  "image/apng": { "compressible": false, "extensions": ["apng"] },
  "image/avci": { "source": "iana", "extensions": ["avci"] },
  "image/avcs": { "source": "iana", "extensions": ["avcs"] },
  "image/avif": { "source": "iana", "compressible": false, "extensions": ["avif"] },
  "image/bmp": { "source": "iana", "compressible": true, "extensions": ["bmp"] },
  "image/cgm": { "source": "iana", "extensions": ["cgm"] },
  "image/dicom-rle": { "source": "iana", "extensions": ["drle"] },
  "image/emf": { "source": "iana", "extensions": ["emf"] },
  "image/fits": { "source": "iana", "extensions": ["fits"] },
  "image/g3fax": { "source": "iana", "extensions": ["g3"] },
  "image/gif": { "source": "iana", "compressible": false, "extensions": ["gif"] },
  "image/heic": { "source": "iana", "extensions": ["heic"] },
  "image/heic-sequence": { "source": "iana", "extensions": ["heics"] },
  "image/heif": { "source": "iana", "extensions": ["heif"] },
  "image/heif-sequence": { "source": "iana", "extensions": ["heifs"] },
  "image/hej2k": { "source": "iana", "extensions": ["hej2"] },
  "image/hsj2": { "source": "iana", "extensions": ["hsj2"] },
  "image/ief": { "source": "iana", "extensions": ["ief"] },
  "image/jls": { "source": "iana", "extensions": ["jls"] },
  "image/jp2": { "source": "iana", "compressible": false, "extensions": ["jp2", "jpg2"] },
  "image/jpeg": { "source": "iana", "compressible": false, "extensions": ["jpeg", "jpg", "jpe"] },
  "image/jph": { "source": "iana", "extensions": ["jph"] },
  "image/jphc": { "source": "iana", "extensions": ["jhc"] },
  "image/jpm": { "source": "iana", "compressible": false, "extensions": ["jpm"] },
  "image/jpx": { "source": "iana", "compressible": false, "extensions": ["jpx", "jpf"] },
  "image/jxr": { "source": "iana", "extensions": ["jxr"] },
  "image/jxra": { "source": "iana", "extensions": ["jxra"] },
  "image/jxrs": { "source": "iana", "extensions": ["jxrs"] },
  "image/jxs": { "source": "iana", "extensions": ["jxs"] },
  "image/jxsc": { "source": "iana", "extensions": ["jxsc"] },
  "image/jxsi": { "source": "iana", "extensions": ["jxsi"] },
  "image/jxss": { "source": "iana", "extensions": ["jxss"] },
  "image/ktx": { "source": "iana", "extensions": ["ktx"] },
  "image/ktx2": { "source": "iana", "extensions": ["ktx2"] },
  "image/naplps": { "source": "iana" },
  "image/pjpeg": { "compressible": false },
  "image/png": { "source": "iana", "compressible": false, "extensions": ["png"] },
  "image/prs.btif": { "source": "iana", "extensions": ["btif"] },
  "image/prs.pti": { "source": "iana", "extensions": ["pti"] },
  "image/pwg-raster": { "source": "iana" },
  "image/sgi": { "source": "apache", "extensions": ["sgi"] },
  "image/svg+xml": { "source": "iana", "compressible": true, "extensions": ["svg", "svgz"] },
  "image/t38": { "source": "iana", "extensions": ["t38"] },
  "image/tiff": { "source": "iana", "compressible": false, "extensions": ["tif", "tiff"] },
  "image/tiff-fx": { "source": "iana", "extensions": ["tfx"] },
  "image/vnd.adobe.photoshop": { "source": "iana", "compressible": true, "extensions": ["psd"] },
  "image/vnd.airzip.accelerator.azv": { "source": "iana", "extensions": ["azv"] },
  "image/vnd.cns.inf2": { "source": "iana" },
  "image/vnd.dece.graphic": { "source": "iana", "extensions": ["uvi", "uvvi", "uvg", "uvvg"] },
  "image/vnd.djvu": { "source": "iana", "extensions": ["djvu", "djv"] },
  "image/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "image/vnd.dwg": { "source": "iana", "extensions": ["dwg"] },
  "image/vnd.dxf": { "source": "iana", "extensions": ["dxf"] },
  "image/vnd.fastbidsheet": { "source": "iana", "extensions": ["fbs"] },
  "image/vnd.fpx": { "source": "iana", "extensions": ["fpx"] },
  "image/vnd.fst": { "source": "iana", "extensions": ["fst"] },
  "image/vnd.fujixerox.edmics-mmr": { "source": "iana", "extensions": ["mmr"] },
  "image/vnd.fujixerox.edmics-rlc": { "source": "iana", "extensions": ["rlc"] },
  "image/vnd.globalgraphics.pgb": { "source": "iana" },
  "image/vnd.microsoft.icon": { "source": "iana", "compressible": true, "extensions": ["ico"] },
  "image/vnd.mix": { "source": "iana" },
  "image/vnd.mozilla.apng": { "source": "iana" },
  "image/vnd.ms-dds": { "compressible": true, "extensions": ["dds"] },
  "image/vnd.ms-modi": { "source": "iana", "extensions": ["mdi"] },
  "image/vnd.ms-photo": { "source": "apache", "extensions": ["wdp"] },
  "image/vnd.net-fpx": { "source": "iana", "extensions": ["npx"] },
  "image/vnd.pco.b16": { "source": "iana", "extensions": ["b16"] },
  "image/vnd.radiance": { "source": "iana" },
  "image/vnd.sealed.png": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.gif": { "source": "iana" },
  "image/vnd.sealedmedia.softseal.jpg": { "source": "iana" },
  "image/vnd.svf": { "source": "iana" },
  "image/vnd.tencent.tap": { "source": "iana", "extensions": ["tap"] },
  "image/vnd.valve.source.texture": { "source": "iana", "extensions": ["vtf"] },
  "image/vnd.wap.wbmp": { "source": "iana", "extensions": ["wbmp"] },
  "image/vnd.xiff": { "source": "iana", "extensions": ["xif"] },
  "image/vnd.zbrush.pcx": { "source": "iana", "extensions": ["pcx"] },
  "image/webp": { "source": "apache", "extensions": ["webp"] },
  "image/wmf": { "source": "iana", "extensions": ["wmf"] },
  "image/x-3ds": { "source": "apache", "extensions": ["3ds"] },
  "image/x-cmu-raster": { "source": "apache", "extensions": ["ras"] },
  "image/x-cmx": { "source": "apache", "extensions": ["cmx"] },
  "image/x-freehand": { "source": "apache", "extensions": ["fh", "fhc", "fh4", "fh5", "fh7"] },
  "image/x-icon": { "source": "apache", "compressible": true, "extensions": ["ico"] },
  "image/x-jng": { "source": "nginx", "extensions": ["jng"] },
  "image/x-mrsid-image": { "source": "apache", "extensions": ["sid"] },
  "image/x-ms-bmp": { "source": "nginx", "compressible": true, "extensions": ["bmp"] },
  "image/x-pcx": { "source": "apache", "extensions": ["pcx"] },
  "image/x-pict": { "source": "apache", "extensions": ["pic", "pct"] },
  "image/x-portable-anymap": { "source": "apache", "extensions": ["pnm"] },
  "image/x-portable-bitmap": { "source": "apache", "extensions": ["pbm"] },
  "image/x-portable-graymap": { "source": "apache", "extensions": ["pgm"] },
  "image/x-portable-pixmap": { "source": "apache", "extensions": ["ppm"] },
  "image/x-rgb": { "source": "apache", "extensions": ["rgb"] },
  "image/x-tga": { "source": "apache", "extensions": ["tga"] },
  "image/x-xbitmap": { "source": "apache", "extensions": ["xbm"] },
  "image/x-xcf": { "compressible": false },
  "image/x-xpixmap": { "source": "apache", "extensions": ["xpm"] },
  "image/x-xwindowdump": { "source": "apache", "extensions": ["xwd"] },
  "message/cpim": { "source": "iana" },
  "message/delivery-status": { "source": "iana" },
  "message/disposition-notification": { "source": "iana", "extensions": ["disposition-notification"] },
  "message/external-body": { "source": "iana" },
  "message/feedback-report": { "source": "iana" },
  "message/global": { "source": "iana", "extensions": ["u8msg"] },
  "message/global-delivery-status": { "source": "iana", "extensions": ["u8dsn"] },
  "message/global-disposition-notification": { "source": "iana", "extensions": ["u8mdn"] },
  "message/global-headers": { "source": "iana", "extensions": ["u8hdr"] },
  "message/http": { "source": "iana", "compressible": false },
  "message/imdn+xml": { "source": "iana", "compressible": true },
  "message/news": { "source": "iana" },
  "message/partial": { "source": "iana", "compressible": false },
  "message/rfc822": { "source": "iana", "compressible": true, "extensions": ["eml", "mime"] },
  "message/s-http": { "source": "iana" },
  "message/sip": { "source": "iana" },
  "message/sipfrag": { "source": "iana" },
  "message/tracking-status": { "source": "iana" },
  "message/vnd.si.simp": { "source": "iana" },
  "message/vnd.wfa.wsc": { "source": "iana", "extensions": ["wsc"] },
  "model/3mf": { "source": "iana", "extensions": ["3mf"] },
  "model/e57": { "source": "iana" },
  "model/gltf+json": { "source": "iana", "compressible": true, "extensions": ["gltf"] },
  "model/gltf-binary": { "source": "iana", "compressible": true, "extensions": ["glb"] },
  "model/iges": { "source": "iana", "compressible": false, "extensions": ["igs", "iges"] },
  "model/mesh": { "source": "iana", "compressible": false, "extensions": ["msh", "mesh", "silo"] },
  "model/mtl": { "source": "iana", "extensions": ["mtl"] },
  "model/obj": { "source": "iana", "extensions": ["obj"] },
  "model/step": { "source": "iana" },
  "model/step+xml": { "source": "iana", "compressible": true, "extensions": ["stpx"] },
  "model/step+zip": { "source": "iana", "compressible": false, "extensions": ["stpz"] },
  "model/step-xml+zip": { "source": "iana", "compressible": false, "extensions": ["stpxz"] },
  "model/stl": { "source": "iana", "extensions": ["stl"] },
  "model/vnd.collada+xml": { "source": "iana", "compressible": true, "extensions": ["dae"] },
  "model/vnd.dwf": { "source": "iana", "extensions": ["dwf"] },
  "model/vnd.flatland.3dml": { "source": "iana" },
  "model/vnd.gdl": { "source": "iana", "extensions": ["gdl"] },
  "model/vnd.gs-gdl": { "source": "apache" },
  "model/vnd.gs.gdl": { "source": "iana" },
  "model/vnd.gtw": { "source": "iana", "extensions": ["gtw"] },
  "model/vnd.moml+xml": { "source": "iana", "compressible": true },
  "model/vnd.mts": { "source": "iana", "extensions": ["mts"] },
  "model/vnd.opengex": { "source": "iana", "extensions": ["ogex"] },
  "model/vnd.parasolid.transmit.binary": { "source": "iana", "extensions": ["x_b"] },
  "model/vnd.parasolid.transmit.text": { "source": "iana", "extensions": ["x_t"] },
  "model/vnd.pytha.pyox": { "source": "iana" },
  "model/vnd.rosette.annotated-data-model": { "source": "iana" },
  "model/vnd.sap.vds": { "source": "iana", "extensions": ["vds"] },
  "model/vnd.usdz+zip": { "source": "iana", "compressible": false, "extensions": ["usdz"] },
  "model/vnd.valve.source.compiled-map": { "source": "iana", "extensions": ["bsp"] },
  "model/vnd.vtu": { "source": "iana", "extensions": ["vtu"] },
  "model/vrml": { "source": "iana", "compressible": false, "extensions": ["wrl", "vrml"] },
  "model/x3d+binary": { "source": "apache", "compressible": false, "extensions": ["x3db", "x3dbz"] },
  "model/x3d+fastinfoset": { "source": "iana", "extensions": ["x3db"] },
  "model/x3d+vrml": { "source": "apache", "compressible": false, "extensions": ["x3dv", "x3dvz"] },
  "model/x3d+xml": { "source": "iana", "compressible": true, "extensions": ["x3d", "x3dz"] },
  "model/x3d-vrml": { "source": "iana", "extensions": ["x3dv"] },
  "multipart/alternative": { "source": "iana", "compressible": false },
  "multipart/appledouble": { "source": "iana" },
  "multipart/byteranges": { "source": "iana" },
  "multipart/digest": { "source": "iana" },
  "multipart/encrypted": { "source": "iana", "compressible": false },
  "multipart/form-data": { "source": "iana", "compressible": false },
  "multipart/header-set": { "source": "iana" },
  "multipart/mixed": { "source": "iana" },
  "multipart/multilingual": { "source": "iana" },
  "multipart/parallel": { "source": "iana" },
  "multipart/related": { "source": "iana", "compressible": false },
  "multipart/report": { "source": "iana" },
  "multipart/signed": { "source": "iana", "compressible": false },
  "multipart/vnd.bint.med-plus": { "source": "iana" },
  "multipart/voice-message": { "source": "iana" },
  "multipart/x-mixed-replace": { "source": "iana" },
  "text/1d-interleaved-parityfec": { "source": "iana" },
  "text/cache-manifest": { "source": "iana", "compressible": true, "extensions": ["appcache", "manifest"] },
  "text/calendar": { "source": "iana", "extensions": ["ics", "ifb"] },
  "text/calender": { "compressible": true },
  "text/cmd": { "compressible": true },
  "text/coffeescript": { "extensions": ["coffee", "litcoffee"] },
  "text/cql": { "source": "iana" },
  "text/cql-expression": { "source": "iana" },
  "text/cql-identifier": { "source": "iana" },
  "text/css": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["css"] },
  "text/csv": { "source": "iana", "compressible": true, "extensions": ["csv"] },
  "text/csv-schema": { "source": "iana" },
  "text/directory": { "source": "iana" },
  "text/dns": { "source": "iana" },
  "text/ecmascript": { "source": "iana" },
  "text/encaprtp": { "source": "iana" },
  "text/enriched": { "source": "iana" },
  "text/fhirpath": { "source": "iana" },
  "text/flexfec": { "source": "iana" },
  "text/fwdred": { "source": "iana" },
  "text/gff3": { "source": "iana" },
  "text/grammar-ref-list": { "source": "iana" },
  "text/html": { "source": "iana", "compressible": true, "extensions": ["html", "htm", "shtml"] },
  "text/jade": { "extensions": ["jade"] },
  "text/javascript": { "source": "iana", "compressible": true },
  "text/jcr-cnd": { "source": "iana" },
  "text/jsx": { "compressible": true, "extensions": ["jsx"] },
  "text/less": { "compressible": true, "extensions": ["less"] },
  "text/markdown": { "source": "iana", "compressible": true, "extensions": ["markdown", "md"] },
  "text/mathml": { "source": "nginx", "extensions": ["mml"] },
  "text/mdx": { "compressible": true, "extensions": ["mdx"] },
  "text/mizar": { "source": "iana" },
  "text/n3": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["n3"] },
  "text/parameters": { "source": "iana", "charset": "UTF-8" },
  "text/parityfec": { "source": "iana" },
  "text/plain": { "source": "iana", "compressible": true, "extensions": ["txt", "text", "conf", "def", "list", "log", "in", "ini"] },
  "text/provenance-notation": { "source": "iana", "charset": "UTF-8" },
  "text/prs.fallenstein.rst": { "source": "iana" },
  "text/prs.lines.tag": { "source": "iana", "extensions": ["dsc"] },
  "text/prs.prop.logic": { "source": "iana" },
  "text/raptorfec": { "source": "iana" },
  "text/red": { "source": "iana" },
  "text/rfc822-headers": { "source": "iana" },
  "text/richtext": { "source": "iana", "compressible": true, "extensions": ["rtx"] },
  "text/rtf": { "source": "iana", "compressible": true, "extensions": ["rtf"] },
  "text/rtp-enc-aescm128": { "source": "iana" },
  "text/rtploopback": { "source": "iana" },
  "text/rtx": { "source": "iana" },
  "text/sgml": { "source": "iana", "extensions": ["sgml", "sgm"] },
  "text/shaclc": { "source": "iana" },
  "text/shex": { "source": "iana", "extensions": ["shex"] },
  "text/slim": { "extensions": ["slim", "slm"] },
  "text/spdx": { "source": "iana", "extensions": ["spdx"] },
  "text/strings": { "source": "iana" },
  "text/stylus": { "extensions": ["stylus", "styl"] },
  "text/t140": { "source": "iana" },
  "text/tab-separated-values": { "source": "iana", "compressible": true, "extensions": ["tsv"] },
  "text/troff": { "source": "iana", "extensions": ["t", "tr", "roff", "man", "me", "ms"] },
  "text/turtle": { "source": "iana", "charset": "UTF-8", "extensions": ["ttl"] },
  "text/ulpfec": { "source": "iana" },
  "text/uri-list": { "source": "iana", "compressible": true, "extensions": ["uri", "uris", "urls"] },
  "text/vcard": { "source": "iana", "compressible": true, "extensions": ["vcard"] },
  "text/vnd.a": { "source": "iana" },
  "text/vnd.abc": { "source": "iana" },
  "text/vnd.ascii-art": { "source": "iana" },
  "text/vnd.curl": { "source": "iana", "extensions": ["curl"] },
  "text/vnd.curl.dcurl": { "source": "apache", "extensions": ["dcurl"] },
  "text/vnd.curl.mcurl": { "source": "apache", "extensions": ["mcurl"] },
  "text/vnd.curl.scurl": { "source": "apache", "extensions": ["scurl"] },
  "text/vnd.debian.copyright": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.dmclientscript": { "source": "iana" },
  "text/vnd.dvb.subtitle": { "source": "iana", "extensions": ["sub"] },
  "text/vnd.esmertec.theme-descriptor": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.familysearch.gedcom": { "source": "iana", "extensions": ["ged"] },
  "text/vnd.ficlab.flt": { "source": "iana" },
  "text/vnd.fly": { "source": "iana", "extensions": ["fly"] },
  "text/vnd.fmi.flexstor": { "source": "iana", "extensions": ["flx"] },
  "text/vnd.gml": { "source": "iana" },
  "text/vnd.graphviz": { "source": "iana", "extensions": ["gv"] },
  "text/vnd.hans": { "source": "iana" },
  "text/vnd.hgl": { "source": "iana" },
  "text/vnd.in3d.3dml": { "source": "iana", "extensions": ["3dml"] },
  "text/vnd.in3d.spot": { "source": "iana", "extensions": ["spot"] },
  "text/vnd.iptc.newsml": { "source": "iana" },
  "text/vnd.iptc.nitf": { "source": "iana" },
  "text/vnd.latex-z": { "source": "iana" },
  "text/vnd.motorola.reflex": { "source": "iana" },
  "text/vnd.ms-mediapackage": { "source": "iana" },
  "text/vnd.net2phone.commcenter.command": { "source": "iana" },
  "text/vnd.radisys.msml-basic-layout": { "source": "iana" },
  "text/vnd.senx.warpscript": { "source": "iana" },
  "text/vnd.si.uricatalogue": { "source": "iana" },
  "text/vnd.sosi": { "source": "iana" },
  "text/vnd.sun.j2me.app-descriptor": { "source": "iana", "charset": "UTF-8", "extensions": ["jad"] },
  "text/vnd.trolltech.linguist": { "source": "iana", "charset": "UTF-8" },
  "text/vnd.wap.si": { "source": "iana" },
  "text/vnd.wap.sl": { "source": "iana" },
  "text/vnd.wap.wml": { "source": "iana", "extensions": ["wml"] },
  "text/vnd.wap.wmlscript": { "source": "iana", "extensions": ["wmls"] },
  "text/vtt": { "source": "iana", "charset": "UTF-8", "compressible": true, "extensions": ["vtt"] },
  "text/x-asm": { "source": "apache", "extensions": ["s", "asm"] },
  "text/x-c": { "source": "apache", "extensions": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"] },
  "text/x-component": { "source": "nginx", "extensions": ["htc"] },
  "text/x-fortran": { "source": "apache", "extensions": ["f", "for", "f77", "f90"] },
  "text/x-gwt-rpc": { "compressible": true },
  "text/x-handlebars-template": { "extensions": ["hbs"] },
  "text/x-java-source": { "source": "apache", "extensions": ["java"] },
  "text/x-jquery-tmpl": { "compressible": true },
  "text/x-lua": { "extensions": ["lua"] },
  "text/x-markdown": { "compressible": true, "extensions": ["mkd"] },
  "text/x-nfo": { "source": "apache", "extensions": ["nfo"] },
  "text/x-opml": { "source": "apache", "extensions": ["opml"] },
  "text/x-org": { "compressible": true, "extensions": ["org"] },
  "text/x-pascal": { "source": "apache", "extensions": ["p", "pas"] },
  "text/x-processing": { "compressible": true, "extensions": ["pde"] },
  "text/x-sass": { "extensions": ["sass"] },
  "text/x-scss": { "extensions": ["scss"] },
  "text/x-setext": { "source": "apache", "extensions": ["etx"] },
  "text/x-sfv": { "source": "apache", "extensions": ["sfv"] },
  "text/x-suse-ymp": { "compressible": true, "extensions": ["ymp"] },
  "text/x-uuencode": { "source": "apache", "extensions": ["uu"] },
  "text/x-vcalendar": { "source": "apache", "extensions": ["vcs"] },
  "text/x-vcard": { "source": "apache", "extensions": ["vcf"] },
  "text/xml": { "source": "iana", "compressible": true, "extensions": ["xml"] },
  "text/xml-external-parsed-entity": { "source": "iana" },
  "text/yaml": { "compressible": true, "extensions": ["yaml", "yml"] },
  "video/1d-interleaved-parityfec": { "source": "iana" },
  "video/3gpp": { "source": "iana", "extensions": ["3gp", "3gpp"] },
  "video/3gpp-tt": { "source": "iana" },
  "video/3gpp2": { "source": "iana", "extensions": ["3g2"] },
  "video/av1": { "source": "iana" },
  "video/bmpeg": { "source": "iana" },
  "video/bt656": { "source": "iana" },
  "video/celb": { "source": "iana" },
  "video/dv": { "source": "iana" },
  "video/encaprtp": { "source": "iana" },
  "video/ffv1": { "source": "iana" },
  "video/flexfec": { "source": "iana" },
  "video/h261": { "source": "iana", "extensions": ["h261"] },
  "video/h263": { "source": "iana", "extensions": ["h263"] },
  "video/h263-1998": { "source": "iana" },
  "video/h263-2000": { "source": "iana" },
  "video/h264": { "source": "iana", "extensions": ["h264"] },
  "video/h264-rcdo": { "source": "iana" },
  "video/h264-svc": { "source": "iana" },
  "video/h265": { "source": "iana" },
  "video/iso.segment": { "source": "iana", "extensions": ["m4s"] },
  "video/jpeg": { "source": "iana", "extensions": ["jpgv"] },
  "video/jpeg2000": { "source": "iana" },
  "video/jpm": { "source": "apache", "extensions": ["jpm", "jpgm"] },
  "video/jxsv": { "source": "iana" },
  "video/mj2": { "source": "iana", "extensions": ["mj2", "mjp2"] },
  "video/mp1s": { "source": "iana" },
  "video/mp2p": { "source": "iana" },
  "video/mp2t": { "source": "iana", "extensions": ["ts"] },
  "video/mp4": { "source": "iana", "compressible": false, "extensions": ["mp4", "mp4v", "mpg4"] },
  "video/mp4v-es": { "source": "iana" },
  "video/mpeg": { "source": "iana", "compressible": false, "extensions": ["mpeg", "mpg", "mpe", "m1v", "m2v"] },
  "video/mpeg4-generic": { "source": "iana" },
  "video/mpv": { "source": "iana" },
  "video/nv": { "source": "iana" },
  "video/ogg": { "source": "iana", "compressible": false, "extensions": ["ogv"] },
  "video/parityfec": { "source": "iana" },
  "video/pointer": { "source": "iana" },
  "video/quicktime": { "source": "iana", "compressible": false, "extensions": ["qt", "mov"] },
  "video/raptorfec": { "source": "iana" },
  "video/raw": { "source": "iana" },
  "video/rtp-enc-aescm128": { "source": "iana" },
  "video/rtploopback": { "source": "iana" },
  "video/rtx": { "source": "iana" },
  "video/scip": { "source": "iana" },
  "video/smpte291": { "source": "iana" },
  "video/smpte292m": { "source": "iana" },
  "video/ulpfec": { "source": "iana" },
  "video/vc1": { "source": "iana" },
  "video/vc2": { "source": "iana" },
  "video/vnd.cctv": { "source": "iana" },
  "video/vnd.dece.hd": { "source": "iana", "extensions": ["uvh", "uvvh"] },
  "video/vnd.dece.mobile": { "source": "iana", "extensions": ["uvm", "uvvm"] },
  "video/vnd.dece.mp4": { "source": "iana" },
  "video/vnd.dece.pd": { "source": "iana", "extensions": ["uvp", "uvvp"] },
  "video/vnd.dece.sd": { "source": "iana", "extensions": ["uvs", "uvvs"] },
  "video/vnd.dece.video": { "source": "iana", "extensions": ["uvv", "uvvv"] },
  "video/vnd.directv.mpeg": { "source": "iana" },
  "video/vnd.directv.mpeg-tts": { "source": "iana" },
  "video/vnd.dlna.mpeg-tts": { "source": "iana" },
  "video/vnd.dvb.file": { "source": "iana", "extensions": ["dvb"] },
  "video/vnd.fvt": { "source": "iana", "extensions": ["fvt"] },
  "video/vnd.hns.video": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.1dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-1010": { "source": "iana" },
  "video/vnd.iptvforum.2dparityfec-2005": { "source": "iana" },
  "video/vnd.iptvforum.ttsavc": { "source": "iana" },
  "video/vnd.iptvforum.ttsmpeg2": { "source": "iana" },
  "video/vnd.motorola.video": { "source": "iana" },
  "video/vnd.motorola.videop": { "source": "iana" },
  "video/vnd.mpegurl": { "source": "iana", "extensions": ["mxu", "m4u"] },
  "video/vnd.ms-playready.media.pyv": { "source": "iana", "extensions": ["pyv"] },
  "video/vnd.nokia.interleaved-multimedia": { "source": "iana" },
  "video/vnd.nokia.mp4vr": { "source": "iana" },
  "video/vnd.nokia.videovoip": { "source": "iana" },
  "video/vnd.objectvideo": { "source": "iana" },
  "video/vnd.radgamettools.bink": { "source": "iana" },
  "video/vnd.radgamettools.smacker": { "source": "iana" },
  "video/vnd.sealed.mpeg1": { "source": "iana" },
  "video/vnd.sealed.mpeg4": { "source": "iana" },
  "video/vnd.sealed.swf": { "source": "iana" },
  "video/vnd.sealedmedia.softseal.mov": { "source": "iana" },
  "video/vnd.uvvu.mp4": { "source": "iana", "extensions": ["uvu", "uvvu"] },
  "video/vnd.vivo": { "source": "iana", "extensions": ["viv"] },
  "video/vnd.youtube.yt": { "source": "iana" },
  "video/vp8": { "source": "iana" },
  "video/vp9": { "source": "iana" },
  "video/webm": { "source": "apache", "compressible": false, "extensions": ["webm"] },
  "video/x-f4v": { "source": "apache", "extensions": ["f4v"] },
  "video/x-fli": { "source": "apache", "extensions": ["fli"] },
  "video/x-flv": { "source": "apache", "compressible": false, "extensions": ["flv"] },
  "video/x-m4v": { "source": "apache", "extensions": ["m4v"] },
  "video/x-matroska": { "source": "apache", "compressible": false, "extensions": ["mkv", "mk3d", "mks"] },
  "video/x-mng": { "source": "apache", "extensions": ["mng"] },
  "video/x-ms-asf": { "source": "apache", "extensions": ["asf", "asx"] },
  "video/x-ms-vob": { "source": "apache", "extensions": ["vob"] },
  "video/x-ms-wm": { "source": "apache", "extensions": ["wm"] },
  "video/x-ms-wmv": { "source": "apache", "compressible": false, "extensions": ["wmv"] },
  "video/x-ms-wmx": { "source": "apache", "extensions": ["wmx"] },
  "video/x-ms-wvx": { "source": "apache", "extensions": ["wvx"] },
  "video/x-msvideo": { "source": "apache", "extensions": ["avi"] },
  "video/x-sgi-movie": { "source": "apache", "extensions": ["movie"] },
  "video/x-smv": { "source": "apache", "extensions": ["smv"] },
  "x-conference/x-cooltalk": { "source": "apache", "extensions": ["ice"] },
  "x-shader/x-fragment": { "compressible": true },
  "x-shader/x-vertex": { "compressible": true }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb;
var hasRequiredMimeDb;
function requireMimeDb() {
  if (hasRequiredMimeDb) return mimeDb;
  hasRequiredMimeDb = 1;
  mimeDb = require$$0;
  return mimeDb;
}
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredMimeTypes;
function requireMimeTypes() {
  if (hasRequiredMimeTypes) return mimeTypes;
  hasRequiredMimeTypes = 1;
  (function(exports) {
    var db = requireMimeDb();
    var extname = require$$1.extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2) mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type2) {
      if (!type2 || typeof type2 !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type2);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path2) {
      if (!path2 || typeof path2 !== "string") {
        return false;
      }
      var extension2 = extname("x." + path2).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types2) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type2) {
        var mime = db[type2];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type2] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types2[extension2]) {
            var from = preference.indexOf(db[types2[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types2[extension2] !== "application/octet-stream" && (from > to || from === to && types2[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types2[extension2] = type2;
        }
      });
    }
  })(mimeTypes);
  return mimeTypes;
}
var defer_1;
var hasRequiredDefer;
function requireDefer() {
  if (hasRequiredDefer) return defer_1;
  hasRequiredDefer = 1;
  defer_1 = defer;
  function defer(fn) {
    var nextTick2 = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
    if (nextTick2) {
      nextTick2(fn);
    } else {
      setTimeout(fn, 0);
    }
  }
  return defer_1;
}
var async_1;
var hasRequiredAsync$1;
function requireAsync$1() {
  if (hasRequiredAsync$1) return async_1;
  hasRequiredAsync$1 = 1;
  var defer = requireDefer();
  async_1 = async2;
  function async2(callback) {
    var isAsync2 = false;
    defer(function() {
      isAsync2 = true;
    });
    return function async_callback(err, result) {
      if (isAsync2) {
        callback(err, result);
      } else {
        defer(function nextTick_callback() {
          callback(err, result);
        });
      }
    };
  }
  return async_1;
}
var abort_1;
var hasRequiredAbort;
function requireAbort() {
  if (hasRequiredAbort) return abort_1;
  hasRequiredAbort = 1;
  abort_1 = abort;
  function abort(state2) {
    Object.keys(state2.jobs).forEach(clean.bind(state2));
    state2.jobs = {};
  }
  function clean(key) {
    if (typeof this.jobs[key] == "function") {
      this.jobs[key]();
    }
  }
  return abort_1;
}
var iterate_1;
var hasRequiredIterate;
function requireIterate() {
  if (hasRequiredIterate) return iterate_1;
  hasRequiredIterate = 1;
  var async2 = requireAsync$1(), abort = requireAbort();
  iterate_1 = iterate;
  function iterate(list, iterator2, state2, callback) {
    var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
    state2.jobs[key] = runJob(iterator2, key, list[key], function(error2, output) {
      if (!(key in state2.jobs)) {
        return;
      }
      delete state2.jobs[key];
      if (error2) {
        abort(state2);
      } else {
        state2.results[key] = output;
      }
      callback(error2, state2.results);
    });
  }
  function runJob(iterator2, key, item, callback) {
    var aborter;
    if (iterator2.length == 2) {
      aborter = iterator2(item, async2(callback));
    } else {
      aborter = iterator2(item, key, async2(callback));
    }
    return aborter;
  }
  return iterate_1;
}
var state_1;
var hasRequiredState$1;
function requireState$1() {
  if (hasRequiredState$1) return state_1;
  hasRequiredState$1 = 1;
  state_1 = state2;
  function state2(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
      index: 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs: {},
      results: isNamedList ? {} : [],
      size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
      initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
        return sortMethod(list[a], list[b]);
      });
    }
    return initState;
  }
  return state_1;
}
var terminator_1;
var hasRequiredTerminator;
function requireTerminator() {
  if (hasRequiredTerminator) return terminator_1;
  hasRequiredTerminator = 1;
  var abort = requireAbort(), async2 = requireAsync$1();
  terminator_1 = terminator;
  function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
      return;
    }
    this.index = this.size;
    abort(this);
    async2(callback)(null, this.results);
  }
  return terminator_1;
}
var parallel_1;
var hasRequiredParallel;
function requireParallel() {
  if (hasRequiredParallel) return parallel_1;
  hasRequiredParallel = 1;
  var iterate = requireIterate(), initState = requireState$1(), terminator = requireTerminator();
  parallel_1 = parallel2;
  function parallel2(list, iterator2, callback) {
    var state2 = initState(list);
    while (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator2, state2, function(error2, result) {
        if (error2) {
          callback(error2, result);
          return;
        }
        if (Object.keys(state2.jobs).length === 0) {
          callback(null, state2.results);
          return;
        }
      });
      state2.index++;
    }
    return terminator.bind(state2, callback);
  }
  return parallel_1;
}
var serialOrdered = { exports: {} };
var hasRequiredSerialOrdered;
function requireSerialOrdered() {
  if (hasRequiredSerialOrdered) return serialOrdered.exports;
  hasRequiredSerialOrdered = 1;
  var iterate = requireIterate(), initState = requireState$1(), terminator = requireTerminator();
  serialOrdered.exports = serialOrdered$1;
  serialOrdered.exports.ascending = ascending;
  serialOrdered.exports.descending = descending;
  function serialOrdered$1(list, iterator2, sortMethod, callback) {
    var state2 = initState(list, sortMethod);
    iterate(list, iterator2, state2, function iteratorHandler(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      state2.index++;
      if (state2.index < (state2["keyedList"] || list).length) {
        iterate(list, iterator2, state2, iteratorHandler);
        return;
      }
      callback(null, state2.results);
    });
    return terminator.bind(state2, callback);
  }
  function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
  }
  function descending(a, b) {
    return -1 * ascending(a, b);
  }
  return serialOrdered.exports;
}
var serial_1;
var hasRequiredSerial;
function requireSerial() {
  if (hasRequiredSerial) return serial_1;
  hasRequiredSerial = 1;
  var serialOrdered2 = requireSerialOrdered();
  serial_1 = serial;
  function serial(list, iterator2, callback) {
    return serialOrdered2(list, iterator2, null, callback);
  }
  return serial_1;
}
var asynckit;
var hasRequiredAsynckit;
function requireAsynckit() {
  if (hasRequiredAsynckit) return asynckit;
  hasRequiredAsynckit = 1;
  asynckit = {
    parallel: requireParallel(),
    serial: requireSerial(),
    serialOrdered: requireSerialOrdered()
  };
  return asynckit;
}
var esObjectAtoms;
var hasRequiredEsObjectAtoms;
function requireEsObjectAtoms() {
  if (hasRequiredEsObjectAtoms) return esObjectAtoms;
  hasRequiredEsObjectAtoms = 1;
  esObjectAtoms = Object;
  return esObjectAtoms;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range$2;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1) return range$2;
  hasRequiredRange$1 = 1;
  range$2 = RangeError;
  return range$2;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var abs;
var hasRequiredAbs;
function requireAbs() {
  if (hasRequiredAbs) return abs;
  hasRequiredAbs = 1;
  abs = Math.abs;
  return abs;
}
var floor;
var hasRequiredFloor;
function requireFloor() {
  if (hasRequiredFloor) return floor;
  hasRequiredFloor = 1;
  floor = Math.floor;
  return floor;
}
var max;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max;
  hasRequiredMax = 1;
  max = Math.max;
  return max;
}
var min;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin) return min;
  hasRequiredMin = 1;
  min = Math.min;
  return min;
}
var pow;
var hasRequiredPow;
function requirePow() {
  if (hasRequiredPow) return pow;
  hasRequiredPow = 1;
  pow = Math.pow;
  return pow;
}
var round;
var hasRequiredRound;
function requireRound() {
  if (hasRequiredRound) return round;
  hasRequiredRound = 1;
  round = Math.round;
  return round;
}
var _isNaN;
var hasRequired_isNaN;
function require_isNaN() {
  if (hasRequired_isNaN) return _isNaN;
  hasRequired_isNaN = 1;
  _isNaN = Number.isNaN || function isNaN2(a) {
    return a !== a;
  };
  return _isNaN;
}
var sign;
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign;
  hasRequiredSign = 1;
  var $isNaN = /* @__PURE__ */ require_isNaN();
  sign = function sign2(number) {
    if ($isNaN(number) || number === 0) {
      return number;
    }
    return number < 0 ? -1 : 1;
  };
  return sign;
}
var gOPD;
var hasRequiredGOPD;
function requireGOPD() {
  if (hasRequiredGOPD) return gOPD;
  hasRequiredGOPD = 1;
  gOPD = Object.getOwnPropertyDescriptor;
  return gOPD;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var $gOPD = /* @__PURE__ */ requireGOPD();
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var $defineProperty = Object.defineProperty || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var shams$1;
var hasRequiredShams$1;
function requireShams$1() {
  if (hasRequiredShams$1) return shams$1;
  hasRequiredShams$1 = 1;
  shams$1 = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (var _2 in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = (
        /** @type {PropertyDescriptor} */
        Object.getOwnPropertyDescriptor(obj, sym)
      );
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams$1;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams$1();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var Reflect_getPrototypeOf;
var hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  if (hasRequiredReflect_getPrototypeOf) return Reflect_getPrototypeOf;
  hasRequiredReflect_getPrototypeOf = 1;
  Reflect_getPrototypeOf = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  return Reflect_getPrototypeOf;
}
var Object_getPrototypeOf;
var hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  Object_getPrototypeOf = $Object.getPrototypeOf || null;
  return Object_getPrototypeOf;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
      arr[j + a.length] = b[j];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
      arr[j] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str = "";
    for (var i = 0; i < arr.length; i += 1) {
      str += arr[i];
      if (i + 1 < arr.length) {
        str += joiner;
      }
    }
    return str;
  };
  implementation = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var functionCall;
var hasRequiredFunctionCall;
function requireFunctionCall() {
  if (hasRequiredFunctionCall) return functionCall;
  hasRequiredFunctionCall = 1;
  functionCall = Function.prototype.call;
  return functionCall;
}
var functionApply;
var hasRequiredFunctionApply;
function requireFunctionApply() {
  if (hasRequiredFunctionApply) return functionApply;
  hasRequiredFunctionApply = 1;
  functionApply = Function.prototype.apply;
  return functionApply;
}
var reflectApply;
var hasRequiredReflectApply;
function requireReflectApply() {
  if (hasRequiredReflectApply) return reflectApply;
  hasRequiredReflectApply = 1;
  reflectApply = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  return reflectApply;
}
var actualApply;
var hasRequiredActualApply;
function requireActualApply() {
  if (hasRequiredActualApply) return actualApply;
  hasRequiredActualApply = 1;
  var bind2 = requireFunctionBind();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var $reflectApply = requireReflectApply();
  actualApply = $reflectApply || bind2.call($call, $apply);
  return actualApply;
}
var callBindApplyHelpers;
var hasRequiredCallBindApplyHelpers;
function requireCallBindApplyHelpers() {
  if (hasRequiredCallBindApplyHelpers) return callBindApplyHelpers;
  hasRequiredCallBindApplyHelpers = 1;
  var bind2 = requireFunctionBind();
  var $TypeError = /* @__PURE__ */ requireType();
  var $call = requireFunctionCall();
  var $actualApply = requireActualApply();
  callBindApplyHelpers = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== "function") {
      throw new $TypeError("a function is required");
    }
    return $actualApply(bind2, $call, args);
  };
  return callBindApplyHelpers;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var callBind = requireCallBindApplyHelpers();
  var gOPD2 = /* @__PURE__ */ requireGopd();
  var hasProtoAccessor;
  try {
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (e) {
    if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
      throw e;
    }
  }
  var desc = !!hasProtoAccessor && gOPD2 && gOPD2(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  );
  var $Object = Object;
  var $getPrototypeOf = $Object.getPrototypeOf;
  get = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
    /** @type {import('./get')} */
    function getDunder(value) {
      return $getPrototypeOf(value == null ? value : $Object(value));
    }
  ) : false;
  return get;
}
var getProto;
var hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto;
  hasRequiredGetProto = 1;
  var reflectGetProto = requireReflect_getPrototypeOf();
  var originalGetProto = requireObject_getPrototypeOf();
  var getDunderProto = /* @__PURE__ */ requireGet();
  getProto = reflectGetProto ? function getProto2(O) {
    return reflectGetProto(O);
  } : originalGetProto ? function getProto2(O) {
    if (!O || typeof O !== "object" && typeof O !== "function") {
      throw new TypeError("getProto: not an object");
    }
    return originalGetProto(O);
  } : getDunderProto ? function getProto2(O) {
    return getDunderProto(O);
  } : null;
  return getProto;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Object = /* @__PURE__ */ requireEsObjectAtoms();
  var $Error = /* @__PURE__ */ requireEsErrors();
  var $EvalError = /* @__PURE__ */ require_eval();
  var $RangeError = /* @__PURE__ */ requireRange$1();
  var $ReferenceError = /* @__PURE__ */ requireRef();
  var $SyntaxError = /* @__PURE__ */ requireSyntax();
  var $TypeError = /* @__PURE__ */ requireType();
  var $URIError = /* @__PURE__ */ requireUri();
  var abs2 = /* @__PURE__ */ requireAbs();
  var floor2 = /* @__PURE__ */ requireFloor();
  var max2 = /* @__PURE__ */ requireMax();
  var min2 = /* @__PURE__ */ requireMin();
  var pow2 = /* @__PURE__ */ requirePow();
  var round2 = /* @__PURE__ */ requireRound();
  var sign2 = /* @__PURE__ */ requireSign();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = /* @__PURE__ */ requireGopd();
  var $defineProperty = /* @__PURE__ */ requireEsDefineProperty();
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var getProto2 = requireGetProto();
  var $ObjectGPO = requireObject_getPrototypeOf();
  var $ReflectGPO = requireReflect_getPrototypeOf();
  var $apply = requireFunctionApply();
  var $call = requireFunctionCall();
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto2 ? undefined$1 : getProto2(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float16Array%": typeof Float16Array === "undefined" ? undefined$1 : Float16Array,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(getProto2([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": $Object,
    "%Object.getOwnPropertyDescriptor%": $gOPD,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto2 ? undefined$1 : getProto2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto2 ? getProto2(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet,
    "%Function.prototype.call%": $call,
    "%Function.prototype.apply%": $apply,
    "%Object.defineProperty%": $defineProperty,
    "%Object.getPrototypeOf%": $ObjectGPO,
    "%Math.abs%": abs2,
    "%Math.floor%": floor2,
    "%Math.max%": max2,
    "%Math.min%": min2,
    "%Math.pow%": pow2,
    "%Math.round%": round2,
    "%Math.sign%": sign2,
    "%Reflect.getPrototypeOf%": $ReflectGPO
  };
  if (getProto2) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto2(getProto2(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto2) {
        value = getProto2(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $concat = bind2.call($call, Array.prototype.concat);
  var $spliceApply = bind2.call($apply, Array.prototype.splice);
  var $replace = bind2.call($call, String.prototype.replace);
  var $strSlice = bind2.call($call, String.prototype.slice);
  var $exec = bind2.call($call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
  return getIntrinsic;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  var hasSymbols2 = requireShams$1();
  shams = function hasToStringTagShams() {
    return hasSymbols2() && !!Symbol.toStringTag;
  };
  return shams;
}
var esSetTostringtag;
var hasRequiredEsSetTostringtag;
function requireEsSetTostringtag() {
  if (hasRequiredEsSetTostringtag) return esSetTostringtag;
  hasRequiredEsSetTostringtag = 1;
  var GetIntrinsic = /* @__PURE__ */ requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var hasToStringTag = requireShams()();
  var hasOwn = /* @__PURE__ */ requireHasown();
  var $TypeError = /* @__PURE__ */ requireType();
  var toStringTag2 = hasToStringTag ? Symbol.toStringTag : null;
  esSetTostringtag = function setToStringTag(object2, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== "undefined" && typeof overrideIfSet !== "boolean" || typeof nonConfigurable !== "undefined" && typeof nonConfigurable !== "boolean") {
      throw new $TypeError("if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans");
    }
    if (toStringTag2 && (overrideIfSet || !hasOwn(object2, toStringTag2))) {
      if ($defineProperty) {
        $defineProperty(object2, toStringTag2, {
          configurable: !nonConfigurable,
          enumerable: false,
          value,
          writable: false
        });
      } else {
        object2[toStringTag2] = value;
      }
    }
  };
  return esSetTostringtag;
}
var populate;
var hasRequiredPopulate;
function requirePopulate() {
  if (hasRequiredPopulate) return populate;
  hasRequiredPopulate = 1;
  populate = function(dst, src2) {
    Object.keys(src2).forEach(function(prop) {
      dst[prop] = dst[prop] || src2[prop];
    });
    return dst;
  };
  return populate;
}
var form_data;
var hasRequiredForm_data;
function requireForm_data() {
  if (hasRequiredForm_data) return form_data;
  hasRequiredForm_data = 1;
  var CombinedStream = requireCombined_stream();
  var util2 = require$$0$2;
  var path2 = require$$1;
  var http = require$$3;
  var https = require$$4;
  var parseUrl = require$$0$3.parse;
  var fs2 = require$$0$4;
  var Stream = require$$0$1.Stream;
  var mime = requireMimeTypes();
  var asynckit2 = requireAsynckit();
  var setToStringTag = /* @__PURE__ */ requireEsSetTostringtag();
  var populate2 = requirePopulate();
  form_data = FormData2;
  util2.inherits(FormData2, CombinedStream);
  function FormData2(options) {
    if (!(this instanceof FormData2)) {
      return new FormData2(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for (var option in options) {
      this[option] = options[option];
    }
  }
  FormData2.LINE_BREAK = "\r\n";
  FormData2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
  FormData2.prototype.append = function(field, value, options) {
    options = options || {};
    if (typeof options == "string") {
      options = { filename: options };
    }
    var append2 = CombinedStream.prototype.append.bind(this);
    if (typeof value == "number") {
      value = "" + value;
    }
    if (Array.isArray(value)) {
      this._error(new Error("Arrays are not supported."));
      return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append2(header);
    append2(value);
    append2(footer);
    this._trackLength(header, value, options);
  };
  FormData2.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    if (options.knownLength != null) {
      valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
      valueLength = value.length;
    } else if (typeof value === "string") {
      valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    this._overheadLength += Buffer.byteLength(header) + FormData2.LINE_BREAK.length;
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) && !(value instanceof Stream)) {
      return;
    }
    if (!options.knownLength) {
      this._valuesToMeasure.push(value);
    }
  };
  FormData2.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, "fd")) {
      if (value.end != void 0 && value.end != Infinity && value.start != void 0) {
        callback(null, value.end + 1 - (value.start ? value.start : 0));
      } else {
        fs2.stat(value.path, function(err, stat) {
          var fileSize;
          if (err) {
            callback(err);
            return;
          }
          fileSize = stat.size - (value.start ? value.start : 0);
          callback(null, fileSize);
        });
      }
    } else if (Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      callback(null, +value.headers["content-length"]);
    } else if (Object.prototype.hasOwnProperty.call(value, "httpModule")) {
      value.on("response", function(response) {
        value.pause();
        callback(null, +response.headers["content-length"]);
      });
      value.resume();
    } else {
      callback("Unknown stream");
    }
  };
  FormData2.prototype._multiPartHeader = function(field, value, options) {
    if (typeof options.header == "string") {
      return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = "";
    var headers2 = {
      // add custom disposition as third element or keep it two elements if not
      "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition || []),
      // if no content type. allow it to be empty array
      "Content-Type": [].concat(contentType || [])
    };
    if (typeof options.header == "object") {
      populate2(headers2, options.header);
    }
    var header;
    for (var prop in headers2) {
      if (Object.prototype.hasOwnProperty.call(headers2, prop)) {
        header = headers2[prop];
        if (header == null) {
          continue;
        }
        if (!Array.isArray(header)) {
          header = [header];
        }
        if (header.length) {
          contents += prop + ": " + header.join("; ") + FormData2.LINE_BREAK;
        }
      }
    }
    return "--" + this.getBoundary() + FormData2.LINE_BREAK + contents + FormData2.LINE_BREAK;
  };
  FormData2.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === "string") {
      filename = path2.normalize(options.filepath).replace(/\\/g, "/");
    } else if (options.filename || value.name || value.path) {
      filename = path2.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      filename = path2.basename(value.client._httpMessage.path || "");
    }
    if (filename) {
      contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
  };
  FormData2.prototype._getContentType = function(value, options) {
    var contentType = options.contentType;
    if (!contentType && value.name) {
      contentType = mime.lookup(value.name);
    }
    if (!contentType && value.path) {
      contentType = mime.lookup(value.path);
    }
    if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, "httpVersion")) {
      contentType = value.headers["content-type"];
    }
    if (!contentType && (options.filepath || options.filename)) {
      contentType = mime.lookup(options.filepath || options.filename);
    }
    if (!contentType && typeof value == "object") {
      contentType = FormData2.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
  };
  FormData2.prototype._multiPartFooter = function() {
    return (function(next) {
      var footer = FormData2.LINE_BREAK;
      var lastPart = this._streams.length === 0;
      if (lastPart) {
        footer += this._lastBoundary();
      }
      next(footer);
    }).bind(this);
  };
  FormData2.prototype._lastBoundary = function() {
    return "--" + this.getBoundary() + "--" + FormData2.LINE_BREAK;
  };
  FormData2.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
      "content-type": "multipart/form-data; boundary=" + this.getBoundary()
    };
    for (header in userHeaders) {
      if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
        formHeaders[header.toLowerCase()] = userHeaders[header];
      }
    }
    return formHeaders;
  };
  FormData2.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
  };
  FormData2.prototype.getBoundary = function() {
    if (!this._boundary) {
      this._generateBoundary();
    }
    return this._boundary;
  };
  FormData2.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    for (var i = 0, len = this._streams.length; i < len; i++) {
      if (typeof this._streams[i] !== "function") {
        if (Buffer.isBuffer(this._streams[i])) {
          dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
        } else {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
        }
        if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
          dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData2.LINE_BREAK)]);
        }
      }
    }
    return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
  };
  FormData2.prototype._generateBoundary = function() {
    var boundary = "--------------------------";
    for (var i = 0; i < 24; i++) {
      boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
  };
  FormData2.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this.hasKnownLength()) {
      this._error(new Error("Cannot calculate proper length in synchronous way."));
    }
    return knownLength;
  };
  FormData2.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
      hasKnownLength = false;
    }
    return hasKnownLength;
  };
  FormData2.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
      knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
      process.nextTick(cb.bind(this, null, knownLength));
      return;
    }
    asynckit2.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
      if (err) {
        cb(err);
        return;
      }
      values.forEach(function(length) {
        knownLength += length;
      });
      cb(null, knownLength);
    });
  };
  FormData2.prototype.submit = function(params, cb) {
    var request, options, defaults2 = { method: "post" };
    if (typeof params == "string") {
      params = parseUrl(params);
      options = populate2({
        port: params.port,
        path: params.pathname,
        host: params.hostname,
        protocol: params.protocol
      }, defaults2);
    } else {
      options = populate2(params, defaults2);
      if (!options.port) {
        options.port = options.protocol == "https:" ? 443 : 80;
      }
    }
    options.headers = this.getHeaders(params.headers);
    if (options.protocol == "https:") {
      request = https.request(options);
    } else {
      request = http.request(options);
    }
    this.getLength((function(err, length) {
      if (err && err !== "Unknown stream") {
        this._error(err);
        return;
      }
      if (length) {
        request.setHeader("Content-Length", length);
      }
      this.pipe(request);
      if (cb) {
        var onResponse;
        var callback = function(error2, responce) {
          request.removeListener("error", callback);
          request.removeListener("response", onResponse);
          return cb.call(this, error2, responce);
        };
        onResponse = callback.bind(this, null);
        request.on("error", callback);
        request.on("response", onResponse);
      }
    }).bind(this));
    return request;
  };
  FormData2.prototype._error = function(err) {
    if (!this.error) {
      this.error = err;
      this.pause();
      this.emit("error", err);
    }
  };
  FormData2.prototype.toString = function() {
    return "[object FormData]";
  };
  setToStringTag(FormData2, "FormData");
  return form_data;
}
var form_dataExports = requireForm_data();
const FormData$1 = /* @__PURE__ */ getDefaultExportFromCjs(form_dataExports);
function isVisitable(thing) {
  return utils$2.isPlainObject(thing) || utils$2.isArray(thing);
}
function removeBrackets(key) {
  return utils$2.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each2(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$2.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$2.toFlatObject(utils$2, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData$1(obj, formData, options) {
  if (!utils$2.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData$1 || FormData)();
  options = utils$2.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$2.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$2.isSpecCompliantForm(formData);
  if (!utils$2.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils$2.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$2.isBlob(value)) {
      throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$2.isArrayBuffer(value) || utils$2.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils$2.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$2.isArray(value) && isFlatArray(value) || (utils$2.isFileList(value) || utils$2.endsWith(key, "[]")) && (arr = utils$2.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each2(el, index2) {
          !(utils$2.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils$2.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils$2.forEach(value, function each2(el, key) {
      const result = !(utils$2.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$2.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$2.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData$1(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each2(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  if (utils$2.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$2.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$2.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams = require$$0$3.URLSearchParams;
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  const randomValues = new Uint32Array(size);
  require$$0$5.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }
  return str;
};
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData$1,
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  navigator: _navigator,
  origin
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils$1,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData$1(data2, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform.isNode && utils$2.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$2.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index2) {
    let name = path2[index2++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index2 >= path2.length;
    name = !name && utils$2.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$2.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$2.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index2);
    if (result && utils$2.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$2.isFormData(formData) && utils$2.isFunction(formData.entries)) {
    const obj = {};
    utils$2.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser2, encoder) {
  if (utils$2.isString(rawValue)) {
    try {
      (parser2 || JSON.parse)(rawValue);
      return utils$2.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults$1 = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers2) {
    const contentType = headers2.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$2.isObject(data2);
    if (isObjectPayload && utils$2.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$2.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$2.isArrayBuffer(data2) || utils$2.isBuffer(data2) || utils$2.isStream(data2) || utils$2.isFile(data2) || utils$2.isBlob(data2) || utils$2.isReadableStream(data2)) {
      return data2;
    }
    if (utils$2.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$2.isURLSearchParams(data2)) {
      headers2.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$2.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData$1(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers2.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults$1.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$2.isResponse(data2) || utils$2.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$2.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$2.forEach(["delete", "get", "head", "post", "put", "patch"], (method2) => {
  defaults$1.headers[method2] = {};
});
const ignoreDuplicateOf = utils$2.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser2(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$2.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context2, value, header, filter3, isHeaderNameFilter) {
  if (utils$2.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$2.isString(value)) return;
  if (utils$2.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$2.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$2.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
let AxiosHeaders$1 = class AxiosHeaders {
  constructor(headers2) {
    headers2 && this.set(headers2);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$2.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers2, _rewrite) => utils$2.forEach(headers2, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$2.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$2.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$2.isObject(header) && utils$2.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$2.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils$2.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser2) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser2) {
          return value;
        }
        if (parser2 === true) {
          return parseTokens(value);
        }
        if (utils$2.isFunction(parser2)) {
          return parser2.call(this, value, key);
        }
        if (utils$2.isRegExp(parser2)) {
          return parser2.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$2.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$2.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$2.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;
    while (i--) {
      const key = keys[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers2 = {};
    utils$2.forEach(this, (value, header) => {
      const key = utils$2.findKey(headers2, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers2[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$2.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$2.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$2.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$2.reduceDescriptors(AxiosHeaders$1.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$2.freezeMethods(AxiosHeaders$1);
function transformData(fns, response) {
  const config = this || defaults$1;
  const context2 = response || config;
  const headers2 = AxiosHeaders$1.from(context2.headers);
  let data2 = context2.data;
  utils$2.forEach(fns, function transform2(fn) {
    data2 = fn.call(config, data2, headers2.normalize(), response ? response.status : void 0);
  });
  headers2.normalize();
  return data2;
}
function isCancel$1(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError$1(message, config, request) {
  AxiosError$1.call(this, message == null ? "canceled" : message, AxiosError$1.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils$2.inherits(CanceledError$1, AxiosError$1, {
  __CANCEL__: true
});
function settle$1(resolve, reject2, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject2(new AxiosError$1(
      "Request failed with status code " + response.status,
      [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
var proxyFromEnv$1 = {};
var hasRequiredProxyFromEnv;
function requireProxyFromEnv() {
  if (hasRequiredProxyFromEnv) return proxyFromEnv$1;
  hasRequiredProxyFromEnv = 1;
  var parseUrl = require$$0$3.parse;
  var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
  };
  var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
  };
  function getProxyForUrl(url) {
    var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
      return "";
    }
    proto = proto.split(":", 1)[0];
    hostname = hostname.replace(/:\d*$/, "");
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
      return "";
    }
    var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
    if (proxy && proxy.indexOf("://") === -1) {
      proxy = proto + "://" + proxy;
    }
    return proxy;
  }
  function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
    if (!NO_PROXY) {
      return true;
    }
    if (NO_PROXY === "*") {
      return false;
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
      if (!proxy) {
        return true;
      }
      var parsedProxy = proxy.match(/^(.+):(\d+)$/);
      var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
      var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
      if (parsedProxyPort && parsedProxyPort !== port) {
        return true;
      }
      if (!/^[.*]/.test(parsedProxyHostname)) {
        return hostname !== parsedProxyHostname;
      }
      if (parsedProxyHostname.charAt(0) === "*") {
        parsedProxyHostname = parsedProxyHostname.slice(1);
      }
      return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
  }
  function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
  }
  proxyFromEnv$1.getProxyForUrl = getProxyForUrl;
  return proxyFromEnv$1;
}
var proxyFromEnvExports = requireProxyFromEnv();
const proxyFromEnv = /* @__PURE__ */ getDefaultExportFromCjs(proxyFromEnvExports);
var followRedirects$1 = { exports: {} };
var src$3 = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type2 = typeof val;
    if (type2 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type2 === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type2 = (match[2] || "ms").toLowerCase();
    switch (type2) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return Math.round(ms2 / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms2 / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms2 / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms2 / s) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d) {
      return plural(ms2, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms2, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms2, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms2, msAbs, s, "second");
    }
    return ms2 + " ms";
  }
  function plural(ms2, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
  }
  return ms;
}
var common$2;
var hasRequiredCommon$2;
function requireCommon$2() {
  if (hasRequiredCommon$2) return common$2;
  hasRequiredCommon$2 = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self2.diff = ms2;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index2++;
          const formatter2 = createDebug.formatters[format];
          if (typeof formatter2 === "function") {
            const val = args[index2];
            match = formatter2.call(self2, val);
            args.splice(index2, 1);
            index2--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend2;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
      for (const ns of split) {
        if (ns[0] === "-") {
          createDebug.skips.push(ns.slice(1));
        } else {
          createDebug.names.push(ns);
        }
      }
    }
    function matchesTemplate(search, template) {
      let searchIndex = 0;
      let templateIndex = 0;
      let starIndex = -1;
      let matchIndex = 0;
      while (searchIndex < search.length) {
        if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
          if (template[templateIndex] === "*") {
            starIndex = templateIndex;
            matchIndex = searchIndex;
            templateIndex++;
          } else {
            searchIndex++;
            templateIndex++;
          }
        } else if (starIndex !== -1) {
          templateIndex = starIndex + 1;
          matchIndex++;
          searchIndex = matchIndex;
        } else {
          return false;
        }
      }
      while (templateIndex < template.length && template[templateIndex] === "*") {
        templateIndex++;
      }
      return templateIndex === template.length;
    }
    function disable() {
      const namespaces = [
        ...createDebug.names,
        ...createDebug.skips.map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      for (const skip of createDebug.skips) {
        if (matchesTemplate(name, skip)) {
          return false;
        }
      }
      for (const ns of createDebug.names) {
        if (matchesTemplate(name, ns)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$2 = setup;
  return common$2;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index2++;
        if (match === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load2() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = requireCommon$2()(exports);
    const { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$6;
  const tty = require$$1$1;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream2) {
    const level = supportsColor(stream2, stream2 && stream2.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$1.exports;
  hasRequiredNode$1 = 1;
  (function(module, exports) {
    const tty = require$$1$1;
    const util2 = require$$0$2;
    exports.init = init;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load2;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = requireSupportsColor();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load2() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module.exports = requireCommon$2()(exports);
    const { formatters } = module.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
var hasRequiredSrc$3;
function requireSrc$3() {
  if (hasRequiredSrc$3) return src$3.exports;
  hasRequiredSrc$3 = 1;
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    src$3.exports = requireBrowser();
  } else {
    src$3.exports = requireNode$1();
  }
  return src$3.exports;
}
var debug_1;
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug_1;
  hasRequiredDebug = 1;
  var debug;
  debug_1 = function() {
    if (!debug) {
      try {
        debug = requireSrc$3()("follow-redirects");
      } catch (error2) {
      }
      if (typeof debug !== "function") {
        debug = function() {
        };
      }
    }
    debug.apply(null, arguments);
  };
  return debug_1;
}
var hasRequiredFollowRedirects;
function requireFollowRedirects() {
  if (hasRequiredFollowRedirects) return followRedirects$1.exports;
  hasRequiredFollowRedirects = 1;
  var url = require$$0$3;
  var URL2 = url.URL;
  var http = require$$3;
  var https = require$$4;
  var Writable = require$$0$1.Writable;
  var assert2 = require$$5;
  var debug = requireDebug();
  (function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction2(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
      console.warn("The follow-redirects package should be excluded from browser builds.");
    }
  })();
  var useNativeURL = false;
  try {
    assert2(new URL2(""));
  } catch (error2) {
    useNativeURL = error2.code === "ERR_INVALID_URL";
  }
  var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
  ];
  var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
  var eventHandlers = /* @__PURE__ */ Object.create(null);
  events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
      this._redirectable.emit(event, arg1, arg2, arg3);
    };
  });
  var InvalidUrlError = createErrorType(
    "ERR_INVALID_URL",
    "Invalid URL",
    TypeError
  );
  var RedirectionError = createErrorType(
    "ERR_FR_REDIRECTION_FAILURE",
    "Redirected request failed"
  );
  var TooManyRedirectsError = createErrorType(
    "ERR_FR_TOO_MANY_REDIRECTS",
    "Maximum number of redirects exceeded",
    RedirectionError
  );
  var MaxBodyLengthExceededError = createErrorType(
    "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
    "Request body larger than maxBodyLength limit"
  );
  var WriteAfterEndError = createErrorType(
    "ERR_STREAM_WRITE_AFTER_END",
    "write after end"
  );
  var destroy = Writable.prototype.destroy || noop2;
  function RedirectableRequest(options, responseCallback) {
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    if (responseCallback) {
      this.on("response", responseCallback);
    }
    var self2 = this;
    this._onNativeResponse = function(response) {
      try {
        self2._processResponse(response);
      } catch (cause) {
        self2.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
      }
    };
    this._performRequest();
  }
  RedirectableRequest.prototype = Object.create(Writable.prototype);
  RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
  };
  RedirectableRequest.prototype.destroy = function(error2) {
    destroyRequest(this._currentRequest, error2);
    destroy.call(this, error2);
    return this;
  };
  RedirectableRequest.prototype.write = function(data2, encoding, callback) {
    if (this._ending) {
      throw new WriteAfterEndError();
    }
    if (!isString2(data2) && !isBuffer2(data2)) {
      throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (data2.length === 0) {
      if (callback) {
        callback();
      }
      return;
    }
    if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
      this._requestBodyLength += data2.length;
      this._requestBodyBuffers.push({ data: data2, encoding });
      this._currentRequest.write(data2, encoding, callback);
    } else {
      this.emit("error", new MaxBodyLengthExceededError());
      this.abort();
    }
  };
  RedirectableRequest.prototype.end = function(data2, encoding, callback) {
    if (isFunction2(data2)) {
      callback = data2;
      data2 = encoding = null;
    } else if (isFunction2(encoding)) {
      callback = encoding;
      encoding = null;
    }
    if (!data2) {
      this._ended = this._ending = true;
      this._currentRequest.end(null, null, callback);
    } else {
      var self2 = this;
      var currentRequest = this._currentRequest;
      this.write(data2, encoding, function() {
        self2._ended = true;
        currentRequest.end(null, null, callback);
      });
      this._ending = true;
    }
  };
  RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
  };
  RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
  };
  RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self2 = this;
    function destroyOnTimeout(socket) {
      socket.setTimeout(msecs);
      socket.removeListener("timeout", socket.destroy);
      socket.addListener("timeout", socket.destroy);
    }
    function startTimer(socket) {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
      }
      self2._timeout = setTimeout(function() {
        self2.emit("timeout");
        clearTimer();
      }, msecs);
      destroyOnTimeout(socket);
    }
    function clearTimer() {
      if (self2._timeout) {
        clearTimeout(self2._timeout);
        self2._timeout = null;
      }
      self2.removeListener("abort", clearTimer);
      self2.removeListener("error", clearTimer);
      self2.removeListener("response", clearTimer);
      self2.removeListener("close", clearTimer);
      if (callback) {
        self2.removeListener("timeout", callback);
      }
      if (!self2.socket) {
        self2._currentRequest.removeListener("socket", startTimer);
      }
    }
    if (callback) {
      this.on("timeout", callback);
    }
    if (this.socket) {
      startTimer(this.socket);
    } else {
      this._currentRequest.once("socket", startTimer);
    }
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
  };
  [
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
  ].forEach(function(method2) {
    RedirectableRequest.prototype[method2] = function(a, b) {
      return this._currentRequest[method2](a, b);
    };
  });
  ["aborted", "connection", "socket"].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
      get: function() {
        return this._currentRequest[property];
      }
    });
  });
  RedirectableRequest.prototype._sanitizeOptions = function(options) {
    if (!options.headers) {
      options.headers = {};
    }
    if (options.host) {
      if (!options.hostname) {
        options.hostname = options.host;
      }
      delete options.host;
    }
    if (!options.pathname && options.path) {
      var searchPos = options.path.indexOf("?");
      if (searchPos < 0) {
        options.pathname = options.path;
      } else {
        options.pathname = options.path.substring(0, searchPos);
        options.search = options.path.substring(searchPos);
      }
    }
  };
  RedirectableRequest.prototype._performRequest = function() {
    var protocol2 = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol2];
    if (!nativeProtocol) {
      throw new TypeError("Unsupported protocol " + protocol2);
    }
    if (this._options.agents) {
      var scheme = protocol2.slice(0, -1);
      this._options.agent = this._options.agents[scheme];
    }
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events) {
      request.on(event, eventHandlers[event]);
    }
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : (
      // When making a request to a proxy, []
      // a client MUST send the target URI in absolute-form [].
      this._options.path
    );
    if (this._isRedirect) {
      var i = 0;
      var self2 = this;
      var buffers2 = this._requestBodyBuffers;
      (function writeNext(error2) {
        if (request === self2._currentRequest) {
          if (error2) {
            self2.emit("error", error2);
          } else if (i < buffers2.length) {
            var buffer = buffers2[i++];
            if (!request.finished) {
              request.write(buffer.data, buffer.encoding, writeNext);
            }
          } else if (self2._ended) {
            request.end();
          }
        }
      })();
    }
  };
  RedirectableRequest.prototype._processResponse = function(response) {
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
      this._redirects.push({
        url: this._currentUrl,
        headers: response.headers,
        statusCode
      });
    }
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
      response.responseUrl = this._currentUrl;
      response.redirects = this._redirects;
      this.emit("response", response);
      this._requestBodyBuffers = [];
      return;
    }
    destroyRequest(this._currentRequest);
    response.destroy();
    if (++this._redirectCount > this._options.maxRedirects) {
      throw new TooManyRedirectsError();
    }
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
      requestHeaders = Object.assign({
        // The Host header was set by nativeProtocol.request
        Host: response.req.getHeader("host")
      }, this._options.headers);
    }
    var method2 = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC72316.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource []
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) []
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
      this._options.method = "GET";
      this._requestBodyBuffers = [];
      removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
      removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    if (isFunction2(beforeRedirect)) {
      var responseDetails = {
        headers: response.headers,
        statusCode
      };
      var requestDetails = {
        url: currentUrl,
        method: method2,
        headers: requestHeaders
      };
      beforeRedirect(this._options, responseDetails, requestDetails);
      this._sanitizeOptions(this._options);
    }
    this._performRequest();
  };
  function wrap2(protocols) {
    var exports = {
      maxRedirects: 21,
      maxBodyLength: 10 * 1024 * 1024
    };
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
      var protocol2 = scheme + ":";
      var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
      var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
      function request(input, options, callback) {
        if (isURL(input)) {
          input = spreadUrlObject(input);
        } else if (isString2(input)) {
          input = spreadUrlObject(parseUrl(input));
        } else {
          callback = options;
          options = validateUrl(input);
          input = { protocol: protocol2 };
        }
        if (isFunction2(options)) {
          callback = options;
          options = null;
        }
        options = Object.assign({
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, input, options);
        options.nativeProtocols = nativeProtocols;
        if (!isString2(options.host) && !isString2(options.hostname)) {
          options.hostname = "::1";
        }
        assert2.equal(options.protocol, protocol2, "protocol mismatch");
        debug("options", options);
        return new RedirectableRequest(options, callback);
      }
      function get2(input, options, callback) {
        var wrappedRequest = wrappedProtocol.request(input, options, callback);
        wrappedRequest.end();
        return wrappedRequest;
      }
      Object.defineProperties(wrappedProtocol, {
        request: { value: request, configurable: true, enumerable: true, writable: true },
        get: { value: get2, configurable: true, enumerable: true, writable: true }
      });
    });
    return exports;
  }
  function noop2() {
  }
  function parseUrl(input) {
    var parsed;
    if (useNativeURL) {
      parsed = new URL2(input);
    } else {
      parsed = validateUrl(url.parse(input));
      if (!isString2(parsed.protocol)) {
        throw new InvalidUrlError({ input });
      }
    }
    return parsed;
  }
  function resolveUrl(relative, base) {
    return useNativeURL ? new URL2(relative, base) : parseUrl(url.resolve(base, relative));
  }
  function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
      throw new InvalidUrlError({ input: input.href || input });
    }
    return input;
  }
  function spreadUrlObject(urlObject, target) {
    var spread2 = target || {};
    for (var key of preservedUrlFields) {
      spread2[key] = urlObject[key];
    }
    if (spread2.hostname.startsWith("[")) {
      spread2.hostname = spread2.hostname.slice(1, -1);
    }
    if (spread2.port !== "") {
      spread2.port = Number(spread2.port);
    }
    spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
    return spread2;
  }
  function removeMatchingHeaders(regex2, headers2) {
    var lastValue;
    for (var header in headers2) {
      if (regex2.test(header)) {
        lastValue = headers2[header];
        delete headers2[header];
      }
    }
    return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
  }
  function createErrorType(code, message, baseClass) {
    function CustomError(properties) {
      if (isFunction2(Error.captureStackTrace)) {
        Error.captureStackTrace(this, this.constructor);
      }
      Object.assign(this, properties || {});
      this.code = code;
      this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
      constructor: {
        value: CustomError,
        enumerable: false
      },
      name: {
        value: "Error [" + code + "]",
        enumerable: false
      }
    });
    return CustomError;
  }
  function destroyRequest(request, error2) {
    for (var event of events) {
      request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop2);
    request.destroy(error2);
  }
  function isSubdomain(subdomain, domain) {
    assert2(isString2(subdomain) && isString2(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
  }
  function isString2(value) {
    return typeof value === "string" || value instanceof String;
  }
  function isFunction2(value) {
    return typeof value === "function";
  }
  function isBuffer2(value) {
    return typeof value === "object" && "length" in value;
  }
  function isURL(value) {
    return URL2 && value instanceof URL2;
  }
  followRedirects$1.exports = wrap2({ http, https });
  followRedirects$1.exports.wrap = wrap2;
  return followRedirects$1.exports;
}
var followRedirectsExports = requireFollowRedirects();
const followRedirects = /* @__PURE__ */ getDefaultExportFromCjs(followRedirectsExports);
const VERSION$1 = "1.9.0";
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol2 = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol2 === "data") {
    uri2 = protocol2.length ? uri2.slice(protocol2.length + 1) : uri2;
    const match = DATA_URL_PATTERN.exec(uri2);
    if (!match) {
      throw new AxiosError$1("Invalid URL", AxiosError$1.ERR_INVALID_URL);
    }
    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError$1("Blob is not supported", AxiosError$1.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime });
    }
    return buffer;
  }
  throw new AxiosError$1("Unsupported protocol " + protocol2, AxiosError$1.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends require$$0$1.Transform {
  constructor(options) {
    options = utils$2.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$2.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = typeof TextEncoder === "function" ? new TextEncoder() : new require$$0$2.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name, value) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$2.isString(value);
    let headers2 = `Content-Disposition: form-data; name="${escapeName(name)}"${!isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers2 += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers2 + CRLF);
    this.contentLength = isStringValue ? value.byteLength : value.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name;
    this.value = value;
  }
  async *encode() {
    yield this.headers;
    const { value } = this;
    if (utils$2.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob(value);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name) {
    return String(name).replace(/[\r\n"]/g, (match) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$2.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$2.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
class ZlibHeaderTransformStream extends require$$0$1.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header = Buffer.alloc(2);
        header[0] = 120;
        header[1] = 156;
        this.push(header, encoding);
      }
    }
    this.__transform(chunk, encoding, callback);
  }
}
const callbackify = (fn, reducer) => {
  return utils$2.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data2);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$2.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib.constants.Z_SYNC_FLUSH,
  finishFlush: zlib.constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib.constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$2.isFunction(zlib.createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects;
const isHttps = /https:?/;
const supportedProtocols = platform.protocols.map((protocol2) => {
  return protocol2 + ":";
});
const flushOnFinish = (stream2, [throttled, flush]) => {
  stream2.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$2.kindOf(process) === "process";
const wrapAsync$1 = (asyncExecutor) => {
  return new Promise((resolve, reject2) => {
    let onDone;
    let isDone;
    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };
    const _resolve = (value) => {
      done(value);
      resolve(value);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject2(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$2.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$2.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync$1(async function dispatchHttpRequest(resolve, reject2, onDone) {
    let { data: data2, lookup, family } = config;
    const { responseType, responseEncoding } = config;
    const method2 = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;
    if (lookup) {
      const _lookup = callbackify(lookup, (value) => utils$2.isArray(value) ? value : [value]);
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$2.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new EventEmitter();
    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort);
      }
      emitter.removeAllListeners();
    };
    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });
    function abort(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError$1(null, config, req) : reason);
    }
    emitter.once("abort", reject2);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener("abort", abort);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : void 0);
    const protocol2 = parsed.protocol || supportedProtocols[0];
    if (protocol2 === "data:") {
      let convertedData;
      if (method2 !== "GET") {
        return settle$1(resolve, reject2, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError$1.from(err, AxiosError$1.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$2.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = require$$0$1.Readable.from(convertedData);
      }
      return settle$1(resolve, reject2, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol2) === -1) {
      return reject2(new AxiosError$1(
        "Unsupported protocol " + protocol2,
        AxiosError$1.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers2 = AxiosHeaders$1.from(config.headers).normalize();
    headers2.set("User-Agent", "axios/" + VERSION$1, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$2.isSpecCompliantForm(data2)) {
      const userBoundary = headers2.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data2 = formDataToStream(data2, (formHeaders) => {
        headers2.set(formHeaders);
      }, {
        tag: `axios-${VERSION$1}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$2.isFormData(data2) && utils$2.isFunction(data2.getHeaders)) {
      headers2.set(data2.getHeaders());
      if (!headers2.hasContentLength()) {
        try {
          const knownLength = await require$$0$2.promisify(data2.getLength).call(data2);
          Number.isFinite(knownLength) && knownLength >= 0 && headers2.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$2.isBlob(data2) || utils$2.isFile(data2)) {
      data2.size && headers2.setContentType(data2.type || "application/octet-stream");
      headers2.setContentLength(data2.size || 0);
      data2 = require$$0$1.Readable.from(readBlob(data2));
    } else if (data2 && !utils$2.isStream(data2)) {
      if (Buffer.isBuffer(data2)) ;
      else if (utils$2.isArrayBuffer(data2)) {
        data2 = Buffer.from(new Uint8Array(data2));
      } else if (utils$2.isString(data2)) {
        data2 = Buffer.from(data2, "utf-8");
      } else {
        return reject2(new AxiosError$1(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
      }
      headers2.setContentLength(data2.length, false);
      if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
        return reject2(new AxiosError$1(
          "Request body larger than maxBodyLength limit",
          AxiosError$1.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils$2.toFiniteNumber(headers2.getContentLength());
    if (utils$2.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data2 && (onUploadProgress || maxUploadRate)) {
      if (!utils$2.isStream(data2)) {
        data2 = require$$0$1.Readable.from(data2, { objectMode: false });
      }
      data2 = require$$0$1.pipeline([data2, new AxiosTransformStream({
        maxRate: utils$2.toFiniteNumber(maxUploadRate)
      })], utils$2.noop);
      onUploadProgress && data2.on("progress", flushOnFinish(
        data2,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers2.delete("authorization");
    let path2;
    try {
      path2 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject2(customErr);
    }
    headers2.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path2,
      method: method2,
      headers: headers2.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol: protocol2,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$2.isUndefined(lookup) && (options.lookup = lookup);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol2 + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? require$$4 : require$$3;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;
      const streams = [res];
      const responseLength = +res.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream({
          maxRate: utils$2.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams.push(transformStream);
      }
      let responseStream = res;
      const lastRequest = res.req || req;
      if (config.decompress !== false && res.headers["content-encoding"]) {
        if (method2 === "HEAD" || res.statusCode === 204) {
          delete res.headers["content-encoding"];
        }
        switch ((res.headers["content-encoding"] || "").toLowerCase()) {
          /*eslint default-case:0*/
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "deflate":
            streams.push(new ZlibHeaderTransformStream());
            streams.push(zlib.createUnzip(zlibOptions));
            delete res.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams.push(zlib.createBrotliDecompress(brotliOptions));
              delete res.headers["content-encoding"];
            }
        }
      }
      responseStream = streams.length > 1 ? require$$0$1.pipeline(streams, utils$2.noop) : streams[0];
      const offListeners = require$$0$1.finished(responseStream, () => {
        offListeners();
        onFinished();
      });
      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response.data = responseStream;
        settle$1(resolve, reject2, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject2(new AxiosError$1(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError$1.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError$1(
            "stream has been aborted",
            AxiosError$1.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject2(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req.destroyed) return;
          reject2(AxiosError$1.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$2.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject2(AxiosError$1.from(err, null, config, response.request, response));
          }
          settle$1(resolve, reject2, response);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject2(err);
      req.destroy(err);
    });
    req.on("error", function handleRequestError(err) {
      reject2(AxiosError$1.from(err, null, config, req));
    });
    req.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout2 = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout2)) {
        reject2(new AxiosError$1(
          "error trying to parse `config.timeout` to int",
          AxiosError$1.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));
        return;
      }
      req.setTimeout(timeout2, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject2(new AxiosError$1(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }
    if (utils$2.isStream(data2)) {
      let ended = false;
      let errored = false;
      data2.on("end", () => {
        ended = true;
      });
      data2.once("error", (err) => {
        errored = true;
        req.destroy(err);
      });
      data2.on("close", () => {
        if (!ended && !errored) {
          abort(new CanceledError$1("Request stream has been aborted", config, req));
        }
      });
      data2.pipe(req);
    } else {
      req.end(data2);
    }
  });
};
const isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils$2.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils$2.isString(path2) && cookie.push("path=" + path2);
      utils$2.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig$1(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils$2.isPlainObject(target) && utils$2.isPlainObject(source)) {
      return utils$2.merge.call({ caseless }, target, source);
    } else if (utils$2.isPlainObject(source)) {
      return utils$2.merge({}, source);
    } else if (utils$2.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, prop, caseless) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(a, b, prop, caseless);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(void 0, a, prop, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$2.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$2.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
  };
  utils$2.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$2.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig$1({}, config);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers: headers2, auth } = newConfig;
  newConfig.headers = headers2 = AxiosHeaders$1.from(headers2);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers2.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils$2.isFormData(data2)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers2.setContentType(void 0);
    } else if ((contentType = headers2.getContentType()) !== false) {
      const [type2, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers2.setContentType([type2 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$2.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers2.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject2) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle$1(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject2(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject2(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject2(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject2(new AxiosError$1(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$2.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$2.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel2) => {
        if (!request) {
          return;
        }
        reject2(!cancel2 || cancel2.type ? new CanceledError$1(null, config, request) : cancel2);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(_config.url);
    if (protocol2 && platform.protocols.indexOf(protocol2) === -1) {
      reject2(new AxiosError$1("Unsupported protocol " + protocol2 + ":", AxiosError$1.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const composeSignals = (signals, timeout2) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout2 || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout2 && setTimeout(() => {
      timer = null;
      onabort(new AxiosError$1(`timeout ${timeout2} of ms exceeded`, AxiosError$1.ETIMEDOUT));
    }, timeout2);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$2.asap(unsubscribe);
    return signal;
  }
};
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream2) {
  if (stream2[Symbol.asyncIterator]) {
    yield* stream2;
    return;
  }
  const reader2 = stream2.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader2.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader2.cancel();
  }
};
const trackStream = (stream2, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream2, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test(() => utils$2.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type2) => {
    !resolvers[type2] && (resolvers[type2] = utils$2.isFunction(res[type2]) ? (res2) => res2[type2]() : (_2, config) => {
      throw new AxiosError$1(`Response type '${type2}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$2.isBlob(body)) {
    return body.size;
  }
  if (utils$2.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$2.isArrayBufferView(body) || utils$2.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$2.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$2.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers2, body) => {
  const length = utils$2.toFiniteNumber(headers2.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method: method2,
    data: data2,
    signal,
    cancelToken,
    timeout: timeout2,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers: headers2,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout2);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method2 !== "get" && method2 !== "head" && (requestContentLength = await resolveBodyLength(headers2, data2)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$2.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers2.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$2.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method2.toUpperCase(),
      headers: headers2.normalize().toJSON(),
      body: data2,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils$2.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$2.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject2) => {
      settle$1(resolve, reject2, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError$1.from(err, err && err.code, config, request);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$2.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$2.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$2.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError$1(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError$1(
        `There is no suitable adapter to dispatch the request ` + s,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError$1(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel$1(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type2, i) => {
  validators$1[type2] = function validator2(thing) {
    return typeof thing === type2 || "a" + (i < 1 ? "n " : " ") + type2;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION$1 + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError$1(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError$1.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError$1("option " + opt + " must be " + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError$1("Unknown option " + opt, AxiosError$1.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
let Axios$1 = class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager(),
      response: new InterceptorManager()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig$1(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers: headers2 } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$2.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) ;
    else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator.assertOptions(config, {
      baseUrl: validators.spelling("baseURL"),
      withXsrfToken: validators.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers2 && utils$2.merge(
      headers2.common,
      headers2[config.method]
    );
    headers2 && utils$2.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method2) => {
        delete headers2[method2];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers2);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i < len) {
        promise2 = promise2.then(chain[i++], chain[i++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig$1(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils$2.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method2) {
  Axios$1.prototype[method2] = function(url, config) {
    return this.request(mergeConfig$1(config || {}, {
      method: method2,
      url,
      data: (config || {}).data
    }));
  };
});
utils$2.forEach(["post", "put", "patch"], function forEachMethodWithData(method2) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig$1(config || {}, {
        method: method2,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios$1.prototype[method2] = generateHTTPMethod();
  Axios$1.prototype[method2 + "Form"] = generateHTTPMethod(true);
});
let CancelToken$1 = class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel2) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel2);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject2() {
        token.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel2(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError$1(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel2;
    const token = new CancelToken(function executor(c) {
      cancel2 = c;
    });
    return {
      token,
      cancel: cancel2
    };
  }
};
function spread$1(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError$1(payload) {
  return utils$2.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode$1 = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
  HttpStatusCode$1[value] = key;
});
function createInstance(defaultConfig) {
  const context2 = new Axios$1(defaultConfig);
  const instance = bind$1(Axios$1.prototype.request, context2);
  utils$2.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
  utils$2.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$2.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {
  Axios: Axios2,
  AxiosError,
  CanceledError,
  isCancel,
  CancelToken: CancelToken2,
  VERSION,
  all: all2,
  Cancel,
  isAxiosError,
  spread,
  toFormData,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode,
  formToJSON,
  getAdapter,
  mergeConfig
} = axios;
var underDash;
var hasRequiredUnderDash;
function requireUnderDash() {
  if (hasRequiredUnderDash) return underDash;
  hasRequiredUnderDash = 1;
  const { toString: toString3 } = Object.prototype;
  const escapeHtmlRegex = /["&<>]/;
  const _2 = {
    each: function each2(obj, cb) {
      if (obj) {
        if (Array.isArray(obj)) {
          obj.forEach(cb);
        } else {
          Object.keys(obj).forEach((key) => {
            cb(obj[key], key);
          });
        }
      }
    },
    some: function some2(obj, cb) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.some(cb);
        }
        return Object.keys(obj).some((key) => cb(obj[key], key));
      }
      return false;
    },
    every: function every2(obj, cb) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.every(cb);
        }
        return Object.keys(obj).every((key) => cb(obj[key], key));
      }
      return true;
    },
    map: function map2(obj, cb) {
      if (obj) {
        if (Array.isArray(obj)) {
          return obj.map(cb);
        }
        return Object.keys(obj).map((key) => cb(obj[key], key));
      }
      return [];
    },
    keyBy(a, p) {
      return a.reduce((o, v) => {
        o[v[p]] = v;
        return o;
      }, {});
    },
    isEqual: function isEqual(a, b) {
      const aType = typeof a;
      const bType = typeof b;
      const aArray = Array.isArray(a);
      const bArray = Array.isArray(b);
      let keys;
      if (aType !== bType) {
        return false;
      }
      switch (typeof a) {
        case "object":
          if (aArray || bArray) {
            if (aArray && bArray) {
              return a.length === b.length && a.every((aValue, index2) => {
                const bValue = b[index2];
                return _2.isEqual(aValue, bValue);
              });
            }
            return false;
          }
          if (a === null || b === null) {
            return a === b;
          }
          keys = Object.keys(a);
          if (Object.keys(b).length !== keys.length) {
            return false;
          }
          for (const key of keys) {
            if (!b.hasOwnProperty(key)) {
              return false;
            }
          }
          return _2.every(a, (aValue, key) => {
            const bValue = b[key];
            return _2.isEqual(aValue, bValue);
          });
        default:
          return a === b;
      }
    },
    escapeHtml(html) {
      const regexResult = escapeHtmlRegex.exec(html);
      if (!regexResult) return html;
      let result = "";
      let escape = "";
      let lastIndex = 0;
      let i = regexResult.index;
      for (; i < html.length; i++) {
        switch (html.charAt(i)) {
          case '"':
            escape = "&quot;";
            break;
          case "&":
            escape = "&amp;";
            break;
          case "'":
            escape = "&apos;";
            break;
          case "<":
            escape = "&lt;";
            break;
          case ">":
            escape = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== i) result += html.substring(lastIndex, i);
        lastIndex = i + 1;
        result += escape;
      }
      if (lastIndex !== i) return result + html.substring(lastIndex, i);
      return result;
    },
    strcmp(a, b) {
      if (a < b) return -1;
      if (a > b) return 1;
      return 0;
    },
    isUndefined(val) {
      return toString3.call(val) === "[object Undefined]";
    },
    isObject(val) {
      return toString3.call(val) === "[object Object]";
    },
    deepMerge() {
      const target = arguments[0] || {};
      const { length } = arguments;
      let src2, clone, copyIsArray;
      function assignValue(val, key) {
        src2 = target[key];
        copyIsArray = Array.isArray(val);
        if (_2.isObject(val) || copyIsArray) {
          if (copyIsArray) {
            copyIsArray = false;
            clone = src2 && Array.isArray(src2) ? src2 : [];
          } else {
            clone = src2 && _2.isObject(src2) ? src2 : {};
          }
          target[key] = _2.deepMerge(clone, val);
        } else if (!_2.isUndefined(val)) {
          target[key] = val;
        }
      }
      for (let i = 0; i < length; i++) {
        _2.each(arguments[i], assignValue);
      }
      return target;
    }
  };
  underDash = _2;
  return underDash;
}
var colCache_1;
var hasRequiredColCache;
function requireColCache() {
  if (hasRequiredColCache) return colCache_1;
  hasRequiredColCache = 1;
  const addressRegex = /^[A-Z]+\d+$/;
  const colCache = {
    _dictionary: [
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ],
    _l2nFill: 0,
    _l2n: {},
    _n2l: [],
    _level(n) {
      if (n <= 26) {
        return 1;
      }
      if (n <= 26 * 26) {
        return 2;
      }
      return 3;
    },
    _fill(level) {
      let c;
      let v;
      let l1;
      let l2;
      let l3;
      let n = 1;
      if (level >= 4) {
        throw new Error("Out of bounds. Excel supports columns from 1 to 16384");
      }
      if (this._l2nFill < 1 && level >= 1) {
        while (n <= 26) {
          c = this._dictionary[n - 1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 1;
      }
      if (this._l2nFill < 2 && level >= 2) {
        n = 27;
        while (n <= 26 + 26 * 26) {
          v = n - (26 + 1);
          l1 = v % 26;
          l2 = Math.floor(v / 26);
          c = this._dictionary[l2] + this._dictionary[l1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 2;
      }
      if (this._l2nFill < 3 && level >= 3) {
        n = 26 + 26 * 26 + 1;
        while (n <= 16384) {
          v = n - (26 * 26 + 26 + 1);
          l1 = v % 26;
          l2 = Math.floor(v / 26) % 26;
          l3 = Math.floor(v / (26 * 26));
          c = this._dictionary[l3] + this._dictionary[l2] + this._dictionary[l1];
          this._n2l[n] = c;
          this._l2n[c] = n;
          n++;
        }
        this._l2nFill = 3;
      }
    },
    l2n(l) {
      if (!this._l2n[l]) {
        this._fill(l.length);
      }
      if (!this._l2n[l]) {
        throw new Error(`Out of bounds. Invalid column letter: ${l}`);
      }
      return this._l2n[l];
    },
    n2l(n) {
      if (n < 1 || n > 16384) {
        throw new Error(`${n} is out of bounds. Excel supports columns from 1 to 16384`);
      }
      if (!this._n2l[n]) {
        this._fill(this._level(n));
      }
      return this._n2l[n];
    },
    // =========================================================================
    // Address processing
    _hash: {},
    // check if value looks like an address
    validateAddress(value) {
      if (!addressRegex.test(value)) {
        throw new Error(`Invalid Address: ${value}`);
      }
      return true;
    },
    // convert address string into structure
    decodeAddress(value) {
      const addr = value.length < 5 && this._hash[value];
      if (addr) {
        return addr;
      }
      let hasCol = false;
      let col = "";
      let colNumber = 0;
      let hasRow = false;
      let row2 = "";
      let rowNumber = 0;
      for (let i = 0, char; i < value.length; i++) {
        char = value.charCodeAt(i);
        if (!hasRow && char >= 65 && char <= 90) {
          hasCol = true;
          col += value[i];
          colNumber = colNumber * 26 + char - 64;
        } else if (char >= 48 && char <= 57) {
          hasRow = true;
          row2 += value[i];
          rowNumber = rowNumber * 10 + char - 48;
        } else if (hasRow && hasCol && char !== 36) {
          break;
        }
      }
      if (!hasCol) {
        colNumber = void 0;
      } else if (colNumber > 16384) {
        throw new Error(`Out of bounds. Invalid column letter: ${col}`);
      }
      if (!hasRow) {
        rowNumber = void 0;
      }
      value = col + row2;
      const address = {
        address: value,
        col: colNumber,
        row: rowNumber,
        $col$row: `$${col}$${row2}`
      };
      if (colNumber <= 100 && rowNumber <= 100) {
        this._hash[value] = address;
        this._hash[address.$col$row] = address;
      }
      return address;
    },
    // convert r,c into structure (if only 1 arg, assume r is address string)
    getAddress(r, c) {
      if (c) {
        const address = this.n2l(c) + r;
        return this.decodeAddress(address);
      }
      return this.decodeAddress(r);
    },
    // convert [address], [tl:br] into address structures
    decode(value) {
      const parts = value.split(":");
      if (parts.length === 2) {
        const tl = this.decodeAddress(parts[0]);
        const br = this.decodeAddress(parts[1]);
        const result = {
          top: Math.min(tl.row, br.row),
          left: Math.min(tl.col, br.col),
          bottom: Math.max(tl.row, br.row),
          right: Math.max(tl.col, br.col)
        };
        result.tl = this.n2l(result.left) + result.top;
        result.br = this.n2l(result.right) + result.bottom;
        result.dimensions = `${result.tl}:${result.br}`;
        return result;
      }
      return this.decodeAddress(value);
    },
    // convert [sheetName!][$]col[$]row[[$]col[$]row] into address or range structures
    decodeEx(value) {
      const groups = value.match(/(?:(?:(?:'((?:[^']|'')*)')|([^'^ !]*))!)?(.*)/);
      const sheetName = groups[1] || groups[2];
      const reference = groups[3];
      const parts = reference.split(":");
      if (parts.length > 1) {
        let tl = this.decodeAddress(parts[0]);
        let br = this.decodeAddress(parts[1]);
        const top = Math.min(tl.row, br.row);
        const left = Math.min(tl.col, br.col);
        const bottom = Math.max(tl.row, br.row);
        const right = Math.max(tl.col, br.col);
        tl = this.n2l(left) + top;
        br = this.n2l(right) + bottom;
        return {
          top,
          left,
          bottom,
          right,
          sheetName,
          tl: { address: tl, col: left, row: top, $col$row: `$${this.n2l(left)}$${top}`, sheetName },
          br: {
            address: br,
            col: right,
            row: bottom,
            $col$row: `$${this.n2l(right)}$${bottom}`,
            sheetName
          },
          dimensions: `${tl}:${br}`
        };
      }
      if (reference.startsWith("#")) {
        return sheetName ? { sheetName, error: reference } : { error: reference };
      }
      const address = this.decodeAddress(reference);
      return sheetName ? { sheetName, ...address } : address;
    },
    // convert row,col into address string
    encodeAddress(row2, col) {
      return colCache.n2l(col) + row2;
    },
    // convert row,col into string address or t,l,b,r into range
    encode() {
      switch (arguments.length) {
        case 2:
          return colCache.encodeAddress(arguments[0], arguments[1]);
        case 4:
          return `${colCache.encodeAddress(arguments[0], arguments[1])}:${colCache.encodeAddress(
            arguments[2],
            arguments[3]
          )}`;
        default:
          throw new Error("Can only encode with 2 or 4 arguments");
      }
    },
    // return true if address is contained within range
    inRange(range2, address) {
      const [left, top, , right, bottom] = range2;
      const [col, row2] = address;
      return col >= left && col <= right && row2 >= top && row2 <= bottom;
    }
  };
  colCache_1 = colCache;
  return colCache_1;
}
var range$1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range$1;
  hasRequiredRange = 1;
  const colCache = requireColCache();
  class Range {
    constructor() {
      this.decode(arguments);
    }
    setTLBR(t, l, b, r, s) {
      if (arguments.length < 4) {
        const tl = colCache.decodeAddress(t);
        const br = colCache.decodeAddress(l);
        this.model = {
          top: Math.min(tl.row, br.row),
          left: Math.min(tl.col, br.col),
          bottom: Math.max(tl.row, br.row),
          right: Math.max(tl.col, br.col),
          sheetName: b
        };
        this.setTLBR(tl.row, tl.col, br.row, br.col, s);
      } else {
        this.model = {
          top: Math.min(t, b),
          left: Math.min(l, r),
          bottom: Math.max(t, b),
          right: Math.max(l, r),
          sheetName: s
        };
      }
    }
    decode(argv) {
      switch (argv.length) {
        case 5:
          this.setTLBR(argv[0], argv[1], argv[2], argv[3], argv[4]);
          break;
        case 4:
          this.setTLBR(argv[0], argv[1], argv[2], argv[3]);
          break;
        case 3:
          this.setTLBR(argv[0], argv[1], argv[2]);
          break;
        case 2:
          this.setTLBR(argv[0], argv[1]);
          break;
        case 1: {
          const value = argv[0];
          if (value instanceof Range) {
            this.model = {
              top: value.model.top,
              left: value.model.left,
              bottom: value.model.bottom,
              right: value.model.right,
              sheetName: value.sheetName
            };
          } else if (value instanceof Array) {
            this.decode(value);
          } else if (value.top && value.left && value.bottom && value.right) {
            this.model = {
              top: value.top,
              left: value.left,
              bottom: value.bottom,
              right: value.right,
              sheetName: value.sheetName
            };
          } else {
            const tlbr = colCache.decodeEx(value);
            if (tlbr.top) {
              this.model = {
                top: tlbr.top,
                left: tlbr.left,
                bottom: tlbr.bottom,
                right: tlbr.right,
                sheetName: tlbr.sheetName
              };
            } else {
              this.model = {
                top: tlbr.row,
                left: tlbr.col,
                bottom: tlbr.row,
                right: tlbr.col,
                sheetName: tlbr.sheetName
              };
            }
          }
          break;
        }
        case 0:
          this.model = {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
          };
          break;
        default:
          throw new Error(`Invalid number of arguments to _getDimensions() - ${argv.length}`);
      }
    }
    get top() {
      return this.model.top || 1;
    }
    set top(value) {
      this.model.top = value;
    }
    get left() {
      return this.model.left || 1;
    }
    set left(value) {
      this.model.left = value;
    }
    get bottom() {
      return this.model.bottom || 1;
    }
    set bottom(value) {
      this.model.bottom = value;
    }
    get right() {
      return this.model.right || 1;
    }
    set right(value) {
      this.model.right = value;
    }
    get sheetName() {
      return this.model.sheetName;
    }
    set sheetName(value) {
      this.model.sheetName = value;
    }
    get _serialisedSheetName() {
      const { sheetName } = this.model;
      if (sheetName) {
        if (/^[a-zA-Z0-9]*$/.test(sheetName)) {
          return `${sheetName}!`;
        }
        return `'${sheetName}'!`;
      }
      return "";
    }
    expand(top, left, bottom, right) {
      if (!this.model.top || top < this.top) this.top = top;
      if (!this.model.left || left < this.left) this.left = left;
      if (!this.model.bottom || bottom > this.bottom) this.bottom = bottom;
      if (!this.model.right || right > this.right) this.right = right;
    }
    expandRow(row2) {
      if (row2) {
        const { dimensions, number } = row2;
        if (dimensions) {
          this.expand(number, dimensions.min, number, dimensions.max);
        }
      }
    }
    expandToAddress(addressStr) {
      const address = colCache.decodeEx(addressStr);
      this.expand(address.row, address.col, address.row, address.col);
    }
    get tl() {
      return colCache.n2l(this.left) + this.top;
    }
    get $t$l() {
      return `$${colCache.n2l(this.left)}$${this.top}`;
    }
    get br() {
      return colCache.n2l(this.right) + this.bottom;
    }
    get $b$r() {
      return `$${colCache.n2l(this.right)}$${this.bottom}`;
    }
    get range() {
      return `${this._serialisedSheetName + this.tl}:${this.br}`;
    }
    get $range() {
      return `${this._serialisedSheetName + this.$t$l}:${this.$b$r}`;
    }
    get shortRange() {
      return this.count > 1 ? this.range : this._serialisedSheetName + this.tl;
    }
    get $shortRange() {
      return this.count > 1 ? this.$range : this._serialisedSheetName + this.$t$l;
    }
    get count() {
      return (1 + this.bottom - this.top) * (1 + this.right - this.left);
    }
    toString() {
      return this.range;
    }
    intersects(other) {
      if (other.sheetName && this.sheetName && other.sheetName !== this.sheetName) return false;
      if (other.bottom < this.top) return false;
      if (other.top > this.bottom) return false;
      if (other.right < this.left) return false;
      if (other.left > this.right) return false;
      return true;
    }
    contains(addressStr) {
      const address = colCache.decodeEx(addressStr);
      return this.containsEx(address);
    }
    containsEx(address) {
      if (address.sheetName && this.sheetName && address.sheetName !== this.sheetName) return false;
      return address.row >= this.top && address.row <= this.bottom && address.col >= this.left && address.col <= this.right;
    }
    forEachAddress(cb) {
      for (let col = this.left; col <= this.right; col++) {
        for (let row2 = this.top; row2 <= this.bottom; row2++) {
          cb(colCache.encodeAddress(row2, col), row2, col);
        }
      }
    }
  }
  range$1 = Range;
  return range$1;
}
var enums;
var hasRequiredEnums;
function requireEnums() {
  if (hasRequiredEnums) return enums;
  hasRequiredEnums = 1;
  enums = {
    ValueType: {
      Null: 0,
      Merge: 1,
      Number: 2,
      String: 3,
      Date: 4,
      Hyperlink: 5,
      Formula: 6,
      SharedString: 7,
      RichText: 8,
      Boolean: 9,
      Error: 10
    },
    FormulaType: {
      None: 0,
      Master: 1,
      Shared: 2
    },
    RelationshipType: {
      None: 0,
      OfficeDocument: 1,
      Worksheet: 2,
      CalcChain: 3,
      SharedStrings: 4,
      Styles: 5,
      Theme: 6,
      Hyperlink: 7
    },
    DocumentType: {
      Xlsx: 1
    },
    ReadingOrder: {
      LeftToRight: 1,
      RightToLeft: 2
    },
    ErrorValue: {
      NotApplicable: "#N/A",
      Ref: "#REF!",
      Name: "#NAME?",
      DivZero: "#DIV/0!",
      Null: "#NULL!",
      Value: "#VALUE!",
      Num: "#NUM!"
    }
  };
  return enums;
}
var sharedFormula;
var hasRequiredSharedFormula;
function requireSharedFormula() {
  if (hasRequiredSharedFormula) return sharedFormula;
  hasRequiredSharedFormula = 1;
  const colCache = requireColCache();
  const replacementCandidateRx = /(([a-z_\-0-9]*)!)?([a-z0-9_$]{2,})([(])?/gi;
  const CRrx = /^([$])?([a-z]+)([$])?([1-9][0-9]*)$/i;
  function slideFormula(formula, fromCell, toCell) {
    const offset = colCache.decode(fromCell);
    const to = colCache.decode(toCell);
    return formula.replace(
      replacementCandidateRx,
      (refMatch, sheet, sheetMaybe, addrPart, trailingParen) => {
        if (trailingParen) {
          return refMatch;
        }
        const match = CRrx.exec(addrPart);
        if (match) {
          const colDollar = match[1];
          const colStr = match[2].toUpperCase();
          const rowDollar = match[3];
          const rowStr = match[4];
          if (colStr.length > 3 || colStr.length === 3 && colStr > "XFD") {
            return refMatch;
          }
          let col = colCache.l2n(colStr);
          let row2 = parseInt(rowStr, 10);
          if (!colDollar) {
            col += to.col - offset.col;
          }
          if (!rowDollar) {
            row2 += to.row - offset.row;
          }
          const res = (sheet || "") + (colDollar || "") + colCache.n2l(col) + (rowDollar || "") + row2;
          return res;
        }
        return refMatch;
      }
    );
  }
  sharedFormula = {
    slideFormula
  };
  return sharedFormula;
}
var note;
var hasRequiredNote;
function requireNote() {
  if (hasRequiredNote) return note;
  hasRequiredNote = 1;
  const _2 = requireUnderDash();
  class Note {
    constructor(note2) {
      this.note = note2;
    }
    get model() {
      let value = null;
      switch (typeof this.note) {
        case "string":
          value = {
            type: "note",
            note: {
              texts: [
                {
                  text: this.note
                }
              ]
            }
          };
          break;
        default:
          value = {
            type: "note",
            note: this.note
          };
          break;
      }
      return _2.deepMerge({}, Note.DEFAULT_CONFIGS, value);
    }
    set model(value) {
      const { note: note2 } = value;
      const { texts } = note2;
      if (texts.length === 1 && Object.keys(texts[0]).length === 1) {
        this.note = texts[0].text;
      } else {
        this.note = note2;
      }
    }
    static fromModel(model) {
      const note2 = new Note();
      note2.model = model;
      return note2;
    }
  }
  Note.DEFAULT_CONFIGS = {
    note: {
      margins: {
        insetmode: "auto",
        inset: [0.13, 0.13, 0.25, 0.25]
      },
      protection: {
        locked: "True",
        lockText: "True"
      },
      editAs: "absolute"
    }
  };
  note = Note;
  return note;
}
var cell;
var hasRequiredCell;
function requireCell() {
  if (hasRequiredCell) return cell;
  hasRequiredCell = 1;
  const colCache = requireColCache();
  const _2 = requireUnderDash();
  const Enums = requireEnums();
  const { slideFormula } = requireSharedFormula();
  const Note = requireNote();
  class Cell {
    constructor(row2, column2, address) {
      if (!row2 || !column2) {
        throw new Error("A Cell needs a Row");
      }
      this._row = row2;
      this._column = column2;
      colCache.validateAddress(address);
      this._address = address;
      this._value = Value.create(Cell.Types.Null, this);
      this.style = this._mergeStyle(row2.style, column2.style, {});
      this._mergeCount = 0;
    }
    get worksheet() {
      return this._row.worksheet;
    }
    get workbook() {
      return this._row.worksheet.workbook;
    }
    // help GC by removing cyclic (and other) references
    destroy() {
      delete this.style;
      delete this._value;
      delete this._row;
      delete this._column;
      delete this._address;
    }
    // =========================================================================
    // Styles stuff
    get numFmt() {
      return this.style.numFmt;
    }
    set numFmt(value) {
      this.style.numFmt = value;
    }
    get font() {
      return this.style.font;
    }
    set font(value) {
      this.style.font = value;
    }
    get alignment() {
      return this.style.alignment;
    }
    set alignment(value) {
      this.style.alignment = value;
    }
    get border() {
      return this.style.border;
    }
    set border(value) {
      this.style.border = value;
    }
    get fill() {
      return this.style.fill;
    }
    set fill(value) {
      this.style.fill = value;
    }
    get protection() {
      return this.style.protection;
    }
    set protection(value) {
      this.style.protection = value;
    }
    _mergeStyle(rowStyle, colStyle, style) {
      const numFmt = rowStyle && rowStyle.numFmt || colStyle && colStyle.numFmt;
      if (numFmt) style.numFmt = numFmt;
      const font = rowStyle && rowStyle.font || colStyle && colStyle.font;
      if (font) style.font = font;
      const alignment = rowStyle && rowStyle.alignment || colStyle && colStyle.alignment;
      if (alignment) style.alignment = alignment;
      const border = rowStyle && rowStyle.border || colStyle && colStyle.border;
      if (border) style.border = border;
      const fill = rowStyle && rowStyle.fill || colStyle && colStyle.fill;
      if (fill) style.fill = fill;
      const protection = rowStyle && rowStyle.protection || colStyle && colStyle.protection;
      if (protection) style.protection = protection;
      return style;
    }
    // =========================================================================
    // return the address for this cell
    get address() {
      return this._address;
    }
    get row() {
      return this._row.number;
    }
    get col() {
      return this._column.number;
    }
    get $col$row() {
      return `$${this._column.letter}$${this.row}`;
    }
    // =========================================================================
    // Value stuff
    get type() {
      return this._value.type;
    }
    get effectiveType() {
      return this._value.effectiveType;
    }
    toCsvString() {
      return this._value.toCsvString();
    }
    // =========================================================================
    // Merge stuff
    addMergeRef() {
      this._mergeCount++;
    }
    releaseMergeRef() {
      this._mergeCount--;
    }
    get isMerged() {
      return this._mergeCount > 0 || this.type === Cell.Types.Merge;
    }
    merge(master, ignoreStyle) {
      this._value.release();
      this._value = Value.create(Cell.Types.Merge, this, master);
      if (!ignoreStyle) {
        this.style = master.style;
      }
    }
    unmerge() {
      if (this.type === Cell.Types.Merge) {
        this._value.release();
        this._value = Value.create(Cell.Types.Null, this);
        this.style = this._mergeStyle(this._row.style, this._column.style, {});
      }
    }
    isMergedTo(master) {
      if (this._value.type !== Cell.Types.Merge) return false;
      return this._value.isMergedTo(master);
    }
    get master() {
      if (this.type === Cell.Types.Merge) {
        return this._value.master;
      }
      return this;
    }
    get isHyperlink() {
      return this._value.type === Cell.Types.Hyperlink;
    }
    get hyperlink() {
      return this._value.hyperlink;
    }
    // return the value
    get value() {
      return this._value.value;
    }
    // set the value - can be number, string or raw
    set value(v) {
      if (this.type === Cell.Types.Merge) {
        this._value.master.value = v;
        return;
      }
      this._value.release();
      this._value = Value.create(Value.getType(v), this, v);
    }
    get note() {
      return this._comment && this._comment.note;
    }
    set note(note2) {
      this._comment = new Note(note2);
    }
    get text() {
      return this._value.toString();
    }
    get html() {
      return _2.escapeHtml(this.text);
    }
    toString() {
      return this.text;
    }
    _upgradeToHyperlink(hyperlink) {
      if (this.type === Cell.Types.String) {
        this._value = Value.create(Cell.Types.Hyperlink, this, {
          text: this._value.value,
          hyperlink
        });
      }
    }
    // =========================================================================
    // Formula stuff
    get formula() {
      return this._value.formula;
    }
    get result() {
      return this._value.result;
    }
    get formulaType() {
      return this._value.formulaType;
    }
    // =========================================================================
    // Name stuff
    get fullAddress() {
      const { worksheet: worksheet2 } = this._row;
      return {
        sheetName: worksheet2.name,
        address: this.address,
        row: this.row,
        col: this.col
      };
    }
    get name() {
      return this.names[0];
    }
    set name(value) {
      this.names = [value];
    }
    get names() {
      return this.workbook.definedNames.getNamesEx(this.fullAddress);
    }
    set names(value) {
      const { definedNames: definedNames2 } = this.workbook;
      definedNames2.removeAllNames(this.fullAddress);
      value.forEach((name) => {
        definedNames2.addEx(this.fullAddress, name);
      });
    }
    addName(name) {
      this.workbook.definedNames.addEx(this.fullAddress, name);
    }
    removeName(name) {
      this.workbook.definedNames.removeEx(this.fullAddress, name);
    }
    removeAllNames() {
      this.workbook.definedNames.removeAllNames(this.fullAddress);
    }
    // =========================================================================
    // Data Validation stuff
    get _dataValidations() {
      return this.worksheet.dataValidations;
    }
    get dataValidation() {
      return this._dataValidations.find(this.address);
    }
    set dataValidation(value) {
      this._dataValidations.add(this.address, value);
    }
    // =========================================================================
    // Model stuff
    get model() {
      const { model } = this._value;
      model.style = this.style;
      if (this._comment) {
        model.comment = this._comment.model;
      }
      return model;
    }
    set model(value) {
      this._value.release();
      this._value = Value.create(value.type, this);
      this._value.model = value;
      if (value.comment) {
        switch (value.comment.type) {
          case "note":
            this._comment = Note.fromModel(value.comment);
            break;
        }
      }
      if (value.style) {
        this.style = value.style;
      } else {
        this.style = {};
      }
    }
  }
  Cell.Types = Enums.ValueType;
  class NullValue {
    constructor(cell2) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Null
      };
    }
    get value() {
      return null;
    }
    set value(value) {
    }
    get type() {
      return Cell.Types.Null;
    }
    get effectiveType() {
      return Cell.Types.Null;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return "";
    }
    release() {
    }
    toString() {
      return "";
    }
  }
  class NumberValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Number,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.Number;
    }
    get effectiveType() {
      return Cell.Types.Number;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.value.toString();
    }
    release() {
    }
    toString() {
      return this.model.value.toString();
    }
  }
  class StringValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.String,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.String;
    }
    get effectiveType() {
      return Cell.Types.String;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return `"${this.model.value.replace(/"/g, '""')}"`;
    }
    release() {
    }
    toString() {
      return this.model.value;
    }
  }
  class RichTextValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.String,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    toString() {
      return this.model.value.richText.map((t) => t.text).join("");
    }
    get type() {
      return Cell.Types.RichText;
    }
    get effectiveType() {
      return Cell.Types.RichText;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return `"${this.text.replace(/"/g, '""')}"`;
    }
    release() {
    }
  }
  class DateValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Date,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.Date;
    }
    get effectiveType() {
      return Cell.Types.Date;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.value.toISOString();
    }
    release() {
    }
    toString() {
      return this.model.value.toString();
    }
  }
  class HyperlinkValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Hyperlink,
        text: value ? value.text : void 0,
        hyperlink: value ? value.hyperlink : void 0
      };
      if (value && value.tooltip) {
        this.model.tooltip = value.tooltip;
      }
    }
    get value() {
      const v = {
        text: this.model.text,
        hyperlink: this.model.hyperlink
      };
      if (this.model.tooltip) {
        v.tooltip = this.model.tooltip;
      }
      return v;
    }
    set value(value) {
      this.model = {
        text: value.text,
        hyperlink: value.hyperlink
      };
      if (value.tooltip) {
        this.model.tooltip = value.tooltip;
      }
    }
    get text() {
      return this.model.text;
    }
    set text(value) {
      this.model.text = value;
    }
    /*
    	  get tooltip() {
    	    return this.model.tooltip;
    	  }
    
    	  set tooltip(value) {
    	    this.model.tooltip = value;
    	  } */
    get hyperlink() {
      return this.model.hyperlink;
    }
    set hyperlink(value) {
      this.model.hyperlink = value;
    }
    get type() {
      return Cell.Types.Hyperlink;
    }
    get effectiveType() {
      return Cell.Types.Hyperlink;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.hyperlink;
    }
    release() {
    }
    toString() {
      return this.model.text;
    }
  }
  class MergeValue {
    constructor(cell2, master) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Merge,
        master: master ? master.address : void 0
      };
      this._master = master;
      if (master) {
        master.addMergeRef();
      }
    }
    get value() {
      return this._master.value;
    }
    set value(value) {
      if (value instanceof Cell) {
        if (this._master) {
          this._master.releaseMergeRef();
        }
        value.addMergeRef();
        this._master = value;
      } else {
        this._master.value = value;
      }
    }
    isMergedTo(master) {
      return master === this._master;
    }
    get master() {
      return this._master;
    }
    get type() {
      return Cell.Types.Merge;
    }
    get effectiveType() {
      return this._master.effectiveType;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return "";
    }
    release() {
      this._master.releaseMergeRef();
    }
    toString() {
      return this.value.toString();
    }
  }
  class FormulaValue {
    constructor(cell2, value) {
      this.cell = cell2;
      this.model = {
        address: cell2.address,
        type: Cell.Types.Formula,
        shareType: value ? value.shareType : void 0,
        ref: value ? value.ref : void 0,
        formula: value ? value.formula : void 0,
        sharedFormula: value ? value.sharedFormula : void 0,
        result: value ? value.result : void 0
      };
    }
    _copyModel(model) {
      const copy = {};
      const cp = (name) => {
        const value = model[name];
        if (value) {
          copy[name] = value;
        }
      };
      cp("formula");
      cp("result");
      cp("ref");
      cp("shareType");
      cp("sharedFormula");
      return copy;
    }
    get value() {
      return this._copyModel(this.model);
    }
    set value(value) {
      this.model = this._copyModel(value);
    }
    validate(value) {
      switch (Value.getType(value)) {
        case Cell.Types.Null:
        case Cell.Types.String:
        case Cell.Types.Number:
        case Cell.Types.Date:
          break;
        case Cell.Types.Hyperlink:
        case Cell.Types.Formula:
        default:
          throw new Error("Cannot process that type of result value");
      }
    }
    get dependencies() {
      const ranges = this.formula.match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g);
      const cells = this.formula.replace(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}:[A-Z]{1,3}\d{1,4}/g, "").match(/([a-zA-Z0-9]+!)?[A-Z]{1,3}\d{1,4}/g);
      return {
        ranges,
        cells
      };
    }
    get formula() {
      return this.model.formula || this._getTranslatedFormula();
    }
    set formula(value) {
      this.model.formula = value;
    }
    get formulaType() {
      if (this.model.formula) {
        return Enums.FormulaType.Master;
      }
      if (this.model.sharedFormula) {
        return Enums.FormulaType.Shared;
      }
      return Enums.FormulaType.None;
    }
    get result() {
      return this.model.result;
    }
    set result(value) {
      this.model.result = value;
    }
    get type() {
      return Cell.Types.Formula;
    }
    get effectiveType() {
      const v = this.model.result;
      if (v === null || v === void 0) {
        return Enums.ValueType.Null;
      }
      if (v instanceof String || typeof v === "string") {
        return Enums.ValueType.String;
      }
      if (typeof v === "number") {
        return Enums.ValueType.Number;
      }
      if (v instanceof Date) {
        return Enums.ValueType.Date;
      }
      if (v.text && v.hyperlink) {
        return Enums.ValueType.Hyperlink;
      }
      if (v.formula) {
        return Enums.ValueType.Formula;
      }
      return Enums.ValueType.Null;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    _getTranslatedFormula() {
      if (!this._translatedFormula && this.model.sharedFormula) {
        const { worksheet: worksheet2 } = this.cell;
        const master = worksheet2.findCell(this.model.sharedFormula);
        this._translatedFormula = master && slideFormula(master.formula, master.address, this.model.address);
      }
      return this._translatedFormula;
    }
    toCsvString() {
      return `${this.model.result || ""}`;
    }
    release() {
    }
    toString() {
      return this.model.result ? this.model.result.toString() : "";
    }
  }
  class SharedStringValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.SharedString,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.SharedString;
    }
    get effectiveType() {
      return Cell.Types.SharedString;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.value.toString();
    }
    release() {
    }
    toString() {
      return this.model.value.toString();
    }
  }
  class BooleanValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Boolean,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.Boolean;
    }
    get effectiveType() {
      return Cell.Types.Boolean;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.value ? 1 : 0;
    }
    release() {
    }
    toString() {
      return this.model.value.toString();
    }
  }
  class ErrorValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.Error,
        value
      };
    }
    get value() {
      return this.model.value;
    }
    set value(value) {
      this.model.value = value;
    }
    get type() {
      return Cell.Types.Error;
    }
    get effectiveType() {
      return Cell.Types.Error;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.toString();
    }
    release() {
    }
    toString() {
      return this.model.value.error.toString();
    }
  }
  class JSONValue {
    constructor(cell2, value) {
      this.model = {
        address: cell2.address,
        type: Cell.Types.String,
        value: JSON.stringify(value),
        rawValue: value
      };
    }
    get value() {
      return this.model.rawValue;
    }
    set value(value) {
      this.model.rawValue = value;
      this.model.value = JSON.stringify(value);
    }
    get type() {
      return Cell.Types.String;
    }
    get effectiveType() {
      return Cell.Types.String;
    }
    get address() {
      return this.model.address;
    }
    set address(value) {
      this.model.address = value;
    }
    toCsvString() {
      return this.model.value;
    }
    release() {
    }
    toString() {
      return this.model.value;
    }
  }
  const Value = {
    getType(value) {
      if (value === null || value === void 0) {
        return Cell.Types.Null;
      }
      if (value instanceof String || typeof value === "string") {
        return Cell.Types.String;
      }
      if (typeof value === "number") {
        return Cell.Types.Number;
      }
      if (typeof value === "boolean") {
        return Cell.Types.Boolean;
      }
      if (value instanceof Date) {
        return Cell.Types.Date;
      }
      if (value.text && value.hyperlink) {
        return Cell.Types.Hyperlink;
      }
      if (value.formula || value.sharedFormula) {
        return Cell.Types.Formula;
      }
      if (value.richText) {
        return Cell.Types.RichText;
      }
      if (value.sharedString) {
        return Cell.Types.SharedString;
      }
      if (value.error) {
        return Cell.Types.Error;
      }
      return Cell.Types.JSON;
    },
    // map valueType to constructor
    types: [
      { t: Cell.Types.Null, f: NullValue },
      { t: Cell.Types.Number, f: NumberValue },
      { t: Cell.Types.String, f: StringValue },
      { t: Cell.Types.Date, f: DateValue },
      { t: Cell.Types.Hyperlink, f: HyperlinkValue },
      { t: Cell.Types.Formula, f: FormulaValue },
      { t: Cell.Types.Merge, f: MergeValue },
      { t: Cell.Types.JSON, f: JSONValue },
      { t: Cell.Types.SharedString, f: SharedStringValue },
      { t: Cell.Types.RichText, f: RichTextValue },
      { t: Cell.Types.Boolean, f: BooleanValue },
      { t: Cell.Types.Error, f: ErrorValue }
    ].reduce((p, t) => {
      p[t.t] = t.f;
      return p;
    }, []),
    create(type2, cell2, value) {
      const T = this.types[type2];
      if (!T) {
        throw new Error(`Could not create Value of type ${type2}`);
      }
      return new T(cell2, value);
    }
  };
  cell = Cell;
  return cell;
}
var row;
var hasRequiredRow;
function requireRow() {
  if (hasRequiredRow) return row;
  hasRequiredRow = 1;
  const _2 = requireUnderDash();
  const Enums = requireEnums();
  const colCache = requireColCache();
  const Cell = requireCell();
  class Row {
    constructor(worksheet2, number) {
      this._worksheet = worksheet2;
      this._number = number;
      this._cells = [];
      this.style = {};
      this.outlineLevel = 0;
    }
    // return the row number
    get number() {
      return this._number;
    }
    get worksheet() {
      return this._worksheet;
    }
    // Inform Streaming Writer that this row (and all rows before it) are complete
    // and ready to write. Has no effect on Worksheet document
    commit() {
      this._worksheet._commitRow(this);
    }
    // helps GC by breaking cyclic references
    destroy() {
      delete this._worksheet;
      delete this._cells;
      delete this.style;
    }
    findCell(colNumber) {
      return this._cells[colNumber - 1];
    }
    // given {address, row, col}, find or create new cell
    getCellEx(address) {
      let cell2 = this._cells[address.col - 1];
      if (!cell2) {
        const column2 = this._worksheet.getColumn(address.col);
        cell2 = new Cell(this, column2, address.address);
        this._cells[address.col - 1] = cell2;
      }
      return cell2;
    }
    // get cell by key, letter or column number
    getCell(col) {
      if (typeof col === "string") {
        const column2 = this._worksheet.getColumnKey(col);
        if (column2) {
          col = column2.number;
        } else {
          col = colCache.l2n(col);
        }
      }
      return this._cells[col - 1] || this.getCellEx({
        address: colCache.encodeAddress(this._number, col),
        row: this._number,
        col
      });
    }
    // remove cell(s) and shift all higher cells down by count
    splice(start, count, ...inserts) {
      const nKeep = start + count;
      const nExpand = inserts.length - count;
      const nEnd = this._cells.length;
      let i;
      let cSrc;
      let cDst;
      if (nExpand < 0) {
        for (i = start + inserts.length; i <= nEnd; i++) {
          cDst = this._cells[i - 1];
          cSrc = this._cells[i - nExpand - 1];
          if (cSrc) {
            cDst = this.getCell(i);
            cDst.value = cSrc.value;
            cDst.style = cSrc.style;
            cDst._comment = cSrc._comment;
          } else if (cDst) {
            cDst.value = null;
            cDst.style = {};
            cDst._comment = void 0;
          }
        }
      } else if (nExpand > 0) {
        for (i = nEnd; i >= nKeep; i--) {
          cSrc = this._cells[i - 1];
          if (cSrc) {
            cDst = this.getCell(i + nExpand);
            cDst.value = cSrc.value;
            cDst.style = cSrc.style;
            cDst._comment = cSrc._comment;
          } else {
            this._cells[i + nExpand - 1] = void 0;
          }
        }
      }
      for (i = 0; i < inserts.length; i++) {
        cDst = this.getCell(start + i);
        cDst.value = inserts[i];
        cDst.style = {};
        cDst._comment = void 0;
      }
    }
    // Iterate over all non-null cells in this row
    eachCell(options, iteratee) {
      if (!iteratee) {
        iteratee = options;
        options = null;
      }
      if (options && options.includeEmpty) {
        const n = this._cells.length;
        for (let i = 1; i <= n; i++) {
          iteratee(this.getCell(i), i);
        }
      } else {
        this._cells.forEach((cell2, index2) => {
          if (cell2 && cell2.type !== Enums.ValueType.Null) {
            iteratee(cell2, index2 + 1);
          }
        });
      }
    }
    // ===========================================================================
    // Page Breaks
    addPageBreak(lft, rght) {
      const ws = this._worksheet;
      const left = Math.max(0, lft - 1) || 0;
      const right = Math.max(0, rght - 1) || 16838;
      const pb = {
        id: this._number,
        max: right,
        man: 1
      };
      if (left) pb.min = left;
      ws.rowBreaks.push(pb);
    }
    // return a sparse array of cell values
    get values() {
      const values = [];
      this._cells.forEach((cell2) => {
        if (cell2 && cell2.type !== Enums.ValueType.Null) {
          values[cell2.col] = cell2.value;
        }
      });
      return values;
    }
    // set the values by contiguous or sparse array, or by key'd object literal
    set values(value) {
      this._cells = [];
      if (!value) ;
      else if (value instanceof Array) {
        let offset = 0;
        if (value.hasOwnProperty("0")) {
          offset = 1;
        }
        value.forEach((item, index2) => {
          if (item !== void 0) {
            this.getCellEx({
              address: colCache.encodeAddress(this._number, index2 + offset),
              row: this._number,
              col: index2 + offset
            }).value = item;
          }
        });
      } else {
        this._worksheet.eachColumnKey((column2, key) => {
          if (value[key] !== void 0) {
            this.getCellEx({
              address: colCache.encodeAddress(this._number, column2.number),
              row: this._number,
              col: column2.number
            }).value = value[key];
          }
        });
      }
    }
    // returns true if the row includes at least one cell with a value
    get hasValues() {
      return _2.some(this._cells, (cell2) => cell2 && cell2.type !== Enums.ValueType.Null);
    }
    get cellCount() {
      return this._cells.length;
    }
    get actualCellCount() {
      let count = 0;
      this.eachCell(() => {
        count++;
      });
      return count;
    }
    // get the min and max column number for the non-null cells in this row or null
    get dimensions() {
      let min2 = 0;
      let max2 = 0;
      this._cells.forEach((cell2) => {
        if (cell2 && cell2.type !== Enums.ValueType.Null) {
          if (!min2 || min2 > cell2.col) {
            min2 = cell2.col;
          }
          if (max2 < cell2.col) {
            max2 = cell2.col;
          }
        }
      });
      return min2 > 0 ? {
        min: min2,
        max: max2
      } : null;
    }
    // =========================================================================
    // styles
    _applyStyle(name, value) {
      this.style[name] = value;
      this._cells.forEach((cell2) => {
        if (cell2) {
          cell2[name] = value;
        }
      });
      return value;
    }
    get numFmt() {
      return this.style.numFmt;
    }
    set numFmt(value) {
      this._applyStyle("numFmt", value);
    }
    get font() {
      return this.style.font;
    }
    set font(value) {
      this._applyStyle("font", value);
    }
    get alignment() {
      return this.style.alignment;
    }
    set alignment(value) {
      this._applyStyle("alignment", value);
    }
    get protection() {
      return this.style.protection;
    }
    set protection(value) {
      this._applyStyle("protection", value);
    }
    get border() {
      return this.style.border;
    }
    set border(value) {
      this._applyStyle("border", value);
    }
    get fill() {
      return this.style.fill;
    }
    set fill(value) {
      this._applyStyle("fill", value);
    }
    get hidden() {
      return !!this._hidden;
    }
    set hidden(value) {
      this._hidden = value;
    }
    get outlineLevel() {
      return this._outlineLevel || 0;
    }
    set outlineLevel(value) {
      this._outlineLevel = value;
    }
    get collapsed() {
      return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelRow);
    }
    // =========================================================================
    get model() {
      const cells = [];
      let min2 = 0;
      let max2 = 0;
      this._cells.forEach((cell2) => {
        if (cell2) {
          const cellModel = cell2.model;
          if (cellModel) {
            if (!min2 || min2 > cell2.col) {
              min2 = cell2.col;
            }
            if (max2 < cell2.col) {
              max2 = cell2.col;
            }
            cells.push(cellModel);
          }
        }
      });
      return this.height || cells.length ? {
        cells,
        number: this.number,
        min: min2,
        max: max2,
        height: this.height,
        style: this.style,
        hidden: this.hidden,
        outlineLevel: this.outlineLevel,
        collapsed: this.collapsed
      } : null;
    }
    set model(value) {
      if (value.number !== this._number) {
        throw new Error("Invalid row number in model");
      }
      this._cells = [];
      let previousAddress;
      value.cells.forEach((cellModel) => {
        switch (cellModel.type) {
          case Cell.Types.Merge:
            break;
          default: {
            let address;
            if (cellModel.address) {
              address = colCache.decodeAddress(cellModel.address);
            } else if (previousAddress) {
              const { row: row2 } = previousAddress;
              const col = previousAddress.col + 1;
              address = {
                row: row2,
                col,
                address: colCache.encodeAddress(row2, col),
                $col$row: `$${colCache.n2l(col)}$${row2}`
              };
            }
            previousAddress = address;
            const cell2 = this.getCellEx(address);
            cell2.model = cellModel;
            break;
          }
        }
      });
      if (value.height) {
        this.height = value.height;
      } else {
        delete this.height;
      }
      this.hidden = value.hidden;
      this.outlineLevel = value.outlineLevel || 0;
      this.style = value.style && JSON.parse(JSON.stringify(value.style)) || {};
    }
  }
  row = Row;
  return row;
}
var column$1;
var hasRequiredColumn$1;
function requireColumn$1() {
  if (hasRequiredColumn$1) return column$1;
  hasRequiredColumn$1 = 1;
  const _2 = requireUnderDash();
  const Enums = requireEnums();
  const colCache = requireColCache();
  const DEFAULT_COLUMN_WIDTH = 9;
  class Column {
    constructor(worksheet2, number, defn) {
      this._worksheet = worksheet2;
      this._number = number;
      if (defn !== false) {
        this.defn = defn;
      }
    }
    get number() {
      return this._number;
    }
    get worksheet() {
      return this._worksheet;
    }
    get letter() {
      return colCache.n2l(this._number);
    }
    get isCustomWidth() {
      return this.width !== void 0 && this.width !== DEFAULT_COLUMN_WIDTH;
    }
    get defn() {
      return {
        header: this._header,
        key: this.key,
        width: this.width,
        style: this.style,
        hidden: this.hidden,
        outlineLevel: this.outlineLevel
      };
    }
    set defn(value) {
      if (value) {
        this.key = value.key;
        this.width = value.width !== void 0 ? value.width : DEFAULT_COLUMN_WIDTH;
        this.outlineLevel = value.outlineLevel;
        if (value.style) {
          this.style = value.style;
        } else {
          this.style = {};
        }
        this.header = value.header;
        this._hidden = !!value.hidden;
      } else {
        delete this._header;
        delete this._key;
        delete this.width;
        this.style = {};
        this.outlineLevel = 0;
      }
    }
    get headers() {
      return this._header && this._header instanceof Array ? this._header : [this._header];
    }
    get header() {
      return this._header;
    }
    set header(value) {
      if (value !== void 0) {
        this._header = value;
        this.headers.forEach((text, index2) => {
          this._worksheet.getCell(index2 + 1, this.number).value = text;
        });
      } else {
        this._header = void 0;
      }
    }
    get key() {
      return this._key;
    }
    set key(value) {
      const column2 = this._key && this._worksheet.getColumnKey(this._key);
      if (column2 === this) {
        this._worksheet.deleteColumnKey(this._key);
      }
      this._key = value;
      if (value) {
        this._worksheet.setColumnKey(this._key, this);
      }
    }
    get hidden() {
      return !!this._hidden;
    }
    set hidden(value) {
      this._hidden = value;
    }
    get outlineLevel() {
      return this._outlineLevel || 0;
    }
    set outlineLevel(value) {
      this._outlineLevel = value;
    }
    get collapsed() {
      return !!(this._outlineLevel && this._outlineLevel >= this._worksheet.properties.outlineLevelCol);
    }
    toString() {
      return JSON.stringify({
        key: this.key,
        width: this.width,
        headers: this.headers.length ? this.headers : void 0
      });
    }
    equivalentTo(other) {
      return this.width === other.width && this.hidden === other.hidden && this.outlineLevel === other.outlineLevel && _2.isEqual(this.style, other.style);
    }
    get isDefault() {
      if (this.isCustomWidth) {
        return false;
      }
      if (this.hidden) {
        return false;
      }
      if (this.outlineLevel) {
        return false;
      }
      const s = this.style;
      if (s && (s.font || s.numFmt || s.alignment || s.border || s.fill || s.protection)) {
        return false;
      }
      return true;
    }
    get headerCount() {
      return this.headers.length;
    }
    eachCell(options, iteratee) {
      const colNumber = this.number;
      if (!iteratee) {
        iteratee = options;
        options = null;
      }
      this._worksheet.eachRow(options, (row2, rowNumber) => {
        iteratee(row2.getCell(colNumber), rowNumber);
      });
    }
    get values() {
      const v = [];
      this.eachCell((cell2, rowNumber) => {
        if (cell2 && cell2.type !== Enums.ValueType.Null) {
          v[rowNumber] = cell2.value;
        }
      });
      return v;
    }
    set values(v) {
      if (!v) {
        return;
      }
      const colNumber = this.number;
      let offset = 0;
      if (v.hasOwnProperty("0")) {
        offset = 1;
      }
      v.forEach((value, index2) => {
        this._worksheet.getCell(index2 + offset, colNumber).value = value;
      });
    }
    // =========================================================================
    // styles
    _applyStyle(name, value) {
      this.style[name] = value;
      this.eachCell((cell2) => {
        cell2[name] = value;
      });
      return value;
    }
    get numFmt() {
      return this.style.numFmt;
    }
    set numFmt(value) {
      this._applyStyle("numFmt", value);
    }
    get font() {
      return this.style.font;
    }
    set font(value) {
      this._applyStyle("font", value);
    }
    get alignment() {
      return this.style.alignment;
    }
    set alignment(value) {
      this._applyStyle("alignment", value);
    }
    get protection() {
      return this.style.protection;
    }
    set protection(value) {
      this._applyStyle("protection", value);
    }
    get border() {
      return this.style.border;
    }
    set border(value) {
      this._applyStyle("border", value);
    }
    get fill() {
      return this.style.fill;
    }
    set fill(value) {
      this._applyStyle("fill", value);
    }
    // =============================================================================
    // static functions
    static toModel(columns) {
      const cols = [];
      let col = null;
      if (columns) {
        columns.forEach((column2, index2) => {
          if (column2.isDefault) {
            if (col) {
              col = null;
            }
          } else if (!col || !column2.equivalentTo(col)) {
            col = {
              min: index2 + 1,
              max: index2 + 1,
              width: column2.width !== void 0 ? column2.width : DEFAULT_COLUMN_WIDTH,
              style: column2.style,
              isCustomWidth: column2.isCustomWidth,
              hidden: column2.hidden,
              outlineLevel: column2.outlineLevel,
              collapsed: column2.collapsed
            };
            cols.push(col);
          } else {
            col.max = index2 + 1;
          }
        });
      }
      return cols.length ? cols : void 0;
    }
    static fromModel(worksheet2, cols) {
      cols = cols || [];
      const columns = [];
      let count = 1;
      let index2 = 0;
      cols = cols.sort(function(pre, next) {
        return pre.min - next.min;
      });
      while (index2 < cols.length) {
        const col = cols[index2++];
        while (count < col.min) {
          columns.push(new Column(worksheet2, count++));
        }
        while (count <= col.max) {
          columns.push(new Column(worksheet2, count++, col));
        }
      }
      return columns.length ? columns : null;
    }
  }
  column$1 = Column;
  return column$1;
}
var anchor;
var hasRequiredAnchor;
function requireAnchor() {
  if (hasRequiredAnchor) return anchor;
  hasRequiredAnchor = 1;
  const colCache = requireColCache();
  class Anchor {
    constructor(worksheet2, address, offset = 0) {
      this.worksheet = worksheet2;
      if (!address) {
        this.nativeCol = 0;
        this.nativeColOff = 0;
        this.nativeRow = 0;
        this.nativeRowOff = 0;
      } else if (typeof address === "string") {
        const decoded = colCache.decodeAddress(address);
        this.nativeCol = decoded.col + offset;
        this.nativeColOff = 0;
        this.nativeRow = decoded.row + offset;
        this.nativeRowOff = 0;
      } else if (address.nativeCol !== void 0) {
        this.nativeCol = address.nativeCol || 0;
        this.nativeColOff = address.nativeColOff || 0;
        this.nativeRow = address.nativeRow || 0;
        this.nativeRowOff = address.nativeRowOff || 0;
      } else if (address.col !== void 0) {
        this.col = address.col + offset;
        this.row = address.row + offset;
      } else {
        this.nativeCol = 0;
        this.nativeColOff = 0;
        this.nativeRow = 0;
        this.nativeRowOff = 0;
      }
    }
    static asInstance(model) {
      return model instanceof Anchor || model == null ? model : new Anchor(model);
    }
    get col() {
      return this.nativeCol + Math.min(this.colWidth - 1, this.nativeColOff) / this.colWidth;
    }
    set col(v) {
      this.nativeCol = Math.floor(v);
      this.nativeColOff = Math.floor((v - this.nativeCol) * this.colWidth);
    }
    get row() {
      return this.nativeRow + Math.min(this.rowHeight - 1, this.nativeRowOff) / this.rowHeight;
    }
    set row(v) {
      this.nativeRow = Math.floor(v);
      this.nativeRowOff = Math.floor((v - this.nativeRow) * this.rowHeight);
    }
    get colWidth() {
      return this.worksheet && this.worksheet.getColumn(this.nativeCol + 1) && this.worksheet.getColumn(this.nativeCol + 1).isCustomWidth ? Math.floor(this.worksheet.getColumn(this.nativeCol + 1).width * 1e4) : 64e4;
    }
    get rowHeight() {
      return this.worksheet && this.worksheet.getRow(this.nativeRow + 1) && this.worksheet.getRow(this.nativeRow + 1).height ? Math.floor(this.worksheet.getRow(this.nativeRow + 1).height * 1e4) : 18e4;
    }
    get model() {
      return {
        nativeCol: this.nativeCol,
        nativeColOff: this.nativeColOff,
        nativeRow: this.nativeRow,
        nativeRowOff: this.nativeRowOff
      };
    }
    set model(value) {
      this.nativeCol = value.nativeCol;
      this.nativeColOff = value.nativeColOff;
      this.nativeRow = value.nativeRow;
      this.nativeRowOff = value.nativeRowOff;
    }
  }
  anchor = Anchor;
  return anchor;
}
var image;
var hasRequiredImage;
function requireImage() {
  if (hasRequiredImage) return image;
  hasRequiredImage = 1;
  const colCache = requireColCache();
  const Anchor = requireAnchor();
  class Image2 {
    constructor(worksheet2, model) {
      this.worksheet = worksheet2;
      this.model = model;
    }
    get model() {
      switch (this.type) {
        case "background":
          return {
            type: this.type,
            imageId: this.imageId
          };
        case "image":
          return {
            type: this.type,
            imageId: this.imageId,
            hyperlinks: this.range.hyperlinks,
            range: {
              tl: this.range.tl.model,
              br: this.range.br && this.range.br.model,
              ext: this.range.ext,
              editAs: this.range.editAs
            }
          };
        default:
          throw new Error("Invalid Image Type");
      }
    }
    set model({ type: type2, imageId, range: range2, hyperlinks }) {
      this.type = type2;
      this.imageId = imageId;
      if (type2 === "image") {
        if (typeof range2 === "string") {
          const decoded = colCache.decode(range2);
          this.range = {
            tl: new Anchor(this.worksheet, { col: decoded.left, row: decoded.top }, -1),
            br: new Anchor(this.worksheet, { col: decoded.right, row: decoded.bottom }, 0),
            editAs: "oneCell"
          };
        } else {
          this.range = {
            tl: new Anchor(this.worksheet, range2.tl, 0),
            br: range2.br && new Anchor(this.worksheet, range2.br, 0),
            ext: range2.ext,
            editAs: range2.editAs,
            hyperlinks: hyperlinks || range2.hyperlinks
          };
        }
      }
    }
  }
  image = Image2;
  return image;
}
var table;
var hasRequiredTable;
function requireTable() {
  if (hasRequiredTable) return table;
  hasRequiredTable = 1;
  const colCache = requireColCache();
  class Column {
    // wrapper around column model, allowing access and manipulation
    constructor(table2, column2, index2) {
      this.table = table2;
      this.column = column2;
      this.index = index2;
    }
    _set(name, value) {
      this.table.cacheState();
      this.column[name] = value;
    }
    /* eslint-disable lines-between-class-members */
    get name() {
      return this.column.name;
    }
    set name(value) {
      this._set("name", value);
    }
    get filterButton() {
      return this.column.filterButton;
    }
    set filterButton(value) {
      this.column.filterButton = value;
    }
    get style() {
      return this.column.style;
    }
    set style(value) {
      this.column.style = value;
    }
    get totalsRowLabel() {
      return this.column.totalsRowLabel;
    }
    set totalsRowLabel(value) {
      this._set("totalsRowLabel", value);
    }
    get totalsRowFunction() {
      return this.column.totalsRowFunction;
    }
    set totalsRowFunction(value) {
      this._set("totalsRowFunction", value);
    }
    get totalsRowResult() {
      return this.column.totalsRowResult;
    }
    set totalsRowResult(value) {
      this._set("totalsRowResult", value);
    }
    get totalsRowFormula() {
      return this.column.totalsRowFormula;
    }
    set totalsRowFormula(value) {
      this._set("totalsRowFormula", value);
    }
    /* eslint-enable lines-between-class-members */
  }
  class Table {
    constructor(worksheet2, table2) {
      this.worksheet = worksheet2;
      if (table2) {
        this.table = table2;
        this.validate();
        this.store();
      }
    }
    getFormula(column2) {
      switch (column2.totalsRowFunction) {
        case "none":
          return null;
        case "average":
          return `SUBTOTAL(101,${this.table.name}[${column2.name}])`;
        case "countNums":
          return `SUBTOTAL(102,${this.table.name}[${column2.name}])`;
        case "count":
          return `SUBTOTAL(103,${this.table.name}[${column2.name}])`;
        case "max":
          return `SUBTOTAL(104,${this.table.name}[${column2.name}])`;
        case "min":
          return `SUBTOTAL(105,${this.table.name}[${column2.name}])`;
        case "stdDev":
          return `SUBTOTAL(106,${this.table.name}[${column2.name}])`;
        case "var":
          return `SUBTOTAL(107,${this.table.name}[${column2.name}])`;
        case "sum":
          return `SUBTOTAL(109,${this.table.name}[${column2.name}])`;
        case "custom":
          return column2.totalsRowFormula;
        default:
          throw new Error(`Invalid Totals Row Function: ${column2.totalsRowFunction}`);
      }
    }
    get width() {
      return this.table.columns.length;
    }
    get height() {
      return this.table.rows.length;
    }
    get filterHeight() {
      return this.height + (this.table.headerRow ? 1 : 0);
    }
    get tableHeight() {
      return this.filterHeight + (this.table.totalsRow ? 1 : 0);
    }
    validate() {
      const { table: table2 } = this;
      const assign = (o, name, dflt) => {
        if (o[name] === void 0) {
          o[name] = dflt;
        }
      };
      assign(table2, "headerRow", true);
      assign(table2, "totalsRow", false);
      assign(table2, "style", {});
      assign(table2.style, "theme", "TableStyleMedium2");
      assign(table2.style, "showFirstColumn", false);
      assign(table2.style, "showLastColumn", false);
      assign(table2.style, "showRowStripes", false);
      assign(table2.style, "showColumnStripes", false);
      const assert2 = (test2, message) => {
        if (!test2) {
          throw new Error(message);
        }
      };
      assert2(table2.ref, "Table must have ref");
      assert2(table2.columns, "Table must have column definitions");
      assert2(table2.rows, "Table must have row definitions");
      table2.tl = colCache.decodeAddress(table2.ref);
      const { row: row2, col } = table2.tl;
      assert2(row2 > 0, "Table must be on valid row");
      assert2(col > 0, "Table must be on valid col");
      const { width, filterHeight, tableHeight } = this;
      table2.autoFilterRef = colCache.encode(row2, col, row2 + filterHeight - 1, col + width - 1);
      table2.tableRef = colCache.encode(row2, col, row2 + tableHeight - 1, col + width - 1);
      table2.columns.forEach((column2, i) => {
        assert2(column2.name, `Column ${i} must have a name`);
        if (i === 0) {
          assign(column2, "totalsRowLabel", "Total");
        } else {
          assign(column2, "totalsRowFunction", "none");
          column2.totalsRowFormula = this.getFormula(column2);
        }
      });
    }
    store() {
      const assignStyle = (cell2, style) => {
        if (style) {
          Object.keys(style).forEach((key) => {
            cell2[key] = style[key];
          });
        }
      };
      const { worksheet: worksheet2, table: table2 } = this;
      const { row: row2, col } = table2.tl;
      let count = 0;
      if (table2.headerRow) {
        const r = worksheet2.getRow(row2 + count++);
        table2.columns.forEach((column2, j) => {
          const { style, name } = column2;
          const cell2 = r.getCell(col + j);
          cell2.value = name;
          assignStyle(cell2, style);
        });
      }
      table2.rows.forEach((data2) => {
        const r = worksheet2.getRow(row2 + count++);
        data2.forEach((value, j) => {
          const cell2 = r.getCell(col + j);
          cell2.value = value;
          assignStyle(cell2, table2.columns[j].style);
        });
      });
      if (table2.totalsRow) {
        const r = worksheet2.getRow(row2 + count++);
        table2.columns.forEach((column2, j) => {
          const cell2 = r.getCell(col + j);
          if (j === 0) {
            cell2.value = column2.totalsRowLabel;
          } else {
            const formula = this.getFormula(column2);
            if (formula) {
              cell2.value = {
                formula: column2.totalsRowFormula,
                result: column2.totalsRowResult
              };
            } else {
              cell2.value = null;
            }
          }
          assignStyle(cell2, column2.style);
        });
      }
    }
    load(worksheet2) {
      const { table: table2 } = this;
      const { row: row2, col } = table2.tl;
      let count = 0;
      if (table2.headerRow) {
        const r = worksheet2.getRow(row2 + count++);
        table2.columns.forEach((column2, j) => {
          const cell2 = r.getCell(col + j);
          cell2.value = column2.name;
        });
      }
      table2.rows.forEach((data2) => {
        const r = worksheet2.getRow(row2 + count++);
        data2.forEach((value, j) => {
          const cell2 = r.getCell(col + j);
          cell2.value = value;
        });
      });
      if (table2.totalsRow) {
        const r = worksheet2.getRow(row2 + count++);
        table2.columns.forEach((column2, j) => {
          const cell2 = r.getCell(col + j);
          if (j === 0) {
            cell2.value = column2.totalsRowLabel;
          } else {
            const formula = this.getFormula(column2);
            if (formula) {
              cell2.value = {
                formula: column2.totalsRowFormula,
                result: column2.totalsRowResult
              };
            }
          }
        });
      }
    }
    get model() {
      return this.table;
    }
    set model(value) {
      this.table = value;
    }
    // ================================================================
    // TODO: Mutating methods
    cacheState() {
      if (!this._cache) {
        this._cache = {
          ref: this.ref,
          width: this.width,
          tableHeight: this.tableHeight
        };
      }
    }
    commit() {
      if (!this._cache) {
        return;
      }
      this.validate();
      const ref2 = colCache.decodeAddress(this._cache.ref);
      if (this.ref !== this._cache.ref) {
        for (let i = 0; i < this._cache.tableHeight; i++) {
          const row2 = this.worksheet.getRow(ref2.row + i);
          for (let j = 0; j < this._cache.width; j++) {
            const cell2 = row2.getCell(ref2.col + j);
            cell2.value = null;
          }
        }
      } else {
        for (let i = this.tableHeight; i < this._cache.tableHeight; i++) {
          const row2 = this.worksheet.getRow(ref2.row + i);
          for (let j = 0; j < this._cache.width; j++) {
            const cell2 = row2.getCell(ref2.col + j);
            cell2.value = null;
          }
        }
        for (let i = 0; i < this.tableHeight; i++) {
          const row2 = this.worksheet.getRow(ref2.row + i);
          for (let j = this.width; j < this._cache.width; j++) {
            const cell2 = row2.getCell(ref2.col + j);
            cell2.value = null;
          }
        }
      }
      this.store();
    }
    addRow(values, rowNumber) {
      this.cacheState();
      if (rowNumber === void 0) {
        this.table.rows.push(values);
      } else {
        this.table.rows.splice(rowNumber, 0, values);
      }
    }
    removeRows(rowIndex, count = 1) {
      this.cacheState();
      this.table.rows.splice(rowIndex, count);
    }
    getColumn(colIndex) {
      const column2 = this.table.columns[colIndex];
      return new Column(this, column2, colIndex);
    }
    addColumn(column2, values, colIndex) {
      this.cacheState();
      if (colIndex === void 0) {
        this.table.columns.push(column2);
        this.table.rows.forEach((row2, i) => {
          row2.push(values[i]);
        });
      } else {
        this.table.columns.splice(colIndex, 0, column2);
        this.table.rows.forEach((row2, i) => {
          row2.splice(colIndex, 0, values[i]);
        });
      }
    }
    removeColumns(colIndex, count = 1) {
      this.cacheState();
      this.table.columns.splice(colIndex, count);
      this.table.rows.forEach((row2) => {
        row2.splice(colIndex, count);
      });
    }
    _assign(target, prop, value) {
      this.cacheState();
      target[prop] = value;
    }
    /* eslint-disable lines-between-class-members */
    get ref() {
      return this.table.ref;
    }
    set ref(value) {
      this._assign(this.table, "ref", value);
    }
    get name() {
      return this.table.name;
    }
    set name(value) {
      this.table.name = value;
    }
    get displayName() {
      return this.table.displyName || this.table.name;
    }
    set displayNamename(value) {
      this.table.displayName = value;
    }
    get headerRow() {
      return this.table.headerRow;
    }
    set headerRow(value) {
      this._assign(this.table, "headerRow", value);
    }
    get totalsRow() {
      return this.table.totalsRow;
    }
    set totalsRow(value) {
      this._assign(this.table, "totalsRow", value);
    }
    get theme() {
      return this.table.style.name;
    }
    set theme(value) {
      this.table.style.name = value;
    }
    get showFirstColumn() {
      return this.table.style.showFirstColumn;
    }
    set showFirstColumn(value) {
      this.table.style.showFirstColumn = value;
    }
    get showLastColumn() {
      return this.table.style.showLastColumn;
    }
    set showLastColumn(value) {
      this.table.style.showLastColumn = value;
    }
    get showRowStripes() {
      return this.table.style.showRowStripes;
    }
    set showRowStripes(value) {
      this.table.style.showRowStripes = value;
    }
    get showColumnStripes() {
      return this.table.style.showColumnStripes;
    }
    set showColumnStripes(value) {
      this.table.style.showColumnStripes = value;
    }
    /* eslint-enable lines-between-class-members */
  }
  table = Table;
  return table;
}
var dataValidations;
var hasRequiredDataValidations;
function requireDataValidations() {
  if (hasRequiredDataValidations) return dataValidations;
  hasRequiredDataValidations = 1;
  class DataValidations {
    constructor(model) {
      this.model = model || {};
    }
    add(address, validation) {
      return this.model[address] = validation;
    }
    find(address) {
      return this.model[address];
    }
    remove(address) {
      this.model[address] = void 0;
    }
  }
  dataValidations = DataValidations;
  return dataValidations;
}
var encryptor;
var hasRequiredEncryptor;
function requireEncryptor() {
  if (hasRequiredEncryptor) return encryptor;
  hasRequiredEncryptor = 1;
  const crypto = require$$0$5;
  const Encryptor = {
    /**
     * Calculate a hash of the concatenated buffers with the given algorithm.
     * @param {string} algorithm - The hash algorithm.
     * @returns {Buffer} The hash
     */
    hash(algorithm, ...buffers2) {
      const hash = crypto.createHash(algorithm);
      hash.update(Buffer.concat(buffers2));
      return hash.digest();
    },
    /**
     * Convert a password into an encryption key
     * @param {string} password - The password
     * @param {string} hashAlgorithm - The hash algoritm
     * @param {string} saltValue - The salt value
     * @param {number} spinCount - The spin count
     * @param {number} keyBits - The length of the key in bits
     * @param {Buffer} blockKey - The block key
     * @returns {Buffer} The encryption key
     */
    convertPasswordToHash(password, hashAlgorithm, saltValue, spinCount) {
      hashAlgorithm = hashAlgorithm.toLowerCase();
      const hashes = crypto.getHashes();
      if (hashes.indexOf(hashAlgorithm) < 0) {
        throw new Error(`Hash algorithm '${hashAlgorithm}' not supported!`);
      }
      const passwordBuffer = Buffer.from(password, "utf16le");
      let key = this.hash(hashAlgorithm, Buffer.from(saltValue, "base64"), passwordBuffer);
      for (let i = 0; i < spinCount; i++) {
        const iterator2 = Buffer.alloc(4);
        iterator2.writeUInt32LE(i, 0);
        key = this.hash(hashAlgorithm, key, iterator2);
      }
      return key.toString("base64");
    },
    /**
     * Generates cryptographically strong pseudo-random data.
     * @param size The size argument is a number indicating the number of bytes to generate.
     */
    randomBytes(size) {
      return crypto.randomBytes(size);
    }
  };
  encryptor = Encryptor;
  return encryptor;
}
var copyStyle = {};
var hasRequiredCopyStyle;
function requireCopyStyle() {
  if (hasRequiredCopyStyle) return copyStyle;
  hasRequiredCopyStyle = 1;
  const oneDepthCopy = (obj, nestKeys) => ({
    ...obj,
    ...nestKeys.reduce((memo, key) => {
      if (obj[key]) memo[key] = { ...obj[key] };
      return memo;
    }, {})
  });
  const setIfExists = (src2, dst, key, nestKeys = []) => {
    if (src2[key]) dst[key] = oneDepthCopy(src2[key], nestKeys);
  };
  const isEmptyObj = (obj) => Object.keys(obj).length === 0;
  const copyStyle$1 = (style) => {
    if (!style) return style;
    if (isEmptyObj(style)) return {};
    const copied = { ...style };
    setIfExists(style, copied, "font", ["color"]);
    setIfExists(style, copied, "alignment");
    setIfExists(style, copied, "protection");
    if (style.border) {
      setIfExists(style, copied, "border");
      setIfExists(style.border, copied.border, "top", ["color"]);
      setIfExists(style.border, copied.border, "left", ["color"]);
      setIfExists(style.border, copied.border, "bottom", ["color"]);
      setIfExists(style.border, copied.border, "right", ["color"]);
      setIfExists(style.border, copied.border, "diagonal", ["color"]);
    }
    if (style.fill) {
      setIfExists(style, copied, "fill", ["fgColor", "bgColor", "center"]);
      if (style.fill.stops) {
        copied.fill.stops = style.fill.stops.map((s) => oneDepthCopy(s, ["color"]));
      }
    }
    return copied;
  };
  copyStyle.copyStyle = copyStyle$1;
  return copyStyle;
}
var worksheet;
var hasRequiredWorksheet;
function requireWorksheet() {
  if (hasRequiredWorksheet) return worksheet;
  hasRequiredWorksheet = 1;
  const _2 = requireUnderDash();
  const colCache = requireColCache();
  const Range = requireRange();
  const Row = requireRow();
  const Column = requireColumn$1();
  const Enums = requireEnums();
  const Image2 = requireImage();
  const Table = requireTable();
  const DataValidations = requireDataValidations();
  const Encryptor = requireEncryptor();
  const { copyStyle: copyStyle2 } = requireCopyStyle();
  class Worksheet {
    constructor(options) {
      options = options || {};
      this._workbook = options.workbook;
      this.id = options.id;
      this.orderNo = options.orderNo;
      this.name = options.name;
      this.state = options.state || "visible";
      this._rows = [];
      this._columns = null;
      this._keys = {};
      this._merges = {};
      this.rowBreaks = [];
      this.properties = Object.assign(
        {},
        {
          defaultRowHeight: 15,
          dyDescent: 55,
          outlineLevelCol: 0,
          outlineLevelRow: 0
        },
        options.properties
      );
      this.pageSetup = Object.assign(
        {},
        {
          margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
          orientation: "portrait",
          horizontalDpi: 4294967295,
          verticalDpi: 4294967295,
          fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
          pageOrder: "downThenOver",
          blackAndWhite: false,
          draft: false,
          cellComments: "None",
          errors: "displayed",
          scale: 100,
          fitToWidth: 1,
          fitToHeight: 1,
          paperSize: void 0,
          showRowColHeaders: false,
          showGridLines: false,
          firstPageNumber: void 0,
          horizontalCentered: false,
          verticalCentered: false,
          rowBreaks: null,
          colBreaks: null
        },
        options.pageSetup
      );
      this.headerFooter = Object.assign(
        {},
        {
          differentFirst: false,
          differentOddEven: false,
          oddHeader: null,
          oddFooter: null,
          evenHeader: null,
          evenFooter: null,
          firstHeader: null,
          firstFooter: null
        },
        options.headerFooter
      );
      this.dataValidations = new DataValidations();
      this.views = options.views || [];
      this.autoFilter = options.autoFilter || null;
      this._media = [];
      this.sheetProtection = null;
      this.tables = {};
      this.conditionalFormattings = [];
    }
    get name() {
      return this._name;
    }
    set name(name) {
      if (name === void 0) {
        name = `sheet${this.id}`;
      }
      if (this._name === name) return;
      if (typeof name !== "string") {
        throw new Error("The name has to be a string.");
      }
      if (name === "") {
        throw new Error("The name can't be empty.");
      }
      if (name === "History") {
        throw new Error('The name "History" is protected. Please use a different name.');
      }
      if (/[*?:/\\[\]]/.test(name)) {
        throw new Error(`Worksheet name ${name} cannot include any of the following characters: * ? : \\ / [ ]`);
      }
      if (/(^')|('$)/.test(name)) {
        throw new Error(`The first or last character of worksheet name cannot be a single quotation mark: ${name}`);
      }
      if (name && name.length > 31) {
        console.warn(`Worksheet name ${name} exceeds 31 chars. This will be truncated`);
        name = name.substring(0, 31);
      }
      if (this._workbook._worksheets.find((ws) => ws && ws.name.toLowerCase() === name.toLowerCase())) {
        throw new Error(`Worksheet name already exists: ${name}`);
      }
      this._name = name;
    }
    get workbook() {
      return this._workbook;
    }
    // when you're done with this worksheet, call this to remove from workbook
    destroy() {
      this._workbook.removeWorksheetEx(this);
    }
    // Get the bounding range of the cells in this worksheet
    get dimensions() {
      const dimensions = new Range();
      this._rows.forEach((row2) => {
        if (row2) {
          const rowDims = row2.dimensions;
          if (rowDims) {
            dimensions.expand(row2.number, rowDims.min, row2.number, rowDims.max);
          }
        }
      });
      return dimensions;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
      return this._columns;
    }
    // set the columns from an array of column definitions.
    // Note: any headers defined will overwrite existing values.
    set columns(value) {
      this._headerRowCount = value.reduce((pv, cv) => {
        const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
        return Math.max(pv, headerCount);
      }, 0);
      let count = 1;
      const columns = this._columns = [];
      value.forEach((defn) => {
        const column2 = new Column(this, count++, false);
        columns.push(column2);
        column2.defn = defn;
      });
    }
    getColumnKey(key) {
      return this._keys[key];
    }
    setColumnKey(key, value) {
      this._keys[key] = value;
    }
    deleteColumnKey(key) {
      delete this._keys[key];
    }
    eachColumnKey(f) {
      _2.each(this._keys, f);
    }
    // get a single column by col number. If it doesn't exist, create it and any gaps before it
    getColumn(c) {
      if (typeof c === "string") {
        const col = this._keys[c];
        if (col) return col;
        c = colCache.l2n(c);
      }
      if (!this._columns) {
        this._columns = [];
      }
      if (c > this._columns.length) {
        let n = this._columns.length + 1;
        while (n <= c) {
          this._columns.push(new Column(this, n++));
        }
      }
      return this._columns[c - 1];
    }
    spliceColumns(start, count, ...inserts) {
      const rows = this._rows;
      const nRows = rows.length;
      if (inserts.length > 0) {
        for (let i = 0; i < nRows; i++) {
          const rowArguments = [start, count];
          inserts.forEach((insert) => {
            rowArguments.push(insert[i] || null);
          });
          const row2 = this.getRow(i + 1);
          row2.splice.apply(row2, rowArguments);
        }
      } else {
        this._rows.forEach((r) => {
          if (r) {
            r.splice(start, count);
          }
        });
      }
      const nExpand = inserts.length - count;
      const nKeep = start + count;
      const nEnd = this._columns.length;
      if (nExpand < 0) {
        for (let i = start + inserts.length; i <= nEnd; i++) {
          this.getColumn(i).defn = this.getColumn(i - nExpand).defn;
        }
      } else if (nExpand > 0) {
        for (let i = nEnd; i >= nKeep; i--) {
          this.getColumn(i + nExpand).defn = this.getColumn(i).defn;
        }
      }
      for (let i = start; i < start + inserts.length; i++) {
        this.getColumn(i).defn = null;
      }
      this.workbook.definedNames.spliceColumns(this.name, start, count, inserts.length);
    }
    get lastColumn() {
      return this.getColumn(this.columnCount);
    }
    get columnCount() {
      let maxCount = 0;
      this.eachRow((row2) => {
        maxCount = Math.max(maxCount, row2.cellCount);
      });
      return maxCount;
    }
    get actualColumnCount() {
      const counts = [];
      let count = 0;
      this.eachRow((row2) => {
        row2.eachCell(({ col }) => {
          if (!counts[col]) {
            counts[col] = true;
            count++;
          }
        });
      });
      return count;
    }
    // =========================================================================
    // Rows
    _commitRow() {
    }
    get _lastRowNumber() {
      const rows = this._rows;
      let n = rows.length;
      while (n > 0 && rows[n - 1] === void 0) {
        n--;
      }
      return n;
    }
    get _nextRow() {
      return this._lastRowNumber + 1;
    }
    get lastRow() {
      if (this._rows.length) {
        return this._rows[this._rows.length - 1];
      }
      return void 0;
    }
    // find a row (if exists) by row number
    findRow(r) {
      return this._rows[r - 1];
    }
    // find multiple rows (if exists) by row number
    findRows(start, length) {
      return this._rows.slice(start - 1, start - 1 + length);
    }
    get rowCount() {
      return this._lastRowNumber;
    }
    get actualRowCount() {
      let count = 0;
      this.eachRow(() => {
        count++;
      });
      return count;
    }
    // get a row by row number.
    getRow(r) {
      let row2 = this._rows[r - 1];
      if (!row2) {
        row2 = this._rows[r - 1] = new Row(this, r);
      }
      return row2;
    }
    // get multiple rows by row number.
    getRows(start, length) {
      if (length < 1) return void 0;
      const rows = [];
      for (let i = start; i < start + length; i++) {
        rows.push(this.getRow(i));
      }
      return rows;
    }
    addRow(value, style = "n") {
      const rowNo = this._nextRow;
      const row2 = this.getRow(rowNo);
      row2.values = value;
      this._setStyleOption(rowNo, style[0] === "i" ? style : "n");
      return row2;
    }
    addRows(value, style = "n") {
      const rows = [];
      value.forEach((row2) => {
        rows.push(this.addRow(row2, style));
      });
      return rows;
    }
    insertRow(pos, value, style = "n") {
      this.spliceRows(pos, 0, value);
      this._setStyleOption(pos, style);
      return this.getRow(pos);
    }
    insertRows(pos, values, style = "n") {
      this.spliceRows(pos, 0, ...values);
      if (style !== "n") {
        for (let i = 0; i < values.length; i++) {
          if (style[0] === "o" && this.findRow(values.length + pos + i) !== void 0) {
            this._copyStyle(values.length + pos + i, pos + i, style[1] === "+");
          } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
            this._copyStyle(pos - 1, pos + i, style[1] === "+");
          }
        }
      }
      return this.getRows(pos, values.length);
    }
    // set row at position to same style as of either pervious row (option 'i') or next row (option 'o')
    _setStyleOption(pos, style = "n") {
      if (style[0] === "o" && this.findRow(pos + 1) !== void 0) {
        this._copyStyle(pos + 1, pos, style[1] === "+");
      } else if (style[0] === "i" && this.findRow(pos - 1) !== void 0) {
        this._copyStyle(pos - 1, pos, style[1] === "+");
      }
    }
    _copyStyle(src2, dest, styleEmpty = false) {
      const rSrc = this.getRow(src2);
      const rDst = this.getRow(dest);
      rDst.style = copyStyle2(rSrc.style);
      rSrc.eachCell({ includeEmpty: styleEmpty }, (cell2, colNumber) => {
        rDst.getCell(colNumber).style = copyStyle2(cell2.style);
      });
      rDst.height = rSrc.height;
    }
    duplicateRow(rowNum, count, insert = false) {
      const rSrc = this._rows[rowNum - 1];
      const inserts = new Array(count).fill(rSrc.values);
      this.spliceRows(rowNum + 1, insert ? 0 : count, ...inserts);
      for (let i = 0; i < count; i++) {
        const rDst = this._rows[rowNum + i];
        rDst.style = rSrc.style;
        rDst.height = rSrc.height;
        rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
          rDst.getCell(colNumber).style = cell2.style;
        });
      }
    }
    spliceRows(start, count, ...inserts) {
      const nKeep = start + count;
      const nInserts = inserts.length;
      const nExpand = nInserts - count;
      const nEnd = this._rows.length;
      let i;
      let rSrc;
      if (nExpand < 0) {
        if (start === nEnd) {
          this._rows[nEnd - 1] = void 0;
        }
        for (i = nKeep; i <= nEnd; i++) {
          rSrc = this._rows[i - 1];
          if (rSrc) {
            const rDst = this.getRow(i + nExpand);
            rDst.values = rSrc.values;
            rDst.style = rSrc.style;
            rDst.height = rSrc.height;
            rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
              rDst.getCell(colNumber).style = cell2.style;
            });
            this._rows[i - 1] = void 0;
          } else {
            this._rows[i + nExpand - 1] = void 0;
          }
        }
      } else if (nExpand > 0) {
        for (i = nEnd; i >= nKeep; i--) {
          rSrc = this._rows[i - 1];
          if (rSrc) {
            const rDst = this.getRow(i + nExpand);
            rDst.values = rSrc.values;
            rDst.style = rSrc.style;
            rDst.height = rSrc.height;
            rSrc.eachCell({ includeEmpty: true }, (cell2, colNumber) => {
              rDst.getCell(colNumber).style = cell2.style;
              if (cell2._value.constructor.name === "MergeValue") {
                const cellToBeMerged = this.getRow(cell2._row._number + nInserts).getCell(colNumber);
                const prevMaster = cell2._value._master;
                const newMaster = this.getRow(prevMaster._row._number + nInserts).getCell(prevMaster._column._number);
                cellToBeMerged.merge(newMaster);
              }
            });
          } else {
            this._rows[i + nExpand - 1] = void 0;
          }
        }
      }
      for (i = 0; i < nInserts; i++) {
        const rDst = this.getRow(start + i);
        rDst.style = {};
        rDst.values = inserts[i];
      }
      this.workbook.definedNames.spliceRows(this.name, start, count, nInserts);
    }
    // iterate over every row in the worksheet, including maybe empty rows
    eachRow(options, iteratee) {
      if (!iteratee) {
        iteratee = options;
        options = void 0;
      }
      if (options && options.includeEmpty) {
        const n = this._rows.length;
        for (let i = 1; i <= n; i++) {
          iteratee(this.getRow(i), i);
        }
      } else {
        this._rows.forEach((row2) => {
          if (row2 && row2.hasValues) {
            iteratee(row2, row2.number);
          }
        });
      }
    }
    // return all rows as sparse array
    getSheetValues() {
      const rows = [];
      this._rows.forEach((row2) => {
        if (row2) {
          rows[row2.number] = row2.values;
        }
      });
      return rows;
    }
    // =========================================================================
    // Cells
    // returns the cell at [r,c] or address given by r. If not found, return undefined
    findCell(r, c) {
      const address = colCache.getAddress(r, c);
      const row2 = this._rows[address.row - 1];
      return row2 ? row2.findCell(address.col) : void 0;
    }
    // return the cell at [r,c] or address given by r. If not found, create a new one.
    getCell(r, c) {
      const address = colCache.getAddress(r, c);
      const row2 = this.getRow(address.row);
      return row2.getCellEx(address);
    }
    // =========================================================================
    // Merge
    // convert the range defined by ['tl:br'], [tl,br] or [t,l,b,r] into a single 'merged' cell
    mergeCells(...cells) {
      const dimensions = new Range(cells);
      this._mergeCellsInternal(dimensions);
    }
    mergeCellsWithoutStyle(...cells) {
      const dimensions = new Range(cells);
      this._mergeCellsInternal(dimensions, true);
    }
    _mergeCellsInternal(dimensions, ignoreStyle) {
      _2.each(this._merges, (merge2) => {
        if (merge2.intersects(dimensions)) {
          throw new Error("Cannot merge already merged cells");
        }
      });
      const master = this.getCell(dimensions.top, dimensions.left);
      for (let i = dimensions.top; i <= dimensions.bottom; i++) {
        for (let j = dimensions.left; j <= dimensions.right; j++) {
          if (i > dimensions.top || j > dimensions.left) {
            this.getCell(i, j).merge(master, ignoreStyle);
          }
        }
      }
      this._merges[master.address] = dimensions;
    }
    _unMergeMaster(master) {
      const merge2 = this._merges[master.address];
      if (merge2) {
        for (let i = merge2.top; i <= merge2.bottom; i++) {
          for (let j = merge2.left; j <= merge2.right; j++) {
            this.getCell(i, j).unmerge();
          }
        }
        delete this._merges[master.address];
      }
    }
    get hasMerges() {
      return _2.some(this._merges, Boolean);
    }
    // scan the range defined by ['tl:br'], [tl,br] or [t,l,b,r] and if any cell is part of a merge,
    // un-merge the group. Note this function can affect multiple merges and merge-blocks are
    // atomic - either they're all merged or all un-merged.
    unMergeCells(...cells) {
      const dimensions = new Range(cells);
      for (let i = dimensions.top; i <= dimensions.bottom; i++) {
        for (let j = dimensions.left; j <= dimensions.right; j++) {
          const cell2 = this.findCell(i, j);
          if (cell2) {
            if (cell2.type === Enums.ValueType.Merge) {
              this._unMergeMaster(cell2.master);
            } else if (this._merges[cell2.address]) {
              this._unMergeMaster(cell2);
            }
          }
        }
      }
    }
    // ===========================================================================
    // Shared/Array Formula
    fillFormula(range2, formula, results, shareType = "shared") {
      const decoded = colCache.decode(range2);
      const { top, left, bottom, right } = decoded;
      const width = right - left + 1;
      const masterAddress = colCache.encodeAddress(top, left);
      const isShared = shareType === "shared";
      let getResult;
      if (typeof results === "function") {
        getResult = results;
      } else if (Array.isArray(results)) {
        if (Array.isArray(results[0])) {
          getResult = (row2, col) => results[row2 - top][col - left];
        } else {
          getResult = (row2, col) => results[(row2 - top) * width + (col - left)];
        }
      } else {
        getResult = () => void 0;
      }
      let first = true;
      for (let r = top; r <= bottom; r++) {
        for (let c = left; c <= right; c++) {
          if (first) {
            this.getCell(r, c).value = {
              shareType,
              formula,
              ref: range2,
              result: getResult(r, c)
            };
            first = false;
          } else {
            this.getCell(r, c).value = isShared ? {
              sharedFormula: masterAddress,
              result: getResult(r, c)
            } : getResult(r, c);
          }
        }
      }
    }
    // =========================================================================
    // Images
    addImage(imageId, range2) {
      const model = {
        type: "image",
        imageId,
        range: range2
      };
      this._media.push(new Image2(this, model));
    }
    getImages() {
      return this._media.filter((m) => m.type === "image");
    }
    addBackgroundImage(imageId) {
      const model = {
        type: "background",
        imageId
      };
      this._media.push(new Image2(this, model));
    }
    getBackgroundImageId() {
      const image2 = this._media.find((m) => m.type === "background");
      return image2 && image2.imageId;
    }
    // =========================================================================
    // Worksheet Protection
    protect(password, options) {
      return new Promise((resolve) => {
        this.sheetProtection = {
          sheet: true
        };
        if (options && "spinCount" in options) {
          options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
        }
        if (password) {
          this.sheetProtection.algorithmName = "SHA-512";
          this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
          this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
          this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(
            password,
            "SHA512",
            this.sheetProtection.saltValue,
            this.sheetProtection.spinCount
          );
        }
        if (options) {
          this.sheetProtection = Object.assign(this.sheetProtection, options);
          if (!password && "spinCount" in options) {
            delete this.sheetProtection.spinCount;
          }
        }
        resolve();
      });
    }
    unprotect() {
      this.sheetProtection = null;
    }
    // =========================================================================
    // Tables
    addTable(model) {
      const table2 = new Table(this, model);
      this.tables[model.name] = table2;
      return table2;
    }
    getTable(name) {
      return this.tables[name];
    }
    removeTable(name) {
      delete this.tables[name];
    }
    getTables() {
      return Object.values(this.tables);
    }
    // ===========================================================================
    // Conditional Formatting
    addConditionalFormatting(cf) {
      this.conditionalFormattings.push(cf);
    }
    removeConditionalFormatting(filter3) {
      if (typeof filter3 === "number") {
        this.conditionalFormattings.splice(filter3, 1);
      } else if (filter3 instanceof Function) {
        this.conditionalFormattings = this.conditionalFormattings.filter(filter3);
      } else {
        this.conditionalFormattings = [];
      }
    }
    // ===========================================================================
    // Deprecated
    get tabColor() {
      console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
      return this.properties.tabColor;
    }
    set tabColor(value) {
      console.trace("worksheet.tabColor property is now deprecated. Please use worksheet.properties.tabColor");
      this.properties.tabColor = value;
    }
    // ===========================================================================
    // Model
    get model() {
      const model = {
        id: this.id,
        name: this.name,
        dataValidations: this.dataValidations.model,
        properties: this.properties,
        state: this.state,
        pageSetup: this.pageSetup,
        headerFooter: this.headerFooter,
        rowBreaks: this.rowBreaks,
        views: this.views,
        autoFilter: this.autoFilter,
        media: this._media.map((medium) => medium.model),
        sheetProtection: this.sheetProtection,
        tables: Object.values(this.tables).map((table2) => table2.model),
        conditionalFormattings: this.conditionalFormattings
      };
      model.cols = Column.toModel(this.columns);
      const rows = model.rows = [];
      const dimensions = model.dimensions = new Range();
      this._rows.forEach((row2) => {
        const rowModel = row2 && row2.model;
        if (rowModel) {
          dimensions.expand(rowModel.number, rowModel.min, rowModel.number, rowModel.max);
          rows.push(rowModel);
        }
      });
      model.merges = [];
      _2.each(this._merges, (merge2) => {
        model.merges.push(merge2.range);
      });
      return model;
    }
    _parseRows(model) {
      this._rows = [];
      model.rows.forEach((rowModel) => {
        const row2 = new Row(this, rowModel.number);
        this._rows[row2.number - 1] = row2;
        row2.model = rowModel;
      });
    }
    _parseMergeCells(model) {
      _2.each(model.mergeCells, (merge2) => {
        this.mergeCellsWithoutStyle(merge2);
      });
    }
    set model(value) {
      this.name = value.name;
      this._columns = Column.fromModel(this, value.cols);
      this._parseRows(value);
      this._parseMergeCells(value);
      this.dataValidations = new DataValidations(value.dataValidations);
      this.properties = value.properties;
      this.pageSetup = value.pageSetup;
      this.headerFooter = value.headerFooter;
      this.views = value.views;
      this.autoFilter = value.autoFilter;
      this._media = value.media.map((medium) => new Image2(this, medium));
      this.sheetProtection = value.sheetProtection;
      this.tables = value.tables.reduce((tables, table2) => {
        const t = new Table();
        t.model = table2;
        tables[table2.name] = t;
        return tables;
      }, {});
      this.conditionalFormattings = value.conditionalFormattings;
    }
  }
  worksheet = Worksheet;
  return worksheet;
}
var cellMatrix;
var hasRequiredCellMatrix;
function requireCellMatrix() {
  if (hasRequiredCellMatrix) return cellMatrix;
  hasRequiredCellMatrix = 1;
  const _2 = requireUnderDash();
  const colCache = requireColCache();
  class CellMatrix {
    constructor(template) {
      this.template = template;
      this.sheets = {};
    }
    addCell(addressStr) {
      this.addCellEx(colCache.decodeEx(addressStr));
    }
    getCell(addressStr) {
      return this.findCellEx(colCache.decodeEx(addressStr), true);
    }
    findCell(addressStr) {
      return this.findCellEx(colCache.decodeEx(addressStr), false);
    }
    findCellAt(sheetName, rowNumber, colNumber) {
      const sheet = this.sheets[sheetName];
      const row2 = sheet && sheet[rowNumber];
      return row2 && row2[colNumber];
    }
    addCellEx(address) {
      if (address.top) {
        for (let row2 = address.top; row2 <= address.bottom; row2++) {
          for (let col = address.left; col <= address.right; col++) {
            this.getCellAt(address.sheetName, row2, col);
          }
        }
      } else {
        this.findCellEx(address, true);
      }
    }
    getCellEx(address) {
      return this.findCellEx(address, true);
    }
    findCellEx(address, create) {
      const sheet = this.findSheet(address, create);
      const row2 = this.findSheetRow(sheet, address, create);
      return this.findRowCell(row2, address, create);
    }
    getCellAt(sheetName, rowNumber, colNumber) {
      const sheet = this.sheets[sheetName] || (this.sheets[sheetName] = []);
      const row2 = sheet[rowNumber] || (sheet[rowNumber] = []);
      const cell2 = row2[colNumber] || (row2[colNumber] = {
        sheetName,
        address: colCache.n2l(colNumber) + rowNumber,
        row: rowNumber,
        col: colNumber
      });
      return cell2;
    }
    removeCellEx(address) {
      const sheet = this.findSheet(address);
      if (!sheet) {
        return;
      }
      const row2 = this.findSheetRow(sheet, address);
      if (!row2) {
        return;
      }
      delete row2[address.col];
    }
    forEachInSheet(sheetName, callback) {
      const sheet = this.sheets[sheetName];
      if (sheet) {
        sheet.forEach((row2, rowNumber) => {
          if (row2) {
            row2.forEach((cell2, colNumber) => {
              if (cell2) {
                callback(cell2, rowNumber, colNumber);
              }
            });
          }
        });
      }
    }
    forEach(callback) {
      _2.each(this.sheets, (sheet, sheetName) => {
        this.forEachInSheet(sheetName, callback);
      });
    }
    map(callback) {
      const results = [];
      this.forEach((cell2) => {
        results.push(callback(cell2));
      });
      return results;
    }
    findSheet(address, create) {
      const name = address.sheetName;
      if (this.sheets[name]) {
        return this.sheets[name];
      }
      if (create) {
        return this.sheets[name] = [];
      }
      return void 0;
    }
    findSheetRow(sheet, address, create) {
      const { row: row2 } = address;
      if (sheet && sheet[row2]) {
        return sheet[row2];
      }
      if (create) {
        return sheet[row2] = [];
      }
      return void 0;
    }
    findRowCell(row2, address, create) {
      const { col } = address;
      if (row2 && row2[col]) {
        return row2[col];
      }
      if (create) {
        return row2[col] = this.template ? Object.assign(address, JSON.parse(JSON.stringify(this.template))) : address;
      }
      return void 0;
    }
    spliceRows(sheetName, start, numDelete, numInsert) {
      const sheet = this.sheets[sheetName];
      if (sheet) {
        const inserts = [];
        for (let i = 0; i < numInsert; i++) {
          inserts.push([]);
        }
        sheet.splice(start, numDelete, ...inserts);
      }
    }
    spliceColumns(sheetName, start, numDelete, numInsert) {
      const sheet = this.sheets[sheetName];
      if (sheet) {
        const inserts = [];
        for (let i = 0; i < numInsert; i++) {
          inserts.push(null);
        }
        _2.each(sheet, (row2) => {
          row2.splice(start, numDelete, ...inserts);
        });
      }
    }
  }
  cellMatrix = CellMatrix;
  return cellMatrix;
}
var definedNames;
var hasRequiredDefinedNames;
function requireDefinedNames() {
  if (hasRequiredDefinedNames) return definedNames;
  hasRequiredDefinedNames = 1;
  const _2 = requireUnderDash();
  const colCache = requireColCache();
  const CellMatrix = requireCellMatrix();
  const Range = requireRange();
  const rangeRegexp = /[$](\w+)[$](\d+)(:[$](\w+)[$](\d+))?/;
  class DefinedNames {
    constructor() {
      this.matrixMap = {};
    }
    getMatrix(name) {
      const matrix = this.matrixMap[name] || (this.matrixMap[name] = new CellMatrix());
      return matrix;
    }
    // add a name to a cell. locStr in the form SheetName!$col$row or SheetName!$c1$r1:$c2:$r2
    add(locStr, name) {
      const location = colCache.decodeEx(locStr);
      this.addEx(location, name);
    }
    addEx(location, name) {
      const matrix = this.getMatrix(name);
      if (location.top) {
        for (let col = location.left; col <= location.right; col++) {
          for (let row2 = location.top; row2 <= location.bottom; row2++) {
            const address = {
              sheetName: location.sheetName,
              address: colCache.n2l(col) + row2,
              row: row2,
              col
            };
            matrix.addCellEx(address);
          }
        }
      } else {
        matrix.addCellEx(location);
      }
    }
    remove(locStr, name) {
      const location = colCache.decodeEx(locStr);
      this.removeEx(location, name);
    }
    removeEx(location, name) {
      const matrix = this.getMatrix(name);
      matrix.removeCellEx(location);
    }
    removeAllNames(location) {
      _2.each(this.matrixMap, (matrix) => {
        matrix.removeCellEx(location);
      });
    }
    forEach(callback) {
      _2.each(this.matrixMap, (matrix, name) => {
        matrix.forEach((cell2) => {
          callback(name, cell2);
        });
      });
    }
    // get all the names of a cell
    getNames(addressStr) {
      return this.getNamesEx(colCache.decodeEx(addressStr));
    }
    getNamesEx(address) {
      return _2.map(this.matrixMap, (matrix, name) => matrix.findCellEx(address) && name).filter(
        Boolean
      );
    }
    _explore(matrix, cell2) {
      cell2.mark = false;
      const { sheetName } = cell2;
      const range2 = new Range(cell2.row, cell2.col, cell2.row, cell2.col, sheetName);
      let x;
      let y;
      function vGrow(yy, edge) {
        const c = matrix.findCellAt(sheetName, yy, cell2.col);
        if (!c || !c.mark) {
          return false;
        }
        range2[edge] = yy;
        c.mark = false;
        return true;
      }
      for (y = cell2.row - 1; vGrow(y, "top"); y--) ;
      for (y = cell2.row + 1; vGrow(y, "bottom"); y++) ;
      function hGrow(xx, edge) {
        const cells = [];
        for (y = range2.top; y <= range2.bottom; y++) {
          const c = matrix.findCellAt(sheetName, y, xx);
          if (c && c.mark) {
            cells.push(c);
          } else {
            return false;
          }
        }
        range2[edge] = xx;
        for (let i = 0; i < cells.length; i++) {
          cells[i].mark = false;
        }
        return true;
      }
      for (x = cell2.col - 1; hGrow(x, "left"); x--) ;
      for (x = cell2.col + 1; hGrow(x, "right"); x++) ;
      return range2;
    }
    getRanges(name, matrix) {
      matrix = matrix || this.matrixMap[name];
      if (!matrix) {
        return { name, ranges: [] };
      }
      matrix.forEach((cell2) => {
        cell2.mark = true;
      });
      const ranges = matrix.map((cell2) => cell2.mark && this._explore(matrix, cell2)).filter(Boolean).map((range2) => range2.$shortRange);
      return {
        name,
        ranges
      };
    }
    normaliseMatrix(matrix, sheetName) {
      matrix.forEachInSheet(sheetName, (cell2, row2, col) => {
        if (cell2) {
          if (cell2.row !== row2 || cell2.col !== col) {
            cell2.row = row2;
            cell2.col = col;
            cell2.address = colCache.n2l(col) + row2;
          }
        }
      });
    }
    spliceRows(sheetName, start, numDelete, numInsert) {
      _2.each(this.matrixMap, (matrix) => {
        matrix.spliceRows(sheetName, start, numDelete, numInsert);
        this.normaliseMatrix(matrix, sheetName);
      });
    }
    spliceColumns(sheetName, start, numDelete, numInsert) {
      _2.each(this.matrixMap, (matrix) => {
        matrix.spliceColumns(sheetName, start, numDelete, numInsert);
        this.normaliseMatrix(matrix, sheetName);
      });
    }
    get model() {
      return _2.map(this.matrixMap, (matrix, name) => this.getRanges(name, matrix)).filter(
        (definedName) => definedName.ranges.length
      );
    }
    set model(value) {
      const matrixMap = this.matrixMap = {};
      value.forEach((definedName) => {
        const matrix = matrixMap[definedName.name] = new CellMatrix();
        definedName.ranges.forEach((rangeStr) => {
          if (rangeRegexp.test(rangeStr.split("!").pop() || "")) {
            matrix.addCell(rangeStr);
          }
        });
      });
    }
  }
  definedNames = DefinedNames;
  return definedNames;
}
var utf8 = {};
var utils = {};
var support = {};
var readable$5 = { exports: {} };
var processNextickArgs = { exports: {} };
var hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1;
  if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
    processNextickArgs.exports = { nextTick: nextTick2 };
  } else {
    processNextickArgs.exports = process;
  }
  function nextTick2(fn, arg1, arg2, arg3) {
    if (typeof fn !== "function") {
      throw new TypeError('"callback" argument must be a function');
    }
    var len = arguments.length;
    var args, i;
    switch (len) {
      case 0:
      case 1:
        return process.nextTick(fn);
      case 2:
        return process.nextTick(function afterTickOne() {
          fn.call(null, arg1);
        });
      case 3:
        return process.nextTick(function afterTickTwo() {
          fn.call(null, arg1, arg2);
        });
      case 4:
        return process.nextTick(function afterTickThree() {
          fn.call(null, arg1, arg2, arg3);
        });
      default:
        args = new Array(len - 1);
        i = 0;
        while (i < args.length) {
          args[i++] = arguments[i];
        }
        return process.nextTick(function afterTick() {
          fn.apply(null, args);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray;
var hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray) return isarray;
  hasRequiredIsarray = 1;
  var toString3 = {}.toString;
  isarray = Array.isArray || function(arr) {
    return toString3.call(arr) == "[object Array]";
  };
  return isarray;
}
var stream$5;
var hasRequiredStream$5;
function requireStream$5() {
  if (hasRequiredStream$5) return stream$5;
  hasRequiredStream$5 = 1;
  stream$5 = require$$0$1;
  return stream$5;
}
var safeBuffer$5 = { exports: {} };
var hasRequiredSafeBuffer$5;
function requireSafeBuffer$5() {
  if (hasRequiredSafeBuffer$5) return safeBuffer$5.exports;
  hasRequiredSafeBuffer$5 = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$5, safeBuffer$5.exports);
  return safeBuffer$5.exports;
}
var util$7 = {};
var hasRequiredUtil$7;
function requireUtil$7() {
  if (hasRequiredUtil$7) return util$7;
  hasRequiredUtil$7 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$7.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$7.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$7.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$7.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$7.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$7.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$7.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$7.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$7.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$7.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util$7.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$7.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$7.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$7.isPrimitive = isPrimitive;
  util$7.isBuffer = require$$0$7.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$7;
}
var inherits = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
var hasRequiredInherits;
function requireInherits() {
  if (hasRequiredInherits) return inherits.exports;
  hasRequiredInherits = 1;
  try {
    var util2 = require("util");
    if (typeof util2.inherits !== "function") throw "";
    inherits.exports = util2.inherits;
  } catch (e) {
    inherits.exports = requireInherits_browser();
  }
  return inherits.exports;
}
var BufferList$4 = { exports: {} };
var hasRequiredBufferList$5;
function requireBufferList$5() {
  if (hasRequiredBufferList$5) return BufferList$4.exports;
  hasRequiredBufferList$5 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$5().Buffer;
    var util2 = require$$0$2;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$4);
  return BufferList$4.exports;
}
var destroy_1$5;
var hasRequiredDestroy$5;
function requireDestroy$5() {
  if (hasRequiredDestroy$5) return destroy_1$5;
  hasRequiredDestroy$5 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$5 = {
    destroy,
    undestroy
  };
  return destroy_1$5;
}
var node;
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  node = require$$0$2.deprecate;
  return node;
}
var _stream_writable$5;
var hasRequired_stream_writable$5;
function require_stream_writable$5() {
  if (hasRequired_stream_writable$5) return _stream_writable$5;
  hasRequired_stream_writable$5 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$5 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$7());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream$5();
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$5();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$5();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$5();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$5;
}
var _stream_duplex$5;
var hasRequired_stream_duplex$5;
function require_stream_duplex$5() {
  if (hasRequired_stream_duplex$5) return _stream_duplex$5;
  hasRequired_stream_duplex$5 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$5 = Duplex;
  var util2 = Object.create(requireUtil$7());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$5();
  var Writable = require_stream_writable$5();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$5;
}
var string_decoder$5 = {};
var hasRequiredString_decoder$5;
function requireString_decoder$5() {
  if (hasRequiredString_decoder$5) return string_decoder$5;
  hasRequiredString_decoder$5 = 1;
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$5.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$5;
}
var _stream_readable$5;
var hasRequired_stream_readable$5;
function require_stream_readable$5() {
  if (hasRequired_stream_readable$5) return _stream_readable$5;
  hasRequired_stream_readable$5 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$5 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream$5();
  var Buffer2 = requireSafeBuffer$5().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$7());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$2;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList$5();
  var destroyImpl = requireDestroy$5();
  var StringDecoder;
  util2.inherits(Readable2, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$5();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder$5().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$5();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder$5().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$5;
}
var _stream_transform$5;
var hasRequired_stream_transform$5;
function require_stream_transform$5() {
  if (hasRequired_stream_transform$5) return _stream_transform$5;
  hasRequired_stream_transform$5 = 1;
  _stream_transform$5 = Transform;
  var Duplex = require_stream_duplex$5();
  var util2 = Object.create(requireUtil$7());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$5;
}
var _stream_passthrough$5;
var hasRequired_stream_passthrough$5;
function require_stream_passthrough$5() {
  if (hasRequired_stream_passthrough$5) return _stream_passthrough$5;
  hasRequired_stream_passthrough$5 = 1;
  _stream_passthrough$5 = PassThrough;
  var Transform = require_stream_transform$5();
  var util2 = Object.create(requireUtil$7());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$5;
}
var hasRequiredReadable$5;
function requireReadable$5() {
  if (hasRequiredReadable$5) return readable$5.exports;
  hasRequiredReadable$5 = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable$5();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$5();
      exports.Duplex = require_stream_duplex$5();
      exports.Transform = require_stream_transform$5();
      exports.PassThrough = require_stream_passthrough$5();
    }
  })(readable$5, readable$5.exports);
  return readable$5.exports;
}
var hasRequiredSupport;
function requireSupport() {
  if (hasRequiredSupport) return support;
  hasRequiredSupport = 1;
  support.base64 = true;
  support.array = true;
  support.string = true;
  support.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  support.nodebuffer = typeof Buffer !== "undefined";
  support.uint8array = typeof Uint8Array !== "undefined";
  if (typeof ArrayBuffer === "undefined") {
    support.blob = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      support.blob = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e) {
      try {
        var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
        var builder = new Builder();
        builder.append(buffer);
        support.blob = builder.getBlob("application/zip").size === 0;
      } catch (e2) {
        support.blob = false;
      }
    }
  }
  try {
    support.nodestream = !!requireReadable$5().Readable;
  } catch (e) {
    support.nodestream = false;
  }
  return support;
}
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var utils2 = requireUtils$1();
  var support2 = requireSupport();
  var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  base64.encode = function(input) {
    var output = [];
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
    var i = 0, len = input.length, remainingBytes = len;
    var isArray2 = utils2.getTypeOf(input) !== "string";
    while (i < input.length) {
      remainingBytes = len - i;
      if (!isArray2) {
        chr1 = input.charCodeAt(i++);
        chr2 = i < len ? input.charCodeAt(i++) : 0;
        chr3 = i < len ? input.charCodeAt(i++) : 0;
      } else {
        chr1 = input[i++];
        chr2 = i < len ? input[i++] : 0;
        chr3 = i < len ? input[i++] : 0;
      }
      enc1 = chr1 >> 2;
      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
      enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
      enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
      output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
    }
    return output.join("");
  };
  base64.decode = function(input) {
    var chr1, chr2, chr3;
    var enc1, enc2, enc3, enc4;
    var i = 0, resultIndex = 0;
    var dataUrlPrefix = "data:";
    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
      throw new Error("Invalid base64 input, it looks like a data url.");
    }
    input = input.replace(/[^A-Za-z0-9+/=]/g, "");
    var totalLength = input.length * 3 / 4;
    if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
      totalLength--;
    }
    if (totalLength % 1 !== 0) {
      throw new Error("Invalid base64 input, bad content length.");
    }
    var output;
    if (support2.uint8array) {
      output = new Uint8Array(totalLength | 0);
    } else {
      output = new Array(totalLength | 0);
    }
    while (i < input.length) {
      enc1 = _keyStr.indexOf(input.charAt(i++));
      enc2 = _keyStr.indexOf(input.charAt(i++));
      enc3 = _keyStr.indexOf(input.charAt(i++));
      enc4 = _keyStr.indexOf(input.charAt(i++));
      chr1 = enc1 << 2 | enc2 >> 4;
      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
      chr3 = (enc3 & 3) << 6 | enc4;
      output[resultIndex++] = chr1;
      if (enc3 !== 64) {
        output[resultIndex++] = chr2;
      }
      if (enc4 !== 64) {
        output[resultIndex++] = chr3;
      }
    }
    return output;
  };
  return base64;
}
var nodejsUtils;
var hasRequiredNodejsUtils;
function requireNodejsUtils() {
  if (hasRequiredNodejsUtils) return nodejsUtils;
  hasRequiredNodejsUtils = 1;
  nodejsUtils = {
    /**
     * True if this is running in Nodejs, will be undefined in a browser.
     * In a browser, browserify won't include this file and the whole module
     * will be resolved an empty object.
     */
    isNode: typeof Buffer !== "undefined",
    /**
     * Create a new nodejs Buffer from an existing content.
     * @param {Object} data the data to pass to the constructor.
     * @param {String} encoding the encoding to use.
     * @return {Buffer} a new Buffer.
     */
    newBufferFrom: function(data2, encoding) {
      if (Buffer.from && Buffer.from !== Uint8Array.from) {
        return Buffer.from(data2, encoding);
      } else {
        if (typeof data2 === "number") {
          throw new Error('The "data" argument must not be a number');
        }
        return new Buffer(data2, encoding);
      }
    },
    /**
     * Create a new nodejs Buffer with the specified size.
     * @param {Integer} size the size of the buffer.
     * @return {Buffer} a new Buffer.
     */
    allocBuffer: function(size) {
      if (Buffer.alloc) {
        return Buffer.alloc(size);
      } else {
        var buf = new Buffer(size);
        buf.fill(0);
        return buf;
      }
    },
    /**
     * Find out if an object is a Buffer.
     * @param {Object} b the object to test.
     * @return {Boolean} true if the object is a Buffer, false otherwise.
     */
    isBuffer: function(b) {
      return Buffer.isBuffer(b);
    },
    isStream: function(obj) {
      return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
    }
  };
  return nodejsUtils;
}
var lib$3;
var hasRequiredLib$3;
function requireLib$3() {
  if (hasRequiredLib$3) return lib$3;
  hasRequiredLib$3 = 1;
  var Mutation = commonjsGlobal.MutationObserver || commonjsGlobal.WebKitMutationObserver;
  var scheduleDrain;
  if (process.browser) {
    if (Mutation) {
      var called = 0;
      var observer = new Mutation(nextTick2);
      var element = commonjsGlobal.document.createTextNode("");
      observer.observe(element, {
        characterData: true
      });
      scheduleDrain = function() {
        element.data = called = ++called % 2;
      };
    } else if (!commonjsGlobal.setImmediate && typeof commonjsGlobal.MessageChannel !== "undefined") {
      var channel = new commonjsGlobal.MessageChannel();
      channel.port1.onmessage = nextTick2;
      scheduleDrain = function() {
        channel.port2.postMessage(0);
      };
    } else if ("document" in commonjsGlobal && "onreadystatechange" in commonjsGlobal.document.createElement("script")) {
      scheduleDrain = function() {
        var scriptEl = commonjsGlobal.document.createElement("script");
        scriptEl.onreadystatechange = function() {
          nextTick2();
          scriptEl.onreadystatechange = null;
          scriptEl.parentNode.removeChild(scriptEl);
          scriptEl = null;
        };
        commonjsGlobal.document.documentElement.appendChild(scriptEl);
      };
    } else {
      scheduleDrain = function() {
        setTimeout(nextTick2, 0);
      };
    }
  } else {
    scheduleDrain = function() {
      process.nextTick(nextTick2);
    };
  }
  var draining;
  var queue2 = [];
  function nextTick2() {
    draining = true;
    var i, oldQueue;
    var len = queue2.length;
    while (len) {
      oldQueue = queue2;
      queue2 = [];
      i = -1;
      while (++i < len) {
        oldQueue[i]();
      }
      len = queue2.length;
    }
    draining = false;
  }
  lib$3 = immediate;
  function immediate(task) {
    if (queue2.push(task) === 1 && !draining) {
      scheduleDrain();
    }
  }
  return lib$3;
}
var lib$2;
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$2;
  hasRequiredLib$2 = 1;
  var immediate = requireLib$3();
  function INTERNAL() {
  }
  var handlers = {};
  var REJECTED = ["REJECTED"];
  var FULFILLED = ["FULFILLED"];
  var PENDING = ["PENDING"];
  if (!process.browser) {
    var UNHANDLED = ["UNHANDLED"];
  }
  lib$2 = Promise2;
  function Promise2(resolver) {
    if (typeof resolver !== "function") {
      throw new TypeError("resolver must be a function");
    }
    this.state = PENDING;
    this.queue = [];
    this.outcome = void 0;
    if (!process.browser) {
      this.handled = UNHANDLED;
    }
    if (resolver !== INTERNAL) {
      safelyResolveThenable(this, resolver);
    }
  }
  Promise2.prototype.finally = function(callback) {
    if (typeof callback !== "function") {
      return this;
    }
    var p = this.constructor;
    return this.then(resolve2, reject3);
    function resolve2(value) {
      function yes() {
        return value;
      }
      return p.resolve(callback()).then(yes);
    }
    function reject3(reason) {
      function no() {
        throw reason;
      }
      return p.resolve(callback()).then(no);
    }
  };
  Promise2.prototype.catch = function(onRejected) {
    return this.then(null, onRejected);
  };
  Promise2.prototype.then = function(onFulfilled, onRejected) {
    if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
      return this;
    }
    var promise2 = new this.constructor(INTERNAL);
    if (!process.browser) {
      if (this.handled === UNHANDLED) {
        this.handled = null;
      }
    }
    if (this.state !== PENDING) {
      var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
      unwrap(promise2, resolver, this.outcome);
    } else {
      this.queue.push(new QueueItem(promise2, onFulfilled, onRejected));
    }
    return promise2;
  };
  function QueueItem(promise2, onFulfilled, onRejected) {
    this.promise = promise2;
    if (typeof onFulfilled === "function") {
      this.onFulfilled = onFulfilled;
      this.callFulfilled = this.otherCallFulfilled;
    }
    if (typeof onRejected === "function") {
      this.onRejected = onRejected;
      this.callRejected = this.otherCallRejected;
    }
  }
  QueueItem.prototype.callFulfilled = function(value) {
    handlers.resolve(this.promise, value);
  };
  QueueItem.prototype.otherCallFulfilled = function(value) {
    unwrap(this.promise, this.onFulfilled, value);
  };
  QueueItem.prototype.callRejected = function(value) {
    handlers.reject(this.promise, value);
  };
  QueueItem.prototype.otherCallRejected = function(value) {
    unwrap(this.promise, this.onRejected, value);
  };
  function unwrap(promise2, func, value) {
    immediate(function() {
      var returnValue;
      try {
        returnValue = func(value);
      } catch (e) {
        return handlers.reject(promise2, e);
      }
      if (returnValue === promise2) {
        handlers.reject(promise2, new TypeError("Cannot resolve promise with itself"));
      } else {
        handlers.resolve(promise2, returnValue);
      }
    });
  }
  handlers.resolve = function(self2, value) {
    var result = tryCatch(getThen, value);
    if (result.status === "error") {
      return handlers.reject(self2, result.value);
    }
    var thenable = result.value;
    if (thenable) {
      safelyResolveThenable(self2, thenable);
    } else {
      self2.state = FULFILLED;
      self2.outcome = value;
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callFulfilled(value);
      }
    }
    return self2;
  };
  handlers.reject = function(self2, error2) {
    self2.state = REJECTED;
    self2.outcome = error2;
    if (!process.browser) {
      if (self2.handled === UNHANDLED) {
        immediate(function() {
          if (self2.handled === UNHANDLED) {
            process.emit("unhandledRejection", error2, self2);
          }
        });
      }
    }
    var i = -1;
    var len = self2.queue.length;
    while (++i < len) {
      self2.queue[i].callRejected(error2);
    }
    return self2;
  };
  function getThen(obj) {
    var then = obj && obj.then;
    if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
      return function appyThen() {
        then.apply(obj, arguments);
      };
    }
  }
  function safelyResolveThenable(self2, thenable) {
    var called = false;
    function onError(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.reject(self2, value);
    }
    function onSuccess(value) {
      if (called) {
        return;
      }
      called = true;
      handlers.resolve(self2, value);
    }
    function tryToUnwrap() {
      thenable(onSuccess, onError);
    }
    var result = tryCatch(tryToUnwrap);
    if (result.status === "error") {
      onError(result.value);
    }
  }
  function tryCatch(func, value) {
    var out = {};
    try {
      out.value = func(value);
      out.status = "success";
    } catch (e) {
      out.status = "error";
      out.value = e;
    }
    return out;
  }
  Promise2.resolve = resolve;
  function resolve(value) {
    if (value instanceof this) {
      return value;
    }
    return handlers.resolve(new this(INTERNAL), value);
  }
  Promise2.reject = reject2;
  function reject2(reason) {
    var promise2 = new this(INTERNAL);
    return handlers.reject(promise2, reason);
  }
  Promise2.all = all3;
  function all3(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var values = new Array(len);
    var resolved = 0;
    var i = -1;
    var promise2 = new this(INTERNAL);
    while (++i < len) {
      allResolver(iterable[i], i);
    }
    return promise2;
    function allResolver(value, i2) {
      self2.resolve(value).then(resolveFromAll, function(error2) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error2);
        }
      });
      function resolveFromAll(outValue) {
        values[i2] = outValue;
        if (++resolved === len && !called) {
          called = true;
          handlers.resolve(promise2, values);
        }
      }
    }
  }
  Promise2.race = race2;
  function race2(iterable) {
    var self2 = this;
    if (Object.prototype.toString.call(iterable) !== "[object Array]") {
      return this.reject(new TypeError("must be an array"));
    }
    var len = iterable.length;
    var called = false;
    if (!len) {
      return this.resolve([]);
    }
    var i = -1;
    var promise2 = new this(INTERNAL);
    while (++i < len) {
      resolver(iterable[i]);
    }
    return promise2;
    function resolver(value) {
      self2.resolve(value).then(function(response) {
        if (!called) {
          called = true;
          handlers.resolve(promise2, response);
        }
      }, function(error2) {
        if (!called) {
          called = true;
          handlers.reject(promise2, error2);
        }
      });
    }
  }
  return lib$2;
}
var external;
var hasRequiredExternal;
function requireExternal() {
  if (hasRequiredExternal) return external;
  hasRequiredExternal = 1;
  var ES6Promise = null;
  if (typeof Promise !== "undefined") {
    ES6Promise = Promise;
  } else {
    ES6Promise = requireLib$2();
  }
  external = {
    Promise: ES6Promise
  };
  return external;
}
var setImmediate$2 = {};
var hasRequiredSetImmediate;
function requireSetImmediate() {
  if (hasRequiredSetImmediate) return setImmediate$2;
  hasRequiredSetImmediate = 1;
  (function(global2, undefined$1) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined$1, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel();
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof commonjsGlobal === "undefined" ? setImmediate$2 : commonjsGlobal : self);
  return setImmediate$2;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  if (hasRequiredUtils$1) return utils;
  hasRequiredUtils$1 = 1;
  (function(exports) {
    var support2 = requireSupport();
    var base642 = requireBase64();
    var nodejsUtils2 = requireNodejsUtils();
    var external2 = requireExternal();
    requireSetImmediate();
    function string2binary(str) {
      var result = null;
      if (support2.uint8array) {
        result = new Uint8Array(str.length);
      } else {
        result = new Array(str.length);
      }
      return stringToArrayLike(str, result);
    }
    exports.newBlob = function(part, type2) {
      exports.checkSupport("blob");
      try {
        return new Blob([part], {
          type: type2
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type2);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type2, chunk) {
        var result = [], k = 0, len = array.length;
        if (len <= chunk) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type2 === "array" || type2 === "nodebuffer") {
            result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
          } else {
            result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
          }
          k += chunk;
        }
        return result.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support2.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support2.nodebuffer && String.fromCharCode.apply(null, nodejsUtils2.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk = 65536, type2 = exports.getTypeOf(array), canUseApply = true;
      if (type2 === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type2 === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type2, chunk);
          } catch (e) {
            chunk = Math.floor(chunk / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform2 = {};
    transform2["string"] = {
      "string": identity,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform2["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils2.allocBuffer(input.length));
      }
    };
    transform2["array"] = {
      "string": arrayLikeToString,
      "array": identity,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform2["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(new Uint8Array(input));
      }
    };
    transform2["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity,
      "nodebuffer": function(input) {
        return nodejsUtils2.newBufferFrom(input);
      }
    };
    transform2["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform2["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity
    };
    exports.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports.checkSupport(outputType);
      var inputType = exports.getTypeOf(input);
      var result = transform2[inputType][outputType](input);
      return result;
    };
    exports.resolve = function(path2) {
      var parts = path2.split("/");
      var result = [];
      for (var index2 = 0; index2 < parts.length; index2++) {
        var part = parts[index2];
        if (part === "." || part === "" && index2 !== 0 && index2 !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result.pop();
        } else {
          result.push(part);
        }
      }
      return result.join("/");
    };
    exports.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support2.nodebuffer && nodejsUtils2.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support2.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support2.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports.checkSupport = function(type2) {
      var supported = support2[type2.toLowerCase()];
      if (!supported) {
        throw new Error(type2 + " is not supported by this platform");
      }
    };
    exports.MAX_VALUE_16BITS = 65535;
    exports.MAX_VALUE_32BITS = -1;
    exports.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports.inherits = function(ctor, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor.prototype = new Obj();
    };
    exports.extend = function() {
      var result = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result[attr] === "undefined") {
            result[attr] = arguments[i][attr];
          }
        }
      }
      return result;
    };
    exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise2 = external2.Promise.resolve(inputData).then(function(data2) {
        var isBlob2 = support2.blob && (data2 instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data2)) !== -1);
        if (isBlob2 && typeof FileReader !== "undefined") {
          return new external2.Promise(function(resolve, reject2) {
            var reader2 = new FileReader();
            reader2.onload = function(e) {
              resolve(e.target.result);
            };
            reader2.onerror = function(e) {
              reject2(e.target.error);
            };
            reader2.readAsArrayBuffer(data2);
          });
        } else {
          return data2;
        }
      });
      return promise2.then(function(data2) {
        var dataType = exports.getTypeOf(data2);
        if (!dataType) {
          return external2.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data2 = exports.transformTo("uint8array", data2);
        } else if (dataType === "string") {
          if (isBase64) {
            data2 = base642.decode(data2);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data2 = string2binary(data2);
            }
          }
        }
        return data2;
      });
    };
  })(utils);
  return utils;
}
var GenericWorker_1;
var hasRequiredGenericWorker;
function requireGenericWorker() {
  if (hasRequiredGenericWorker) return GenericWorker_1;
  hasRequiredGenericWorker = 1;
  function GenericWorker(name) {
    this.name = name || "default";
    this.streamInfo = {};
    this.generatedError = null;
    this.extraStreamInfo = {};
    this.isPaused = true;
    this.isFinished = false;
    this.isLocked = false;
    this._listeners = {
      "data": [],
      "end": [],
      "error": []
    };
    this.previous = null;
  }
  GenericWorker.prototype = {
    /**
     * Push a chunk to the next workers.
     * @param {Object} chunk the chunk to push
     */
    push: function(chunk) {
      this.emit("data", chunk);
    },
    /**
     * End the stream.
     * @return {Boolean} true if this call ended the worker, false otherwise.
     */
    end: function() {
      if (this.isFinished) {
        return false;
      }
      this.flush();
      try {
        this.emit("end");
        this.cleanUp();
        this.isFinished = true;
      } catch (e) {
        this.emit("error", e);
      }
      return true;
    },
    /**
     * End the stream with an error.
     * @param {Error} e the error which caused the premature end.
     * @return {Boolean} true if this call ended the worker with an error, false otherwise.
     */
    error: function(e) {
      if (this.isFinished) {
        return false;
      }
      if (this.isPaused) {
        this.generatedError = e;
      } else {
        this.isFinished = true;
        this.emit("error", e);
        if (this.previous) {
          this.previous.error(e);
        }
        this.cleanUp();
      }
      return true;
    },
    /**
     * Add a callback on an event.
     * @param {String} name the name of the event (data, end, error)
     * @param {Function} listener the function to call when the event is triggered
     * @return {GenericWorker} the current object for chainability
     */
    on: function(name, listener) {
      this._listeners[name].push(listener);
      return this;
    },
    /**
     * Clean any references when a worker is ending.
     */
    cleanUp: function() {
      this.streamInfo = this.generatedError = this.extraStreamInfo = null;
      this._listeners = [];
    },
    /**
     * Trigger an event. This will call registered callback with the provided arg.
     * @param {String} name the name of the event (data, end, error)
     * @param {Object} arg the argument to call the callback with.
     */
    emit: function(name, arg) {
      if (this._listeners[name]) {
        for (var i = 0; i < this._listeners[name].length; i++) {
          this._listeners[name][i].call(this, arg);
        }
      }
    },
    /**
     * Chain a worker with an other.
     * @param {Worker} next the worker receiving events from the current one.
     * @return {worker} the next worker for chainability
     */
    pipe: function(next) {
      return next.registerPrevious(this);
    },
    /**
     * Same as `pipe` in the other direction.
     * Using an API with `pipe(next)` is very easy.
     * Implementing the API with the point of view of the next one registering
     * a source is easier, see the ZipFileWorker.
     * @param {Worker} previous the previous worker, sending events to this one
     * @return {Worker} the current worker for chainability
     */
    registerPrevious: function(previous) {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.streamInfo = previous.streamInfo;
      this.mergeStreamInfo();
      this.previous = previous;
      var self2 = this;
      previous.on("data", function(chunk) {
        self2.processChunk(chunk);
      });
      previous.on("end", function() {
        self2.end();
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    },
    /**
     * Pause the stream so it doesn't send events anymore.
     * @return {Boolean} true if this call paused the worker, false otherwise.
     */
    pause: function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = true;
      if (this.previous) {
        this.previous.pause();
      }
      return true;
    },
    /**
     * Resume a paused stream.
     * @return {Boolean} true if this call resumed the worker, false otherwise.
     */
    resume: function() {
      if (!this.isPaused || this.isFinished) {
        return false;
      }
      this.isPaused = false;
      var withError = false;
      if (this.generatedError) {
        this.error(this.generatedError);
        withError = true;
      }
      if (this.previous) {
        this.previous.resume();
      }
      return !withError;
    },
    /**
     * Flush any remaining bytes as the stream is ending.
     */
    flush: function() {
    },
    /**
     * Process a chunk. This is usually the method overridden.
     * @param {Object} chunk the chunk to process.
     */
    processChunk: function(chunk) {
      this.push(chunk);
    },
    /**
     * Add a key/value to be added in the workers chain streamInfo once activated.
     * @param {String} key the key to use
     * @param {Object} value the associated value
     * @return {Worker} the current worker for chainability
     */
    withStreamInfo: function(key, value) {
      this.extraStreamInfo[key] = value;
      this.mergeStreamInfo();
      return this;
    },
    /**
     * Merge this worker's streamInfo into the chain's streamInfo.
     */
    mergeStreamInfo: function() {
      for (var key in this.extraStreamInfo) {
        if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
          continue;
        }
        this.streamInfo[key] = this.extraStreamInfo[key];
      }
    },
    /**
     * Lock the stream to prevent further updates on the workers chain.
     * After calling this method, all calls to pipe will fail.
     */
    lock: function() {
      if (this.isLocked) {
        throw new Error("The stream '" + this + "' has already been used.");
      }
      this.isLocked = true;
      if (this.previous) {
        this.previous.lock();
      }
    },
    /**
     *
     * Pretty print the workers chain.
     */
    toString: function() {
      var me = "Worker " + this.name;
      if (this.previous) {
        return this.previous + " -> " + me;
      } else {
        return me;
      }
    }
  };
  GenericWorker_1 = GenericWorker;
  return GenericWorker_1;
}
var hasRequiredUtf8;
function requireUtf8() {
  if (hasRequiredUtf8) return utf8;
  hasRequiredUtf8 = 1;
  (function(exports) {
    var utils2 = requireUtils$1();
    var support2 = requireSupport();
    var nodejsUtils2 = requireNodejsUtils();
    var GenericWorker = requireGenericWorker();
    var _utf8len = new Array(256);
    for (var i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support2.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils2.applyFromCharCode(utf16buf);
    };
    exports.utf8encode = function utf8encode(str) {
      if (support2.nodebuffer) {
        return nodejsUtils2.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports.utf8decode = function utf8decode(buf) {
      if (support2.nodebuffer) {
        return utils2.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils2.transformTo(support2.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils2.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk) {
      var data2 = utils2.transformTo(support2.uint8array ? "uint8array" : "array", chunk.data);
      if (this.leftOver && this.leftOver.length) {
        if (support2.uint8array) {
          var previousData = data2;
          data2 = new Uint8Array(previousData.length + this.leftOver.length);
          data2.set(this.leftOver, 0);
          data2.set(previousData, this.leftOver.length);
        } else {
          data2 = this.leftOver.concat(data2);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data2);
      var usableData = data2;
      if (nextBoundary !== data2.length) {
        if (support2.uint8array) {
          usableData = data2.subarray(0, nextBoundary);
          this.leftOver = data2.subarray(nextBoundary, data2.length);
        } else {
          usableData = data2.slice(0, nextBoundary);
          this.leftOver = data2.slice(nextBoundary, data2.length);
        }
      }
      this.push({
        data: exports.utf8decode(usableData),
        meta: chunk.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils2.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk) {
      this.push({
        data: exports.utf8encode(chunk.data),
        meta: chunk.meta
      });
    };
    exports.Utf8EncodeWorker = Utf8EncodeWorker;
  })(utf8);
  return utf8;
}
var ConvertWorker_1;
var hasRequiredConvertWorker;
function requireConvertWorker() {
  if (hasRequiredConvertWorker) return ConvertWorker_1;
  hasRequiredConvertWorker = 1;
  var GenericWorker = requireGenericWorker();
  var utils2 = requireUtils$1();
  function ConvertWorker(destType) {
    GenericWorker.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  utils2.inherits(ConvertWorker, GenericWorker);
  ConvertWorker.prototype.processChunk = function(chunk) {
    this.push({
      data: utils2.transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  ConvertWorker_1 = ConvertWorker;
  return ConvertWorker_1;
}
var NodejsStreamOutputAdapter_1;
var hasRequiredNodejsStreamOutputAdapter;
function requireNodejsStreamOutputAdapter() {
  if (hasRequiredNodejsStreamOutputAdapter) return NodejsStreamOutputAdapter_1;
  hasRequiredNodejsStreamOutputAdapter = 1;
  var Readable2 = requireReadable$5().Readable;
  var utils2 = requireUtils$1();
  utils2.inherits(NodejsStreamOutputAdapter, Readable2);
  function NodejsStreamOutputAdapter(helper, options, updateCb) {
    Readable2.call(this, options);
    this._helper = helper;
    var self2 = this;
    helper.on("data", function(data2, meta) {
      if (!self2.push(data2)) {
        self2._helper.pause();
      }
      if (updateCb) {
        updateCb(meta);
      }
    }).on("error", function(e) {
      self2.emit("error", e);
    }).on("end", function() {
      self2.push(null);
    });
  }
  NodejsStreamOutputAdapter.prototype._read = function() {
    this._helper.resume();
  };
  NodejsStreamOutputAdapter_1 = NodejsStreamOutputAdapter;
  return NodejsStreamOutputAdapter_1;
}
var StreamHelper_1;
var hasRequiredStreamHelper;
function requireStreamHelper() {
  if (hasRequiredStreamHelper) return StreamHelper_1;
  hasRequiredStreamHelper = 1;
  var utils2 = requireUtils$1();
  var ConvertWorker = requireConvertWorker();
  var GenericWorker = requireGenericWorker();
  var base642 = requireBase64();
  var support2 = requireSupport();
  var external2 = requireExternal();
  var NodejsStreamOutputAdapter = null;
  if (support2.nodestream) {
    try {
      NodejsStreamOutputAdapter = requireNodejsStreamOutputAdapter();
    } catch (e) {
    }
  }
  function transformZipOutput(type2, content, mimeType) {
    switch (type2) {
      case "blob":
        return utils2.newBlob(utils2.transformTo("arraybuffer", content), mimeType);
      case "base64":
        return base642.encode(content);
      default:
        return utils2.transformTo(type2, content);
    }
  }
  function concat2(type2, dataArray) {
    var i, index2 = 0, res = null, totalLength = 0;
    for (i = 0; i < dataArray.length; i++) {
      totalLength += dataArray[i].length;
    }
    switch (type2) {
      case "string":
        return dataArray.join("");
      case "array":
        return Array.prototype.concat.apply([], dataArray);
      case "uint8array":
        res = new Uint8Array(totalLength);
        for (i = 0; i < dataArray.length; i++) {
          res.set(dataArray[i], index2);
          index2 += dataArray[i].length;
        }
        return res;
      case "nodebuffer":
        return Buffer.concat(dataArray);
      default:
        throw new Error("concat : unsupported type '" + type2 + "'");
    }
  }
  function accumulate(helper, updateCallback) {
    return new external2.Promise(function(resolve, reject2) {
      var dataArray = [];
      var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
      helper.on("data", function(data2, meta) {
        dataArray.push(data2);
        if (updateCallback) {
          updateCallback(meta);
        }
      }).on("error", function(err) {
        dataArray = [];
        reject2(err);
      }).on("end", function() {
        try {
          var result = transformZipOutput(resultType, concat2(chunkType, dataArray), mimeType);
          resolve(result);
        } catch (e) {
          reject2(e);
        }
        dataArray = [];
      }).resume();
    });
  }
  function StreamHelper(worker, outputType, mimeType) {
    var internalType = outputType;
    switch (outputType) {
      case "blob":
      case "arraybuffer":
        internalType = "uint8array";
        break;
      case "base64":
        internalType = "string";
        break;
    }
    try {
      this._internalType = internalType;
      this._outputType = outputType;
      this._mimeType = mimeType;
      utils2.checkSupport(internalType);
      this._worker = worker.pipe(new ConvertWorker(internalType));
      worker.lock();
    } catch (e) {
      this._worker = new GenericWorker("error");
      this._worker.error(e);
    }
  }
  StreamHelper.prototype = {
    /**
     * Listen a StreamHelper, accumulate its content and concatenate it into a
     * complete block.
     * @param {Function} updateCb the update callback.
     * @return Promise the promise for the accumulation.
     */
    accumulate: function(updateCb) {
      return accumulate(this, updateCb);
    },
    /**
     * Add a listener on an event triggered on a stream.
     * @param {String} evt the name of the event
     * @param {Function} fn the listener
     * @return {StreamHelper} the current helper.
     */
    on: function(evt, fn) {
      var self2 = this;
      if (evt === "data") {
        this._worker.on(evt, function(chunk) {
          fn.call(self2, chunk.data, chunk.meta);
        });
      } else {
        this._worker.on(evt, function() {
          utils2.delay(fn, arguments, self2);
        });
      }
      return this;
    },
    /**
     * Resume the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    resume: function() {
      utils2.delay(this._worker.resume, [], this._worker);
      return this;
    },
    /**
     * Pause the flow of chunks.
     * @return {StreamHelper} the current helper.
     */
    pause: function() {
      this._worker.pause();
      return this;
    },
    /**
     * Return a nodejs stream for this helper.
     * @param {Function} updateCb the update callback.
     * @return {NodejsStreamOutputAdapter} the nodejs stream.
     */
    toNodejsStream: function(updateCb) {
      utils2.checkSupport("nodestream");
      if (this._outputType !== "nodebuffer") {
        throw new Error(this._outputType + " is not supported by this method");
      }
      return new NodejsStreamOutputAdapter(this, {
        objectMode: this._outputType !== "nodebuffer"
      }, updateCb);
    }
  };
  StreamHelper_1 = StreamHelper;
  return StreamHelper_1;
}
var defaults = {};
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults) return defaults;
  hasRequiredDefaults = 1;
  defaults.base64 = false;
  defaults.binary = false;
  defaults.dir = false;
  defaults.createFolders = true;
  defaults.date = null;
  defaults.compression = null;
  defaults.compressionOptions = null;
  defaults.comment = null;
  defaults.unixPermissions = null;
  defaults.dosPermissions = null;
  return defaults;
}
var DataWorker_1;
var hasRequiredDataWorker;
function requireDataWorker() {
  if (hasRequiredDataWorker) return DataWorker_1;
  hasRequiredDataWorker = 1;
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  var DEFAULT_BLOCK_SIZE = 16 * 1024;
  function DataWorker(dataP) {
    GenericWorker.call(this, "DataWorker");
    var self2 = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data2) {
      self2.dataIsReady = true;
      self2.data = data2;
      self2.max = data2 && data2.length || 0;
      self2.type = utils2.getTypeOf(data2);
      if (!self2.isPaused) {
        self2._tickAndRepeat();
      }
    }, function(e) {
      self2.error(e);
    });
  }
  utils2.inherits(DataWorker, GenericWorker);
  DataWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      utils2.delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker.prototype._tickAndRepeat = function() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      utils2.delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker.prototype._tick = function() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data2 = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data2 = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data2 = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
        case "nodebuffer":
          data2 = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data: data2,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  DataWorker_1 = DataWorker;
  return DataWorker_1;
}
var crc32_1$1;
var hasRequiredCrc32$2;
function requireCrc32$2() {
  if (hasRequiredCrc32$2) return crc32_1$1;
  hasRequiredCrc32$2 = 1;
  var utils2 = requireUtils$1();
  function makeTable() {
    var c, table2 = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table2[n] = c;
    }
    return table2;
  }
  var crcTable = makeTable();
  function crc322(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  function crc32str(crc, str, len, pos) {
    var t = crcTable, end = pos + len;
    crc = crc ^ -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
    }
    return crc ^ -1;
  }
  crc32_1$1 = function crc32wrapper(input, crc) {
    if (typeof input === "undefined" || !input.length) {
      return 0;
    }
    var isArray2 = utils2.getTypeOf(input) !== "string";
    if (isArray2) {
      return crc322(crc | 0, input, input.length, 0);
    } else {
      return crc32str(crc | 0, input, input.length, 0);
    }
  };
  return crc32_1$1;
}
var Crc32Probe_1;
var hasRequiredCrc32Probe;
function requireCrc32Probe() {
  if (hasRequiredCrc32Probe) return Crc32Probe_1;
  hasRequiredCrc32Probe = 1;
  var GenericWorker = requireGenericWorker();
  var crc322 = requireCrc32$2();
  var utils2 = requireUtils$1();
  function Crc32Probe() {
    GenericWorker.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  utils2.inherits(Crc32Probe, GenericWorker);
  Crc32Probe.prototype.processChunk = function(chunk) {
    this.streamInfo.crc32 = crc322(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  Crc32Probe_1 = Crc32Probe;
  return Crc32Probe_1;
}
var DataLengthProbe_1;
var hasRequiredDataLengthProbe;
function requireDataLengthProbe() {
  if (hasRequiredDataLengthProbe) return DataLengthProbe_1;
  hasRequiredDataLengthProbe = 1;
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  function DataLengthProbe(propName) {
    GenericWorker.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  utils2.inherits(DataLengthProbe, GenericWorker);
  DataLengthProbe.prototype.processChunk = function(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker.prototype.processChunk.call(this, chunk);
  };
  DataLengthProbe_1 = DataLengthProbe;
  return DataLengthProbe_1;
}
var compressedObject;
var hasRequiredCompressedObject;
function requireCompressedObject() {
  if (hasRequiredCompressedObject) return compressedObject;
  hasRequiredCompressedObject = 1;
  var external2 = requireExternal();
  var DataWorker = requireDataWorker();
  var Crc32Probe = requireCrc32Probe();
  var DataLengthProbe = requireDataLengthProbe();
  function CompressedObject(compressedSize, uncompressedSize, crc322, compression, data2) {
    this.compressedSize = compressedSize;
    this.uncompressedSize = uncompressedSize;
    this.crc32 = crc322;
    this.compression = compression;
    this.compressedContent = data2;
  }
  CompressedObject.prototype = {
    /**
     * Create a worker to get the uncompressed content.
     * @return {GenericWorker} the worker.
     */
    getContentWorker: function() {
      var worker = new DataWorker(external2.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
      var that = this;
      worker.on("end", function() {
        if (this.streamInfo["data_length"] !== that.uncompressedSize) {
          throw new Error("Bug : uncompressed data size mismatch");
        }
      });
      return worker;
    },
    /**
     * Create a worker to get the compressed content.
     * @return {GenericWorker} the worker.
     */
    getCompressedWorker: function() {
      return new DataWorker(external2.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
    }
  };
  CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
    return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
  };
  compressedObject = CompressedObject;
  return compressedObject;
}
var zipObject;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject) return zipObject;
  hasRequiredZipObject = 1;
  var StreamHelper = requireStreamHelper();
  var DataWorker = requireDataWorker();
  var utf82 = requireUtf8();
  var CompressedObject = requireCompressedObject();
  var GenericWorker = requireGenericWorker();
  var ZipObject = function(name, data2, options) {
    this.name = name;
    this.dir = options.dir;
    this.date = options.date;
    this.comment = options.comment;
    this.unixPermissions = options.unixPermissions;
    this.dosPermissions = options.dosPermissions;
    this._data = data2;
    this._dataBinary = options.binary;
    this.options = {
      compression: options.compression,
      compressionOptions: options.compressionOptions
    };
  };
  ZipObject.prototype = {
    /**
     * Create an internal stream for the content of this object.
     * @param {String} type the type of each chunk.
     * @return StreamHelper the stream.
     */
    internalStream: function(type2) {
      var result = null, outputType = "string";
      try {
        if (!type2) {
          throw new Error("No output type specified.");
        }
        outputType = type2.toLowerCase();
        var askUnicodeString = outputType === "string" || outputType === "text";
        if (outputType === "binarystring" || outputType === "text") {
          outputType = "string";
        }
        result = this._decompressWorker();
        var isUnicodeString = !this._dataBinary;
        if (isUnicodeString && !askUnicodeString) {
          result = result.pipe(new utf82.Utf8EncodeWorker());
        }
        if (!isUnicodeString && askUnicodeString) {
          result = result.pipe(new utf82.Utf8DecodeWorker());
        }
      } catch (e) {
        result = new GenericWorker("error");
        result.error(e);
      }
      return new StreamHelper(result, outputType, "");
    },
    /**
     * Prepare the content in the asked type.
     * @param {String} type the type of the result.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Promise the promise of the result.
     */
    async: function(type2, onUpdate) {
      return this.internalStream(type2).accumulate(onUpdate);
    },
    /**
     * Prepare the content as a nodejs stream.
     * @param {String} type the type of each chunk.
     * @param {Function} onUpdate a function to call on each internal update.
     * @return Stream the stream.
     */
    nodeStream: function(type2, onUpdate) {
      return this.internalStream(type2 || "nodebuffer").toNodejsStream(onUpdate);
    },
    /**
     * Return a worker for the compressed content.
     * @private
     * @param {Object} compression the compression object to use.
     * @param {Object} compressionOptions the options to use when compressing.
     * @return Worker the worker.
     */
    _compressWorker: function(compression, compressionOptions) {
      if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
        return this._data.getCompressedWorker();
      } else {
        var result = this._decompressWorker();
        if (!this._dataBinary) {
          result = result.pipe(new utf82.Utf8EncodeWorker());
        }
        return CompressedObject.createWorkerFrom(result, compression, compressionOptions);
      }
    },
    /**
     * Return a worker for the decompressed content.
     * @private
     * @return Worker the worker.
     */
    _decompressWorker: function() {
      if (this._data instanceof CompressedObject) {
        return this._data.getContentWorker();
      } else if (this._data instanceof GenericWorker) {
        return this._data;
      } else {
        return new DataWorker(this._data);
      }
    }
  };
  var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
  var removedFn = function() {
    throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
  };
  for (var i = 0; i < removedMethods.length; i++) {
    ZipObject.prototype[removedMethods[i]] = removedFn;
  }
  zipObject = ZipObject;
  return zipObject;
}
var generate = {};
var compressions = {};
var flate = {};
var common$1 = {};
var hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1) return common$1;
  hasRequiredCommon$1 = 1;
  (function(exports) {
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports.shrinkBuf = function(buf, size) {
      if (buf.length === size) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size);
      }
      buf.length = size;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports.setTyped = function(on) {
      if (on) {
        exports.Buf8 = Uint8Array;
        exports.Buf16 = Uint16Array;
        exports.Buf32 = Int32Array;
        exports.assign(exports, fnTyped);
      } else {
        exports.Buf8 = Array;
        exports.Buf16 = Array;
        exports.Buf32 = Array;
        exports.assign(exports, fnUntyped);
      }
    };
    exports.setTyped(TYPED_OK);
  })(common$1);
  return common$1;
}
var deflate$1 = {};
var deflate = {};
var trees = {};
var hasRequiredTrees;
function requireTrees() {
  if (hasRequiredTrees) return trees;
  hasRequiredTrees = 1;
  var utils2 = requireCommon$1();
  var Z_FIXED = 4;
  var Z_BINARY = 0;
  var Z_TEXT = 1;
  var Z_UNKNOWN = 2;
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  var STORED_BLOCK = 0;
  var STATIC_TREES = 1;
  var DYN_TREES = 2;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var Buf_size = 16;
  var MAX_BL_BITS = 7;
  var END_BLOCK = 256;
  var REP_3_6 = 16;
  var REPZ_3_10 = 17;
  var REPZ_11_138 = 18;
  var extra_lbits = (
    /* extra bits for each length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
  );
  var extra_dbits = (
    /* extra bits for each distance code */
    [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
  );
  var extra_blbits = (
    /* extra bits for each bit length code */
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
  );
  var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var DIST_CODE_LEN = 512;
  var static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  var static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  var _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  var base_length = new Array(LENGTH_CODES);
  zero(base_length);
  var base_dist = new Array(D_CODES);
  zero(base_dist);
  function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
    this.static_tree = static_tree;
    this.extra_bits = extra_bits;
    this.extra_base = extra_base;
    this.elems = elems;
    this.max_length = max_length;
    this.has_stree = static_tree && static_tree.length;
  }
  var static_l_desc;
  var static_d_desc;
  var static_bl_desc;
  function TreeDesc(dyn_tree, stat_desc) {
    this.dyn_tree = dyn_tree;
    this.max_code = 0;
    this.stat_desc = stat_desc;
  }
  function d_code(dist2) {
    return dist2 < 256 ? _dist_code[dist2] : _dist_code[256 + (dist2 >>> 7)];
  }
  function put_short(s, w) {
    s.pending_buf[s.pending++] = w & 255;
    s.pending_buf[s.pending++] = w >>> 8 & 255;
  }
  function send_bits(s, value, length) {
    if (s.bi_valid > Buf_size - length) {
      s.bi_buf |= value << s.bi_valid & 65535;
      put_short(s, s.bi_buf);
      s.bi_buf = value >> Buf_size - s.bi_valid;
      s.bi_valid += length - Buf_size;
    } else {
      s.bi_buf |= value << s.bi_valid & 65535;
      s.bi_valid += length;
    }
  }
  function send_code(s, c, tree) {
    send_bits(
      s,
      tree[c * 2],
      tree[c * 2 + 1]
      /*.Len*/
    );
  }
  function bi_reverse(code, len) {
    var res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function bi_flush(s) {
    if (s.bi_valid === 16) {
      put_short(s, s.bi_buf);
      s.bi_buf = 0;
      s.bi_valid = 0;
    } else if (s.bi_valid >= 8) {
      s.pending_buf[s.pending++] = s.bi_buf & 255;
      s.bi_buf >>= 8;
      s.bi_valid -= 8;
    }
  }
  function gen_bitlen(s, desc) {
    var tree = desc.dyn_tree;
    var max_code = desc.max_code;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var extra = desc.stat_desc.extra_bits;
    var base = desc.stat_desc.extra_base;
    var max_length = desc.stat_desc.max_length;
    var h;
    var n, m;
    var bits;
    var xbits;
    var f;
    var overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++) {
      s.bl_count[bits] = 0;
    }
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > max_code) {
        continue;
      }
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base) {
        xbits = extra[n - base];
      }
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (has_stree) {
        s.static_len += f * (stree[n * 2 + 1] + xbits);
      }
    }
    if (overflow === 0) {
      return;
    }
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0) {
        bits--;
      }
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > max_code) {
          continue;
        }
        if (tree[m * 2 + 1] !== bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function gen_codes(tree, max_code, bl_count) {
    var next_code = new Array(MAX_BITS + 1);
    var code = 0;
    var bits;
    var n;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      var len = tree[n * 2 + 1];
      if (len === 0) {
        continue;
      }
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  function tr_static_init() {
    var n;
    var bits;
    var length;
    var code;
    var dist2;
    var bl_count = new Array(MAX_BITS + 1);
    length = 0;
    for (code = 0; code < LENGTH_CODES - 1; code++) {
      base_length[code] = length;
      for (n = 0; n < 1 << extra_lbits[code]; n++) {
        _length_code[length++] = code;
      }
    }
    _length_code[length - 1] = code;
    dist2 = 0;
    for (code = 0; code < 16; code++) {
      base_dist[code] = dist2;
      for (n = 0; n < 1 << extra_dbits[code]; n++) {
        _dist_code[dist2++] = code;
      }
    }
    dist2 >>= 7;
    for (; code < D_CODES; code++) {
      base_dist[code] = dist2 << 7;
      for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
        _dist_code[256 + dist2++] = code;
      }
    }
    for (bits = 0; bits <= MAX_BITS; bits++) {
      bl_count[bits] = 0;
    }
    n = 0;
    while (n <= 143) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    while (n <= 255) {
      static_ltree[n * 2 + 1] = 9;
      n++;
      bl_count[9]++;
    }
    while (n <= 279) {
      static_ltree[n * 2 + 1] = 7;
      n++;
      bl_count[7]++;
    }
    while (n <= 287) {
      static_ltree[n * 2 + 1] = 8;
      n++;
      bl_count[8]++;
    }
    gen_codes(static_ltree, L_CODES + 1, bl_count);
    for (n = 0; n < D_CODES; n++) {
      static_dtree[n * 2 + 1] = 5;
      static_dtree[n * 2] = bi_reverse(n, 5);
    }
    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
    static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
  }
  function init_block(s) {
    var n;
    for (n = 0; n < L_CODES; n++) {
      s.dyn_ltree[n * 2] = 0;
    }
    for (n = 0; n < D_CODES; n++) {
      s.dyn_dtree[n * 2] = 0;
    }
    for (n = 0; n < BL_CODES; n++) {
      s.bl_tree[n * 2] = 0;
    }
    s.dyn_ltree[END_BLOCK * 2] = 1;
    s.opt_len = s.static_len = 0;
    s.last_lit = s.matches = 0;
  }
  function bi_windup(s) {
    if (s.bi_valid > 8) {
      put_short(s, s.bi_buf);
    } else if (s.bi_valid > 0) {
      s.pending_buf[s.pending++] = s.bi_buf;
    }
    s.bi_buf = 0;
    s.bi_valid = 0;
  }
  function copy_block(s, buf, len, header) {
    bi_windup(s);
    {
      put_short(s, len);
      put_short(s, ~len);
    }
    utils2.arraySet(s.pending_buf, s.window, buf, len, s.pending);
    s.pending += len;
  }
  function smaller2(tree, n, m, depth) {
    var _n2 = n * 2;
    var _m2 = m * 2;
    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
  }
  function pqdownheap(s, tree, k) {
    var v = s.heap[k];
    var j = k << 1;
    while (j <= s.heap_len) {
      if (j < s.heap_len && smaller2(tree, s.heap[j + 1], s.heap[j], s.depth)) {
        j++;
      }
      if (smaller2(tree, v, s.heap[j], s.depth)) {
        break;
      }
      s.heap[k] = s.heap[j];
      k = j;
      j <<= 1;
    }
    s.heap[k] = v;
  }
  function compress_block(s, ltree, dtree) {
    var dist2;
    var lc;
    var lx = 0;
    var code;
    var extra;
    if (s.last_lit !== 0) {
      do {
        dist2 = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
        lc = s.pending_buf[s.l_buf + lx];
        lx++;
        if (dist2 === 0) {
          send_code(s, lc, ltree);
        } else {
          code = _length_code[lc];
          send_code(s, code + LITERALS + 1, ltree);
          extra = extra_lbits[code];
          if (extra !== 0) {
            lc -= base_length[code];
            send_bits(s, lc, extra);
          }
          dist2--;
          code = d_code(dist2);
          send_code(s, code, dtree);
          extra = extra_dbits[code];
          if (extra !== 0) {
            dist2 -= base_dist[code];
            send_bits(s, dist2, extra);
          }
        }
      } while (lx < s.last_lit);
    }
    send_code(s, END_BLOCK, ltree);
  }
  function build_tree(s, desc) {
    var tree = desc.dyn_tree;
    var stree = desc.stat_desc.static_tree;
    var has_stree = desc.stat_desc.has_stree;
    var elems = desc.stat_desc.elems;
    var n, m;
    var max_code = -1;
    var node2;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node2 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node2 * 2] = 1;
      s.depth[node2] = 0;
      s.opt_len--;
      if (has_stree) {
        s.static_len -= stree[node2 * 2 + 1];
      }
    }
    desc.max_code = max_code;
    for (n = s.heap_len >> 1; n >= 1; n--) {
      pqdownheap(s, tree, n);
    }
    node2 = elems;
    do {
      n = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[
        1
        /*SMALLEST*/
      ] = s.heap[s.heap_len--];
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
      m = s.heap[
        1
        /*SMALLEST*/
      ];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node2 * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node2] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node2;
      s.heap[
        1
        /*SMALLEST*/
      ] = node2++;
      pqdownheap(
        s,
        tree,
        1
        /*SMALLEST*/
      );
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[
      1
      /*SMALLEST*/
    ];
    gen_bitlen(s, desc);
    gen_codes(tree, max_code, s.bl_count);
  }
  function scan_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        s.bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          s.bl_tree[curlen * 2]++;
        }
        s.bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        s.bl_tree[REPZ_3_10 * 2]++;
      } else {
        s.bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_tree(s, tree, max_code) {
    var n;
    var prevlen = -1;
    var curlen;
    var nextlen = tree[0 * 2 + 1];
    var count = 0;
    var max_count = 7;
    var min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen === nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(s, curlen, s.bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen !== prevlen) {
          send_code(s, curlen, s.bl_tree);
          count--;
        }
        send_code(s, REP_3_6, s.bl_tree);
        send_bits(s, count - 3, 2);
      } else if (count <= 10) {
        send_code(s, REPZ_3_10, s.bl_tree);
        send_bits(s, count - 3, 3);
      } else {
        send_code(s, REPZ_11_138, s.bl_tree);
        send_bits(s, count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen === nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree(s) {
    var max_blindex;
    scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
    scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
    build_tree(s, s.bl_desc);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
        break;
      }
    }
    s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function send_all_trees(s, lcodes, dcodes, blcodes) {
    var rank;
    send_bits(s, lcodes - 257, 5);
    send_bits(s, dcodes - 1, 5);
    send_bits(s, blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
    }
    send_tree(s, s.dyn_ltree, lcodes - 1);
    send_tree(s, s.dyn_dtree, dcodes - 1);
  }
  function detect_data_type(s) {
    var black_mask = 4093624447;
    var n;
    for (n = 0; n <= 31; n++, black_mask >>>= 1) {
      if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
        return Z_BINARY;
      }
    }
    if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
      return Z_TEXT;
    }
    for (n = 32; n < LITERALS; n++) {
      if (s.dyn_ltree[n * 2] !== 0) {
        return Z_TEXT;
      }
    }
    return Z_BINARY;
  }
  var static_init_done = false;
  function _tr_init(s) {
    if (!static_init_done) {
      tr_static_init();
      static_init_done = true;
    }
    s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
    s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
    s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
    s.bi_buf = 0;
    s.bi_valid = 0;
    init_block(s);
  }
  function _tr_stored_block(s, buf, stored_len, last) {
    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
    copy_block(s, buf, stored_len);
  }
  function _tr_align(s) {
    send_bits(s, STATIC_TREES << 1, 3);
    send_code(s, END_BLOCK, static_ltree);
    bi_flush(s);
  }
  function _tr_flush_block(s, buf, stored_len, last) {
    var opt_lenb, static_lenb;
    var max_blindex = 0;
    if (s.level > 0) {
      if (s.strm.data_type === Z_UNKNOWN) {
        s.strm.data_type = detect_data_type(s);
      }
      build_tree(s, s.l_desc);
      build_tree(s, s.d_desc);
      max_blindex = build_bl_tree(s);
      opt_lenb = s.opt_len + 3 + 7 >>> 3;
      static_lenb = s.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb) {
        opt_lenb = static_lenb;
      }
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf !== -1) {
      _tr_stored_block(s, buf, stored_len, last);
    } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
      send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
      compress_block(s, static_ltree, static_dtree);
    } else {
      send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
      send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
      compress_block(s, s.dyn_ltree, s.dyn_dtree);
    }
    init_block(s);
    if (last) {
      bi_windup(s);
    }
  }
  function _tr_tally(s, dist2, lc) {
    s.pending_buf[s.d_buf + s.last_lit * 2] = dist2 >>> 8 & 255;
    s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist2 & 255;
    s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
    s.last_lit++;
    if (dist2 === 0) {
      s.dyn_ltree[lc * 2]++;
    } else {
      s.matches++;
      dist2--;
      s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
      s.dyn_dtree[d_code(dist2) * 2]++;
    }
    return s.last_lit === s.lit_bufsize - 1;
  }
  trees._tr_init = _tr_init;
  trees._tr_stored_block = _tr_stored_block;
  trees._tr_flush_block = _tr_flush_block;
  trees._tr_tally = _tr_tally;
  trees._tr_align = _tr_align;
  return trees;
}
var adler32_1;
var hasRequiredAdler32;
function requireAdler32() {
  if (hasRequiredAdler32) return adler32_1;
  hasRequiredAdler32 = 1;
  function adler32(adler, buf, len, pos) {
    var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
    while (len !== 0) {
      n = len > 2e3 ? 2e3 : len;
      len -= n;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  }
  adler32_1 = adler32;
  return adler32_1;
}
var crc32_1;
var hasRequiredCrc32$1;
function requireCrc32$1() {
  if (hasRequiredCrc32$1) return crc32_1;
  hasRequiredCrc32$1 = 1;
  function makeTable() {
    var c, table2 = [];
    for (var n = 0; n < 256; n++) {
      c = n;
      for (var k = 0; k < 8; k++) {
        c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
      }
      table2[n] = c;
    }
    return table2;
  }
  var crcTable = makeTable();
  function crc322(crc, buf, len, pos) {
    var t = crcTable, end = pos + len;
    crc ^= -1;
    for (var i = pos; i < end; i++) {
      crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
    }
    return crc ^ -1;
  }
  crc32_1 = crc322;
  return crc32_1;
}
var messages;
var hasRequiredMessages;
function requireMessages() {
  if (hasRequiredMessages) return messages;
  hasRequiredMessages = 1;
  messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  return messages;
}
var hasRequiredDeflate$1;
function requireDeflate$1() {
  if (hasRequiredDeflate$1) return deflate;
  hasRequiredDeflate$1 = 1;
  var utils2 = requireCommon$1();
  var trees2 = requireTrees();
  var adler32 = requireAdler32();
  var crc322 = requireCrc32$1();
  var msg = requireMessages();
  var Z_NO_FLUSH = 0;
  var Z_PARTIAL_FLUSH = 1;
  var Z_FULL_FLUSH = 3;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_BUF_ERROR = -5;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_FILTERED = 1;
  var Z_HUFFMAN_ONLY = 2;
  var Z_RLE = 3;
  var Z_FIXED = 4;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_UNKNOWN = 2;
  var Z_DEFLATED = 8;
  var MAX_MEM_LEVEL = 9;
  var MAX_WBITS = 15;
  var DEF_MEM_LEVEL = 8;
  var LENGTH_CODES = 29;
  var LITERALS = 256;
  var L_CODES = LITERALS + 1 + LENGTH_CODES;
  var D_CODES = 30;
  var BL_CODES = 19;
  var HEAP_SIZE = 2 * L_CODES + 1;
  var MAX_BITS = 15;
  var MIN_MATCH = 3;
  var MAX_MATCH = 258;
  var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
  var PRESET_DICT = 32;
  var INIT_STATE = 42;
  var EXTRA_STATE = 69;
  var NAME_STATE = 73;
  var COMMENT_STATE = 91;
  var HCRC_STATE = 103;
  var BUSY_STATE = 113;
  var FINISH_STATE = 666;
  var BS_NEED_MORE = 1;
  var BS_BLOCK_DONE = 2;
  var BS_FINISH_STARTED = 3;
  var BS_FINISH_DONE = 4;
  var OS_CODE = 3;
  function err(strm, errorCode) {
    strm.msg = msg[errorCode];
    return errorCode;
  }
  function rank(f) {
    return (f << 1) - (f > 4 ? 9 : 0);
  }
  function zero(buf) {
    var len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  function flush_pending(strm) {
    var s = strm.state;
    var len = s.pending;
    if (len > strm.avail_out) {
      len = strm.avail_out;
    }
    if (len === 0) {
      return;
    }
    utils2.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
    strm.next_out += len;
    s.pending_out += len;
    strm.total_out += len;
    strm.avail_out -= len;
    s.pending -= len;
    if (s.pending === 0) {
      s.pending_out = 0;
    }
  }
  function flush_block_only(s, last) {
    trees2._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);
    s.block_start = s.strstart;
    flush_pending(s.strm);
  }
  function put_byte(s, b) {
    s.pending_buf[s.pending++] = b;
  }
  function putShortMSB(s, b) {
    s.pending_buf[s.pending++] = b >>> 8 & 255;
    s.pending_buf[s.pending++] = b & 255;
  }
  function read_buf(strm, buf, start, size) {
    var len = strm.avail_in;
    if (len > size) {
      len = size;
    }
    if (len === 0) {
      return 0;
    }
    strm.avail_in -= len;
    utils2.arraySet(buf, strm.input, strm.next_in, len, start);
    if (strm.state.wrap === 1) {
      strm.adler = adler32(strm.adler, buf, len, start);
    } else if (strm.state.wrap === 2) {
      strm.adler = crc322(strm.adler, buf, len, start);
    }
    strm.next_in += len;
    strm.total_in += len;
    return len;
  }
  function longest_match(s, cur_match) {
    var chain_length = s.max_chain_length;
    var scan = s.strstart;
    var match;
    var len;
    var best_len = s.prev_length;
    var nice_match = s.nice_match;
    var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
    var _win = s.window;
    var wmask = s.w_mask;
    var prev = s.prev;
    var strend = s.strstart + MAX_MATCH;
    var scan_end1 = _win[scan + best_len - 1];
    var scan_end = _win[scan + best_len];
    if (s.prev_length >= s.good_match) {
      chain_length >>= 2;
    }
    if (nice_match > s.lookahead) {
      nice_match = s.lookahead;
    }
    do {
      match = cur_match;
      if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
        continue;
      }
      scan += 2;
      match++;
      do {
      } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        s.match_start = cur_match;
        best_len = len;
        if (len >= nice_match) {
          break;
        }
        scan_end1 = _win[scan + best_len - 1];
        scan_end = _win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
    if (best_len <= s.lookahead) {
      return best_len;
    }
    return s.lookahead;
  }
  function fill_window(s) {
    var _w_size = s.w_size;
    var p, n, m, more, str;
    do {
      more = s.window_size - s.lookahead - s.strstart;
      if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
        utils2.arraySet(s.window, s.window, _w_size, _w_size, 0);
        s.match_start -= _w_size;
        s.strstart -= _w_size;
        s.block_start -= _w_size;
        n = s.hash_size;
        p = n;
        do {
          m = s.head[--p];
          s.head[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        n = _w_size;
        p = n;
        do {
          m = s.prev[--p];
          s.prev[p] = m >= _w_size ? m - _w_size : 0;
        } while (--n);
        more += _w_size;
      }
      if (s.strm.avail_in === 0) {
        break;
      }
      n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
      s.lookahead += n;
      if (s.lookahead + s.insert >= MIN_MATCH) {
        str = s.strstart - s.insert;
        s.ins_h = s.window[str];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
        while (s.insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
          s.insert--;
          if (s.lookahead + s.insert < MIN_MATCH) {
            break;
          }
        }
      }
    } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  }
  function deflate_stored(s, flush) {
    var max_block_size = 65535;
    if (max_block_size > s.pending_buf_size - 5) {
      max_block_size = s.pending_buf_size - 5;
    }
    for (; ; ) {
      if (s.lookahead <= 1) {
        fill_window(s);
        if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.strstart += s.lookahead;
      s.lookahead = 0;
      var max_start = s.block_start + max_block_size;
      if (s.strstart === 0 || s.strstart >= max_start) {
        s.lookahead = s.strstart - max_start;
        s.strstart = max_start;
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.strstart > s.block_start) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_NEED_MORE;
  }
  function deflate_fast(s, flush) {
    var hash_head;
    var bflush;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
          s.match_length--;
          do {
            s.strstart++;
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          } while (--s.match_length !== 0);
          s.strstart++;
        } else {
          s.strstart += s.match_length;
          s.match_length = 0;
          s.ins_h = s.window[s.strstart];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
        }
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_slow(s, flush) {
    var hash_head;
    var bflush;
    var max_insert;
    for (; ; ) {
      if (s.lookahead < MIN_LOOKAHEAD) {
        fill_window(s);
        if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      hash_head = 0;
      if (s.lookahead >= MIN_MATCH) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
        hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = s.strstart;
      }
      s.prev_length = s.match_length;
      s.prev_match = s.match_start;
      s.match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
        s.match_length = longest_match(s, hash_head);
        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
          s.match_length = MIN_MATCH - 1;
        }
      }
      if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
        max_insert = s.strstart + s.lookahead - MIN_MATCH;
        bflush = trees2._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
        s.lookahead -= s.prev_length - 1;
        s.prev_length -= 2;
        do {
          if (++s.strstart <= max_insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = s.strstart;
          }
        } while (--s.prev_length !== 0);
        s.match_available = 0;
        s.match_length = MIN_MATCH - 1;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      } else if (s.match_available) {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
        if (bflush) {
          flush_block_only(s, false);
        }
        s.strstart++;
        s.lookahead--;
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      } else {
        s.match_available = 1;
        s.strstart++;
        s.lookahead--;
      }
    }
    if (s.match_available) {
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart - 1]);
      s.match_available = 0;
    }
    s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_rle(s, flush) {
    var bflush;
    var prev;
    var scan, strend;
    var _win = s.window;
    for (; ; ) {
      if (s.lookahead <= MAX_MATCH) {
        fill_window(s);
        if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        if (s.lookahead === 0) {
          break;
        }
      }
      s.match_length = 0;
      if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
        scan = s.strstart - 1;
        prev = _win[scan];
        if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
          strend = s.strstart + MAX_MATCH;
          do {
          } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
          s.match_length = MAX_MATCH - (strend - scan);
          if (s.match_length > s.lookahead) {
            s.match_length = s.lookahead;
          }
        }
      }
      if (s.match_length >= MIN_MATCH) {
        bflush = trees2._tr_tally(s, 1, s.match_length - MIN_MATCH);
        s.lookahead -= s.match_length;
        s.strstart += s.match_length;
        s.match_length = 0;
      } else {
        bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
      }
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function deflate_huff(s, flush) {
    var bflush;
    for (; ; ) {
      if (s.lookahead === 0) {
        fill_window(s);
        if (s.lookahead === 0) {
          if (flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          break;
        }
      }
      s.match_length = 0;
      bflush = trees2._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    }
    s.insert = 0;
    if (flush === Z_FINISH) {
      flush_block_only(s, true);
      if (s.strm.avail_out === 0) {
        return BS_FINISH_STARTED;
      }
      return BS_FINISH_DONE;
    }
    if (s.last_lit) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    return BS_BLOCK_DONE;
  }
  function Config(good_length, max_lazy, nice_length, max_chain, func) {
    this.good_length = good_length;
    this.max_lazy = max_lazy;
    this.nice_length = nice_length;
    this.max_chain = max_chain;
    this.func = func;
  }
  var configuration_table;
  configuration_table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  function lm_init(s) {
    s.window_size = 2 * s.w_size;
    zero(s.head);
    s.max_lazy_match = configuration_table[s.level].max_lazy;
    s.good_match = configuration_table[s.level].good_length;
    s.nice_match = configuration_table[s.level].nice_length;
    s.max_chain_length = configuration_table[s.level].max_chain;
    s.strstart = 0;
    s.block_start = 0;
    s.lookahead = 0;
    s.insert = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    s.ins_h = 0;
  }
  function DeflateState() {
    this.strm = null;
    this.status = 0;
    this.pending_buf = null;
    this.pending_buf_size = 0;
    this.pending_out = 0;
    this.pending = 0;
    this.wrap = 0;
    this.gzhead = null;
    this.gzindex = 0;
    this.method = Z_DEFLATED;
    this.last_flush = -1;
    this.w_size = 0;
    this.w_bits = 0;
    this.w_mask = 0;
    this.window = null;
    this.window_size = 0;
    this.prev = null;
    this.head = null;
    this.ins_h = 0;
    this.hash_size = 0;
    this.hash_bits = 0;
    this.hash_mask = 0;
    this.hash_shift = 0;
    this.block_start = 0;
    this.match_length = 0;
    this.prev_match = 0;
    this.match_available = 0;
    this.strstart = 0;
    this.match_start = 0;
    this.lookahead = 0;
    this.prev_length = 0;
    this.max_chain_length = 0;
    this.max_lazy_match = 0;
    this.level = 0;
    this.strategy = 0;
    this.good_match = 0;
    this.nice_match = 0;
    this.dyn_ltree = new utils2.Buf16(HEAP_SIZE * 2);
    this.dyn_dtree = new utils2.Buf16((2 * D_CODES + 1) * 2);
    this.bl_tree = new utils2.Buf16((2 * BL_CODES + 1) * 2);
    zero(this.dyn_ltree);
    zero(this.dyn_dtree);
    zero(this.bl_tree);
    this.l_desc = null;
    this.d_desc = null;
    this.bl_desc = null;
    this.bl_count = new utils2.Buf16(MAX_BITS + 1);
    this.heap = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.heap);
    this.heap_len = 0;
    this.heap_max = 0;
    this.depth = new utils2.Buf16(2 * L_CODES + 1);
    zero(this.depth);
    this.l_buf = 0;
    this.lit_bufsize = 0;
    this.last_lit = 0;
    this.d_buf = 0;
    this.opt_len = 0;
    this.static_len = 0;
    this.matches = 0;
    this.insert = 0;
    this.bi_buf = 0;
    this.bi_valid = 0;
  }
  function deflateResetKeep(strm) {
    var s;
    if (!strm || !strm.state) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.total_in = strm.total_out = 0;
    strm.data_type = Z_UNKNOWN;
    s = strm.state;
    s.pending = 0;
    s.pending_out = 0;
    if (s.wrap < 0) {
      s.wrap = -s.wrap;
    }
    s.status = s.wrap ? INIT_STATE : BUSY_STATE;
    strm.adler = s.wrap === 2 ? 0 : 1;
    s.last_flush = Z_NO_FLUSH;
    trees2._tr_init(s);
    return Z_OK;
  }
  function deflateReset(strm) {
    var ret = deflateResetKeep(strm);
    if (ret === Z_OK) {
      lm_init(strm.state);
    }
    return ret;
  }
  function deflateSetHeader(strm, head) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    if (strm.state.wrap !== 2) {
      return Z_STREAM_ERROR;
    }
    strm.state.gzhead = head;
    return Z_OK;
  }
  function deflateInit2(strm, level, method2, windowBits, memLevel, strategy) {
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    var wrap2 = 1;
    if (level === Z_DEFAULT_COMPRESSION) {
      level = 6;
    }
    if (windowBits < 0) {
      wrap2 = 0;
      windowBits = -windowBits;
    } else if (windowBits > 15) {
      wrap2 = 2;
      windowBits -= 16;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method2 !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
      return err(strm, Z_STREAM_ERROR);
    }
    if (windowBits === 8) {
      windowBits = 9;
    }
    var s = new DeflateState();
    strm.state = s;
    s.strm = strm;
    s.wrap = wrap2;
    s.gzhead = null;
    s.w_bits = windowBits;
    s.w_size = 1 << s.w_bits;
    s.w_mask = s.w_size - 1;
    s.hash_bits = memLevel + 7;
    s.hash_size = 1 << s.hash_bits;
    s.hash_mask = s.hash_size - 1;
    s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    s.window = new utils2.Buf8(s.w_size * 2);
    s.head = new utils2.Buf16(s.hash_size);
    s.prev = new utils2.Buf16(s.w_size);
    s.lit_bufsize = 1 << memLevel + 6;
    s.pending_buf_size = s.lit_bufsize * 4;
    s.pending_buf = new utils2.Buf8(s.pending_buf_size);
    s.d_buf = 1 * s.lit_bufsize;
    s.l_buf = (1 + 2) * s.lit_bufsize;
    s.level = level;
    s.strategy = strategy;
    s.method = method2;
    return deflateReset(strm);
  }
  function deflateInit(strm, level) {
    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
  }
  function deflate$12(strm, flush) {
    var old_flush, s;
    var beg, val;
    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
      return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
    }
    s = strm.state;
    if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
      return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
    }
    s.strm = strm;
    old_flush = s.last_flush;
    s.last_flush = flush;
    if (s.status === INIT_STATE) {
      if (s.wrap === 2) {
        strm.adler = 0;
        put_byte(s, 31);
        put_byte(s, 139);
        put_byte(s, 8);
        if (!s.gzhead) {
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, 0);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, OS_CODE);
          s.status = BUSY_STATE;
        } else {
          put_byte(
            s,
            (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
          );
          put_byte(s, s.gzhead.time & 255);
          put_byte(s, s.gzhead.time >> 8 & 255);
          put_byte(s, s.gzhead.time >> 16 & 255);
          put_byte(s, s.gzhead.time >> 24 & 255);
          put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
          put_byte(s, s.gzhead.os & 255);
          if (s.gzhead.extra && s.gzhead.extra.length) {
            put_byte(s, s.gzhead.extra.length & 255);
            put_byte(s, s.gzhead.extra.length >> 8 & 255);
          }
          if (s.gzhead.hcrc) {
            strm.adler = crc322(strm.adler, s.pending_buf, s.pending, 0);
          }
          s.gzindex = 0;
          s.status = EXTRA_STATE;
        }
      } else {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;
        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }
        header |= level_flags << 6;
        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }
        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 65535);
        }
        strm.adler = 1;
      }
    }
    if (s.status === EXTRA_STATE) {
      if (s.gzhead.extra) {
        beg = s.pending;
        while (s.gzindex < (s.gzhead.extra.length & 65535)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              break;
            }
          }
          put_byte(s, s.gzhead.extra[s.gzindex] & 255);
          s.gzindex++;
        }
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
        s.status = NAME_STATE;
      }
    }
    if (s.status === NAME_STATE) {
      if (s.gzhead.name) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
        s.status = COMMENT_STATE;
      }
    }
    if (s.status === COMMENT_STATE) {
      if (s.gzhead.comment) {
        beg = s.pending;
        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
            }
            flush_pending(strm);
            beg = s.pending;
            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          }
          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
          } else {
            val = 0;
          }
          put_byte(s, val);
        } while (val !== 0);
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc322(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
        s.status = HCRC_STATE;
      }
    }
    if (s.status === HCRC_STATE) {
      if (s.gzhead.hcrc) {
        if (s.pending + 2 > s.pending_buf_size) {
          flush_pending(strm);
        }
        if (s.pending + 2 <= s.pending_buf_size) {
          put_byte(s, strm.adler & 255);
          put_byte(s, strm.adler >> 8 & 255);
          strm.adler = 0;
          s.status = BUSY_STATE;
        }
      } else {
        s.status = BUSY_STATE;
      }
    }
    if (s.pending !== 0) {
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
      return err(strm, Z_BUF_ERROR);
    }
    if (s.status === FINISH_STATE && strm.avail_in !== 0) {
      return err(strm, Z_BUF_ERROR);
    }
    if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
      var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
      if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
        s.status = FINISH_STATE;
      }
      if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
        if (strm.avail_out === 0) {
          s.last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate === BS_BLOCK_DONE) {
        if (flush === Z_PARTIAL_FLUSH) {
          trees2._tr_align(s);
        } else if (flush !== Z_BLOCK) {
          trees2._tr_stored_block(s, 0, 0, false);
          if (flush === Z_FULL_FLUSH) {
            zero(s.head);
            if (s.lookahead === 0) {
              s.strstart = 0;
              s.block_start = 0;
              s.insert = 0;
            }
          }
        }
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush !== Z_FINISH) {
      return Z_OK;
    }
    if (s.wrap <= 0) {
      return Z_STREAM_END;
    }
    if (s.wrap === 2) {
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      put_byte(s, strm.adler >> 16 & 255);
      put_byte(s, strm.adler >> 24 & 255);
      put_byte(s, strm.total_in & 255);
      put_byte(s, strm.total_in >> 8 & 255);
      put_byte(s, strm.total_in >> 16 & 255);
      put_byte(s, strm.total_in >> 24 & 255);
    } else {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    flush_pending(strm);
    if (s.wrap > 0) {
      s.wrap = -s.wrap;
    }
    return s.pending !== 0 ? Z_OK : Z_STREAM_END;
  }
  function deflateEnd(strm) {
    var status;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    status = strm.state.status;
    if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
      return err(strm, Z_STREAM_ERROR);
    }
    strm.state = null;
    return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
  }
  function deflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var s;
    var str, n;
    var wrap2;
    var avail;
    var next;
    var input;
    var tmpDict;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    s = strm.state;
    wrap2 = s.wrap;
    if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
      return Z_STREAM_ERROR;
    }
    if (wrap2 === 1) {
      strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
    }
    s.wrap = 0;
    if (dictLength >= s.w_size) {
      if (wrap2 === 0) {
        zero(s.head);
        s.strstart = 0;
        s.block_start = 0;
        s.insert = 0;
      }
      tmpDict = new utils2.Buf8(s.w_size);
      utils2.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
      dictionary = tmpDict;
      dictLength = s.w_size;
    }
    avail = strm.avail_in;
    next = strm.next_in;
    input = strm.input;
    strm.avail_in = dictLength;
    strm.next_in = 0;
    strm.input = dictionary;
    fill_window(s);
    while (s.lookahead >= MIN_MATCH) {
      str = s.strstart;
      n = s.lookahead - (MIN_MATCH - 1);
      do {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
      } while (--n);
      s.strstart = str;
      s.lookahead = MIN_MATCH - 1;
      fill_window(s);
    }
    s.strstart += s.lookahead;
    s.block_start = s.strstart;
    s.insert = s.lookahead;
    s.lookahead = 0;
    s.match_length = s.prev_length = MIN_MATCH - 1;
    s.match_available = 0;
    strm.next_in = next;
    strm.input = input;
    strm.avail_in = avail;
    s.wrap = wrap2;
    return Z_OK;
  }
  deflate.deflateInit = deflateInit;
  deflate.deflateInit2 = deflateInit2;
  deflate.deflateReset = deflateReset;
  deflate.deflateResetKeep = deflateResetKeep;
  deflate.deflateSetHeader = deflateSetHeader;
  deflate.deflate = deflate$12;
  deflate.deflateEnd = deflateEnd;
  deflate.deflateSetDictionary = deflateSetDictionary;
  deflate.deflateInfo = "pako deflate (from Nodeca project)";
  return deflate;
}
var strings = {};
var hasRequiredStrings;
function requireStrings() {
  if (hasRequiredStrings) return strings;
  hasRequiredStrings = 1;
  var utils2 = requireCommon$1();
  var STR_APPLY_OK = true;
  var STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (__) {
    STR_APPLY_OK = false;
  }
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  var _utf8len = new utils2.Buf8(256);
  for (var q = 0; q < 256; q++) {
    _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  strings.string2buf = function(str) {
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
    }
    buf = new utils2.Buf8(buf_len);
    for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
      c = str.charCodeAt(m_pos);
      if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
        c2 = str.charCodeAt(m_pos + 1);
        if ((c2 & 64512) === 56320) {
          c = 65536 + (c - 55296 << 10) + (c2 - 56320);
          m_pos++;
        }
      }
      if (c < 128) {
        buf[i++] = c;
      } else if (c < 2048) {
        buf[i++] = 192 | c >>> 6;
        buf[i++] = 128 | c & 63;
      } else if (c < 65536) {
        buf[i++] = 224 | c >>> 12;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      } else {
        buf[i++] = 240 | c >>> 18;
        buf[i++] = 128 | c >>> 12 & 63;
        buf[i++] = 128 | c >>> 6 & 63;
        buf[i++] = 128 | c & 63;
      }
    }
    return buf;
  };
  function buf2binstring(buf, len) {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
        return String.fromCharCode.apply(null, utils2.shrinkBuf(buf, len));
      }
    }
    var result = "";
    for (var i = 0; i < len; i++) {
      result += String.fromCharCode(buf[i]);
    }
    return result;
  }
  strings.buf2binstring = function(buf) {
    return buf2binstring(buf, buf.length);
  };
  strings.binstring2buf = function(str) {
    var buf = new utils2.Buf8(str.length);
    for (var i = 0, len = buf.length; i < len; i++) {
      buf[i] = str.charCodeAt(i);
    }
    return buf;
  };
  strings.buf2string = function(buf, max2) {
    var i, out, c, c_len;
    var len = max2 || buf.length;
    var utf16buf = new Array(len * 2);
    for (out = 0, i = 0; i < len; ) {
      c = buf[i++];
      if (c < 128) {
        utf16buf[out++] = c;
        continue;
      }
      c_len = _utf8len[c];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i += c_len - 1;
        continue;
      }
      c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i < len) {
        c = c << 6 | buf[i++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c < 65536) {
        utf16buf[out++] = c;
      } else {
        c -= 65536;
        utf16buf[out++] = 55296 | c >> 10 & 1023;
        utf16buf[out++] = 56320 | c & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  strings.utf8border = function(buf, max2) {
    var pos;
    max2 = max2 || buf.length;
    if (max2 > buf.length) {
      max2 = buf.length;
    }
    pos = max2 - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max2;
    }
    if (pos === 0) {
      return max2;
    }
    return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
  };
  return strings;
}
var zstream;
var hasRequiredZstream;
function requireZstream() {
  if (hasRequiredZstream) return zstream;
  hasRequiredZstream = 1;
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  zstream = ZStream;
  return zstream;
}
var hasRequiredDeflate;
function requireDeflate() {
  if (hasRequiredDeflate) return deflate$1;
  hasRequiredDeflate = 1;
  var zlib_deflate = requireDeflate$1();
  var utils2 = requireCommon$1();
  var strings2 = requireStrings();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var toString3 = Object.prototype.toString;
  var Z_NO_FLUSH = 0;
  var Z_FINISH = 4;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_SYNC_FLUSH = 2;
  var Z_DEFAULT_COMPRESSION = -1;
  var Z_DEFAULT_STRATEGY = 0;
  var Z_DEFLATED = 8;
  function Deflate(options) {
    if (!(this instanceof Deflate)) return new Deflate(options);
    this.options = utils2.assign({
      level: Z_DEFAULT_COMPRESSION,
      method: Z_DEFLATED,
      chunkSize: 16384,
      windowBits: 15,
      memLevel: 8,
      strategy: Z_DEFAULT_STRATEGY,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits > 0) {
      opt.windowBits = -opt.windowBits;
    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
      opt.windowBits += 16;
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_deflate.deflateInit2(
      this.strm,
      opt.level,
      opt.method,
      opt.windowBits,
      opt.memLevel,
      opt.strategy
    );
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    if (opt.header) {
      zlib_deflate.deflateSetHeader(this.strm, opt.header);
    }
    if (opt.dictionary) {
      var dict;
      if (typeof opt.dictionary === "string") {
        dict = strings2.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        dict = new Uint8Array(opt.dictionary);
      } else {
        dict = opt.dictionary;
      }
      status = zlib_deflate.deflateSetDictionary(this.strm, dict);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      this._dict_set = true;
    }
  }
  Deflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var status, _mode;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings2.string2buf(data2);
    } else if (toString3.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_deflate.deflate(strm, _mode);
      if (status !== Z_STREAM_END && status !== Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          this.onData(strings2.buf2binstring(utils2.shrinkBuf(strm.output, strm.next_out)));
        } else {
          this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
        }
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
    if (_mode === Z_FINISH) {
      status = zlib_deflate.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK;
    }
    if (_mode === Z_SYNC_FLUSH) {
      this.onEnd(Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Deflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Deflate.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function deflate2(input, options) {
    var deflator = new Deflate(options);
    deflator.push(input, true);
    if (deflator.err) {
      throw deflator.msg || msg[deflator.err];
    }
    return deflator.result;
  }
  function deflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return deflate2(input, options);
  }
  function gzip(input, options) {
    options = options || {};
    options.gzip = true;
    return deflate2(input, options);
  }
  deflate$1.Deflate = Deflate;
  deflate$1.deflate = deflate2;
  deflate$1.deflateRaw = deflateRaw;
  deflate$1.gzip = gzip;
  return deflate$1;
}
var inflate$1 = {};
var inflate = {};
var inffast;
var hasRequiredInffast;
function requireInffast() {
  if (hasRequiredInffast) return inffast;
  hasRequiredInffast = 1;
  var BAD = 30;
  var TYPE = 12;
  inffast = function inflate_fast(strm, start) {
    var state2;
    var _in;
    var last;
    var _out;
    var beg;
    var end;
    var dmax;
    var wsize;
    var whave;
    var wnext;
    var s_window;
    var hold;
    var bits;
    var lcode;
    var dcode;
    var lmask;
    var dmask;
    var here;
    var op;
    var len;
    var dist2;
    var from;
    var from_source;
    var input, output;
    state2 = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state2.dmax;
    wsize = state2.wsize;
    whave = state2.whave;
    wnext = state2.wnext;
    s_window = state2.window;
    hold = state2.hold;
    bits = state2.bits;
    lcode = state2.lencode;
    dcode = state2.distcode;
    lmask = (1 << state2.lenbits) - 1;
    dmask = (1 << state2.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist2 = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist2 += hold & (1 << op) - 1;
                    if (dist2 > dmax) {
                      strm.msg = "invalid distance too far back";
                      state2.mode = BAD;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist2 > op) {
                      op = dist2 - op;
                      if (op > whave) {
                        if (state2.sane) {
                          strm.msg = "invalid distance too far back";
                          state2.mode = BAD;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist2;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist2;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist2;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state2.mode = BAD;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state2.mode = TYPE;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state2.hold = hold;
    state2.bits = bits;
    return;
  };
  return inffast;
}
var inftrees;
var hasRequiredInftrees;
function requireInftrees() {
  if (hasRequiredInftrees) return inftrees;
  hasRequiredInftrees = 1;
  var utils2 = requireCommon$1();
  var MAXBITS = 15;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var lbase = [
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ];
  var lext = [
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ];
  var dbase = [
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ];
  var dext = [
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ];
  inftrees = function inflate_table(type2, lens, lens_index, codes, table2, table_index, work, opts) {
    var bits = opts.bits;
    var len = 0;
    var sym = 0;
    var min2 = 0, max2 = 0;
    var root = 0;
    var curr = 0;
    var drop = 0;
    var left = 0;
    var used = 0;
    var huff = 0;
    var incr;
    var fill;
    var low;
    var mask;
    var next;
    var base = null;
    var base_index = 0;
    var end;
    var count = new utils2.Buf16(MAXBITS + 1);
    var offs = new utils2.Buf16(MAXBITS + 1);
    var extra = null;
    var extra_index = 0;
    var here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max2 = MAXBITS; max2 >= 1; max2--) {
      if (count[max2] !== 0) {
        break;
      }
    }
    if (root > max2) {
      root = max2;
    }
    if (max2 === 0) {
      table2[table_index++] = 1 << 24 | 64 << 16 | 0;
      table2[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min2 = 1; min2 < max2; min2++) {
      if (count[min2] !== 0) {
        break;
      }
    }
    if (root < min2) {
      root = min2;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type2 === CODES || max2 !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type2 === CODES) {
      base = extra = work;
      end = 19;
    } else if (type2 === LENS) {
      base = lbase;
      base_index -= 257;
      extra = lext;
      extra_index -= 257;
      end = 256;
    } else {
      base = dbase;
      extra = dext;
      end = -1;
    }
    huff = 0;
    sym = 0;
    len = min2;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] < end) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] > end) {
        here_op = extra[extra_index + work[sym]];
        here_val = base[base_index + work[sym]];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min2 = fill;
      do {
        fill -= incr;
        table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max2) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min2;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max2) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type2 === LENS && used > ENOUGH_LENS || type2 === DISTS && used > ENOUGH_DISTS) {
          return 1;
        }
        low = huff & mask;
        table2[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  return inftrees;
}
var hasRequiredInflate$1;
function requireInflate$1() {
  if (hasRequiredInflate$1) return inflate;
  hasRequiredInflate$1 = 1;
  var utils2 = requireCommon$1();
  var adler32 = requireAdler32();
  var crc322 = requireCrc32$1();
  var inflate_fast = requireInffast();
  var inflate_table = requireInftrees();
  var CODES = 0;
  var LENS = 1;
  var DISTS = 2;
  var Z_FINISH = 4;
  var Z_BLOCK = 5;
  var Z_TREES = 6;
  var Z_OK = 0;
  var Z_STREAM_END = 1;
  var Z_NEED_DICT = 2;
  var Z_STREAM_ERROR = -2;
  var Z_DATA_ERROR = -3;
  var Z_MEM_ERROR = -4;
  var Z_BUF_ERROR = -5;
  var Z_DEFLATED = 8;
  var HEAD = 1;
  var FLAGS = 2;
  var TIME = 3;
  var OS = 4;
  var EXLEN = 5;
  var EXTRA = 6;
  var NAME = 7;
  var COMMENT = 8;
  var HCRC = 9;
  var DICTID = 10;
  var DICT = 11;
  var TYPE = 12;
  var TYPEDO = 13;
  var STORED = 14;
  var COPY_ = 15;
  var COPY = 16;
  var TABLE = 17;
  var LENLENS = 18;
  var CODELENS = 19;
  var LEN_ = 20;
  var LEN = 21;
  var LENEXT = 22;
  var DIST = 23;
  var DISTEXT = 24;
  var MATCH = 25;
  var LIT = 26;
  var CHECK = 27;
  var LENGTH = 28;
  var DONE = 29;
  var BAD = 30;
  var MEM = 31;
  var SYNC = 32;
  var ENOUGH_LENS = 852;
  var ENOUGH_DISTS = 592;
  var MAX_WBITS = 15;
  var DEF_WBITS = MAX_WBITS;
  function zswap32(q) {
    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
  }
  function InflateState() {
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new utils2.Buf16(320);
    this.work = new utils2.Buf16(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  function inflateResetKeep(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    strm.total_in = strm.total_out = state2.total = 0;
    strm.msg = "";
    if (state2.wrap) {
      strm.adler = state2.wrap & 1;
    }
    state2.mode = HEAD;
    state2.last = 0;
    state2.havedict = 0;
    state2.dmax = 32768;
    state2.head = null;
    state2.hold = 0;
    state2.bits = 0;
    state2.lencode = state2.lendyn = new utils2.Buf32(ENOUGH_LENS);
    state2.distcode = state2.distdyn = new utils2.Buf32(ENOUGH_DISTS);
    state2.sane = 1;
    state2.back = -1;
    return Z_OK;
  }
  function inflateReset(strm) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    state2.wsize = 0;
    state2.whave = 0;
    state2.wnext = 0;
    return inflateResetKeep(strm);
  }
  function inflateReset2(strm, windowBits) {
    var wrap2;
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (windowBits < 0) {
      wrap2 = 0;
      windowBits = -windowBits;
    } else {
      wrap2 = (windowBits >> 4) + 1;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR;
    }
    if (state2.window !== null && state2.wbits !== windowBits) {
      state2.window = null;
    }
    state2.wrap = wrap2;
    state2.wbits = windowBits;
    return inflateReset(strm);
  }
  function inflateInit2(strm, windowBits) {
    var ret;
    var state2;
    if (!strm) {
      return Z_STREAM_ERROR;
    }
    state2 = new InflateState();
    strm.state = state2;
    state2.window = null;
    ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK) {
      strm.state = null;
    }
    return ret;
  }
  function inflateInit(strm) {
    return inflateInit2(strm, DEF_WBITS);
  }
  var virgin = true;
  var lenfix, distfix;
  function fixedtables(state2) {
    if (virgin) {
      var sym;
      lenfix = new utils2.Buf32(512);
      distfix = new utils2.Buf32(32);
      sym = 0;
      while (sym < 144) {
        state2.lens[sym++] = 8;
      }
      while (sym < 256) {
        state2.lens[sym++] = 9;
      }
      while (sym < 280) {
        state2.lens[sym++] = 7;
      }
      while (sym < 288) {
        state2.lens[sym++] = 8;
      }
      inflate_table(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state2.lens[sym++] = 5;
      }
      inflate_table(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
      virgin = false;
    }
    state2.lencode = lenfix;
    state2.lenbits = 9;
    state2.distcode = distfix;
    state2.distbits = 5;
  }
  function updatewindow(strm, src2, end, copy) {
    var dist2;
    var state2 = strm.state;
    if (state2.window === null) {
      state2.wsize = 1 << state2.wbits;
      state2.wnext = 0;
      state2.whave = 0;
      state2.window = new utils2.Buf8(state2.wsize);
    }
    if (copy >= state2.wsize) {
      utils2.arraySet(state2.window, src2, end - state2.wsize, state2.wsize, 0);
      state2.wnext = 0;
      state2.whave = state2.wsize;
    } else {
      dist2 = state2.wsize - state2.wnext;
      if (dist2 > copy) {
        dist2 = copy;
      }
      utils2.arraySet(state2.window, src2, end - copy, dist2, state2.wnext);
      copy -= dist2;
      if (copy) {
        utils2.arraySet(state2.window, src2, end - copy, copy, 0);
        state2.wnext = copy;
        state2.whave = state2.wsize;
      } else {
        state2.wnext += dist2;
        if (state2.wnext === state2.wsize) {
          state2.wnext = 0;
        }
        if (state2.whave < state2.wsize) {
          state2.whave += dist2;
        }
      }
    }
    return 0;
  }
  function inflate$12(strm, flush) {
    var state2;
    var input, output;
    var next;
    var put;
    var have, left;
    var hold;
    var bits;
    var _in, _out;
    var copy;
    var from;
    var from_source;
    var here = 0;
    var here_bits, here_op, here_val;
    var last_bits, last_op, last_val;
    var len;
    var ret;
    var hbuf = new utils2.Buf8(4);
    var opts;
    var n;
    var order = (
      /* permutation of code lengths */
      [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
    );
    if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (state2.mode === TYPE) {
      state2.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state2.hold;
    bits = state2.bits;
    _in = have;
    _out = left;
    ret = Z_OK;
    inf_leave:
      for (; ; ) {
        switch (state2.mode) {
          case HEAD:
            if (state2.wrap === 0) {
              state2.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 2 && hold === 35615) {
              state2.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state2.mode = FLAGS;
              break;
            }
            state2.flags = 0;
            if (state2.head) {
              state2.head.done = false;
            }
            if (!(state2.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state2.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state2.wbits === 0) {
              state2.wbits = len;
            } else if (len > state2.wbits) {
              strm.msg = "invalid window size";
              state2.mode = BAD;
              break;
            }
            state2.dmax = 1 << len;
            strm.adler = state2.check = 1;
            state2.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.flags = hold;
            if ((state2.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            if (state2.flags & 57344) {
              strm.msg = "unknown header flags set";
              state2.mode = BAD;
              break;
            }
            if (state2.head) {
              state2.head.text = hold >> 8 & 1;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.time = hold;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state2.check = crc322(state2.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.xflags = hold & 255;
              state2.head.os = hold >> 8;
            }
            if (state2.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc322(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state2.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length = hold;
              if (state2.head) {
                state2.head.extra_len = hold;
              }
              if (state2.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc322(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state2.head) {
              state2.head.extra = null;
            }
            state2.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state2.flags & 1024) {
              copy = state2.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state2.head) {
                  len = state2.head.extra_len - state2.length;
                  if (!state2.head.extra) {
                    state2.head.extra = new Array(state2.head.extra_len);
                  }
                  utils2.arraySet(
                    state2.head.extra,
                    input,
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    copy,
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state2.flags & 512) {
                  state2.check = crc322(state2.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state2.length -= copy;
              }
              if (state2.length) {
                break inf_leave;
              }
            }
            state2.length = 0;
            state2.mode = NAME;
          /* falls through */
          case NAME:
            if (state2.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state2.flags & 512) {
                state2.check = crc322(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.name = null;
            }
            state2.length = 0;
            state2.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state2.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state2.flags & 512) {
                state2.check = crc322(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.comment = null;
            }
            state2.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state2.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.check & 65535)) {
                strm.msg = "header crc mismatch";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state2.head) {
              state2.head.hcrc = state2.flags >> 9 & 1;
              state2.head.done = true;
            }
            strm.adler = state2.check = 0;
            state2.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state2.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state2.mode = DICT;
          /* falls through */
          case DICT:
            if (state2.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              return Z_NEED_DICT;
            }
            strm.adler = state2.check = 1;
            state2.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state2.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state2.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state2.mode = STORED;
                break;
              case 1:
                fixedtables(state2);
                state2.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state2.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state2.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state2.mode = BAD;
              break;
            }
            state2.length = hold & 65535;
            hold = 0;
            bits = 0;
            state2.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state2.mode = COPY;
          /* falls through */
          case COPY:
            copy = state2.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              utils2.arraySet(output, input, next, copy, put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state2.length -= copy;
              break;
            }
            state2.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state2.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state2.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state2.nlen > 286 || state2.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state2.have < state2.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.lens[order[state2.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state2.have < 19) {
              state2.lens[order[state2.have++]] = 0;
            }
            state2.lencode = state2.lendyn;
            state2.lenbits = 7;
            opts = { bits: state2.lenbits };
            ret = inflate_table(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state2.have < state2.nlen + state2.ndist) {
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state2.lens[state2.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n = here_bits + 2;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state2.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD;
                    break;
                  }
                  len = state2.lens[state2.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n = here_bits + 3;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n = here_bits + 7;
                  while (bits < n) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state2.have + copy > state2.nlen + state2.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                while (copy--) {
                  state2.lens[state2.have++] = len;
                }
              }
            }
            if (state2.mode === BAD) {
              break;
            }
            if (state2.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state2.mode = BAD;
              break;
            }
            state2.lenbits = 9;
            opts = { bits: state2.lenbits };
            ret = inflate_table(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state2.mode = BAD;
              break;
            }
            state2.distbits = 6;
            state2.distcode = state2.distdyn;
            opts = { bits: state2.distbits };
            ret = inflate_table(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
            state2.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state2.mode = BAD;
              break;
            }
            state2.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state2.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              inflate_fast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state2.hold;
              bits = state2.bits;
              if (state2.mode === TYPE) {
                state2.back = -1;
              }
              break;
            }
            state2.back = 0;
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            state2.length = here_val;
            if (here_op === 0) {
              state2.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state2.back = -1;
              state2.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD;
              break;
            }
            state2.extra = here_op & 15;
            state2.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state2.extra) {
              n = state2.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            state2.was = state2.length;
            state2.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state2.distcode[hold & (1 << state2.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state2.mode = BAD;
              break;
            }
            state2.offset = here_val;
            state2.extra = here_op & 15;
            state2.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state2.extra) {
              n = state2.extra;
              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.offset += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            if (state2.offset > state2.dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD;
              break;
            }
            state2.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state2.offset > copy) {
              copy = state2.offset - copy;
              if (copy > state2.whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD;
                  break;
                }
              }
              if (copy > state2.wnext) {
                copy -= state2.wnext;
                from = state2.wsize - copy;
              } else {
                from = state2.wnext - copy;
              }
              if (copy > state2.length) {
                copy = state2.length;
              }
              from_source = state2.window;
            } else {
              from_source = output;
              from = put - state2.offset;
              copy = state2.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state2.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state2.length === 0) {
              state2.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state2.length;
            left--;
            state2.mode = LEN;
            break;
          case CHECK:
            if (state2.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state2.total += _out;
              if (_out) {
                strm.adler = state2.check = /*UPDATE(state.check, put - _out, _out);*/
                state2.flags ? crc322(state2.check, output, _out, put - _out) : adler32(state2.check, output, _out, put - _out);
              }
              _out = left;
              if ((state2.flags ? hold : zswap32(hold)) !== state2.check) {
                strm.msg = "incorrect data check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state2.wrap && state2.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (hold !== (state2.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state2.hold = hold;
    state2.bits = bits;
    if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state2.total += _out;
    if (state2.wrap && _out) {
      strm.adler = state2.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      state2.flags ? crc322(state2.check, output, _out, strm.next_out - _out) : adler32(state2.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  }
  function inflateEnd(strm) {
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    var state2 = strm.state;
    if (state2.window) {
      state2.window = null;
    }
    strm.state = null;
    return Z_OK;
  }
  function inflateGetHeader(strm, head) {
    var state2;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if ((state2.wrap & 2) === 0) {
      return Z_STREAM_ERROR;
    }
    state2.head = head;
    head.done = false;
    return Z_OK;
  }
  function inflateSetDictionary(strm, dictionary) {
    var dictLength = dictionary.length;
    var state2;
    var dictid;
    var ret;
    if (!strm || !strm.state) {
      return Z_STREAM_ERROR;
    }
    state2 = strm.state;
    if (state2.wrap !== 0 && state2.mode !== DICT) {
      return Z_STREAM_ERROR;
    }
    if (state2.mode === DICT) {
      dictid = 1;
      dictid = adler32(dictid, dictionary, dictLength, 0);
      if (dictid !== state2.check) {
        return Z_DATA_ERROR;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state2.mode = MEM;
      return Z_MEM_ERROR;
    }
    state2.havedict = 1;
    return Z_OK;
  }
  inflate.inflateReset = inflateReset;
  inflate.inflateReset2 = inflateReset2;
  inflate.inflateResetKeep = inflateResetKeep;
  inflate.inflateInit = inflateInit;
  inflate.inflateInit2 = inflateInit2;
  inflate.inflate = inflate$12;
  inflate.inflateEnd = inflateEnd;
  inflate.inflateGetHeader = inflateGetHeader;
  inflate.inflateSetDictionary = inflateSetDictionary;
  inflate.inflateInfo = "pako inflate (from Nodeca project)";
  return inflate;
}
var constants$1;
var hasRequiredConstants$1;
function requireConstants$1() {
  if (hasRequiredConstants$1) return constants$1;
  hasRequiredConstants$1 = 1;
  constants$1 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_PARTIAL_FLUSH: 1,
    Z_SYNC_FLUSH: 2,
    Z_FULL_FLUSH: 3,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_ERRNO: -1,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    //Z_MEM_ERROR:     -4,
    Z_BUF_ERROR: -5,
    //Z_VERSION_ERROR: -6,
    /* compression levels */
    Z_NO_COMPRESSION: 0,
    Z_BEST_SPEED: 1,
    Z_BEST_COMPRESSION: 9,
    Z_DEFAULT_COMPRESSION: -1,
    Z_FILTERED: 1,
    Z_HUFFMAN_ONLY: 2,
    Z_RLE: 3,
    Z_FIXED: 4,
    Z_DEFAULT_STRATEGY: 0,
    /* Possible values of the data_type field (though see inflate()) */
    Z_BINARY: 0,
    Z_TEXT: 1,
    //Z_ASCII:                1, // = Z_TEXT (deprecated)
    Z_UNKNOWN: 2,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  return constants$1;
}
var gzheader;
var hasRequiredGzheader;
function requireGzheader() {
  if (hasRequiredGzheader) return gzheader;
  hasRequiredGzheader = 1;
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  gzheader = GZheader;
  return gzheader;
}
var hasRequiredInflate;
function requireInflate() {
  if (hasRequiredInflate) return inflate$1;
  hasRequiredInflate = 1;
  var zlib_inflate = requireInflate$1();
  var utils2 = requireCommon$1();
  var strings2 = requireStrings();
  var c = requireConstants$1();
  var msg = requireMessages();
  var ZStream = requireZstream();
  var GZheader = requireGzheader();
  var toString3 = Object.prototype.toString;
  function Inflate(options) {
    if (!(this instanceof Inflate)) return new Inflate(options);
    this.options = utils2.assign({
      chunkSize: 16384,
      windowBits: 0,
      to: ""
    }, options || {});
    var opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new ZStream();
    this.strm.avail_out = 0;
    var status = zlib_inflate.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== c.Z_OK) {
      throw new Error(msg[status]);
    }
    this.header = new GZheader();
    zlib_inflate.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings2.string2buf(opt.dictionary);
      } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== c.Z_OK) {
          throw new Error(msg[status]);
        }
      }
    }
  }
  Inflate.prototype.push = function(data2, mode) {
    var strm = this.strm;
    var chunkSize = this.options.chunkSize;
    var dictionary = this.options.dictionary;
    var status, _mode;
    var next_out_utf8, tail, utf8str;
    var allowBufError = false;
    if (this.ended) {
      return false;
    }
    _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
    if (typeof data2 === "string") {
      strm.input = strings2.binstring2buf(data2);
    } else if (toString3.call(data2) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data2);
    } else {
      strm.input = data2;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    do {
      if (strm.avail_out === 0) {
        strm.output = new utils2.Buf8(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
      if (status === c.Z_NEED_DICT && dictionary) {
        status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
      }
      if (status === c.Z_BUF_ERROR && allowBufError === true) {
        status = c.Z_OK;
        allowBufError = false;
      }
      if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
        this.onEnd(status);
        this.ended = true;
        return false;
      }
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
            tail = strm.next_out - next_out_utf8;
            utf8str = strings2.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) {
              utils2.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
            }
            this.onData(utf8str);
          } else {
            this.onData(utils2.shrinkBuf(strm.output, strm.next_out));
          }
        }
      }
      if (strm.avail_in === 0 && strm.avail_out === 0) {
        allowBufError = true;
      }
    } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
    if (status === c.Z_STREAM_END) {
      _mode = c.Z_FINISH;
    }
    if (_mode === c.Z_FINISH) {
      status = zlib_inflate.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === c.Z_OK;
    }
    if (_mode === c.Z_SYNC_FLUSH) {
      this.onEnd(c.Z_OK);
      strm.avail_out = 0;
      return true;
    }
    return true;
  };
  Inflate.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate.prototype.onEnd = function(status) {
    if (status === c.Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = utils2.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate2(input, options) {
    var inflator = new Inflate(options);
    inflator.push(input, true);
    if (inflator.err) {
      throw inflator.msg || msg[inflator.err];
    }
    return inflator.result;
  }
  function inflateRaw(input, options) {
    options = options || {};
    options.raw = true;
    return inflate2(input, options);
  }
  inflate$1.Inflate = Inflate;
  inflate$1.inflate = inflate2;
  inflate$1.inflateRaw = inflateRaw;
  inflate$1.ungzip = inflate2;
  return inflate$1;
}
var pako_1;
var hasRequiredPako;
function requirePako() {
  if (hasRequiredPako) return pako_1;
  hasRequiredPako = 1;
  var assign = requireCommon$1().assign;
  var deflate2 = requireDeflate();
  var inflate2 = requireInflate();
  var constants2 = requireConstants$1();
  var pako = {};
  assign(pako, deflate2, inflate2, constants2);
  pako_1 = pako;
  return pako_1;
}
var hasRequiredFlate;
function requireFlate() {
  if (hasRequiredFlate) return flate;
  hasRequiredFlate = 1;
  var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var pako = requirePako();
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
  flate.magic = "\b\0";
  function FlateWorker(action, options) {
    GenericWorker.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  utils2.inherits(FlateWorker, GenericWorker);
  FlateWorker.prototype.processChunk = function(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(utils2.transformTo(ARRAY_TYPE, chunk.data), false);
  };
  FlateWorker.prototype.flush = function() {
    GenericWorker.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker.prototype.cleanUp = function() {
    GenericWorker.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker.prototype._createPako = function() {
    this._pako = new pako[this._pakoAction]({
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    });
    var self2 = this;
    this._pako.onData = function(data2) {
      self2.push({
        data: data2,
        meta: self2.meta
      });
    };
  };
  flate.compressWorker = function(compressionOptions) {
    return new FlateWorker("Deflate", compressionOptions);
  };
  flate.uncompressWorker = function() {
    return new FlateWorker("Inflate", {});
  };
  return flate;
}
var hasRequiredCompressions;
function requireCompressions() {
  if (hasRequiredCompressions) return compressions;
  hasRequiredCompressions = 1;
  var GenericWorker = requireGenericWorker();
  compressions.STORE = {
    magic: "\0\0",
    compressWorker: function() {
      return new GenericWorker("STORE compression");
    },
    uncompressWorker: function() {
      return new GenericWorker("STORE decompression");
    }
  };
  compressions.DEFLATE = requireFlate();
  return compressions;
}
var signature = {};
var hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature) return signature;
  hasRequiredSignature = 1;
  signature.LOCAL_FILE_HEADER = "PK";
  signature.CENTRAL_FILE_HEADER = "PK";
  signature.CENTRAL_DIRECTORY_END = "PK";
  signature.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
  signature.ZIP64_CENTRAL_DIRECTORY_END = "PK";
  signature.DATA_DESCRIPTOR = "PK\x07\b";
  return signature;
}
var ZipFileWorker_1;
var hasRequiredZipFileWorker;
function requireZipFileWorker() {
  if (hasRequiredZipFileWorker) return ZipFileWorker_1;
  hasRequiredZipFileWorker = 1;
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  var utf82 = requireUtf8();
  var crc322 = requireCrc32$2();
  var signature2 = requireSignature();
  var decToHex = function(dec, bytes) {
    var hex = "", i;
    for (i = 0; i < bytes; i++) {
      hex += String.fromCharCode(dec & 255);
      dec = dec >>> 8;
    }
    return hex;
  };
  var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
    var result = unixPermissions;
    if (!unixPermissions) {
      result = isDir ? 16893 : 33204;
    }
    return (result & 65535) << 16;
  };
  var generateDosExternalFileAttr = function(dosPermissions) {
    return (dosPermissions || 0) & 63;
  };
  var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform2, encodeFileName) {
    var file2 = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf82.utf8encode, encodedFileName = utils2.transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = utils2.transformTo("string", utf82.utf8encode(file2.name)), comment = file2.comment, encodedComment = utils2.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils2.transformTo("string", utf82.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date = file2.date;
    var dataInfo = {
      crc32: 0,
      compressedSize: 0,
      uncompressedSize: 0
    };
    if (!streamedContent || streamingEnded) {
      dataInfo.crc32 = streamInfo["crc32"];
      dataInfo.compressedSize = streamInfo["compressedSize"];
      dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
    }
    var bitflag = 0;
    if (streamedContent) {
      bitflag |= 8;
    }
    if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
      bitflag |= 2048;
    }
    var extFileAttr = 0;
    var versionMadeBy = 0;
    if (dir2) {
      extFileAttr |= 16;
    }
    if (platform2 === "UNIX") {
      versionMadeBy = 798;
      extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
    } else {
      versionMadeBy = 20;
      extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
    }
    dosTime = date.getUTCHours();
    dosTime = dosTime << 6;
    dosTime = dosTime | date.getUTCMinutes();
    dosTime = dosTime << 5;
    dosTime = dosTime | date.getUTCSeconds() / 2;
    dosDate = date.getUTCFullYear() - 1980;
    dosDate = dosDate << 4;
    dosDate = dosDate | date.getUTCMonth() + 1;
    dosDate = dosDate << 5;
    dosDate = dosDate | date.getUTCDate();
    if (useUTF8ForFileName) {
      unicodePathExtraField = // Version
      decToHex(1, 1) + // NameCRC32
      decToHex(crc322(encodedFileName), 4) + // UnicodeName
      utfEncodedFileName;
      extraFields += // Info-ZIP Unicode Path Extra Field
      "up" + // size
      decToHex(unicodePathExtraField.length, 2) + // content
      unicodePathExtraField;
    }
    if (useUTF8ForComment) {
      unicodeCommentExtraField = // Version
      decToHex(1, 1) + // CommentCRC32
      decToHex(crc322(encodedComment), 4) + // UnicodeName
      utfEncodedComment;
      extraFields += // Info-ZIP Unicode Path Extra Field
      "uc" + // size
      decToHex(unicodeCommentExtraField.length, 2) + // content
      unicodeCommentExtraField;
    }
    var header = "";
    header += "\n\0";
    header += decToHex(bitflag, 2);
    header += compression.magic;
    header += decToHex(dosTime, 2);
    header += decToHex(dosDate, 2);
    header += decToHex(dataInfo.crc32, 4);
    header += decToHex(dataInfo.compressedSize, 4);
    header += decToHex(dataInfo.uncompressedSize, 4);
    header += decToHex(encodedFileName.length, 2);
    header += decToHex(extraFields.length, 2);
    var fileRecord = signature2.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
    var dirRecord = signature2.CENTRAL_FILE_HEADER + // version made by (00: DOS)
    decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
    header + // file comment length
    decToHex(encodedComment.length, 2) + // disk number start
    "\0\0\0\0" + // external file attributes
    decToHex(extFileAttr, 4) + // relative offset of local header
    decToHex(offset, 4) + // file name
    encodedFileName + // extra field
    extraFields + // file comment
    encodedComment;
    return {
      fileRecord,
      dirRecord
    };
  };
  var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
    var dirEnd = "";
    var encodedComment = utils2.transformTo("string", encodeFileName(comment));
    dirEnd = signature2.CENTRAL_DIRECTORY_END + // number of this disk
    "\0\0\0\0" + // total number of entries in the central directory on this disk
    decToHex(entriesCount, 2) + // total number of entries in the central directory
    decToHex(entriesCount, 2) + // size of the central directory   4 bytes
    decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
    decToHex(localDirLength, 4) + // .ZIP file comment length
    decToHex(encodedComment.length, 2) + // .ZIP file comment
    encodedComment;
    return dirEnd;
  };
  var generateDataDescriptors = function(streamInfo) {
    var descriptor = "";
    descriptor = signature2.DATA_DESCRIPTOR + // crc-32                          4 bytes
    decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
    decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
    decToHex(streamInfo["uncompressedSize"], 4);
    return descriptor;
  };
  function ZipFileWorker(streamFiles, comment, platform2, encodeFileName) {
    GenericWorker.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment;
    this.zipPlatform = platform2;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  utils2.inherits(ZipFileWorker, GenericWorker);
  ZipFileWorker.prototype.push = function(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker.prototype.openedSource = function(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker.prototype.closedSource = function(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker.prototype.flush = function() {
    var localDirLength = this.bytesWritten;
    for (var i = 0; i < this.dirRecords.length; i++) {
      this.push({
        data: this.dirRecords[i],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker.prototype.prepareNextSource = function() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker.prototype.registerPrevious = function(previous) {
    this._sources.push(previous);
    var self2 = this;
    previous.on("data", function(chunk) {
      self2.processChunk(chunk);
    });
    previous.on("end", function() {
      self2.closedSource(self2.previous.streamInfo);
      if (self2._sources.length) {
        self2.prepareNextSource();
      } else {
        self2.end();
      }
    });
    previous.on("error", function(e) {
      self2.error(e);
    });
    return this;
  };
  ZipFileWorker.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker.prototype.error = function(e) {
    var sources = this._sources;
    if (!GenericWorker.prototype.error.call(this, e)) {
      return false;
    }
    for (var i = 0; i < sources.length; i++) {
      try {
        sources[i].error(e);
      } catch (e2) {
      }
    }
    return true;
  };
  ZipFileWorker.prototype.lock = function() {
    GenericWorker.prototype.lock.call(this);
    var sources = this._sources;
    for (var i = 0; i < sources.length; i++) {
      sources[i].lock();
    }
  };
  ZipFileWorker_1 = ZipFileWorker;
  return ZipFileWorker_1;
}
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate) return generate;
  hasRequiredGenerate = 1;
  var compressions2 = requireCompressions();
  var ZipFileWorker = requireZipFileWorker();
  var getCompression = function(fileCompression, zipCompression) {
    var compressionName = fileCompression || zipCompression;
    var compression = compressions2[compressionName];
    if (!compression) {
      throw new Error(compressionName + " is not a valid compression method !");
    }
    return compression;
  };
  generate.generateWorker = function(zip2, options, comment) {
    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
    var entriesCount = 0;
    try {
      zip2.forEach(function(relativePath, file2) {
        entriesCount++;
        var compression = getCompression(file2.options.compression, options.compression);
        var compressionOptions = file2.options.compressionOptions || options.compressionOptions || {};
        var dir2 = file2.dir, date = file2.date;
        file2._compressWorker(compression, compressionOptions).withStreamInfo("file", {
          name: relativePath,
          dir: dir2,
          date,
          comment: file2.comment || "",
          unixPermissions: file2.unixPermissions,
          dosPermissions: file2.dosPermissions
        }).pipe(zipFileWorker);
      });
      zipFileWorker.entriesCount = entriesCount;
    } catch (e) {
      zipFileWorker.error(e);
    }
    return zipFileWorker;
  };
  return generate;
}
var NodejsStreamInputAdapter_1;
var hasRequiredNodejsStreamInputAdapter;
function requireNodejsStreamInputAdapter() {
  if (hasRequiredNodejsStreamInputAdapter) return NodejsStreamInputAdapter_1;
  hasRequiredNodejsStreamInputAdapter = 1;
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  function NodejsStreamInputAdapter(filename, stream2) {
    GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
    this._upstreamEnded = false;
    this._bindStream(stream2);
  }
  utils2.inherits(NodejsStreamInputAdapter, GenericWorker);
  NodejsStreamInputAdapter.prototype._bindStream = function(stream2) {
    var self2 = this;
    this._stream = stream2;
    stream2.pause();
    stream2.on("data", function(chunk) {
      self2.push({
        data: chunk,
        meta: {
          percent: 0
        }
      });
    }).on("error", function(e) {
      if (self2.isPaused) {
        this.generatedError = e;
      } else {
        self2.error(e);
      }
    }).on("end", function() {
      if (self2.isPaused) {
        self2._upstreamEnded = true;
      } else {
        self2.end();
      }
    });
  };
  NodejsStreamInputAdapter.prototype.pause = function() {
    if (!GenericWorker.prototype.pause.call(this)) {
      return false;
    }
    this._stream.pause();
    return true;
  };
  NodejsStreamInputAdapter.prototype.resume = function() {
    if (!GenericWorker.prototype.resume.call(this)) {
      return false;
    }
    if (this._upstreamEnded) {
      this.end();
    } else {
      this._stream.resume();
    }
    return true;
  };
  NodejsStreamInputAdapter_1 = NodejsStreamInputAdapter;
  return NodejsStreamInputAdapter_1;
}
var object;
var hasRequiredObject;
function requireObject() {
  if (hasRequiredObject) return object;
  hasRequiredObject = 1;
  var utf82 = requireUtf8();
  var utils2 = requireUtils$1();
  var GenericWorker = requireGenericWorker();
  var StreamHelper = requireStreamHelper();
  var defaults2 = requireDefaults();
  var CompressedObject = requireCompressedObject();
  var ZipObject = requireZipObject();
  var generate2 = requireGenerate();
  var nodejsUtils2 = requireNodejsUtils();
  var NodejsStreamInputAdapter = requireNodejsStreamInputAdapter();
  var fileAdd = function(name, data2, originalOptions) {
    var dataType = utils2.getTypeOf(data2), parent2;
    var o = utils2.extend(originalOptions || {}, defaults2);
    o.date = o.date || /* @__PURE__ */ new Date();
    if (o.compression !== null) {
      o.compression = o.compression.toUpperCase();
    }
    if (typeof o.unixPermissions === "string") {
      o.unixPermissions = parseInt(o.unixPermissions, 8);
    }
    if (o.unixPermissions && o.unixPermissions & 16384) {
      o.dir = true;
    }
    if (o.dosPermissions && o.dosPermissions & 16) {
      o.dir = true;
    }
    if (o.dir) {
      name = forceTrailingSlash(name);
    }
    if (o.createFolders && (parent2 = parentFolder(name))) {
      folderAdd.call(this, parent2, true);
    }
    var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
    if (!originalOptions || typeof originalOptions.binary === "undefined") {
      o.binary = !isUnicodeString;
    }
    var isCompressedEmpty = data2 instanceof CompressedObject && data2.uncompressedSize === 0;
    if (isCompressedEmpty || o.dir || !data2 || data2.length === 0) {
      o.base64 = false;
      o.binary = true;
      data2 = "";
      o.compression = "STORE";
      dataType = "string";
    }
    var zipObjectContent = null;
    if (data2 instanceof CompressedObject || data2 instanceof GenericWorker) {
      zipObjectContent = data2;
    } else if (nodejsUtils2.isNode && nodejsUtils2.isStream(data2)) {
      zipObjectContent = new NodejsStreamInputAdapter(name, data2);
    } else {
      zipObjectContent = utils2.prepareContent(name, data2, o.binary, o.optimizedBinaryString, o.base64);
    }
    var object2 = new ZipObject(name, zipObjectContent, o);
    this.files[name] = object2;
  };
  var parentFolder = function(path2) {
    if (path2.slice(-1) === "/") {
      path2 = path2.substring(0, path2.length - 1);
    }
    var lastSlash = path2.lastIndexOf("/");
    return lastSlash > 0 ? path2.substring(0, lastSlash) : "";
  };
  var forceTrailingSlash = function(path2) {
    if (path2.slice(-1) !== "/") {
      path2 += "/";
    }
    return path2;
  };
  var folderAdd = function(name, createFolders) {
    createFolders = typeof createFolders !== "undefined" ? createFolders : defaults2.createFolders;
    name = forceTrailingSlash(name);
    if (!this.files[name]) {
      fileAdd.call(this, name, null, {
        dir: true,
        createFolders
      });
    }
    return this.files[name];
  };
  function isRegExp2(object2) {
    return Object.prototype.toString.call(object2) === "[object RegExp]";
  }
  var out = {
    /**
     * @see loadAsync
     */
    load: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    /**
     * Call a callback function for each entry at this folder level.
     * @param {Function} cb the callback function:
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     */
    forEach: function(cb) {
      var filename, relativePath, file2;
      for (filename in this.files) {
        file2 = this.files[filename];
        relativePath = filename.slice(this.root.length, filename.length);
        if (relativePath && filename.slice(0, this.root.length) === this.root) {
          cb(relativePath, file2);
        }
      }
    },
    /**
     * Filter nested files/folders with the specified function.
     * @param {Function} search the predicate to use :
     * function (relativePath, file) {...}
     * It takes 2 arguments : the relative path and the file.
     * @return {Array} An array of matching elements.
     */
    filter: function(search) {
      var result = [];
      this.forEach(function(relativePath, entry) {
        if (search(relativePath, entry)) {
          result.push(entry);
        }
      });
      return result;
    },
    /**
     * Add a file to the zip file, or search a file.
     * @param   {string|RegExp} name The name of the file to add (if data is defined),
     * the name of the file to find (if no data) or a regex to match files.
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
     * @param   {Object} o     File options
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
     * a file (when searching by string) or an array of files (when searching by regex).
     */
    file: function(name, data2, o) {
      if (arguments.length === 1) {
        if (isRegExp2(name)) {
          var regexp = name;
          return this.filter(function(relativePath, file2) {
            return !file2.dir && regexp.test(relativePath);
          });
        } else {
          var obj = this.files[this.root + name];
          if (obj && !obj.dir) {
            return obj;
          } else {
            return null;
          }
        }
      } else {
        name = this.root + name;
        fileAdd.call(this, name, data2, o);
      }
      return this;
    },
    /**
     * Add a directory to the zip file, or search.
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
     */
    folder: function(arg) {
      if (!arg) {
        return this;
      }
      if (isRegExp2(arg)) {
        return this.filter(function(relativePath, file2) {
          return file2.dir && arg.test(relativePath);
        });
      }
      var name = this.root + arg;
      var newFolder = folderAdd.call(this, name);
      var ret = this.clone();
      ret.root = newFolder.name;
      return ret;
    },
    /**
     * Delete a file, or a directory and all sub-files, from the zip
     * @param {string} name the name of the file to delete
     * @return {JSZip} this JSZip object
     */
    remove: function(name) {
      name = this.root + name;
      var file2 = this.files[name];
      if (!file2) {
        if (name.slice(-1) !== "/") {
          name += "/";
        }
        file2 = this.files[name];
      }
      if (file2 && !file2.dir) {
        delete this.files[name];
      } else {
        var kids = this.filter(function(relativePath, file3) {
          return file3.name.slice(0, name.length) === name;
        });
        for (var i = 0; i < kids.length; i++) {
          delete this.files[kids[i].name];
        }
      }
      return this;
    },
    /**
     * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
     */
    generate: function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    },
    /**
     * Generate the complete zip file as an internal stream.
     * @param {Object} options the options to generate the zip file :
     * - compression, "STORE" by default.
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
     * @return {StreamHelper} the streamed zip file.
     */
    generateInternalStream: function(options) {
      var worker, opts = {};
      try {
        opts = utils2.extend(options || {}, {
          streamFiles: false,
          compression: "STORE",
          compressionOptions: null,
          type: "",
          platform: "DOS",
          comment: null,
          mimeType: "application/zip",
          encodeFileName: utf82.utf8encode
        });
        opts.type = opts.type.toLowerCase();
        opts.compression = opts.compression.toUpperCase();
        if (opts.type === "binarystring") {
          opts.type = "string";
        }
        if (!opts.type) {
          throw new Error("No output type specified.");
        }
        utils2.checkSupport(opts.type);
        if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
          opts.platform = "UNIX";
        }
        if (opts.platform === "win32") {
          opts.platform = "DOS";
        }
        var comment = opts.comment || this.comment || "";
        worker = generate2.generateWorker(this, opts, comment);
      } catch (e) {
        worker = new GenericWorker("error");
        worker.error(e);
      }
      return new StreamHelper(worker, opts.type || "string", opts.mimeType);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateAsync: function(options, onUpdate) {
      return this.generateInternalStream(options).accumulate(onUpdate);
    },
    /**
     * Generate the complete zip file asynchronously.
     * @see generateInternalStream
     */
    generateNodeStream: function(options, onUpdate) {
      options = options || {};
      if (!options.type) {
        options.type = "nodebuffer";
      }
      return this.generateInternalStream(options).toNodejsStream(onUpdate);
    }
  };
  object = out;
  return object;
}
var DataReader_1;
var hasRequiredDataReader;
function requireDataReader() {
  if (hasRequiredDataReader) return DataReader_1;
  hasRequiredDataReader = 1;
  var utils2 = requireUtils$1();
  function DataReader(data2) {
    this.data = data2;
    this.length = data2.length;
    this.index = 0;
    this.zero = 0;
  }
  DataReader.prototype = {
    /**
     * Check that the offset will not go too far.
     * @param {string} offset the additional offset to check.
     * @throws {Error} an Error if the offset is out of bounds.
     */
    checkOffset: function(offset) {
      this.checkIndex(this.index + offset);
    },
    /**
     * Check that the specified index will not be too far.
     * @param {string} newIndex the index to check.
     * @throws {Error} an Error if the index is out of bounds.
     */
    checkIndex: function(newIndex) {
      if (this.length < this.zero + newIndex || newIndex < 0) {
        throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
      }
    },
    /**
     * Change the index.
     * @param {number} newIndex The new index.
     * @throws {Error} if the new index is out of the data.
     */
    setIndex: function(newIndex) {
      this.checkIndex(newIndex);
      this.index = newIndex;
    },
    /**
     * Skip the next n bytes.
     * @param {number} n the number of bytes to skip.
     * @throws {Error} if the new index is out of the data.
     */
    skip: function(n) {
      this.setIndex(this.index + n);
    },
    /**
     * Get the byte at the specified index.
     * @param {number} i the index to use.
     * @return {number} a byte.
     */
    byteAt: function() {
    },
    /**
     * Get the next number with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {number} the corresponding number.
     */
    readInt: function(size) {
      var result = 0, i;
      this.checkOffset(size);
      for (i = this.index + size - 1; i >= this.index; i--) {
        result = (result << 8) + this.byteAt(i);
      }
      this.index += size;
      return result;
    },
    /**
     * Get the next string with a given byte size.
     * @param {number} size the number of bytes to read.
     * @return {string} the corresponding string.
     */
    readString: function(size) {
      return utils2.transformTo("string", this.readData(size));
    },
    /**
     * Get raw data without conversion, <size> bytes.
     * @param {number} size the number of bytes to read.
     * @return {Object} the raw data, implementation specific.
     */
    readData: function() {
    },
    /**
     * Find the last occurrence of a zip signature (4 bytes).
     * @param {string} sig the signature to find.
     * @return {number} the index of the last occurrence, -1 if not found.
     */
    lastIndexOfSignature: function() {
    },
    /**
     * Read the signature (4 bytes) at the current position and compare it with sig.
     * @param {string} sig the expected signature
     * @return {boolean} true if the signature matches, false otherwise.
     */
    readAndCheckSignature: function() {
    },
    /**
     * Get the next date.
     * @return {Date} the date.
     */
    readDate: function() {
      var dostime = this.readInt(4);
      return new Date(Date.UTC(
        (dostime >> 25 & 127) + 1980,
        // year
        (dostime >> 21 & 15) - 1,
        // month
        dostime >> 16 & 31,
        // day
        dostime >> 11 & 31,
        // hour
        dostime >> 5 & 63,
        // minute
        (dostime & 31) << 1
      ));
    }
  };
  DataReader_1 = DataReader;
  return DataReader_1;
}
var ArrayReader_1;
var hasRequiredArrayReader;
function requireArrayReader() {
  if (hasRequiredArrayReader) return ArrayReader_1;
  hasRequiredArrayReader = 1;
  var DataReader = requireDataReader();
  var utils2 = requireUtils$1();
  function ArrayReader(data2) {
    DataReader.call(this, data2);
    for (var i = 0; i < this.data.length; i++) {
      data2[i] = data2[i] & 255;
    }
  }
  utils2.inherits(ArrayReader, DataReader);
  ArrayReader.prototype.byteAt = function(i) {
    return this.data[this.zero + i];
  };
  ArrayReader.prototype.lastIndexOfSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i = this.length - 4; i >= 0; --i) {
      if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
        return i - this.zero;
      }
    }
    return -1;
  };
  ArrayReader.prototype.readAndCheckSignature = function(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data2 = this.readData(4);
    return sig0 === data2[0] && sig1 === data2[1] && sig2 === data2[2] && sig3 === data2[3];
  };
  ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  ArrayReader_1 = ArrayReader;
  return ArrayReader_1;
}
var StringReader_1;
var hasRequiredStringReader;
function requireStringReader() {
  if (hasRequiredStringReader) return StringReader_1;
  hasRequiredStringReader = 1;
  var DataReader = requireDataReader();
  var utils2 = requireUtils$1();
  function StringReader(data2) {
    DataReader.call(this, data2);
  }
  utils2.inherits(StringReader, DataReader);
  StringReader.prototype.byteAt = function(i) {
    return this.data.charCodeAt(this.zero + i);
  };
  StringReader.prototype.lastIndexOfSignature = function(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader.prototype.readAndCheckSignature = function(sig) {
    var data2 = this.readData(4);
    return sig === data2;
  };
  StringReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  StringReader_1 = StringReader;
  return StringReader_1;
}
var Uint8ArrayReader_1;
var hasRequiredUint8ArrayReader;
function requireUint8ArrayReader() {
  if (hasRequiredUint8ArrayReader) return Uint8ArrayReader_1;
  hasRequiredUint8ArrayReader = 1;
  var ArrayReader = requireArrayReader();
  var utils2 = requireUtils$1();
  function Uint8ArrayReader(data2) {
    ArrayReader.call(this, data2);
  }
  utils2.inherits(Uint8ArrayReader, ArrayReader);
  Uint8ArrayReader.prototype.readData = function(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  Uint8ArrayReader_1 = Uint8ArrayReader;
  return Uint8ArrayReader_1;
}
var NodeBufferReader_1;
var hasRequiredNodeBufferReader;
function requireNodeBufferReader() {
  if (hasRequiredNodeBufferReader) return NodeBufferReader_1;
  hasRequiredNodeBufferReader = 1;
  var Uint8ArrayReader = requireUint8ArrayReader();
  var utils2 = requireUtils$1();
  function NodeBufferReader(data2) {
    Uint8ArrayReader.call(this, data2);
  }
  utils2.inherits(NodeBufferReader, Uint8ArrayReader);
  NodeBufferReader.prototype.readData = function(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  NodeBufferReader_1 = NodeBufferReader;
  return NodeBufferReader_1;
}
var readerFor;
var hasRequiredReaderFor;
function requireReaderFor() {
  if (hasRequiredReaderFor) return readerFor;
  hasRequiredReaderFor = 1;
  var utils2 = requireUtils$1();
  var support2 = requireSupport();
  var ArrayReader = requireArrayReader();
  var StringReader = requireStringReader();
  var NodeBufferReader = requireNodeBufferReader();
  var Uint8ArrayReader = requireUint8ArrayReader();
  readerFor = function(data2) {
    var type2 = utils2.getTypeOf(data2);
    utils2.checkSupport(type2);
    if (type2 === "string" && !support2.uint8array) {
      return new StringReader(data2);
    }
    if (type2 === "nodebuffer") {
      return new NodeBufferReader(data2);
    }
    if (support2.uint8array) {
      return new Uint8ArrayReader(utils2.transformTo("uint8array", data2));
    }
    return new ArrayReader(utils2.transformTo("array", data2));
  };
  return readerFor;
}
var zipEntry;
var hasRequiredZipEntry;
function requireZipEntry() {
  if (hasRequiredZipEntry) return zipEntry;
  hasRequiredZipEntry = 1;
  var readerFor2 = requireReaderFor();
  var utils2 = requireUtils$1();
  var CompressedObject = requireCompressedObject();
  var crc32fn = requireCrc32$2();
  var utf82 = requireUtf8();
  var compressions2 = requireCompressions();
  var support2 = requireSupport();
  var MADE_BY_DOS = 0;
  var MADE_BY_UNIX = 3;
  var findCompression = function(compressionMethod) {
    for (var method2 in compressions2) {
      if (!Object.prototype.hasOwnProperty.call(compressions2, method2)) {
        continue;
      }
      if (compressions2[method2].magic === compressionMethod) {
        return compressions2[method2];
      }
    }
    return null;
  };
  function ZipEntry(options, loadOptions) {
    this.options = options;
    this.loadOptions = loadOptions;
  }
  ZipEntry.prototype = {
    /**
     * say if the file is encrypted.
     * @return {boolean} true if the file is encrypted, false otherwise.
     */
    isEncrypted: function() {
      return (this.bitFlag & 1) === 1;
    },
    /**
     * say if the file has utf-8 filename/comment.
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
     */
    useUTF8: function() {
      return (this.bitFlag & 2048) === 2048;
    },
    /**
     * Read the local part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readLocalPart: function(reader2) {
      var compression, localExtraFieldsLength;
      reader2.skip(22);
      this.fileNameLength = reader2.readInt(2);
      localExtraFieldsLength = reader2.readInt(2);
      this.fileName = reader2.readData(this.fileNameLength);
      reader2.skip(localExtraFieldsLength);
      if (this.compressedSize === -1 || this.uncompressedSize === -1) {
        throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
      }
      compression = findCompression(this.compressionMethod);
      if (compression === null) {
        throw new Error("Corrupted zip : compression " + utils2.pretty(this.compressionMethod) + " unknown (inner file : " + utils2.transformTo("string", this.fileName) + ")");
      }
      this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader2.readData(this.compressedSize));
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readCentralPart: function(reader2) {
      this.versionMadeBy = reader2.readInt(2);
      reader2.skip(2);
      this.bitFlag = reader2.readInt(2);
      this.compressionMethod = reader2.readString(2);
      this.date = reader2.readDate();
      this.crc32 = reader2.readInt(4);
      this.compressedSize = reader2.readInt(4);
      this.uncompressedSize = reader2.readInt(4);
      var fileNameLength = reader2.readInt(2);
      this.extraFieldsLength = reader2.readInt(2);
      this.fileCommentLength = reader2.readInt(2);
      this.diskNumberStart = reader2.readInt(2);
      this.internalFileAttributes = reader2.readInt(2);
      this.externalFileAttributes = reader2.readInt(4);
      this.localHeaderOffset = reader2.readInt(4);
      if (this.isEncrypted()) {
        throw new Error("Encrypted zip are not supported");
      }
      reader2.skip(fileNameLength);
      this.readExtraFields(reader2);
      this.parseZIP64ExtraField(reader2);
      this.fileComment = reader2.readData(this.fileCommentLength);
    },
    /**
     * Parse the external file attributes and get the unix/dos permissions.
     */
    processAttributes: function() {
      this.unixPermissions = null;
      this.dosPermissions = null;
      var madeBy = this.versionMadeBy >> 8;
      this.dir = this.externalFileAttributes & 16 ? true : false;
      if (madeBy === MADE_BY_DOS) {
        this.dosPermissions = this.externalFileAttributes & 63;
      }
      if (madeBy === MADE_BY_UNIX) {
        this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
      }
      if (!this.dir && this.fileNameStr.slice(-1) === "/") {
        this.dir = true;
      }
    },
    /**
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
     * @param {DataReader} reader the reader to use.
     */
    parseZIP64ExtraField: function() {
      if (!this.extraFields[1]) {
        return;
      }
      var extraReader = readerFor2(this.extraFields[1].value);
      if (this.uncompressedSize === utils2.MAX_VALUE_32BITS) {
        this.uncompressedSize = extraReader.readInt(8);
      }
      if (this.compressedSize === utils2.MAX_VALUE_32BITS) {
        this.compressedSize = extraReader.readInt(8);
      }
      if (this.localHeaderOffset === utils2.MAX_VALUE_32BITS) {
        this.localHeaderOffset = extraReader.readInt(8);
      }
      if (this.diskNumberStart === utils2.MAX_VALUE_32BITS) {
        this.diskNumberStart = extraReader.readInt(4);
      }
    },
    /**
     * Read the central part of a zip file and add the info in this object.
     * @param {DataReader} reader the reader to use.
     */
    readExtraFields: function(reader2) {
      var end = reader2.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
      if (!this.extraFields) {
        this.extraFields = {};
      }
      while (reader2.index + 4 < end) {
        extraFieldId = reader2.readInt(2);
        extraFieldLength = reader2.readInt(2);
        extraFieldValue = reader2.readData(extraFieldLength);
        this.extraFields[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
      reader2.setIndex(end);
    },
    /**
     * Apply an UTF8 transformation if needed.
     */
    handleUTF8: function() {
      var decodeParamType = support2.uint8array ? "uint8array" : "array";
      if (this.useUTF8()) {
        this.fileNameStr = utf82.utf8decode(this.fileName);
        this.fileCommentStr = utf82.utf8decode(this.fileComment);
      } else {
        var upath = this.findExtraFieldUnicodePath();
        if (upath !== null) {
          this.fileNameStr = upath;
        } else {
          var fileNameByteArray = utils2.transformTo(decodeParamType, this.fileName);
          this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
        }
        var ucomment = this.findExtraFieldUnicodeComment();
        if (ucomment !== null) {
          this.fileCommentStr = ucomment;
        } else {
          var commentByteArray = utils2.transformTo(decodeParamType, this.fileComment);
          this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
        }
      }
    },
    /**
     * Find the unicode path declared in the extra field, if any.
     * @return {String} the unicode path, null otherwise.
     */
    findExtraFieldUnicodePath: function() {
      var upathField = this.extraFields[28789];
      if (upathField) {
        var extraReader = readerFor2(upathField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
          return null;
        }
        return utf82.utf8decode(extraReader.readData(upathField.length - 5));
      }
      return null;
    },
    /**
     * Find the unicode comment declared in the extra field, if any.
     * @return {String} the unicode comment, null otherwise.
     */
    findExtraFieldUnicodeComment: function() {
      var ucommentField = this.extraFields[25461];
      if (ucommentField) {
        var extraReader = readerFor2(ucommentField.value);
        if (extraReader.readInt(1) !== 1) {
          return null;
        }
        if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
          return null;
        }
        return utf82.utf8decode(extraReader.readData(ucommentField.length - 5));
      }
      return null;
    }
  };
  zipEntry = ZipEntry;
  return zipEntry;
}
var zipEntries;
var hasRequiredZipEntries;
function requireZipEntries() {
  if (hasRequiredZipEntries) return zipEntries;
  hasRequiredZipEntries = 1;
  var readerFor2 = requireReaderFor();
  var utils2 = requireUtils$1();
  var sig = requireSignature();
  var ZipEntry = requireZipEntry();
  var support2 = requireSupport();
  function ZipEntries(loadOptions) {
    this.files = [];
    this.loadOptions = loadOptions;
  }
  ZipEntries.prototype = {
    /**
     * Check that the reader is on the specified signature.
     * @param {string} expectedSignature the expected signature.
     * @throws {Error} if it is an other signature.
     */
    checkSignature: function(expectedSignature) {
      if (!this.reader.readAndCheckSignature(expectedSignature)) {
        this.reader.index -= 4;
        var signature2 = this.reader.readString(4);
        throw new Error("Corrupted zip or bug: unexpected signature (" + utils2.pretty(signature2) + ", expected " + utils2.pretty(expectedSignature) + ")");
      }
    },
    /**
     * Check if the given signature is at the given index.
     * @param {number} askedIndex the index to check.
     * @param {string} expectedSignature the signature to expect.
     * @return {boolean} true if the signature is here, false otherwise.
     */
    isSignature: function(askedIndex, expectedSignature) {
      var currentIndex = this.reader.index;
      this.reader.setIndex(askedIndex);
      var signature2 = this.reader.readString(4);
      var result = signature2 === expectedSignature;
      this.reader.setIndex(currentIndex);
      return result;
    },
    /**
     * Read the end of the central directory.
     */
    readBlockEndOfCentral: function() {
      this.diskNumber = this.reader.readInt(2);
      this.diskWithCentralDirStart = this.reader.readInt(2);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
      this.centralDirRecords = this.reader.readInt(2);
      this.centralDirSize = this.reader.readInt(4);
      this.centralDirOffset = this.reader.readInt(4);
      this.zipCommentLength = this.reader.readInt(2);
      var zipComment = this.reader.readData(this.zipCommentLength);
      var decodeParamType = support2.uint8array ? "uint8array" : "array";
      var decodeContent = utils2.transformTo(decodeParamType, zipComment);
      this.zipComment = this.loadOptions.decodeFileName(decodeContent);
    },
    /**
     * Read the end of the Zip 64 central directory.
     * Not merged with the method readEndOfCentral :
     * The end of central can coexist with its Zip64 brother,
     * I don't want to read the wrong number of bytes !
     */
    readBlockZip64EndOfCentral: function() {
      this.zip64EndOfCentralSize = this.reader.readInt(8);
      this.reader.skip(4);
      this.diskNumber = this.reader.readInt(4);
      this.diskWithCentralDirStart = this.reader.readInt(4);
      this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
      this.centralDirRecords = this.reader.readInt(8);
      this.centralDirSize = this.reader.readInt(8);
      this.centralDirOffset = this.reader.readInt(8);
      this.zip64ExtensibleData = {};
      var extraDataSize = this.zip64EndOfCentralSize - 44, index2 = 0, extraFieldId, extraFieldLength, extraFieldValue;
      while (index2 < extraDataSize) {
        extraFieldId = this.reader.readInt(2);
        extraFieldLength = this.reader.readInt(4);
        extraFieldValue = this.reader.readData(extraFieldLength);
        this.zip64ExtensibleData[extraFieldId] = {
          id: extraFieldId,
          length: extraFieldLength,
          value: extraFieldValue
        };
      }
    },
    /**
     * Read the end of the Zip 64 central directory locator.
     */
    readBlockZip64EndOfCentralLocator: function() {
      this.diskWithZip64CentralDirStart = this.reader.readInt(4);
      this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
      this.disksCount = this.reader.readInt(4);
      if (this.disksCount > 1) {
        throw new Error("Multi-volumes zip are not supported");
      }
    },
    /**
     * Read the local files, based on the offset read in the central part.
     */
    readLocalFiles: function() {
      var i, file2;
      for (i = 0; i < this.files.length; i++) {
        file2 = this.files[i];
        this.reader.setIndex(file2.localHeaderOffset);
        this.checkSignature(sig.LOCAL_FILE_HEADER);
        file2.readLocalPart(this.reader);
        file2.handleUTF8();
        file2.processAttributes();
      }
    },
    /**
     * Read the central directory.
     */
    readCentralDir: function() {
      var file2;
      this.reader.setIndex(this.centralDirOffset);
      while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
        file2 = new ZipEntry({
          zip64: this.zip64
        }, this.loadOptions);
        file2.readCentralPart(this.reader);
        this.files.push(file2);
      }
      if (this.centralDirRecords !== this.files.length) {
        if (this.centralDirRecords !== 0 && this.files.length === 0) {
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
        }
      }
    },
    /**
     * Read the end of central directory.
     */
    readEndOfCentral: function() {
      var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
      if (offset < 0) {
        var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
        if (isGarbage) {
          throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        } else {
          throw new Error("Corrupted zip: can't find end of central directory");
        }
      }
      this.reader.setIndex(offset);
      var endOfCentralDirOffset = offset;
      this.checkSignature(sig.CENTRAL_DIRECTORY_END);
      this.readBlockEndOfCentral();
      if (this.diskNumber === utils2.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils2.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils2.MAX_VALUE_16BITS || this.centralDirRecords === utils2.MAX_VALUE_16BITS || this.centralDirSize === utils2.MAX_VALUE_32BITS || this.centralDirOffset === utils2.MAX_VALUE_32BITS) {
        this.zip64 = true;
        offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        if (offset < 0) {
          throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
        }
        this.reader.setIndex(offset);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
        this.readBlockZip64EndOfCentralLocator();
        if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
          this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          if (this.relativeOffsetEndOfZip64CentralDir < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          }
        }
        this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
        this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
        this.readBlockZip64EndOfCentral();
      }
      var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
      if (this.zip64) {
        expectedEndOfCentralDirOffset += 20;
        expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
      }
      var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
      if (extraBytes > 0) {
        if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) ;
        else {
          this.reader.zero = extraBytes;
        }
      } else if (extraBytes < 0) {
        throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
      }
    },
    prepareReader: function(data2) {
      this.reader = readerFor2(data2);
    },
    /**
     * Read a zip file and create ZipEntries.
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
     */
    load: function(data2) {
      this.prepareReader(data2);
      this.readEndOfCentral();
      this.readCentralDir();
      this.readLocalFiles();
    }
  };
  zipEntries = ZipEntries;
  return zipEntries;
}
var load;
var hasRequiredLoad;
function requireLoad() {
  if (hasRequiredLoad) return load;
  hasRequiredLoad = 1;
  var utils2 = requireUtils$1();
  var external2 = requireExternal();
  var utf82 = requireUtf8();
  var ZipEntries = requireZipEntries();
  var Crc32Probe = requireCrc32Probe();
  var nodejsUtils2 = requireNodejsUtils();
  function checkEntryCRC32(zipEntry2) {
    return new external2.Promise(function(resolve, reject2) {
      var worker = zipEntry2.decompressed.getContentWorker().pipe(new Crc32Probe());
      worker.on("error", function(e) {
        reject2(e);
      }).on("end", function() {
        if (worker.streamInfo.crc32 !== zipEntry2.decompressed.crc32) {
          reject2(new Error("Corrupted zip : CRC32 mismatch"));
        } else {
          resolve();
        }
      }).resume();
    });
  }
  load = function(data2, options) {
    var zip2 = this;
    options = utils2.extend(options || {}, {
      base64: false,
      checkCRC32: false,
      optimizedBinaryString: false,
      createFolders: false,
      decodeFileName: utf82.utf8decode
    });
    if (nodejsUtils2.isNode && nodejsUtils2.isStream(data2)) {
      return external2.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
    }
    return utils2.prepareContent("the loaded zip file", data2, true, options.optimizedBinaryString, options.base64).then(function(data3) {
      var zipEntries2 = new ZipEntries(options);
      zipEntries2.load(data3);
      return zipEntries2;
    }).then(function checkCRC32(zipEntries2) {
      var promises = [external2.Promise.resolve(zipEntries2)];
      var files = zipEntries2.files;
      if (options.checkCRC32) {
        for (var i = 0; i < files.length; i++) {
          promises.push(checkEntryCRC32(files[i]));
        }
      }
      return external2.Promise.all(promises);
    }).then(function addFiles(results) {
      var zipEntries2 = results.shift();
      var files = zipEntries2.files;
      for (var i = 0; i < files.length; i++) {
        var input = files[i];
        var unsafeName = input.fileNameStr;
        var safeName = utils2.resolve(input.fileNameStr);
        zip2.file(safeName, input.decompressed, {
          binary: true,
          optimizedBinaryString: true,
          date: input.date,
          dir: input.dir,
          comment: input.fileCommentStr.length ? input.fileCommentStr : null,
          unixPermissions: input.unixPermissions,
          dosPermissions: input.dosPermissions,
          createFolders: options.createFolders
        });
        if (!input.dir) {
          zip2.file(safeName).unsafeOriginalName = unsafeName;
        }
      }
      if (zipEntries2.zipComment.length) {
        zip2.comment = zipEntries2.zipComment;
      }
      return zip2;
    });
  };
  return load;
}
var lib$1;
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$1;
  hasRequiredLib$1 = 1;
  function JSZip() {
    if (!(this instanceof JSZip)) {
      return new JSZip();
    }
    if (arguments.length) {
      throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
    }
    this.files = /* @__PURE__ */ Object.create(null);
    this.comment = null;
    this.root = "";
    this.clone = function() {
      var newObj = new JSZip();
      for (var i in this) {
        if (typeof this[i] !== "function") {
          newObj[i] = this[i];
        }
      }
      return newObj;
    };
  }
  JSZip.prototype = requireObject();
  JSZip.prototype.loadAsync = requireLoad();
  JSZip.support = requireSupport();
  JSZip.defaults = requireDefaults();
  JSZip.version = "3.10.1";
  JSZip.loadAsync = function(content, options) {
    return new JSZip().loadAsync(content, options);
  };
  JSZip.external = requireExternal();
  lib$1 = JSZip;
  return lib$1;
}
var readable$4 = { exports: {} };
var stream$4;
var hasRequiredStream$4;
function requireStream$4() {
  if (hasRequiredStream$4) return stream$4;
  hasRequiredStream$4 = 1;
  stream$4 = require$$0$1;
  return stream$4;
}
var buffer_list;
var hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props2) {
    for (var i = 0; i < props2.length; i++) {
      var descriptor = props2[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    Object.defineProperty(Constructor, "prototype", { writable: false });
    return Constructor;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(input);
  }
  var _require = require$$0$7, Buffer2 = _require.Buffer;
  var _require2 = require$$0$2, inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src2, target, offset) {
    Buffer2.prototype.copy.call(src2, target, offset);
  }
  buffer_list = /* @__PURE__ */ function() {
    function BufferList2() {
      _classCallCheck(this, BufferList2);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList2, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) ret += s + p.data;
        return ret;
      }
    }, {
      key: "concat",
      value: function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length) ret += str;
          else ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next) this.head = p.next;
              else this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: custom,
      value: function value(_2, options) {
        return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: false
        }));
      }
    }]);
    return BufferList2;
  }();
  return buffer_list;
}
var destroy_1$4;
var hasRequiredDestroy$4;
function requireDestroy$4() {
  if (hasRequiredDestroy$4) return destroy_1$4;
  hasRequiredDestroy$4 = 1;
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose) return;
    if (self2._readableState && !self2._readableState.emitClose) return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream2, err) {
    var rState = stream2._readableState;
    var wState = stream2._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream2.destroy(err);
    else stream2.emit("error", err);
  }
  destroy_1$4 = {
    destroy,
    undestroy,
    errorOrDestroy
  };
  return destroy_1$4;
}
var errors$1 = {};
var hasRequiredErrors$1;
function requireErrors$1() {
  if (hasRequiredErrors$1) return errors$1;
  hasRequiredErrors$1 = 1;
  const codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(0, search.length) === search;
  }
  function endsWith2(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith2(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type2 = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type2} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  errors$1.codes = codes;
  return errors$1;
}
var state;
var hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var ERR_INVALID_OPT_VALUE = requireErrors$1().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state2, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state2.objectMode ? 16 : 16 * 1024;
  }
  state = {
    getHighWaterMark
  };
  return state;
}
var _stream_writable$4;
var hasRequired_stream_writable$4;
function require_stream_writable$4() {
  if (hasRequired_stream_writable$4) return _stream_writable$4;
  hasRequired_stream_writable$4 = 1;
  _stream_writable$4 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream$4();
  var Buffer2 = require$$0$7.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$4();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  requireInherits()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex$4();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$4();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream2, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream2, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ending) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (state2.destroyed) state2.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      errorOrDestroy(stream2, er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2) || stream2.destroyed;
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        process.nextTick(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        errorOrDestroy(stream2, err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function" && !state2.destroyed) {
        state2.pendingcb++;
        state2.finalCalled = true;
        process.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
        if (state2.autoDestroy) {
          var rState = stream2._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream2.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) process.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  return _stream_writable$4;
}
var _stream_duplex$4;
var hasRequired_stream_duplex$4;
function require_stream_duplex$4() {
  if (hasRequired_stream_duplex$4) return _stream_duplex$4;
  hasRequired_stream_duplex$4 = 1;
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) keys2.push(key);
    return keys2;
  };
  _stream_duplex$4 = Duplex;
  var Readable2 = require_stream_readable$4();
  var Writable = require_stream_writable$4();
  requireInherits()(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false) this.readable = false;
      if (options.writable === false) this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended) return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  return _stream_duplex$4;
}
var string_decoder$4 = {};
var safeBuffer$4 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$4;
function requireSafeBuffer$4() {
  if (hasRequiredSafeBuffer$4) return safeBuffer$4.exports;
  hasRequiredSafeBuffer$4 = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$4, safeBuffer$4.exports);
  return safeBuffer$4.exports;
}
var hasRequiredString_decoder$4;
function requireString_decoder$4() {
  if (hasRequiredString_decoder$4) return string_decoder$4;
  hasRequiredString_decoder$4 = 1;
  var Buffer2 = requireSafeBuffer$4().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$4.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$4;
}
var endOfStream$1;
var hasRequiredEndOfStream$1;
function requireEndOfStream$1() {
  if (hasRequiredEndOfStream$1) return endOfStream$1;
  hasRequiredEndOfStream$1 = 1;
  var ERR_STREAM_PREMATURE_CLOSE = requireErrors$1().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop2() {
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function eos(stream2, opts, callback) {
    if (typeof opts === "function") return eos(stream2, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop2);
    var readable2 = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream2.writable) onfinish();
    };
    var writableEnded = stream2._writableState && stream2._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable2) callback.call(stream2);
    };
    var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
    var onend = function onend2() {
      readable2 = false;
      readableEnded = true;
      if (!writable) callback.call(stream2);
    };
    var onerror = function onerror2(err) {
      callback.call(stream2, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable2 && !readableEnded) {
        if (!stream2._readableState || !stream2._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
      if (writable && !writableEnded) {
        if (!stream2._writableState || !stream2._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream2, err);
      }
    };
    var onrequest = function onrequest2() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest2(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req) onrequest();
      else stream2.on("request", onrequest);
    } else if (writable && !stream2._writableState) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false) stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  }
  endOfStream$1 = eos;
  return endOfStream$1;
}
var async_iterator;
var hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var finished = requireEndOfStream$1();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data2 = iter[kStream].read();
      if (data2 !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data2, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject2) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject2);
      }, reject2);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error2 = this[kError];
      if (error2 !== null) {
        return Promise.reject(error2);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject2) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject2(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise2;
      if (lastPromise) {
        promise2 = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data2 = this[kStream].read();
        if (data2 !== null) {
          return Promise.resolve(createIterResult(data2, false));
        }
        promise2 = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise2;
      return promise2;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject2) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject2(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
    var _Object$create;
    var iterator2 = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream2,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream2._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject2) {
        var data2 = iterator2[kStream].read();
        if (data2) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          resolve(createIterResult(data2, false));
        } else {
          iterator2[kLastResolve] = resolve;
          iterator2[kLastReject] = reject2;
        }
      },
      writable: true
    }), _Object$create));
    iterator2[kLastPromise] = null;
    finished(stream2, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject2 = iterator2[kLastReject];
        if (reject2 !== null) {
          iterator2[kLastPromise] = null;
          iterator2[kLastResolve] = null;
          iterator2[kLastReject] = null;
          reject2(err);
        }
        iterator2[kError] = err;
        return;
      }
      var resolve = iterator2[kLastResolve];
      if (resolve !== null) {
        iterator2[kLastPromise] = null;
        iterator2[kLastResolve] = null;
        iterator2[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator2[kEnded] = true;
    });
    stream2.on("readable", onReadable.bind(null, iterator2));
    return iterator2;
  };
  async_iterator = createReadableStreamAsyncIterator;
  return async_iterator;
}
var from_1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from_1;
  hasRequiredFrom = 1;
  function asyncGeneratorStep(gen, resolve, reject2, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error2) {
      reject2(error2);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject2) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject2, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  function ownKeys(object2, enumerableOnly) {
    var keys = Object.keys(object2);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object2);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint);
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  var ERR_INVALID_ARG_TYPE = requireErrors$1().codes.ERR_INVALID_ARG_TYPE;
  function from(Readable2, iterable, opts) {
    var iterator2;
    if (iterable && typeof iterable.next === "function") {
      iterator2 = iterable;
    } else if (iterable && iterable[Symbol.asyncIterator]) iterator2 = iterable[Symbol.asyncIterator]();
    else if (iterable && iterable[Symbol.iterator]) iterator2 = iterable[Symbol.iterator]();
    else throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
    var readable2 = new Readable2(_objectSpread({
      objectMode: true
    }, opts));
    var reading = false;
    readable2._read = function() {
      if (!reading) {
        reading = true;
        next();
      }
    };
    function next() {
      return _next2.apply(this, arguments);
    }
    function _next2() {
      _next2 = _asyncToGenerator(function* () {
        try {
          var _yield$iterator$next = yield iterator2.next(), value = _yield$iterator$next.value, done = _yield$iterator$next.done;
          if (done) {
            readable2.push(null);
          } else if (readable2.push(yield value)) {
            next();
          } else {
            reading = false;
          }
        } catch (err) {
          readable2.destroy(err);
        }
      });
      return _next2.apply(this, arguments);
    }
    return readable2;
  }
  from_1 = from;
  return from_1;
}
var _stream_readable$4;
var hasRequired_stream_readable$4;
function require_stream_readable$4() {
  if (hasRequired_stream_readable$4) return _stream_readable$4;
  hasRequired_stream_readable$4 = 1;
  _stream_readable$4 = Readable2;
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream$4();
  var Buffer2 = require$$0$7.Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require$$0$2;
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList2 = requireBuffer_list();
  var destroyImpl = requireDestroy$4();
  var _require = requireState(), getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = requireErrors$1().codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  requireInherits()(Readable2, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2, isDuplex) {
    Duplex = Duplex || require_stream_duplex$4();
    options = options || {};
    if (typeof isDuplex !== "boolean") isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder$4().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$4();
    if (!(this instanceof Readable2)) return new Readable2(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        errorOrDestroy(stream2, er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state2.destroyed) {
          return false;
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
        maybeReadMore(stream2, state2);
      }
    }
    return !state2.ended && (state2.length < state2.highWaterMark || state2.length === 0);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      state2.awaitDrain = 0;
      stream2.emit("data", chunk);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder$4().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "") this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && ((state2.highWaterMark !== 0 ? state2.length >= state2.highWaterMark : state2.length > 0) || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = state2.length <= state2.highWaterMark;
      n = 0;
    } else {
      state2.length -= n;
      state2.awaitDrain = 0;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    debug("onEofChunk");
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    if (state2.sync) {
      emitReadable(stream2);
    } else {
      state2.needReadable = false;
      if (!state2.emittedReadable) {
        state2.emittedReadable = true;
        emitReadable_(stream2);
      }
    }
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    debug("emitReadable", state2.needReadable, state2.emittedReadable);
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      process.nextTick(emitReadable_, stream2);
    }
  }
  function emitReadable_(stream2) {
    var state2 = stream2._readableState;
    debug("emitReadable_", state2.destroyed, state2.length, state2.ended);
    if (!state2.destroyed && (state2.length || state2.ended)) {
      stream2.emit("readable");
      state2.emittedReadable = false;
    }
    state2.needReadable = !state2.flowing && !state2.ended && state2.length <= state2.highWaterMark;
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      process.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    while (!state2.reading && !state2.ended && (state2.length < state2.highWaterMark || state2.flowing && state2.length === 0)) {
      var len = state2.length;
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) process.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function pipeOnDrainFunctionResult() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
        hasUnpiped: false
      });
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state2 = this._readableState;
    if (ev === "data") {
      state2.readableListening = this.listenerCount("readable") > 0;
      if (state2.flowing !== false) this.resume();
    } else if (ev === "readable") {
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.flowing = false;
        state2.emittedReadable = false;
        debug("on readable", state2.length, state2.reading);
        if (state2.length) {
          emitReadable(this);
        } else if (!state2.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  Readable2.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable2.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state2 = self2._readableState;
    state2.readableListening = self2.listenerCount("readable") > 0;
    if (state2.resumeScheduled && !state2.paused) {
      state2.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = !state2.readableListening;
      resume(this, state2);
    }
    state2.paused = false;
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      process.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    debug("resume", state2.reading);
    if (!state2.reading) {
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) ;
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function methodWrap(method2) {
          return function methodWrapReturnFunction() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable2.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = requireAsync_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable2.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.flowing;
    },
    set: function set(state2) {
      if (this._readableState) {
        this._readableState.flowing = state2;
      }
    }
  });
  Readable2._fromList = fromList;
  Object.defineProperty(Readable2.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function get2() {
      return this._readableState.length;
    }
  });
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.first();
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = state2.buffer.consume(n, state2.decoder);
    }
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    debug("endReadable", state2.endEmitted);
    if (!state2.endEmitted) {
      state2.ended = true;
      process.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    debug("endReadableNT", state2.endEmitted, state2.length);
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
      if (state2.autoDestroy) {
        var wState = stream2._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream2.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable2.from = function(iterable, opts) {
      if (from === void 0) {
        from = requireFrom();
      }
      return from(Readable2, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$4;
}
var _stream_transform$4;
var hasRequired_stream_transform$4;
function require_stream_transform$4() {
  if (hasRequired_stream_transform$4) return _stream_transform$4;
  hasRequired_stream_transform$4 = 1;
  _stream_transform$4 = Transform;
  var _require$codes = requireErrors$1().codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex$4();
  requireInherits()(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream2._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream2.push(null);
  }
  return _stream_transform$4;
}
var _stream_passthrough$4;
var hasRequired_stream_passthrough$4;
function require_stream_passthrough$4() {
  if (hasRequired_stream_passthrough$4) return _stream_passthrough$4;
  hasRequired_stream_passthrough$4 = 1;
  _stream_passthrough$4 = PassThrough;
  var Transform = require_stream_transform$4();
  requireInherits()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$4;
}
var pipeline_1;
var hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var eos;
  function once2(callback) {
    var called = false;
    return function() {
      if (called) return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = requireErrors$1().codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop2(err) {
    if (err) throw err;
  }
  function isRequest2(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  }
  function destroyer(stream2, reading, writing, callback) {
    callback = once2(callback);
    var closed = false;
    stream2.on("close", function() {
      closed = true;
    });
    if (eos === void 0) eos = requireEndOfStream$1();
    eos(stream2, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err) return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed) return;
      if (destroyed) return;
      destroyed = true;
      if (isRequest2(stream2)) return stream2.abort();
      if (typeof stream2.destroy === "function") return stream2.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length) return noop2;
    if (typeof streams[streams.length - 1] !== "function") return noop2;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0])) streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error2;
    var destroys = streams.map(function(stream2, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream2, reading, writing, function(err) {
        if (!error2) error2 = err;
        if (err) destroys.forEach(call);
        if (reading) return;
        destroys.forEach(call);
        callback(error2);
      });
    });
    return streams.reduce(pipe);
  }
  pipeline_1 = pipeline;
  return pipeline_1;
}
var hasRequiredReadable$4;
function requireReadable$4() {
  if (hasRequiredReadable$4) return readable$4.exports;
  hasRequiredReadable$4 = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream.Readable;
      Object.assign(module.exports, Stream);
      module.exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable$4();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$4();
      exports.Duplex = require_stream_duplex$4();
      exports.Transform = require_stream_transform$4();
      exports.PassThrough = require_stream_passthrough$4();
      exports.finished = requireEndOfStream$1();
      exports.pipeline = requirePipeline();
    }
  })(readable$4, readable$4.exports);
  return readable$4.exports;
}
var utils_1;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils_1;
  hasRequiredUtils = 1;
  const fs2 = require$$0$4;
  const inherits2 = function(cls, superCtor, statics, prototype2) {
    cls.super_ = superCtor;
    if (!prototype2) {
      prototype2 = statics;
      statics = null;
    }
    if (statics) {
      Object.keys(statics).forEach((i) => {
        Object.defineProperty(cls, i, Object.getOwnPropertyDescriptor(statics, i));
      });
    }
    const properties = {
      constructor: {
        value: cls,
        enumerable: false,
        writable: false,
        configurable: true
      }
    };
    if (prototype2) {
      Object.keys(prototype2).forEach((i) => {
        properties[i] = Object.getOwnPropertyDescriptor(prototype2, i);
      });
    }
    cls.prototype = Object.create(superCtor.prototype, properties);
  };
  const xmlDecodeRegex = /[<>&'"\x7F\x00-\x08\x0B-\x0C\x0E-\x1F]/;
  const utils2 = {
    nop() {
    },
    promiseImmediate(value) {
      return new Promise((resolve) => {
        if (commonjsGlobal.setImmediate) {
          setImmediate(() => {
            resolve(value);
          });
        } else {
          setTimeout(() => {
            resolve(value);
          }, 1);
        }
      });
    },
    inherits: inherits2,
    dateToExcel(d, date1904) {
      return 25569 + d.getTime() / (24 * 3600 * 1e3) - (date1904 ? 1462 : 0);
    },
    excelToDate(v, date1904) {
      const millisecondSinceEpoch = Math.round((v - 25569 + (date1904 ? 1462 : 0)) * 24 * 3600 * 1e3);
      return new Date(millisecondSinceEpoch);
    },
    parsePath(filepath) {
      const last = filepath.lastIndexOf("/");
      return {
        path: filepath.substring(0, last),
        name: filepath.substring(last + 1)
      };
    },
    getRelsPath(filepath) {
      const path2 = utils2.parsePath(filepath);
      return `${path2.path}/_rels/${path2.name}.rels`;
    },
    xmlEncode(text) {
      const regexResult = xmlDecodeRegex.exec(text);
      if (!regexResult) return text;
      let result = "";
      let escape = "";
      let lastIndex = 0;
      let i = regexResult.index;
      for (; i < text.length; i++) {
        const charCode = text.charCodeAt(i);
        switch (charCode) {
          case 34:
            escape = "&quot;";
            break;
          case 38:
            escape = "&amp;";
            break;
          case 39:
            escape = "&apos;";
            break;
          case 60:
            escape = "&lt;";
            break;
          case 62:
            escape = "&gt;";
            break;
          case 127:
            escape = "";
            break;
          default: {
            if (charCode <= 31 && (charCode <= 8 || charCode >= 11 && charCode !== 13)) {
              escape = "";
              break;
            }
            continue;
          }
        }
        if (lastIndex !== i) result += text.substring(lastIndex, i);
        lastIndex = i + 1;
        if (escape) result += escape;
      }
      if (lastIndex !== i) return result + text.substring(lastIndex, i);
      return result;
    },
    xmlDecode(text) {
      return text.replace(/&([a-z]*);/g, (c) => {
        switch (c) {
          case "&lt;":
            return "<";
          case "&gt;":
            return ">";
          case "&amp;":
            return "&";
          case "&apos;":
            return "'";
          case "&quot;":
            return '"';
          default:
            return c;
        }
      });
    },
    validInt(value) {
      const i = parseInt(value, 10);
      return !Number.isNaN(i) ? i : 0;
    },
    isDateFmt(fmt) {
      if (!fmt) {
        return false;
      }
      fmt = fmt.replace(/\[[^\]]*]/g, "");
      fmt = fmt.replace(/"[^"]*"/g, "");
      const result = fmt.match(/[ymdhMsb]+/) !== null;
      return result;
    },
    fs: {
      exists(path2) {
        return new Promise((resolve) => {
          fs2.access(path2, fs2.constants.F_OK, (err) => {
            resolve(!err);
          });
        });
      }
    },
    toIsoDateString(dt) {
      return dt.toIsoString().subsstr(0, 10);
    },
    parseBoolean(value) {
      return value === true || value === "true" || value === 1 || value === "1";
    }
  };
  utils_1 = utils2;
  return utils_1;
}
var stringBuf;
var hasRequiredStringBuf;
function requireStringBuf() {
  if (hasRequiredStringBuf) return stringBuf;
  hasRequiredStringBuf = 1;
  class StringBuf {
    constructor(options) {
      this._buf = Buffer.alloc(options && options.size || 16384);
      this._encoding = options && options.encoding || "utf8";
      this._inPos = 0;
      this._buffer = void 0;
    }
    get length() {
      return this._inPos;
    }
    get capacity() {
      return this._buf.length;
    }
    get buffer() {
      return this._buf;
    }
    toBuffer() {
      if (!this._buffer) {
        this._buffer = Buffer.alloc(this.length);
        this._buf.copy(this._buffer, 0, 0, this.length);
      }
      return this._buffer;
    }
    reset(position) {
      position = position || 0;
      this._buffer = void 0;
      this._inPos = position;
    }
    _grow(min2) {
      let size = this._buf.length * 2;
      while (size < min2) {
        size *= 2;
      }
      const buf = Buffer.alloc(size);
      this._buf.copy(buf, 0);
      this._buf = buf;
    }
    addText(text) {
      this._buffer = void 0;
      let inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
      while (inPos >= this._buf.length - 4) {
        this._grow(this._inPos + text.length);
        inPos = this._inPos + this._buf.write(text, this._inPos, this._encoding);
      }
      this._inPos = inPos;
    }
    addStringBuf(inBuf) {
      if (inBuf.length) {
        this._buffer = void 0;
        if (this.length + inBuf.length > this.capacity) {
          this._grow(this.length + inBuf.length);
        }
        inBuf._buf.copy(this._buf, this._inPos, 0, inBuf.length);
        this._inPos += inBuf.length;
      }
    }
  }
  stringBuf = StringBuf;
  return stringBuf;
}
var streamBuf;
var hasRequiredStreamBuf;
function requireStreamBuf() {
  if (hasRequiredStreamBuf) return streamBuf;
  hasRequiredStreamBuf = 1;
  const Stream = requireReadable$4();
  const utils2 = requireUtils();
  const StringBuf = requireStringBuf();
  class StringChunk {
    constructor(data2, encoding) {
      this._data = data2;
      this._encoding = encoding;
    }
    get length() {
      return this.toBuffer().length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
      return this.toBuffer().copy(target, targetOffset, offset, length);
    }
    toBuffer() {
      if (!this._buffer) {
        this._buffer = Buffer.from(this._data, this._encoding);
      }
      return this._buffer;
    }
  }
  class StringBufChunk {
    constructor(data2) {
      this._data = data2;
    }
    get length() {
      return this._data.length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
      return this._data._buf.copy(target, targetOffset, offset, length);
    }
    toBuffer() {
      return this._data.toBuffer();
    }
  }
  class BufferChunk {
    constructor(data2) {
      this._data = data2;
    }
    get length() {
      return this._data.length;
    }
    // copy to target buffer
    copy(target, targetOffset, offset, length) {
      this._data.copy(target, targetOffset, offset, length);
    }
    toBuffer() {
      return this._data;
    }
  }
  class ReadWriteBuf {
    constructor(size) {
      this.size = size;
      this.buffer = Buffer.alloc(size);
      this.iRead = 0;
      this.iWrite = 0;
    }
    toBuffer() {
      if (this.iRead === 0 && this.iWrite === this.size) {
        return this.buffer;
      }
      const buf = Buffer.alloc(this.iWrite - this.iRead);
      this.buffer.copy(buf, 0, this.iRead, this.iWrite);
      return buf;
    }
    get length() {
      return this.iWrite - this.iRead;
    }
    get eod() {
      return this.iRead === this.iWrite;
    }
    get full() {
      return this.iWrite === this.size;
    }
    read(size) {
      let buf;
      if (size === 0) {
        return null;
      }
      if (size === void 0 || size >= this.length) {
        buf = this.toBuffer();
        this.iRead = this.iWrite;
        return buf;
      }
      buf = Buffer.alloc(size);
      this.buffer.copy(buf, 0, this.iRead, size);
      this.iRead += size;
      return buf;
    }
    write(chunk, offset, length) {
      const size = Math.min(length, this.size - this.iWrite);
      chunk.copy(this.buffer, this.iWrite, offset, offset + size);
      this.iWrite += size;
      return size;
    }
  }
  const StreamBuf = function(options) {
    options = options || {};
    this.bufSize = options.bufSize || 1024 * 1024;
    this.buffers = [];
    this.batch = options.batch || false;
    this.corked = false;
    this.inPos = 0;
    this.outPos = 0;
    this.pipes = [];
    this.paused = false;
    this.encoding = null;
  };
  utils2.inherits(StreamBuf, Stream.Duplex, {
    toBuffer() {
      switch (this.buffers.length) {
        case 0:
          return null;
        case 1:
          return this.buffers[0].toBuffer();
        default:
          return Buffer.concat(this.buffers.map((rwBuf) => rwBuf.toBuffer()));
      }
    },
    // writable
    // event drain - if write returns false (which it won't), indicates when safe to write again.
    // finish - end() has been called
    // pipe(src) - pipe() has been called on readable
    // unpipe(src) - unpipe() has been called on readable
    // error - duh
    _getWritableBuffer() {
      if (this.buffers.length) {
        const last = this.buffers[this.buffers.length - 1];
        if (!last.full) {
          return last;
        }
      }
      const buf = new ReadWriteBuf(this.bufSize);
      this.buffers.push(buf);
      return buf;
    },
    async _pipe(chunk) {
      const write = function(pipe) {
        return new Promise((resolve) => {
          pipe.write(chunk.toBuffer(), () => {
            resolve();
          });
        });
      };
      await Promise.all(this.pipes.map(write));
    },
    _writeToBuffers(chunk) {
      let inPos = 0;
      const inLen = chunk.length;
      while (inPos < inLen) {
        const buffer = this._getWritableBuffer();
        inPos += buffer.write(chunk, inPos, inLen - inPos);
      }
    },
    async write(data2, encoding, callback) {
      if (encoding instanceof Function) {
        callback = encoding;
        encoding = "utf8";
      }
      callback = callback || utils2.nop;
      let chunk;
      if (data2 instanceof StringBuf) {
        chunk = new StringBufChunk(data2);
      } else if (data2 instanceof Buffer) {
        chunk = new BufferChunk(data2);
      } else if (typeof data2 === "string" || data2 instanceof String || data2 instanceof ArrayBuffer) {
        chunk = new StringChunk(data2, encoding);
      } else {
        throw new Error("Chunk must be one of type String, Buffer or StringBuf.");
      }
      if (this.pipes.length) {
        if (this.batch) {
          this._writeToBuffers(chunk);
          while (!this.corked && this.buffers.length > 1) {
            this._pipe(this.buffers.shift());
          }
        } else if (!this.corked) {
          await this._pipe(chunk);
          callback();
        } else {
          this._writeToBuffers(chunk);
          process.nextTick(callback);
        }
      } else {
        if (!this.paused) {
          this.emit("data", chunk.toBuffer());
        }
        this._writeToBuffers(chunk);
        this.emit("readable");
      }
      return true;
    },
    cork() {
      this.corked = true;
    },
    _flush() {
      if (this.pipes.length) {
        while (this.buffers.length) {
          this._pipe(this.buffers.shift());
        }
      }
    },
    uncork() {
      this.corked = false;
      this._flush();
    },
    end(chunk, encoding, callback) {
      const writeComplete = (error2) => {
        if (error2) {
          callback(error2);
        } else {
          this._flush();
          this.pipes.forEach((pipe) => {
            pipe.end();
          });
          this.emit("finish");
        }
      };
      if (chunk) {
        this.write(chunk, encoding, writeComplete);
      } else {
        writeComplete();
      }
    },
    // readable
    // event readable - some data is now available
    // event data - switch to flowing mode - feeds chunks to handler
    // event end - no more data
    // event close - optional, indicates upstream close
    // event error - duh
    read(size) {
      let buffers2;
      if (size) {
        buffers2 = [];
        while (size && this.buffers.length && !this.buffers[0].eod) {
          const first = this.buffers[0];
          const buffer = first.read(size);
          size -= buffer.length;
          buffers2.push(buffer);
          if (first.eod && first.full) {
            this.buffers.shift();
          }
        }
        return Buffer.concat(buffers2);
      }
      buffers2 = this.buffers.map((buf) => buf.toBuffer()).filter(Boolean);
      this.buffers = [];
      return Buffer.concat(buffers2);
    },
    setEncoding(encoding) {
      this.encoding = encoding;
    },
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    },
    isPaused() {
      return !!this.paused;
    },
    pipe(destination) {
      this.pipes.push(destination);
      if (!this.paused && this.buffers.length) {
        this.end();
      }
    },
    unpipe(destination) {
      this.pipes = this.pipes.filter((pipe) => pipe !== destination);
    },
    unshift() {
      throw new Error("Not Implemented");
    },
    wrap() {
      throw new Error("Not Implemented");
    }
  });
  streamBuf = StreamBuf;
  return streamBuf;
}
var browserBufferEncode = {};
var hasRequiredBrowserBufferEncode;
function requireBrowserBufferEncode() {
  if (hasRequiredBrowserBufferEncode) return browserBufferEncode;
  hasRequiredBrowserBufferEncode = 1;
  const textEncoder2 = typeof TextEncoder === "undefined" ? null : new TextEncoder("utf-8");
  const { Buffer: Buffer2 } = require$$0$7;
  function stringToBuffer(str) {
    if (typeof str !== "string") {
      return str;
    }
    if (textEncoder2) {
      return Buffer2.from(textEncoder2.encode(str).buffer);
    }
    return Buffer2.from(str);
  }
  browserBufferEncode.stringToBuffer = stringToBuffer;
  return browserBufferEncode;
}
var zipStream$1;
var hasRequiredZipStream$1;
function requireZipStream$1() {
  if (hasRequiredZipStream$1) return zipStream$1;
  hasRequiredZipStream$1 = 1;
  const events = require$$2$1;
  const JSZip = requireLib$1();
  const StreamBuf = requireStreamBuf();
  const { stringToBuffer } = requireBrowserBufferEncode();
  class ZipWriter extends events.EventEmitter {
    constructor(options) {
      super();
      this.options = Object.assign(
        {
          type: "nodebuffer",
          compression: "DEFLATE"
        },
        options
      );
      this.zip = new JSZip();
      this.stream = new StreamBuf();
    }
    append(data2, options) {
      if (options.hasOwnProperty("base64") && options.base64) {
        this.zip.file(options.name, data2, { base64: true });
      } else {
        if (process.browser && typeof data2 === "string") {
          data2 = stringToBuffer(data2);
        }
        this.zip.file(options.name, data2);
      }
    }
    async finalize() {
      const content = await this.zip.generateAsync(this.options);
      this.stream.end(content);
      this.emit("finish");
    }
    // ==========================================================================
    // Stream.Readable interface
    read(size) {
      return this.stream.read(size);
    }
    setEncoding(encoding) {
      return this.stream.setEncoding(encoding);
    }
    pause() {
      return this.stream.pause();
    }
    resume() {
      return this.stream.resume();
    }
    isPaused() {
      return this.stream.isPaused();
    }
    pipe(destination, options) {
      return this.stream.pipe(destination, options);
    }
    unpipe(destination) {
      return this.stream.unpipe(destination);
    }
    unshift(chunk) {
      return this.stream.unshift(chunk);
    }
    wrap(stream2) {
      return this.stream.wrap(stream2);
    }
  }
  zipStream$1 = {
    ZipWriter
  };
  return zipStream$1;
}
var xmlStream;
var hasRequiredXmlStream;
function requireXmlStream() {
  if (hasRequiredXmlStream) return xmlStream;
  hasRequiredXmlStream = 1;
  const _2 = requireUnderDash();
  const utils2 = requireUtils();
  const OPEN_ANGLE = "<";
  const CLOSE_ANGLE = ">";
  const OPEN_ANGLE_SLASH = "</";
  const CLOSE_SLASH_ANGLE = "/>";
  function pushAttribute(xml, name, value) {
    xml.push(` ${name}="${utils2.xmlEncode(value.toString())}"`);
  }
  function pushAttributes(xml, attributes) {
    if (attributes) {
      const tmp2 = [];
      _2.each(attributes, (value, name) => {
        if (value !== void 0) {
          pushAttribute(tmp2, name, value);
        }
      });
      xml.push(tmp2.join(""));
    }
  }
  class XmlStream {
    constructor() {
      this._xml = [];
      this._stack = [];
      this._rollbacks = [];
    }
    get tos() {
      return this._stack.length ? this._stack[this._stack.length - 1] : void 0;
    }
    get cursor() {
      return this._xml.length;
    }
    openXml(docAttributes) {
      const xml = this._xml;
      xml.push("<?xml");
      pushAttributes(xml, docAttributes);
      xml.push("?>\n");
    }
    openNode(name, attributes) {
      const parent2 = this.tos;
      const xml = this._xml;
      if (parent2 && this.open) {
        xml.push(CLOSE_ANGLE);
      }
      this._stack.push(name);
      xml.push(OPEN_ANGLE);
      xml.push(name);
      pushAttributes(xml, attributes);
      this.leaf = true;
      this.open = true;
    }
    addAttribute(name, value) {
      if (!this.open) {
        throw new Error("Cannot write attributes to node if it is not open");
      }
      if (value !== void 0) {
        pushAttribute(this._xml, name, value);
      }
    }
    addAttributes(attrs) {
      if (!this.open) {
        throw new Error("Cannot write attributes to node if it is not open");
      }
      pushAttributes(this._xml, attrs);
    }
    writeText(text) {
      const xml = this._xml;
      if (this.open) {
        xml.push(CLOSE_ANGLE);
        this.open = false;
      }
      this.leaf = false;
      xml.push(utils2.xmlEncode(text.toString()));
    }
    writeXml(xml) {
      if (this.open) {
        this._xml.push(CLOSE_ANGLE);
        this.open = false;
      }
      this.leaf = false;
      this._xml.push(xml);
    }
    closeNode() {
      const node2 = this._stack.pop();
      const xml = this._xml;
      if (this.leaf) {
        xml.push(CLOSE_SLASH_ANGLE);
      } else {
        xml.push(OPEN_ANGLE_SLASH);
        xml.push(node2);
        xml.push(CLOSE_ANGLE);
      }
      this.open = false;
      this.leaf = false;
    }
    leafNode(name, attributes, text) {
      this.openNode(name, attributes);
      if (text !== void 0) {
        this.writeText(text);
      }
      this.closeNode();
    }
    closeAll() {
      while (this._stack.length) {
        this.closeNode();
      }
    }
    addRollback() {
      this._rollbacks.push({
        xml: this._xml.length,
        stack: this._stack.length,
        leaf: this.leaf,
        open: this.open
      });
      return this.cursor;
    }
    commit() {
      this._rollbacks.pop();
    }
    rollback() {
      const r = this._rollbacks.pop();
      if (this._xml.length > r.xml) {
        this._xml.splice(r.xml, this._xml.length - r.xml);
      }
      if (this._stack.length > r.stack) {
        this._stack.splice(r.stack, this._stack.length - r.stack);
      }
      this.leaf = r.leaf;
      this.open = r.open;
    }
    get xml() {
      this.closeAll();
      return this._xml.join("");
    }
  }
  XmlStream.StdDocAttributes = {
    version: "1.0",
    encoding: "UTF-8",
    standalone: "yes"
  };
  xmlStream = XmlStream;
  return xmlStream;
}
var browserBufferDecode = {};
var hasRequiredBrowserBufferDecode;
function requireBrowserBufferDecode() {
  if (hasRequiredBrowserBufferDecode) return browserBufferDecode;
  hasRequiredBrowserBufferDecode = 1;
  const textDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8");
  function bufferToString(chunk) {
    if (typeof chunk === "string") {
      return chunk;
    }
    if (textDecoder) {
      return textDecoder.decode(chunk);
    }
    return chunk.toString();
  }
  browserBufferDecode.bufferToString = bufferToString;
  return browserBufferDecode;
}
var saxes = {};
var ed5 = {};
var hasRequiredEd5;
function requireEd5() {
  if (hasRequiredEd5) return ed5;
  hasRequiredEd5 = 1;
  (function(exports) {
    /**
     * Character classes and associated utilities for the 5th edition of XML 1.0.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAR = "	\n\r ---";
    exports.S = " 	\r\n";
    exports.NAME_START_CHAR = ":A-Z_a-z-----------";
    exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9--";
    exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
    exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
    exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
    exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
    exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
    exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= SPACE && c <= 55295 || c === NL || c === CR || c === TAB || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isChar = isChar;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports.isNameChar = isNameChar;
  })(ed5);
  return ed5;
}
var ed2 = {};
var hasRequiredEd2;
function requireEd2() {
  if (hasRequiredEd2) return ed2;
  hasRequiredEd2 = 1;
  (function(exports) {
    /**
     * Character classes and associated utilities for the 2nd edition of XML 1.1.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CHAR = "---";
    exports.RESTRICTED_CHAR = "-\b\v\f---";
    exports.S = " 	\r\n";
    exports.NAME_START_CHAR = ":A-Z_a-z-----------";
    exports.NAME_CHAR = "-" + exports.NAME_START_CHAR + ".0-9--";
    exports.CHAR_RE = new RegExp("^[" + exports.CHAR + "]$", "u");
    exports.RESTRICTED_CHAR_RE = new RegExp("^[" + exports.RESTRICTED_CHAR + "]$", "u");
    exports.S_RE = new RegExp("^[" + exports.S + "]+$", "u");
    exports.NAME_START_CHAR_RE = new RegExp("^[" + exports.NAME_START_CHAR + "]$", "u");
    exports.NAME_CHAR_RE = new RegExp("^[" + exports.NAME_CHAR + "]$", "u");
    exports.NAME_RE = new RegExp("^[" + exports.NAME_START_CHAR + "][" + exports.NAME_CHAR + "]*$", "u");
    exports.NMTOKEN_RE = new RegExp("^[" + exports.NAME_CHAR + "]+$", "u");
    var TAB = 9;
    var NL = 10;
    var CR = 13;
    var SPACE = 32;
    exports.S_LIST = [SPACE, NL, CR, TAB];
    function isChar(c) {
      return c >= 1 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isChar = isChar;
    function isRestrictedChar(c) {
      return c >= 1 && c <= 8 || c === 11 || c === 12 || c >= 14 && c <= 31 || c >= 127 && c <= 132 || c >= 134 && c <= 159;
    }
    exports.isRestrictedChar = isRestrictedChar;
    function isCharAndNotRestricted(c) {
      return c === 9 || c === 10 || c === 13 || c > 31 && c < 127 || c === 133 || c > 159 && c <= 55295 || c >= 57344 && c <= 65533 || c >= 65536 && c <= 1114111;
    }
    exports.isCharAndNotRestricted = isCharAndNotRestricted;
    function isS(c) {
      return c === SPACE || c === NL || c === CR || c === TAB;
    }
    exports.isS = isS;
    function isNameStartChar(c) {
      return c >= 65 && c <= 90 || c >= 97 && c <= 122 || c === 58 || c === 95 || c === 8204 || c === 8205 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNameStartChar = isNameStartChar;
    function isNameChar(c) {
      return isNameStartChar(c) || c >= 48 && c <= 57 || c === 45 || c === 46 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256;
    }
    exports.isNameChar = isNameChar;
  })(ed2);
  return ed2;
}
var ed3 = {};
var hasRequiredEd3;
function requireEd3() {
  if (hasRequiredEd3) return ed3;
  hasRequiredEd3 = 1;
  (function(exports) {
    /**
     * Character class utilities for XML NS 1.0 edition 3.
     *
     * @author Louis-Dominique Dubeau
     * @license MIT
     * @copyright Louis-Dominique Dubeau
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NC_NAME_START_CHAR = "A-Z_a-z------------";
    exports.NC_NAME_CHAR = "-" + exports.NC_NAME_START_CHAR + ".0-9--";
    exports.NC_NAME_START_CHAR_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "]$", "u");
    exports.NC_NAME_CHAR_RE = new RegExp("^[" + exports.NC_NAME_CHAR + "]$", "u");
    exports.NC_NAME_RE = new RegExp("^[" + exports.NC_NAME_START_CHAR + "][" + exports.NC_NAME_CHAR + "]*$", "u");
    function isNCNameStartChar(c) {
      return c >= 65 && c <= 90 || c === 95 || c >= 97 && c <= 122 || c >= 192 && c <= 214 || c >= 216 && c <= 246 || c >= 248 && c <= 767 || c >= 880 && c <= 893 || c >= 895 && c <= 8191 || c >= 8204 && c <= 8205 || c >= 8304 && c <= 8591 || c >= 11264 && c <= 12271 || c >= 12289 && c <= 55295 || c >= 63744 && c <= 64975 || c >= 65008 && c <= 65533 || c >= 65536 && c <= 983039;
    }
    exports.isNCNameStartChar = isNCNameStartChar;
    function isNCNameChar(c) {
      return isNCNameStartChar(c) || (c === 45 || c === 46 || c >= 48 && c <= 57 || c === 183 || c >= 768 && c <= 879 || c >= 8255 && c <= 8256);
    }
    exports.isNCNameChar = isNCNameChar;
  })(ed3);
  return ed3;
}
var hasRequiredSaxes;
function requireSaxes() {
  if (hasRequiredSaxes) return saxes;
  hasRequiredSaxes = 1;
  Object.defineProperty(saxes, "__esModule", { value: true });
  const ed52 = requireEd5();
  const ed22 = requireEd2();
  const NSed3 = requireEd3();
  var isS = ed52.isS;
  var isChar10 = ed52.isChar;
  var isNameStartChar = ed52.isNameStartChar;
  var isNameChar = ed52.isNameChar;
  var S_LIST = ed52.S_LIST;
  var NAME_RE = ed52.NAME_RE;
  var isChar11 = ed22.isChar;
  var isNCNameStartChar = NSed3.isNCNameStartChar;
  var isNCNameChar = NSed3.isNCNameChar;
  var NC_NAME_RE = NSed3.NC_NAME_RE;
  const XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
  const XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
  const rootNS = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __proto__: null,
    xml: XML_NAMESPACE,
    xmlns: XMLNS_NAMESPACE
  };
  const XML_ENTITIES = {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    __proto__: null,
    amp: "&",
    gt: ">",
    lt: "<",
    quot: '"',
    apos: "'"
  };
  const EOC = -1;
  const NL_LIKE = -2;
  const S_BEGIN = 0;
  const S_BEGIN_WHITESPACE = 1;
  const S_DOCTYPE = 2;
  const S_DOCTYPE_QUOTE = 3;
  const S_DTD = 4;
  const S_DTD_QUOTED = 5;
  const S_DTD_OPEN_WAKA = 6;
  const S_DTD_OPEN_WAKA_BANG = 7;
  const S_DTD_COMMENT = 8;
  const S_DTD_COMMENT_ENDING = 9;
  const S_DTD_COMMENT_ENDED = 10;
  const S_DTD_PI = 11;
  const S_DTD_PI_ENDING = 12;
  const S_TEXT = 13;
  const S_ENTITY = 14;
  const S_OPEN_WAKA = 15;
  const S_OPEN_WAKA_BANG = 16;
  const S_COMMENT = 17;
  const S_COMMENT_ENDING = 18;
  const S_COMMENT_ENDED = 19;
  const S_CDATA = 20;
  const S_CDATA_ENDING = 21;
  const S_CDATA_ENDING_2 = 22;
  const S_PI_FIRST_CHAR = 23;
  const S_PI_REST = 24;
  const S_PI_BODY = 25;
  const S_PI_ENDING = 26;
  const S_XML_DECL_NAME_START = 27;
  const S_XML_DECL_NAME = 28;
  const S_XML_DECL_EQ = 29;
  const S_XML_DECL_VALUE_START = 30;
  const S_XML_DECL_VALUE = 31;
  const S_XML_DECL_SEPARATOR = 32;
  const S_XML_DECL_ENDING = 33;
  const S_OPEN_TAG = 34;
  const S_OPEN_TAG_SLASH = 35;
  const S_ATTRIB = 36;
  const S_ATTRIB_NAME = 37;
  const S_ATTRIB_NAME_SAW_WHITE = 38;
  const S_ATTRIB_VALUE = 39;
  const S_ATTRIB_VALUE_QUOTED = 40;
  const S_ATTRIB_VALUE_CLOSED = 41;
  const S_ATTRIB_VALUE_UNQUOTED = 42;
  const S_CLOSE_TAG = 43;
  const S_CLOSE_TAG_SAW_WHITE = 44;
  const TAB = 9;
  const NL = 10;
  const CR = 13;
  const SPACE = 32;
  const BANG = 33;
  const DQUOTE = 34;
  const AMP = 38;
  const SQUOTE = 39;
  const MINUS = 45;
  const FORWARD_SLASH = 47;
  const SEMICOLON = 59;
  const LESS = 60;
  const EQUAL = 61;
  const GREATER = 62;
  const QUESTION = 63;
  const OPEN_BRACKET = 91;
  const CLOSE_BRACKET = 93;
  const NEL = 133;
  const LS = 8232;
  const isQuote = (c) => c === DQUOTE || c === SQUOTE;
  const QUOTES = [DQUOTE, SQUOTE];
  const DOCTYPE_TERMINATOR = [...QUOTES, OPEN_BRACKET, GREATER];
  const DTD_TERMINATOR = [...QUOTES, LESS, CLOSE_BRACKET];
  const XML_DECL_NAME_TERMINATOR = [EQUAL, QUESTION, ...S_LIST];
  const ATTRIB_VALUE_UNQUOTED_TERMINATOR = [...S_LIST, GREATER, AMP, LESS];
  function nsPairCheck(parser2, prefix, uri2) {
    switch (prefix) {
      case "xml":
        if (uri2 !== XML_NAMESPACE) {
          parser2.fail(`xml prefix must be bound to ${XML_NAMESPACE}.`);
        }
        break;
      case "xmlns":
        if (uri2 !== XMLNS_NAMESPACE) {
          parser2.fail(`xmlns prefix must be bound to ${XMLNS_NAMESPACE}.`);
        }
        break;
    }
    switch (uri2) {
      case XMLNS_NAMESPACE:
        parser2.fail(prefix === "" ? `the default namespace may not be set to ${uri2}.` : `may not assign a prefix (even "xmlns") to the URI ${XMLNS_NAMESPACE}.`);
        break;
      case XML_NAMESPACE:
        switch (prefix) {
          case "xml":
            break;
          case "":
            parser2.fail(`the default namespace may not be set to ${uri2}.`);
            break;
          default:
            parser2.fail("may not assign the xml namespace to another prefix.");
        }
        break;
    }
  }
  function nsMappingCheck(parser2, mapping) {
    for (const local of Object.keys(mapping)) {
      nsPairCheck(parser2, local, mapping[local]);
    }
  }
  const isNCName = (name) => NC_NAME_RE.test(name);
  const isName = (name) => NAME_RE.test(name);
  const FORBIDDEN_START = 0;
  const FORBIDDEN_BRACKET = 1;
  const FORBIDDEN_BRACKET_BRACKET = 2;
  saxes.EVENTS = [
    "xmldecl",
    "text",
    "processinginstruction",
    "doctype",
    "comment",
    "opentagstart",
    "attribute",
    "opentag",
    "closetag",
    "cdata",
    "error",
    "end",
    "ready"
  ];
  const EVENT_NAME_TO_HANDLER_NAME = {
    xmldecl: "xmldeclHandler",
    text: "textHandler",
    processinginstruction: "piHandler",
    doctype: "doctypeHandler",
    comment: "commentHandler",
    opentagstart: "openTagStartHandler",
    attribute: "attributeHandler",
    opentag: "openTagHandler",
    closetag: "closeTagHandler",
    cdata: "cdataHandler",
    error: "errorHandler",
    end: "endHandler",
    ready: "readyHandler"
  };
  class SaxesParser {
    /**
     * @param opt The parser options.
     */
    constructor(opt) {
      this.opt = opt !== null && opt !== void 0 ? opt : {};
      this.fragmentOpt = !!this.opt.fragment;
      const xmlnsOpt = this.xmlnsOpt = !!this.opt.xmlns;
      this.trackPosition = this.opt.position !== false;
      this.fileName = this.opt.fileName;
      if (xmlnsOpt) {
        this.nameStartCheck = isNCNameStartChar;
        this.nameCheck = isNCNameChar;
        this.isName = isNCName;
        this.processAttribs = this.processAttribsNS;
        this.pushAttrib = this.pushAttribNS;
        this.ns = Object.assign({ __proto__: null }, rootNS);
        const additional = this.opt.additionalNamespaces;
        if (additional != null) {
          nsMappingCheck(this, additional);
          Object.assign(this.ns, additional);
        }
      } else {
        this.nameStartCheck = isNameStartChar;
        this.nameCheck = isNameChar;
        this.isName = isName;
        this.processAttribs = this.processAttribsPlain;
        this.pushAttrib = this.pushAttribPlain;
      }
      this.stateTable = [
        /* eslint-disable @typescript-eslint/unbound-method */
        this.sBegin,
        this.sBeginWhitespace,
        this.sDoctype,
        this.sDoctypeQuote,
        this.sDTD,
        this.sDTDQuoted,
        this.sDTDOpenWaka,
        this.sDTDOpenWakaBang,
        this.sDTDComment,
        this.sDTDCommentEnding,
        this.sDTDCommentEnded,
        this.sDTDPI,
        this.sDTDPIEnding,
        this.sText,
        this.sEntity,
        this.sOpenWaka,
        this.sOpenWakaBang,
        this.sComment,
        this.sCommentEnding,
        this.sCommentEnded,
        this.sCData,
        this.sCDataEnding,
        this.sCDataEnding2,
        this.sPIFirstChar,
        this.sPIRest,
        this.sPIBody,
        this.sPIEnding,
        this.sXMLDeclNameStart,
        this.sXMLDeclName,
        this.sXMLDeclEq,
        this.sXMLDeclValueStart,
        this.sXMLDeclValue,
        this.sXMLDeclSeparator,
        this.sXMLDeclEnding,
        this.sOpenTag,
        this.sOpenTagSlash,
        this.sAttrib,
        this.sAttribName,
        this.sAttribNameSawWhite,
        this.sAttribValue,
        this.sAttribValueQuoted,
        this.sAttribValueClosed,
        this.sAttribValueUnquoted,
        this.sCloseTag,
        this.sCloseTagSawWhite
      ];
      this._init();
    }
    /**
     * Indicates whether or not the parser is closed. If ``true``, wait for
     * the ``ready`` event to write again.
     */
    get closed() {
      return this._closed;
    }
    _init() {
      var _a;
      this.openWakaBang = "";
      this.text = "";
      this.name = "";
      this.piTarget = "";
      this.entity = "";
      this.q = null;
      this.tags = [];
      this.tag = null;
      this.topNS = null;
      this.chunk = "";
      this.chunkPosition = 0;
      this.i = 0;
      this.prevI = 0;
      this.carriedFromPrevious = void 0;
      this.forbiddenState = FORBIDDEN_START;
      this.attribList = [];
      const { fragmentOpt } = this;
      this.state = fragmentOpt ? S_TEXT : S_BEGIN;
      this.reportedTextBeforeRoot = this.reportedTextAfterRoot = this.closedRoot = this.sawRoot = fragmentOpt;
      this.xmlDeclPossible = !fragmentOpt;
      this.xmlDeclExpects = ["version"];
      this.entityReturnState = void 0;
      let { defaultXMLVersion } = this.opt;
      if (defaultXMLVersion === void 0) {
        if (this.opt.forceXMLVersion === true) {
          throw new Error("forceXMLVersion set but defaultXMLVersion is not set");
        }
        defaultXMLVersion = "1.0";
      }
      this.setXMLVersion(defaultXMLVersion);
      this.positionAtNewLine = 0;
      this.doctype = false;
      this._closed = false;
      this.xmlDecl = {
        version: void 0,
        encoding: void 0,
        standalone: void 0
      };
      this.line = 1;
      this.column = 0;
      this.ENTITIES = Object.create(XML_ENTITIES);
      (_a = this.readyHandler) === null || _a === void 0 ? void 0 : _a.call(this);
    }
    /**
     * The stream position the parser is currently looking at. This field is
     * zero-based.
     *
     * This field is not based on counting Unicode characters but is to be
     * interpreted as a plain index into a JavaScript string.
     */
    get position() {
      return this.chunkPosition + this.i;
    }
    /**
     * The column number of the next character to be read by the parser.  *
     * This field is zero-based. (The first column in a line is 0.)
     *
     * This field reports the index at which the next character would be in the
     * line if the line were represented as a JavaScript string.  Note that this
     * *can* be different to a count based on the number of *Unicode characters*
     * due to how JavaScript handles astral plane characters.
     *
     * See [[column]] for a number that corresponds to a count of Unicode
     * characters.
     */
    get columnIndex() {
      return this.position - this.positionAtNewLine;
    }
    /**
     * Set an event listener on an event. The parser supports one handler per
     * event type. If you try to set an event handler over an existing handler,
     * the old handler is silently overwritten.
     *
     * @param name The event to listen to.
     *
     * @param handler The handler to set.
     */
    on(name, handler) {
      this[EVENT_NAME_TO_HANDLER_NAME[name]] = handler;
    }
    /**
     * Unset an event handler.
     *
     * @parma name The event to stop listening to.
     */
    off(name) {
      this[EVENT_NAME_TO_HANDLER_NAME[name]] = void 0;
    }
    /**
     * Make an error object. The error object will have a message that contains
     * the ``fileName`` option passed at the creation of the parser. If position
     * tracking was turned on, it will also have line and column number
     * information.
     *
     * @param message The message describing the error to report.
     *
     * @returns An error object with a properly formatted message.
     */
    makeError(message) {
      var _a;
      let msg = (_a = this.fileName) !== null && _a !== void 0 ? _a : "";
      if (this.trackPosition) {
        if (msg.length > 0) {
          msg += ":";
        }
        msg += `${this.line}:${this.column}`;
      }
      if (msg.length > 0) {
        msg += ": ";
      }
      return new Error(msg + message);
    }
    /**
     * Report a parsing error. This method is made public so that client code may
     * check for issues that are outside the scope of this project and can report
     * errors.
     *
     * @param message The error to report.
     *
     * @returns this
     */
    fail(message) {
      const err = this.makeError(message);
      const handler = this.errorHandler;
      if (handler === void 0) {
        throw err;
      } else {
        handler(err);
      }
      return this;
    }
    /**
     * Write a XML data to the parser.
     *
     * @param chunk The XML data to write.
     *
     * @returns this
     */
    write(chunk) {
      if (this.closed) {
        return this.fail("cannot write after close; assign an onready handler.");
      }
      let end = false;
      if (chunk === null) {
        end = true;
        chunk = "";
      } else if (typeof chunk === "object") {
        chunk = chunk.toString();
      }
      if (this.carriedFromPrevious !== void 0) {
        chunk = `${this.carriedFromPrevious}${chunk}`;
        this.carriedFromPrevious = void 0;
      }
      let limit = chunk.length;
      const lastCode = chunk.charCodeAt(limit - 1);
      if (!end && // A trailing CR or surrogate must be carried over to the next
      // chunk.
      (lastCode === CR || lastCode >= 55296 && lastCode <= 56319)) {
        this.carriedFromPrevious = chunk[limit - 1];
        limit--;
        chunk = chunk.slice(0, limit);
      }
      const { stateTable } = this;
      this.chunk = chunk;
      this.i = 0;
      while (this.i < limit) {
        stateTable[this.state].call(this);
      }
      this.chunkPosition += limit;
      return end ? this.end() : this;
    }
    /**
     * Close the current stream. Perform final well-formedness checks and reset
     * the parser tstate.
     *
     * @returns this
     */
    close() {
      return this.write(null);
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.0.
     *
     * @returns The character read.
     */
    getCode10() {
      const { chunk, i } = this;
      this.prevI = i;
      this.i = i + 1;
      if (i >= chunk.length) {
        return EOC;
      }
      const code = chunk.charCodeAt(i);
      this.column++;
      if (code < 55296) {
        if (code >= SPACE || code === TAB) {
          return code;
        }
        switch (code) {
          case NL:
            this.line++;
            this.column = 0;
            this.positionAtNewLine = this.position;
            return NL;
          case CR:
            if (chunk.charCodeAt(i + 1) === NL) {
              this.i = i + 2;
            }
            this.line++;
            this.column = 0;
            this.positionAtNewLine = this.position;
            return NL_LIKE;
          default:
            this.fail("disallowed character.");
            return code;
        }
      }
      if (code > 56319) {
        if (!(code >= 57344 && code <= 65533)) {
          this.fail("disallowed character.");
        }
        return code;
      }
      const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
      this.i = i + 2;
      if (final > 1114111) {
        this.fail("disallowed character.");
      }
      return final;
    }
    /**
     * Get a single code point out of the current chunk. This updates the current
     * position if we do position tracking.
     *
     * This is the algorithm to use for XML 1.1.
     *
     * @returns {number} The character read.
     */
    getCode11() {
      const { chunk, i } = this;
      this.prevI = i;
      this.i = i + 1;
      if (i >= chunk.length) {
        return EOC;
      }
      const code = chunk.charCodeAt(i);
      this.column++;
      if (code < 55296) {
        if (code > 31 && code < 127 || code > 159 && code !== LS || code === TAB) {
          return code;
        }
        switch (code) {
          case NL:
            this.line++;
            this.column = 0;
            this.positionAtNewLine = this.position;
            return NL;
          case CR: {
            const next = chunk.charCodeAt(i + 1);
            if (next === NL || next === NEL) {
              this.i = i + 2;
            }
          }
          /* yes, fall through */
          case NEL:
          // 0x85
          case LS:
            this.line++;
            this.column = 0;
            this.positionAtNewLine = this.position;
            return NL_LIKE;
          default:
            this.fail("disallowed character.");
            return code;
        }
      }
      if (code > 56319) {
        if (!(code >= 57344 && code <= 65533)) {
          this.fail("disallowed character.");
        }
        return code;
      }
      const final = 65536 + (code - 55296) * 1024 + (chunk.charCodeAt(i + 1) - 56320);
      this.i = i + 2;
      if (final > 1114111) {
        this.fail("disallowed character.");
      }
      return final;
    }
    /**
     * Like ``getCode`` but with the return value normalized so that ``NL`` is
     * returned for ``NL_LIKE``.
     */
    getCodeNorm() {
      const c = this.getCode();
      return c === NL_LIKE ? NL : c;
    }
    unget() {
      this.i = this.prevI;
      this.column--;
    }
    /**
     * Capture characters into a buffer until encountering one of a set of
     * characters.
     *
     * @param chars An array of codepoints. Encountering a character in the array
     * ends the capture. (``chars`` may safely contain ``NL``.)
     *
     * @return The character code that made the capture end, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    captureTo(chars) {
      let { i: start } = this;
      const { chunk } = this;
      while (true) {
        const c = this.getCode();
        const isNLLike = c === NL_LIKE;
        const final = isNLLike ? NL : c;
        if (final === EOC || chars.includes(final)) {
          this.text += chunk.slice(start, this.prevI);
          return final;
        }
        if (isNLLike) {
          this.text += `${chunk.slice(start, this.prevI)}
`;
          start = this.i;
        }
      }
    }
    /**
     * Capture characters into a buffer until encountering a character.
     *
     * @param char The codepoint that ends the capture. **NOTE ``char`` MAY NOT
     * CONTAIN ``NL``.** Passing ``NL`` will result in buggy behavior.
     *
     * @return ``true`` if we ran into the character. Otherwise, we ran into the
     * end of the current chunk.
     */
    captureToChar(char) {
      let { i: start } = this;
      const { chunk } = this;
      while (true) {
        let c = this.getCode();
        switch (c) {
          case NL_LIKE:
            this.text += `${chunk.slice(start, this.prevI)}
`;
            start = this.i;
            c = NL;
            break;
          case EOC:
            this.text += chunk.slice(start);
            return false;
        }
        if (c === char) {
          this.text += chunk.slice(start, this.prevI);
          return true;
        }
      }
    }
    /**
     * Capture characters that satisfy ``isNameChar`` into the ``name`` field of
     * this parser.
     *
     * @return The character code that made the test fail, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    captureNameChars() {
      const { chunk, i: start } = this;
      while (true) {
        const c = this.getCode();
        if (c === EOC) {
          this.name += chunk.slice(start);
          return EOC;
        }
        if (!isNameChar(c)) {
          this.name += chunk.slice(start, this.prevI);
          return c === NL_LIKE ? NL : c;
        }
      }
    }
    /**
     * Skip white spaces.
     *
     * @return The character that ended the skip, or ``EOC`` if we hit
     * the end of the chunk. The return value cannot be NL_LIKE: NL is returned
     * instead.
     */
    skipSpaces() {
      while (true) {
        const c = this.getCodeNorm();
        if (c === EOC || !isS(c)) {
          return c;
        }
      }
    }
    setXMLVersion(version2) {
      this.currentXMLVersion = version2;
      if (version2 === "1.0") {
        this.isChar = isChar10;
        this.getCode = this.getCode10;
      } else {
        this.isChar = isChar11;
        this.getCode = this.getCode11;
      }
    }
    // STATE ENGINE METHODS
    // This needs to be a state separate from S_BEGIN_WHITESPACE because we want
    // to be sure never to come back to this state later.
    sBegin() {
      if (this.chunk.charCodeAt(0) === 65279) {
        this.i++;
        this.column++;
      }
      this.state = S_BEGIN_WHITESPACE;
    }
    sBeginWhitespace() {
      const iBefore = this.i;
      const c = this.skipSpaces();
      if (this.prevI !== iBefore) {
        this.xmlDeclPossible = false;
      }
      switch (c) {
        case LESS:
          this.state = S_OPEN_WAKA;
          if (this.text.length !== 0) {
            throw new Error("no-empty text at start");
          }
          break;
        case EOC:
          break;
        default:
          this.unget();
          this.state = S_TEXT;
          this.xmlDeclPossible = false;
      }
    }
    sDoctype() {
      var _a;
      const c = this.captureTo(DOCTYPE_TERMINATOR);
      switch (c) {
        case GREATER: {
          (_a = this.doctypeHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
          this.text = "";
          this.state = S_TEXT;
          this.doctype = true;
          break;
        }
        case EOC:
          break;
        default:
          this.text += String.fromCodePoint(c);
          if (c === OPEN_BRACKET) {
            this.state = S_DTD;
          } else if (isQuote(c)) {
            this.state = S_DOCTYPE_QUOTE;
            this.q = c;
          }
      }
    }
    sDoctypeQuote() {
      const q = this.q;
      if (this.captureToChar(q)) {
        this.text += String.fromCodePoint(q);
        this.q = null;
        this.state = S_DOCTYPE;
      }
    }
    sDTD() {
      const c = this.captureTo(DTD_TERMINATOR);
      if (c === EOC) {
        return;
      }
      this.text += String.fromCodePoint(c);
      if (c === CLOSE_BRACKET) {
        this.state = S_DOCTYPE;
      } else if (c === LESS) {
        this.state = S_DTD_OPEN_WAKA;
      } else if (isQuote(c)) {
        this.state = S_DTD_QUOTED;
        this.q = c;
      }
    }
    sDTDQuoted() {
      const q = this.q;
      if (this.captureToChar(q)) {
        this.text += String.fromCodePoint(q);
        this.state = S_DTD;
        this.q = null;
      }
    }
    sDTDOpenWaka() {
      const c = this.getCodeNorm();
      this.text += String.fromCodePoint(c);
      switch (c) {
        case BANG:
          this.state = S_DTD_OPEN_WAKA_BANG;
          this.openWakaBang = "";
          break;
        case QUESTION:
          this.state = S_DTD_PI;
          break;
        default:
          this.state = S_DTD;
      }
    }
    sDTDOpenWakaBang() {
      const char = String.fromCodePoint(this.getCodeNorm());
      const owb = this.openWakaBang += char;
      this.text += char;
      if (owb !== "-") {
        this.state = owb === "--" ? S_DTD_COMMENT : S_DTD;
        this.openWakaBang = "";
      }
    }
    sDTDComment() {
      if (this.captureToChar(MINUS)) {
        this.text += "-";
        this.state = S_DTD_COMMENT_ENDING;
      }
    }
    sDTDCommentEnding() {
      const c = this.getCodeNorm();
      this.text += String.fromCodePoint(c);
      this.state = c === MINUS ? S_DTD_COMMENT_ENDED : S_DTD_COMMENT;
    }
    sDTDCommentEnded() {
      const c = this.getCodeNorm();
      this.text += String.fromCodePoint(c);
      if (c === GREATER) {
        this.state = S_DTD;
      } else {
        this.fail("malformed comment.");
        this.state = S_DTD_COMMENT;
      }
    }
    sDTDPI() {
      if (this.captureToChar(QUESTION)) {
        this.text += "?";
        this.state = S_DTD_PI_ENDING;
      }
    }
    sDTDPIEnding() {
      const c = this.getCodeNorm();
      this.text += String.fromCodePoint(c);
      if (c === GREATER) {
        this.state = S_DTD;
      }
    }
    sText() {
      if (this.tags.length !== 0) {
        this.handleTextInRoot();
      } else {
        this.handleTextOutsideRoot();
      }
    }
    sEntity() {
      let { i: start } = this;
      const { chunk } = this;
      loop:
        while (true) {
          switch (this.getCode()) {
            case NL_LIKE:
              this.entity += `${chunk.slice(start, this.prevI)}
`;
              start = this.i;
              break;
            case SEMICOLON: {
              const { entityReturnState } = this;
              const entity = this.entity + chunk.slice(start, this.prevI);
              this.state = entityReturnState;
              let parsed;
              if (entity === "") {
                this.fail("empty entity name.");
                parsed = "&;";
              } else {
                parsed = this.parseEntity(entity);
                this.entity = "";
              }
              if (entityReturnState !== S_TEXT || this.textHandler !== void 0) {
                this.text += parsed;
              }
              break loop;
            }
            case EOC:
              this.entity += chunk.slice(start);
              break loop;
          }
        }
    }
    sOpenWaka() {
      const c = this.getCode();
      if (isNameStartChar(c)) {
        this.state = S_OPEN_TAG;
        this.unget();
        this.xmlDeclPossible = false;
      } else {
        switch (c) {
          case FORWARD_SLASH:
            this.state = S_CLOSE_TAG;
            this.xmlDeclPossible = false;
            break;
          case BANG:
            this.state = S_OPEN_WAKA_BANG;
            this.openWakaBang = "";
            this.xmlDeclPossible = false;
            break;
          case QUESTION:
            this.state = S_PI_FIRST_CHAR;
            break;
          default:
            this.fail("disallowed character in tag name");
            this.state = S_TEXT;
            this.xmlDeclPossible = false;
        }
      }
    }
    sOpenWakaBang() {
      this.openWakaBang += String.fromCodePoint(this.getCodeNorm());
      switch (this.openWakaBang) {
        case "[CDATA[":
          if (!this.sawRoot && !this.reportedTextBeforeRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextBeforeRoot = true;
          }
          if (this.closedRoot && !this.reportedTextAfterRoot) {
            this.fail("text data outside of root node.");
            this.reportedTextAfterRoot = true;
          }
          this.state = S_CDATA;
          this.openWakaBang = "";
          break;
        case "--":
          this.state = S_COMMENT;
          this.openWakaBang = "";
          break;
        case "DOCTYPE":
          this.state = S_DOCTYPE;
          if (this.doctype || this.sawRoot) {
            this.fail("inappropriately located doctype declaration.");
          }
          this.openWakaBang = "";
          break;
        default:
          if (this.openWakaBang.length >= 7) {
            this.fail("incorrect syntax.");
          }
      }
    }
    sComment() {
      if (this.captureToChar(MINUS)) {
        this.state = S_COMMENT_ENDING;
      }
    }
    sCommentEnding() {
      var _a;
      const c = this.getCodeNorm();
      if (c === MINUS) {
        this.state = S_COMMENT_ENDED;
        (_a = this.commentHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
        this.text = "";
      } else {
        this.text += `-${String.fromCodePoint(c)}`;
        this.state = S_COMMENT;
      }
    }
    sCommentEnded() {
      const c = this.getCodeNorm();
      if (c !== GREATER) {
        this.fail("malformed comment.");
        this.text += `--${String.fromCodePoint(c)}`;
        this.state = S_COMMENT;
      } else {
        this.state = S_TEXT;
      }
    }
    sCData() {
      if (this.captureToChar(CLOSE_BRACKET)) {
        this.state = S_CDATA_ENDING;
      }
    }
    sCDataEnding() {
      const c = this.getCodeNorm();
      if (c === CLOSE_BRACKET) {
        this.state = S_CDATA_ENDING_2;
      } else {
        this.text += `]${String.fromCodePoint(c)}`;
        this.state = S_CDATA;
      }
    }
    sCDataEnding2() {
      var _a;
      const c = this.getCodeNorm();
      switch (c) {
        case GREATER: {
          (_a = this.cdataHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.text);
          this.text = "";
          this.state = S_TEXT;
          break;
        }
        case CLOSE_BRACKET:
          this.text += "]";
          break;
        default:
          this.text += `]]${String.fromCodePoint(c)}`;
          this.state = S_CDATA;
      }
    }
    // We need this separate state to check the first character fo the pi target
    // with this.nameStartCheck which allows less characters than this.nameCheck.
    sPIFirstChar() {
      const c = this.getCodeNorm();
      if (this.nameStartCheck(c)) {
        this.piTarget += String.fromCodePoint(c);
        this.state = S_PI_REST;
      } else if (c === QUESTION || isS(c)) {
        this.fail("processing instruction without a target.");
        this.state = c === QUESTION ? S_PI_ENDING : S_PI_BODY;
      } else {
        this.fail("disallowed character in processing instruction name.");
        this.piTarget += String.fromCodePoint(c);
        this.state = S_PI_REST;
      }
    }
    sPIRest() {
      const { chunk, i: start } = this;
      while (true) {
        const c = this.getCodeNorm();
        if (c === EOC) {
          this.piTarget += chunk.slice(start);
          return;
        }
        if (!this.nameCheck(c)) {
          this.piTarget += chunk.slice(start, this.prevI);
          const isQuestion = c === QUESTION;
          if (isQuestion || isS(c)) {
            if (this.piTarget === "xml") {
              if (!this.xmlDeclPossible) {
                this.fail("an XML declaration must be at the start of the document.");
              }
              this.state = isQuestion ? S_XML_DECL_ENDING : S_XML_DECL_NAME_START;
            } else {
              this.state = isQuestion ? S_PI_ENDING : S_PI_BODY;
            }
          } else {
            this.fail("disallowed character in processing instruction name.");
            this.piTarget += String.fromCodePoint(c);
          }
          break;
        }
      }
    }
    sPIBody() {
      if (this.text.length === 0) {
        const c = this.getCodeNorm();
        if (c === QUESTION) {
          this.state = S_PI_ENDING;
        } else if (!isS(c)) {
          this.text = String.fromCodePoint(c);
        }
      } else if (this.captureToChar(QUESTION)) {
        this.state = S_PI_ENDING;
      }
    }
    sPIEnding() {
      var _a;
      const c = this.getCodeNorm();
      if (c === GREATER) {
        const { piTarget } = this;
        if (piTarget.toLowerCase() === "xml") {
          this.fail("the XML declaration must appear at the start of the document.");
        }
        (_a = this.piHandler) === null || _a === void 0 ? void 0 : _a.call(this, {
          target: piTarget,
          body: this.text
        });
        this.piTarget = this.text = "";
        this.state = S_TEXT;
      } else if (c === QUESTION) {
        this.text += "?";
      } else {
        this.text += `?${String.fromCodePoint(c)}`;
        this.state = S_PI_BODY;
      }
      this.xmlDeclPossible = false;
    }
    sXMLDeclNameStart() {
      const c = this.skipSpaces();
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        return;
      }
      if (c !== EOC) {
        this.state = S_XML_DECL_NAME;
        this.name = String.fromCodePoint(c);
      }
    }
    sXMLDeclName() {
      const c = this.captureTo(XML_DECL_NAME_TERMINATOR);
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        this.name += this.text;
        this.text = "";
        this.fail("XML declaration is incomplete.");
        return;
      }
      if (!(isS(c) || c === EQUAL)) {
        return;
      }
      this.name += this.text;
      this.text = "";
      if (!this.xmlDeclExpects.includes(this.name)) {
        switch (this.name.length) {
          case 0:
            this.fail("did not expect any more name/value pairs.");
            break;
          case 1:
            this.fail(`expected the name ${this.xmlDeclExpects[0]}.`);
            break;
          default:
            this.fail(`expected one of ${this.xmlDeclExpects.join(", ")}`);
        }
      }
      this.state = c === EQUAL ? S_XML_DECL_VALUE_START : S_XML_DECL_EQ;
    }
    sXMLDeclEq() {
      const c = this.getCodeNorm();
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        this.fail("XML declaration is incomplete.");
        return;
      }
      if (isS(c)) {
        return;
      }
      if (c !== EQUAL) {
        this.fail("value required.");
      }
      this.state = S_XML_DECL_VALUE_START;
    }
    sXMLDeclValueStart() {
      const c = this.getCodeNorm();
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        this.fail("XML declaration is incomplete.");
        return;
      }
      if (isS(c)) {
        return;
      }
      if (!isQuote(c)) {
        this.fail("value must be quoted.");
        this.q = SPACE;
      } else {
        this.q = c;
      }
      this.state = S_XML_DECL_VALUE;
    }
    sXMLDeclValue() {
      const c = this.captureTo([this.q, QUESTION]);
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        this.text = "";
        this.fail("XML declaration is incomplete.");
        return;
      }
      if (c === EOC) {
        return;
      }
      const value = this.text;
      this.text = "";
      switch (this.name) {
        case "version": {
          this.xmlDeclExpects = ["encoding", "standalone"];
          const version2 = value;
          this.xmlDecl.version = version2;
          if (!/^1\.[0-9]+$/.test(version2)) {
            this.fail("version number must match /^1\\.[0-9]+$/.");
          } else if (!this.opt.forceXMLVersion) {
            this.setXMLVersion(version2);
          }
          break;
        }
        case "encoding":
          if (!/^[A-Za-z][A-Za-z0-9._-]*$/.test(value)) {
            this.fail("encoding value must match 	/^[A-Za-z0-9][A-Za-z0-9._-]*$/.");
          }
          this.xmlDeclExpects = ["standalone"];
          this.xmlDecl.encoding = value;
          break;
        case "standalone":
          if (value !== "yes" && value !== "no") {
            this.fail('standalone value must match "yes" or "no".');
          }
          this.xmlDeclExpects = [];
          this.xmlDecl.standalone = value;
          break;
      }
      this.name = "";
      this.state = S_XML_DECL_SEPARATOR;
    }
    sXMLDeclSeparator() {
      const c = this.getCodeNorm();
      if (c === QUESTION) {
        this.state = S_XML_DECL_ENDING;
        return;
      }
      if (!isS(c)) {
        this.fail("whitespace required.");
        this.unget();
      }
      this.state = S_XML_DECL_NAME_START;
    }
    sXMLDeclEnding() {
      var _a;
      const c = this.getCodeNorm();
      if (c === GREATER) {
        if (this.piTarget !== "xml") {
          this.fail("processing instructions are not allowed before root.");
        } else if (this.name !== "version" && this.xmlDeclExpects.includes("version")) {
          this.fail("XML declaration must contain a version.");
        }
        (_a = this.xmldeclHandler) === null || _a === void 0 ? void 0 : _a.call(this, this.xmlDecl);
        this.name = "";
        this.piTarget = this.text = "";
        this.state = S_TEXT;
      } else {
        this.fail("The character ? is disallowed anywhere in XML declarations.");
      }
      this.xmlDeclPossible = false;
    }
    sOpenTag() {
      var _a;
      const c = this.captureNameChars();
      if (c === EOC) {
        return;
      }
      const tag = this.tag = {
        name: this.name,
        attributes: /* @__PURE__ */ Object.create(null)
      };
      this.name = "";
      if (this.xmlnsOpt) {
        this.topNS = tag.ns = /* @__PURE__ */ Object.create(null);
      }
      (_a = this.openTagStartHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
      this.sawRoot = true;
      if (!this.fragmentOpt && this.closedRoot) {
        this.fail("documents may contain only one root.");
      }
      switch (c) {
        case GREATER:
          this.openTag();
          break;
        case FORWARD_SLASH:
          this.state = S_OPEN_TAG_SLASH;
          break;
        default:
          if (!isS(c)) {
            this.fail("disallowed character in tag name.");
          }
          this.state = S_ATTRIB;
      }
    }
    sOpenTagSlash() {
      if (this.getCode() === GREATER) {
        this.openSelfClosingTag();
      } else {
        this.fail("forward-slash in opening tag not followed by >.");
        this.state = S_ATTRIB;
      }
    }
    sAttrib() {
      const c = this.skipSpaces();
      if (c === EOC) {
        return;
      }
      if (isNameStartChar(c)) {
        this.unget();
        this.state = S_ATTRIB_NAME;
      } else if (c === GREATER) {
        this.openTag();
      } else if (c === FORWARD_SLASH) {
        this.state = S_OPEN_TAG_SLASH;
      } else {
        this.fail("disallowed character in attribute name.");
      }
    }
    sAttribName() {
      const c = this.captureNameChars();
      if (c === EQUAL) {
        this.state = S_ATTRIB_VALUE;
      } else if (isS(c)) {
        this.state = S_ATTRIB_NAME_SAW_WHITE;
      } else if (c === GREATER) {
        this.fail("attribute without value.");
        this.pushAttrib(this.name, this.name);
        this.name = this.text = "";
        this.openTag();
      } else if (c !== EOC) {
        this.fail("disallowed character in attribute name.");
      }
    }
    sAttribNameSawWhite() {
      const c = this.skipSpaces();
      switch (c) {
        case EOC:
          return;
        case EQUAL:
          this.state = S_ATTRIB_VALUE;
          break;
        default:
          this.fail("attribute without value.");
          this.text = "";
          this.name = "";
          if (c === GREATER) {
            this.openTag();
          } else if (isNameStartChar(c)) {
            this.unget();
            this.state = S_ATTRIB_NAME;
          } else {
            this.fail("disallowed character in attribute name.");
            this.state = S_ATTRIB;
          }
      }
    }
    sAttribValue() {
      const c = this.getCodeNorm();
      if (isQuote(c)) {
        this.q = c;
        this.state = S_ATTRIB_VALUE_QUOTED;
      } else if (!isS(c)) {
        this.fail("unquoted attribute value.");
        this.state = S_ATTRIB_VALUE_UNQUOTED;
        this.unget();
      }
    }
    sAttribValueQuoted() {
      const { q, chunk } = this;
      let { i: start } = this;
      while (true) {
        switch (this.getCode()) {
          case q:
            this.pushAttrib(this.name, this.text + chunk.slice(start, this.prevI));
            this.name = this.text = "";
            this.q = null;
            this.state = S_ATTRIB_VALUE_CLOSED;
            return;
          case AMP:
            this.text += chunk.slice(start, this.prevI);
            this.state = S_ENTITY;
            this.entityReturnState = S_ATTRIB_VALUE_QUOTED;
            return;
          case NL:
          case NL_LIKE:
          case TAB:
            this.text += `${chunk.slice(start, this.prevI)} `;
            start = this.i;
            break;
          case LESS:
            this.text += chunk.slice(start, this.prevI);
            this.fail("disallowed character.");
            return;
          case EOC:
            this.text += chunk.slice(start);
            return;
        }
      }
    }
    sAttribValueClosed() {
      const c = this.getCodeNorm();
      if (isS(c)) {
        this.state = S_ATTRIB;
      } else if (c === GREATER) {
        this.openTag();
      } else if (c === FORWARD_SLASH) {
        this.state = S_OPEN_TAG_SLASH;
      } else if (isNameStartChar(c)) {
        this.fail("no whitespace between attributes.");
        this.unget();
        this.state = S_ATTRIB_NAME;
      } else {
        this.fail("disallowed character in attribute name.");
      }
    }
    sAttribValueUnquoted() {
      const c = this.captureTo(ATTRIB_VALUE_UNQUOTED_TERMINATOR);
      switch (c) {
        case AMP:
          this.state = S_ENTITY;
          this.entityReturnState = S_ATTRIB_VALUE_UNQUOTED;
          break;
        case LESS:
          this.fail("disallowed character.");
          break;
        case EOC:
          break;
        default:
          if (this.text.includes("]]>")) {
            this.fail('the string "]]>" is disallowed in char data.');
          }
          this.pushAttrib(this.name, this.text);
          this.name = this.text = "";
          if (c === GREATER) {
            this.openTag();
          } else {
            this.state = S_ATTRIB;
          }
      }
    }
    sCloseTag() {
      const c = this.captureNameChars();
      if (c === GREATER) {
        this.closeTag();
      } else if (isS(c)) {
        this.state = S_CLOSE_TAG_SAW_WHITE;
      } else if (c !== EOC) {
        this.fail("disallowed character in closing tag.");
      }
    }
    sCloseTagSawWhite() {
      switch (this.skipSpaces()) {
        case GREATER:
          this.closeTag();
          break;
        case EOC:
          break;
        default:
          this.fail("disallowed character in closing tag.");
      }
    }
    // END OF STATE ENGINE METHODS
    handleTextInRoot() {
      let { i: start, forbiddenState } = this;
      const { chunk, textHandler: handler } = this;
      scanLoop:
        while (true) {
          switch (this.getCode()) {
            case LESS: {
              this.state = S_OPEN_WAKA;
              if (handler !== void 0) {
                const { text } = this;
                const slice = chunk.slice(start, this.prevI);
                if (text.length !== 0) {
                  handler(text + slice);
                  this.text = "";
                } else if (slice.length !== 0) {
                  handler(slice);
                }
              }
              forbiddenState = FORBIDDEN_START;
              break scanLoop;
            }
            case AMP:
              this.state = S_ENTITY;
              this.entityReturnState = S_TEXT;
              if (handler !== void 0) {
                this.text += chunk.slice(start, this.prevI);
              }
              forbiddenState = FORBIDDEN_START;
              break scanLoop;
            case CLOSE_BRACKET:
              switch (forbiddenState) {
                case FORBIDDEN_START:
                  forbiddenState = FORBIDDEN_BRACKET;
                  break;
                case FORBIDDEN_BRACKET:
                  forbiddenState = FORBIDDEN_BRACKET_BRACKET;
                  break;
                case FORBIDDEN_BRACKET_BRACKET:
                  break;
                default:
                  throw new Error("impossible state");
              }
              break;
            case GREATER:
              if (forbiddenState === FORBIDDEN_BRACKET_BRACKET) {
                this.fail('the string "]]>" is disallowed in char data.');
              }
              forbiddenState = FORBIDDEN_START;
              break;
            case NL_LIKE:
              if (handler !== void 0) {
                this.text += `${chunk.slice(start, this.prevI)}
`;
              }
              start = this.i;
              forbiddenState = FORBIDDEN_START;
              break;
            case EOC:
              if (handler !== void 0) {
                this.text += chunk.slice(start);
              }
              break scanLoop;
            default:
              forbiddenState = FORBIDDEN_START;
          }
        }
      this.forbiddenState = forbiddenState;
    }
    handleTextOutsideRoot() {
      let { i: start } = this;
      const { chunk, textHandler: handler } = this;
      let nonSpace = false;
      outRootLoop:
        while (true) {
          const code = this.getCode();
          switch (code) {
            case LESS: {
              this.state = S_OPEN_WAKA;
              if (handler !== void 0) {
                const { text } = this;
                const slice = chunk.slice(start, this.prevI);
                if (text.length !== 0) {
                  handler(text + slice);
                  this.text = "";
                } else if (slice.length !== 0) {
                  handler(slice);
                }
              }
              break outRootLoop;
            }
            case AMP:
              this.state = S_ENTITY;
              this.entityReturnState = S_TEXT;
              if (handler !== void 0) {
                this.text += chunk.slice(start, this.prevI);
              }
              nonSpace = true;
              break outRootLoop;
            case NL_LIKE:
              if (handler !== void 0) {
                this.text += `${chunk.slice(start, this.prevI)}
`;
              }
              start = this.i;
              break;
            case EOC:
              if (handler !== void 0) {
                this.text += chunk.slice(start);
              }
              break outRootLoop;
            default:
              if (!isS(code)) {
                nonSpace = true;
              }
          }
        }
      if (!nonSpace) {
        return;
      }
      if (!this.sawRoot && !this.reportedTextBeforeRoot) {
        this.fail("text data outside of root node.");
        this.reportedTextBeforeRoot = true;
      }
      if (this.closedRoot && !this.reportedTextAfterRoot) {
        this.fail("text data outside of root node.");
        this.reportedTextAfterRoot = true;
      }
    }
    pushAttribNS(name, value) {
      var _a;
      const { prefix, local } = this.qname(name);
      const attr = { name, prefix, local, value };
      this.attribList.push(attr);
      (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
      if (prefix === "xmlns") {
        const trimmed = value.trim();
        if (this.currentXMLVersion === "1.0" && trimmed === "") {
          this.fail("invalid attempt to undefine prefix in XML 1.0");
        }
        this.topNS[local] = trimmed;
        nsPairCheck(this, local, trimmed);
      } else if (name === "xmlns") {
        const trimmed = value.trim();
        this.topNS[""] = trimmed;
        nsPairCheck(this, "", trimmed);
      }
    }
    pushAttribPlain(name, value) {
      var _a;
      const attr = { name, value };
      this.attribList.push(attr);
      (_a = this.attributeHandler) === null || _a === void 0 ? void 0 : _a.call(this, attr);
    }
    /**
     * End parsing. This performs final well-formedness checks and resets the
     * parser to a clean state.
     *
     * @returns this
     */
    end() {
      var _a, _b;
      if (!this.sawRoot) {
        this.fail("document must contain a root element.");
      }
      const { tags } = this;
      while (tags.length > 0) {
        const tag = tags.pop();
        this.fail(`unclosed tag: ${tag.name}`);
      }
      if (this.state !== S_BEGIN && this.state !== S_TEXT) {
        this.fail("unexpected end.");
      }
      const { text } = this;
      if (text.length !== 0) {
        (_a = this.textHandler) === null || _a === void 0 ? void 0 : _a.call(this, text);
        this.text = "";
      }
      this._closed = true;
      (_b = this.endHandler) === null || _b === void 0 ? void 0 : _b.call(this);
      this._init();
      return this;
    }
    /**
     * Resolve a namespace prefix.
     *
     * @param prefix The prefix to resolve.
     *
     * @returns The namespace URI or ``undefined`` if the prefix is not defined.
     */
    resolve(prefix) {
      var _a, _b;
      let uri2 = this.topNS[prefix];
      if (uri2 !== void 0) {
        return uri2;
      }
      const { tags } = this;
      for (let index2 = tags.length - 1; index2 >= 0; index2--) {
        uri2 = tags[index2].ns[prefix];
        if (uri2 !== void 0) {
          return uri2;
        }
      }
      uri2 = this.ns[prefix];
      if (uri2 !== void 0) {
        return uri2;
      }
      return (_b = (_a = this.opt).resolvePrefix) === null || _b === void 0 ? void 0 : _b.call(_a, prefix);
    }
    /**
     * Parse a qname into its prefix and local name parts.
     *
     * @param name The name to parse
     *
     * @returns
     */
    qname(name) {
      const colon = name.indexOf(":");
      if (colon === -1) {
        return { prefix: "", local: name };
      }
      const local = name.slice(colon + 1);
      const prefix = name.slice(0, colon);
      if (prefix === "" || local === "" || local.includes(":")) {
        this.fail(`malformed name: ${name}.`);
      }
      return { prefix, local };
    }
    processAttribsNS() {
      var _a;
      const { attribList } = this;
      const tag = this.tag;
      {
        const { prefix, local } = this.qname(tag.name);
        tag.prefix = prefix;
        tag.local = local;
        const uri2 = tag.uri = (_a = this.resolve(prefix)) !== null && _a !== void 0 ? _a : "";
        if (prefix !== "") {
          if (prefix === "xmlns") {
            this.fail('tags may not have "xmlns" as prefix.');
          }
          if (uri2 === "") {
            this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
            tag.uri = prefix;
          }
        }
      }
      if (attribList.length === 0) {
        return;
      }
      const { attributes } = tag;
      const seen = /* @__PURE__ */ new Set();
      for (const attr of attribList) {
        const { name, prefix, local } = attr;
        let uri2;
        let eqname;
        if (prefix === "") {
          uri2 = name === "xmlns" ? XMLNS_NAMESPACE : "";
          eqname = name;
        } else {
          uri2 = this.resolve(prefix);
          if (uri2 === void 0) {
            this.fail(`unbound namespace prefix: ${JSON.stringify(prefix)}.`);
            uri2 = prefix;
          }
          eqname = `{${uri2}}${local}`;
        }
        if (seen.has(eqname)) {
          this.fail(`duplicate attribute: ${eqname}.`);
        }
        seen.add(eqname);
        attr.uri = uri2;
        attributes[name] = attr;
      }
      this.attribList = [];
    }
    processAttribsPlain() {
      const { attribList } = this;
      const attributes = this.tag.attributes;
      for (const { name, value } of attribList) {
        if (attributes[name] !== void 0) {
          this.fail(`duplicate attribute: ${name}.`);
        }
        attributes[name] = value;
      }
      this.attribList = [];
    }
    /**
     * Handle a complete open tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onopentag``.
     */
    openTag() {
      var _a;
      this.processAttribs();
      const { tags } = this;
      const tag = this.tag;
      tag.isSelfClosing = false;
      (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
      tags.push(tag);
      this.state = S_TEXT;
      this.name = "";
    }
    /**
     * Handle a complete self-closing tag. This parser code calls this once it has
     * seen the whole tag. This method checks for well-formeness and then emits
     * ``onopentag`` and ``onclosetag``.
     */
    openSelfClosingTag() {
      var _a, _b, _c;
      this.processAttribs();
      const { tags } = this;
      const tag = this.tag;
      tag.isSelfClosing = true;
      (_a = this.openTagHandler) === null || _a === void 0 ? void 0 : _a.call(this, tag);
      (_b = this.closeTagHandler) === null || _b === void 0 ? void 0 : _b.call(this, tag);
      const top = this.tag = (_c = tags[tags.length - 1]) !== null && _c !== void 0 ? _c : null;
      if (top === null) {
        this.closedRoot = true;
      }
      this.state = S_TEXT;
      this.name = "";
    }
    /**
     * Handle a complete close tag. This parser code calls this once it has seen
     * the whole tag. This method checks for well-formeness and then emits
     * ``onclosetag``.
     */
    closeTag() {
      const { tags, name } = this;
      this.state = S_TEXT;
      this.name = "";
      if (name === "") {
        this.fail("weird empty close tag.");
        this.text += "</>";
        return;
      }
      const handler = this.closeTagHandler;
      let l = tags.length;
      while (l-- > 0) {
        const tag = this.tag = tags.pop();
        this.topNS = tag.ns;
        handler === null || handler === void 0 ? void 0 : handler(tag);
        if (tag.name === name) {
          break;
        }
        this.fail("unexpected close tag.");
      }
      if (l === 0) {
        this.closedRoot = true;
      } else if (l < 0) {
        this.fail(`unmatched closing tag: ${name}.`);
        this.text += `</${name}>`;
      }
    }
    /**
     * Resolves an entity. Makes any necessary well-formedness checks.
     *
     * @param entity The entity to resolve.
     *
     * @returns The parsed entity.
     */
    parseEntity(entity) {
      if (entity[0] !== "#") {
        const defined = this.ENTITIES[entity];
        if (defined !== void 0) {
          return defined;
        }
        this.fail(this.isName(entity) ? "undefined entity." : "disallowed character in entity name.");
        return `&${entity};`;
      }
      let num = NaN;
      if (entity[1] === "x" && /^#x[0-9a-f]+$/i.test(entity)) {
        num = parseInt(entity.slice(2), 16);
      } else if (/^#[0-9]+$/.test(entity)) {
        num = parseInt(entity.slice(1), 10);
      }
      if (!this.isChar(num)) {
        this.fail("malformed character entity.");
        return `&${entity};`;
      }
      return String.fromCodePoint(num);
    }
  }
  saxes.SaxesParser = SaxesParser;
  return saxes;
}
var parseSax;
var hasRequiredParseSax;
function requireParseSax() {
  if (hasRequiredParseSax) return parseSax;
  hasRequiredParseSax = 1;
  const { SaxesParser } = requireSaxes();
  const { PassThrough } = requireReadable$4();
  const { bufferToString } = requireBrowserBufferDecode();
  parseSax = async function* (iterable) {
    if (iterable.pipe && !iterable[Symbol.asyncIterator]) {
      iterable = iterable.pipe(new PassThrough());
    }
    const saxesParser = new SaxesParser();
    let error2;
    saxesParser.on("error", (err) => {
      error2 = err;
    });
    let events = [];
    saxesParser.on("opentag", (value) => events.push({ eventType: "opentag", value }));
    saxesParser.on("text", (value) => events.push({ eventType: "text", value }));
    saxesParser.on("closetag", (value) => events.push({ eventType: "closetag", value }));
    for await (const chunk of iterable) {
      saxesParser.write(bufferToString(chunk));
      if (error2) throw error2;
      yield events;
      events = [];
    }
  };
  return parseSax;
}
var baseXform;
var hasRequiredBaseXform;
function requireBaseXform() {
  if (hasRequiredBaseXform) return baseXform;
  hasRequiredBaseXform = 1;
  const parseSax2 = requireParseSax();
  const XmlStream = requireXmlStream();
  class BaseXform {
    // constructor(/* model, name */) {}
    // ============================================================
    // Virtual Interface
    prepare() {
    }
    render() {
    }
    parseOpen(node2) {
    }
    parseText(text) {
    }
    parseClose(name) {
    }
    reconcile(model, options) {
    }
    // ============================================================
    reset() {
      this.model = null;
      if (this.map) {
        Object.values(this.map).forEach((xform) => {
          if (xform instanceof BaseXform) {
            xform.reset();
          } else if (xform.xform) {
            xform.xform.reset();
          }
        });
      }
    }
    mergeModel(obj) {
      this.model = Object.assign(this.model || {}, obj);
    }
    async parse(saxParser) {
      for await (const events of saxParser) {
        for (const { eventType, value } of events) {
          if (eventType === "opentag") {
            this.parseOpen(value);
          } else if (eventType === "text") {
            this.parseText(value);
          } else if (eventType === "closetag") {
            if (!this.parseClose(value.name)) {
              return this.model;
            }
          }
        }
      }
      return this.model;
    }
    async parseStream(stream2) {
      return this.parse(parseSax2(stream2));
    }
    get xml() {
      return this.toXml(this.model);
    }
    toXml(model) {
      const xmlStream2 = new XmlStream();
      this.render(xmlStream2, model);
      return xmlStream2.xml;
    }
    // ============================================================
    // Useful Utilities
    static toAttribute(value, dflt, always = false) {
      if (value === void 0) {
        if (always) {
          return dflt;
        }
      } else if (always || value !== dflt) {
        return value.toString();
      }
      return void 0;
    }
    static toStringAttribute(value, dflt, always = false) {
      return BaseXform.toAttribute(value, dflt, always);
    }
    static toStringValue(attr, dflt) {
      return attr === void 0 ? dflt : attr;
    }
    static toBoolAttribute(value, dflt, always = false) {
      if (value === void 0) {
        if (always) {
          return dflt;
        }
      } else if (always || value !== dflt) {
        return value ? "1" : "0";
      }
      return void 0;
    }
    static toBoolValue(attr, dflt) {
      return attr === void 0 ? dflt : attr === "1";
    }
    static toIntAttribute(value, dflt, always = false) {
      return BaseXform.toAttribute(value, dflt, always);
    }
    static toIntValue(attr, dflt) {
      return attr === void 0 ? dflt : parseInt(attr, 10);
    }
    static toFloatAttribute(value, dflt, always = false) {
      return BaseXform.toAttribute(value, dflt, always);
    }
    static toFloatValue(attr, dflt) {
      return attr === void 0 ? dflt : parseFloat(attr);
    }
  }
  baseXform = BaseXform;
  return baseXform;
}
var staticXform;
var hasRequiredStaticXform;
function requireStaticXform() {
  if (hasRequiredStaticXform) return staticXform;
  hasRequiredStaticXform = 1;
  const BaseXform = requireBaseXform();
  const XmlStream = requireXmlStream();
  function build(xmlStream2, model) {
    xmlStream2.openNode(model.tag, model.$);
    if (model.c) {
      model.c.forEach((child) => {
        build(xmlStream2, child);
      });
    }
    if (model.t) {
      xmlStream2.writeText(model.t);
    }
    xmlStream2.closeNode();
  }
  class StaticXform extends BaseXform {
    constructor(model) {
      super();
      this._model = model;
    }
    render(xmlStream2) {
      if (!this._xml) {
        const stream2 = new XmlStream();
        build(stream2, this._model);
        this._xml = stream2.xml;
      }
      xmlStream2.writeXml(this._xml);
    }
    parseOpen() {
      return true;
    }
    parseText() {
    }
    parseClose(name) {
      switch (name) {
        case this._model.tag:
          return false;
        default:
          return true;
      }
    }
  }
  staticXform = StaticXform;
  return staticXform;
}
var listXform;
var hasRequiredListXform;
function requireListXform() {
  if (hasRequiredListXform) return listXform;
  hasRequiredListXform = 1;
  const BaseXform = requireBaseXform();
  class ListXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.always = !!options.always;
      this.count = options.count;
      this.empty = options.empty;
      this.$count = options.$count || "count";
      this.$ = options.$;
      this.childXform = options.childXform;
      this.maxItems = options.maxItems;
    }
    prepare(model, options) {
      const { childXform } = this;
      if (model) {
        model.forEach((childModel, index2) => {
          options.index = index2;
          childXform.prepare(childModel, options);
        });
      }
    }
    render(xmlStream2, model) {
      if (this.always || model && model.length) {
        xmlStream2.openNode(this.tag, this.$);
        if (this.count) {
          xmlStream2.addAttribute(this.$count, model && model.length || 0);
        }
        const { childXform } = this;
        (model || []).forEach((childModel, index2) => {
          childXform.render(xmlStream2, childModel, index2);
        });
        xmlStream2.closeNode();
      } else if (this.empty) {
        xmlStream2.leafNode(this.tag);
      }
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.model = [];
          return true;
        default:
          if (this.childXform.parseOpen(node2)) {
            this.parser = this.childXform;
            return true;
          }
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.push(this.parser.model);
          this.parser = void 0;
          if (this.maxItems && this.model.length > this.maxItems) {
            throw new Error(`Max ${this.childXform.tag} count (${this.maxItems}) exceeded`);
          }
        }
        return true;
      }
      return false;
    }
    reconcile(model, options) {
      if (model) {
        const { childXform } = this;
        model.forEach((childModel) => {
          childXform.reconcile(childModel, options);
        });
      }
    }
  }
  listXform = ListXform;
  return listXform;
}
var colorXform;
var hasRequiredColorXform;
function requireColorXform() {
  if (hasRequiredColorXform) return colorXform;
  hasRequiredColorXform = 1;
  const BaseXform = requireBaseXform();
  class ColorXform extends BaseXform {
    constructor(name) {
      super();
      this.name = name || "color";
    }
    get tag() {
      return this.name;
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.openNode(this.name);
        if (model.argb) {
          xmlStream2.addAttribute("rgb", model.argb);
        } else if (model.theme !== void 0) {
          xmlStream2.addAttribute("theme", model.theme);
          if (model.tint !== void 0) {
            xmlStream2.addAttribute("tint", model.tint);
          }
        } else if (model.indexed !== void 0) {
          xmlStream2.addAttribute("indexed", model.indexed);
        } else {
          xmlStream2.addAttribute("auto", "1");
        }
        xmlStream2.closeNode();
        return true;
      }
      return false;
    }
    parseOpen(node2) {
      if (node2.name === this.name) {
        if (node2.attributes.rgb) {
          this.model = { argb: node2.attributes.rgb };
        } else if (node2.attributes.theme) {
          this.model = { theme: parseInt(node2.attributes.theme, 10) };
          if (node2.attributes.tint) {
            this.model.tint = parseFloat(node2.attributes.tint);
          }
        } else if (node2.attributes.indexed) {
          this.model = { indexed: parseInt(node2.attributes.indexed, 10) };
        } else {
          this.model = void 0;
        }
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  colorXform = ColorXform;
  return colorXform;
}
var booleanXform;
var hasRequiredBooleanXform;
function requireBooleanXform() {
  if (hasRequiredBooleanXform) return booleanXform;
  hasRequiredBooleanXform = 1;
  const BaseXform = requireBaseXform();
  class BooleanXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.attr = options.attr;
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.openNode(this.tag);
        xmlStream2.closeNode();
      }
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = true;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  booleanXform = BooleanXform;
  return booleanXform;
}
var integerXform;
var hasRequiredIntegerXform;
function requireIntegerXform() {
  if (hasRequiredIntegerXform) return integerXform;
  hasRequiredIntegerXform = 1;
  const BaseXform = requireBaseXform();
  class IntegerXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.attr = options.attr;
      this.attrs = options.attrs;
      this.zero = options.zero;
    }
    render(xmlStream2, model) {
      if (model || this.zero) {
        xmlStream2.openNode(this.tag);
        if (this.attrs) {
          xmlStream2.addAttributes(this.attrs);
        }
        if (this.attr) {
          xmlStream2.addAttribute(this.attr, model);
        } else {
          xmlStream2.writeText(model);
        }
        xmlStream2.closeNode();
      }
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        if (this.attr) {
          this.model = parseInt(node2.attributes[this.attr], 10);
        } else {
          this.text = [];
        }
        return true;
      }
      return false;
    }
    parseText(text) {
      if (!this.attr) {
        this.text.push(text);
      }
    }
    parseClose() {
      if (!this.attr) {
        this.model = parseInt(this.text.join("") || 0, 10);
      }
      return false;
    }
  }
  integerXform = IntegerXform;
  return integerXform;
}
var stringXform;
var hasRequiredStringXform;
function requireStringXform() {
  if (hasRequiredStringXform) return stringXform;
  hasRequiredStringXform = 1;
  const BaseXform = requireBaseXform();
  class StringXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.attr = options.attr;
      this.attrs = options.attrs;
    }
    render(xmlStream2, model) {
      if (model !== void 0) {
        xmlStream2.openNode(this.tag);
        if (this.attrs) {
          xmlStream2.addAttributes(this.attrs);
        }
        if (this.attr) {
          xmlStream2.addAttribute(this.attr, model);
        } else {
          xmlStream2.writeText(model);
        }
        xmlStream2.closeNode();
      }
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        if (this.attr) {
          this.model = node2.attributes[this.attr];
        } else {
          this.text = [];
        }
      }
    }
    parseText(text) {
      if (!this.attr) {
        this.text.push(text);
      }
    }
    parseClose() {
      if (!this.attr) {
        this.model = this.text.join("");
      }
      return false;
    }
  }
  stringXform = StringXform;
  return stringXform;
}
var underlineXform;
var hasRequiredUnderlineXform;
function requireUnderlineXform() {
  if (hasRequiredUnderlineXform) return underlineXform;
  hasRequiredUnderlineXform = 1;
  const BaseXform = requireBaseXform();
  class UnderlineXform extends BaseXform {
    constructor(model) {
      super();
      this.model = model;
    }
    get tag() {
      return "u";
    }
    render(xmlStream2, model) {
      model = model || this.model;
      if (model === true) {
        xmlStream2.leafNode("u");
      } else {
        const attr = UnderlineXform.Attributes[model];
        if (attr) {
          xmlStream2.leafNode("u", attr);
        }
      }
    }
    parseOpen(node2) {
      if (node2.name === "u") {
        this.model = node2.attributes.val || true;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  UnderlineXform.Attributes = {
    single: {},
    double: { val: "double" },
    singleAccounting: { val: "singleAccounting" },
    doubleAccounting: { val: "doubleAccounting" }
  };
  underlineXform = UnderlineXform;
  return underlineXform;
}
var fontXform;
var hasRequiredFontXform;
function requireFontXform() {
  if (hasRequiredFontXform) return fontXform;
  hasRequiredFontXform = 1;
  const ColorXform = requireColorXform();
  const BooleanXform = requireBooleanXform();
  const IntegerXform = requireIntegerXform();
  const StringXform = requireStringXform();
  const UnderlineXform = requireUnderlineXform();
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  class FontXform extends BaseXform {
    constructor(options) {
      super();
      this.options = options || FontXform.OPTIONS;
      this.map = {
        b: { prop: "bold", xform: new BooleanXform({ tag: "b", attr: "val" }) },
        i: { prop: "italic", xform: new BooleanXform({ tag: "i", attr: "val" }) },
        u: { prop: "underline", xform: new UnderlineXform() },
        charset: { prop: "charset", xform: new IntegerXform({ tag: "charset", attr: "val" }) },
        color: { prop: "color", xform: new ColorXform() },
        condense: { prop: "condense", xform: new BooleanXform({ tag: "condense", attr: "val" }) },
        extend: { prop: "extend", xform: new BooleanXform({ tag: "extend", attr: "val" }) },
        family: { prop: "family", xform: new IntegerXform({ tag: "family", attr: "val" }) },
        outline: { prop: "outline", xform: new BooleanXform({ tag: "outline", attr: "val" }) },
        vertAlign: { prop: "vertAlign", xform: new StringXform({ tag: "vertAlign", attr: "val" }) },
        scheme: { prop: "scheme", xform: new StringXform({ tag: "scheme", attr: "val" }) },
        shadow: { prop: "shadow", xform: new BooleanXform({ tag: "shadow", attr: "val" }) },
        strike: { prop: "strike", xform: new BooleanXform({ tag: "strike", attr: "val" }) },
        sz: { prop: "size", xform: new IntegerXform({ tag: "sz", attr: "val" }) }
      };
      this.map[this.options.fontNameTag] = {
        prop: "name",
        xform: new StringXform({ tag: this.options.fontNameTag, attr: "val" })
      };
    }
    get tag() {
      return this.options.tagName;
    }
    render(xmlStream2, model) {
      const { map: map2 } = this;
      xmlStream2.openNode(this.options.tagName);
      _2.each(this.map, (defn, tag) => {
        map2[tag].xform.render(xmlStream2, model[defn.prop]);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (this.map[node2.name]) {
        this.parser = this.map[node2.name].xform;
        return this.parser.parseOpen(node2);
      }
      switch (node2.name) {
        case this.options.tagName:
          this.model = {};
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser && !this.parser.parseClose(name)) {
        const item = this.map[name];
        if (this.parser.model) {
          this.model[item.prop] = this.parser.model;
        }
        this.parser = void 0;
        return true;
      }
      switch (name) {
        case this.options.tagName:
          return false;
        default:
          return true;
      }
    }
  }
  FontXform.OPTIONS = {
    tagName: "font",
    fontNameTag: "name"
  };
  fontXform = FontXform;
  return fontXform;
}
var fillXform;
var hasRequiredFillXform;
function requireFillXform() {
  if (hasRequiredFillXform) return fillXform;
  hasRequiredFillXform = 1;
  const BaseXform = requireBaseXform();
  const ColorXform = requireColorXform();
  class StopXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        color: new ColorXform()
      };
    }
    get tag() {
      return "stop";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("stop");
      xmlStream2.addAttribute("position", model.position);
      this.map.color.render(xmlStream2, model.color);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "stop":
          this.model = {
            position: parseFloat(node2.attributes.position)
          };
          return true;
        case "color":
          this.parser = this.map.color;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.color = this.parser.model;
          this.parser = void 0;
        }
        return true;
      }
      return false;
    }
  }
  class PatternFillXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        fgColor: new ColorXform("fgColor"),
        bgColor: new ColorXform("bgColor")
      };
    }
    get name() {
      return "pattern";
    }
    get tag() {
      return "patternFill";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("patternFill");
      xmlStream2.addAttribute("patternType", model.pattern);
      if (model.fgColor) {
        this.map.fgColor.render(xmlStream2, model.fgColor);
      }
      if (model.bgColor) {
        this.map.bgColor.render(xmlStream2, model.bgColor);
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "patternFill":
          this.model = {
            type: "pattern",
            pattern: node2.attributes.patternType
          };
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          if (this.parser.model) {
            this.model[name] = this.parser.model;
          }
          this.parser = void 0;
        }
        return true;
      }
      return false;
    }
  }
  class GradientFillXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        stop: new StopXform()
      };
    }
    get name() {
      return "gradient";
    }
    get tag() {
      return "gradientFill";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("gradientFill");
      switch (model.gradient) {
        case "angle":
          xmlStream2.addAttribute("degree", model.degree);
          break;
        case "path":
          xmlStream2.addAttribute("type", "path");
          if (model.center.left) {
            xmlStream2.addAttribute("left", model.center.left);
            if (model.center.right === void 0) {
              xmlStream2.addAttribute("right", model.center.left);
            }
          }
          if (model.center.right) {
            xmlStream2.addAttribute("right", model.center.right);
          }
          if (model.center.top) {
            xmlStream2.addAttribute("top", model.center.top);
            if (model.center.bottom === void 0) {
              xmlStream2.addAttribute("bottom", model.center.top);
            }
          }
          if (model.center.bottom) {
            xmlStream2.addAttribute("bottom", model.center.bottom);
          }
          break;
      }
      const stopXform = this.map.stop;
      model.stops.forEach((stopModel) => {
        stopXform.render(xmlStream2, stopModel);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "gradientFill": {
          const model = this.model = {
            stops: []
          };
          if (node2.attributes.degree) {
            model.gradient = "angle";
            model.degree = parseInt(node2.attributes.degree, 10);
          } else if (node2.attributes.type === "path") {
            model.gradient = "path";
            model.center = {
              left: node2.attributes.left ? parseFloat(node2.attributes.left) : 0,
              top: node2.attributes.top ? parseFloat(node2.attributes.top) : 0
            };
            if (node2.attributes.right !== node2.attributes.left) {
              model.center.right = node2.attributes.right ? parseFloat(node2.attributes.right) : 0;
            }
            if (node2.attributes.bottom !== node2.attributes.top) {
              model.center.bottom = node2.attributes.bottom ? parseFloat(node2.attributes.bottom) : 0;
            }
          }
          return true;
        }
        case "stop":
          this.parser = this.map.stop;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.stops.push(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      return false;
    }
  }
  class FillXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        patternFill: new PatternFillXform(),
        gradientFill: new GradientFillXform()
      };
    }
    get tag() {
      return "fill";
    }
    render(xmlStream2, model) {
      xmlStream2.addRollback();
      xmlStream2.openNode("fill");
      switch (model.type) {
        case "pattern":
          this.map.patternFill.render(xmlStream2, model);
          break;
        case "gradient":
          this.map.gradientFill.render(xmlStream2, model);
          break;
        default:
          xmlStream2.rollback();
          return;
      }
      xmlStream2.closeNode();
      xmlStream2.commit();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "fill":
          this.model = {};
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model = this.parser.model;
          this.model.type = this.parser.name;
          this.parser = void 0;
        }
        return true;
      }
      return false;
    }
    validStyle(value) {
      return FillXform.validPatternValues[value];
    }
  }
  FillXform.validPatternValues = [
    "none",
    "solid",
    "darkVertical",
    "darkGray",
    "mediumGray",
    "lightGray",
    "gray125",
    "gray0625",
    "darkHorizontal",
    "darkVertical",
    "darkDown",
    "darkUp",
    "darkGrid",
    "darkTrellis",
    "lightHorizontal",
    "lightVertical",
    "lightDown",
    "lightUp",
    "lightGrid",
    "lightTrellis",
    "lightGrid"
  ].reduce((p, v) => {
    p[v] = true;
    return p;
  }, {});
  FillXform.StopXform = StopXform;
  FillXform.PatternFillXform = PatternFillXform;
  FillXform.GradientFillXform = GradientFillXform;
  fillXform = FillXform;
  return fillXform;
}
var borderXform;
var hasRequiredBorderXform;
function requireBorderXform() {
  if (hasRequiredBorderXform) return borderXform;
  hasRequiredBorderXform = 1;
  const BaseXform = requireBaseXform();
  const utils2 = requireUtils();
  const ColorXform = requireColorXform();
  class EdgeXform extends BaseXform {
    constructor(name) {
      super();
      this.name = name;
      this.map = {
        color: new ColorXform()
      };
    }
    get tag() {
      return this.name;
    }
    render(xmlStream2, model, defaultColor) {
      const color = model && model.color || defaultColor || this.defaultColor;
      xmlStream2.openNode(this.name);
      if (model && model.style) {
        xmlStream2.addAttribute("style", model.style);
        if (color) {
          this.map.color.render(xmlStream2, color);
        }
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.name: {
          const { style } = node2.attributes;
          if (style) {
            this.model = {
              style
            };
          } else {
            this.model = void 0;
          }
          return true;
        }
        case "color":
          this.parser = this.map.color;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      if (name === this.name) {
        if (this.map.color.model) {
          if (!this.model) {
            this.model = {};
          }
          this.model.color = this.map.color.model;
        }
      }
      return false;
    }
    validStyle(value) {
      return EdgeXform.validStyleValues[value];
    }
  }
  EdgeXform.validStyleValues = [
    "thin",
    "dashed",
    "dotted",
    "dashDot",
    "hair",
    "dashDotDot",
    "slantDashDot",
    "mediumDashed",
    "mediumDashDotDot",
    "mediumDashDot",
    "medium",
    "double",
    "thick"
  ].reduce((p, v) => {
    p[v] = true;
    return p;
  }, {});
  class BorderXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        top: new EdgeXform("top"),
        left: new EdgeXform("left"),
        bottom: new EdgeXform("bottom"),
        right: new EdgeXform("right"),
        diagonal: new EdgeXform("diagonal")
      };
    }
    render(xmlStream2, model) {
      const { color } = model;
      xmlStream2.openNode("border");
      if (model.diagonal && model.diagonal.style) {
        if (model.diagonal.up) {
          xmlStream2.addAttribute("diagonalUp", "1");
        }
        if (model.diagonal.down) {
          xmlStream2.addAttribute("diagonalDown", "1");
        }
      }
      function add(edgeModel, edgeXform) {
        if (edgeModel && !edgeModel.color && model.color) {
          edgeModel = {
            ...edgeModel,
            color: model.color
          };
        }
        edgeXform.render(xmlStream2, edgeModel, color);
      }
      add(model.left, this.map.left);
      add(model.right, this.map.right);
      add(model.top, this.map.top);
      add(model.bottom, this.map.bottom);
      add(model.diagonal, this.map.diagonal);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "border":
          this.reset();
          this.diagonalUp = utils2.parseBoolean(node2.attributes.diagonalUp);
          this.diagonalDown = utils2.parseBoolean(node2.attributes.diagonalDown);
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      if (name === "border") {
        const model = this.model = {};
        const add = function(key, edgeModel, extensions) {
          if (edgeModel) {
            if (extensions) {
              Object.assign(edgeModel, extensions);
            }
            model[key] = edgeModel;
          }
        };
        add("left", this.map.left.model);
        add("right", this.map.right.model);
        add("top", this.map.top.model);
        add("bottom", this.map.bottom.model);
        add("diagonal", this.map.diagonal.model, { up: this.diagonalUp, down: this.diagonalDown });
      }
      return false;
    }
  }
  borderXform = BorderXform;
  return borderXform;
}
var defaultnumformats;
var hasRequiredDefaultnumformats;
function requireDefaultnumformats() {
  if (hasRequiredDefaultnumformats) return defaultnumformats;
  hasRequiredDefaultnumformats = 1;
  defaultnumformats = {
    0: { f: "General" },
    1: { f: "0" },
    2: { f: "0.00" },
    3: { f: "#,##0" },
    4: { f: "#,##0.00" },
    9: { f: "0%" },
    10: { f: "0.00%" },
    11: { f: "0.00E+00" },
    12: { f: "# ?/?" },
    13: { f: "# ??/??" },
    14: { f: "mm-dd-yy" },
    15: { f: "d-mmm-yy" },
    16: { f: "d-mmm" },
    17: { f: "mmm-yy" },
    18: { f: "h:mm AM/PM" },
    19: { f: "h:mm:ss AM/PM" },
    20: { f: "h:mm" },
    21: { f: "h:mm:ss" },
    22: { f: 'm/d/yy "h":mm' },
    27: {
      "zh-tw": "[$-404]e/m/d",
      "zh-cn": 'yyyy""m""',
      "ja-jp": "[$-411]ge.m.d",
      "ko-kr": 'yyyy"" mm"" dd""'
    },
    28: {
      "zh-tw": '[$-404]e""m""d""',
      "zh-cn": 'm""d""',
      "ja-jp": '[$-411]ggge""m""d""',
      "ko-kr": "mm-dd"
    },
    29: {
      "zh-tw": '[$-404]e""m""d""',
      "zh-cn": 'm""d""',
      "ja-jp": '[$-411]ggge""m""d""',
      "ko-kr": "mm-dd"
    },
    30: { "zh-tw": "m/d/yy ", "zh-cn": "m-d-yy", "ja-jp": "m/d/yy", "ko-kr": "mm-dd-yy" },
    31: {
      "zh-tw": 'yyyy""m""d""',
      "zh-cn": 'yyyy""m""d""',
      "ja-jp": 'yyyy""m""d""',
      "ko-kr": 'yyyy"" mm"" dd""'
    },
    32: {
      "zh-tw": 'hh""mm""',
      "zh-cn": 'h""mm""',
      "ja-jp": 'h""mm""',
      "ko-kr": 'h"" mm""'
    },
    33: {
      "zh-tw": 'hh""mm""ss""',
      "zh-cn": 'h""mm""ss""',
      "ja-jp": 'h""mm""ss""',
      "ko-kr": 'h"" mm"" ss""'
    },
    34: {
      "zh-tw": '/ hh""mm""',
      "zh-cn": '/ h""mm""',
      "ja-jp": 'yyyy""m""',
      "ko-kr": "yyyy-mm-dd"
    },
    35: {
      "zh-tw": '/ hh""mm""ss""',
      "zh-cn": '/ h""mm""ss""',
      "ja-jp": 'm""d""',
      "ko-kr": "yyyy-mm-dd"
    },
    36: {
      "zh-tw": "[$-404]e/m/d",
      "zh-cn": 'yyyy""m""',
      "ja-jp": "[$-411]ge.m.d",
      "ko-kr": 'yyyy"" mm"" dd""'
    },
    37: { f: "#,##0 ;(#,##0)" },
    38: { f: "#,##0 ;[Red](#,##0)" },
    39: { f: "#,##0.00 ;(#,##0.00)" },
    40: { f: "#,##0.00 ;[Red](#,##0.00)" },
    45: { f: "mm:ss" },
    46: { f: "[h]:mm:ss" },
    47: { f: "mmss.0" },
    48: { f: "##0.0E+0" },
    49: { f: "@" },
    50: {
      "zh-tw": "[$-404]e/m/d",
      "zh-cn": 'yyyy""m""',
      "ja-jp": "[$-411]ge.m.d",
      "ko-kr": 'yyyy"" mm"" dd""'
    },
    51: {
      "zh-tw": '[$-404]e""m""d""',
      "zh-cn": 'm""d""',
      "ja-jp": '[$-411]ggge""m""d""',
      "ko-kr": "mm-dd"
    },
    52: {
      "zh-tw": '/ hh""mm""',
      "zh-cn": 'yyyy""m""',
      "ja-jp": 'yyyy""m""',
      "ko-kr": "yyyy-mm-dd"
    },
    53: {
      "zh-tw": '/ hh""mm""ss""',
      "zh-cn": 'm""d""',
      "ja-jp": 'm""d""',
      "ko-kr": "yyyy-mm-dd"
    },
    54: {
      "zh-tw": '[$-404]e""m""d""',
      "zh-cn": 'm""d""',
      "ja-jp": '[$-411]ggge""m""d""',
      "ko-kr": "mm-dd"
    },
    55: {
      "zh-tw": '/ hh""mm""',
      "zh-cn": '/ h""mm""',
      "ja-jp": 'yyyy""m""',
      "ko-kr": "yyyy-mm-dd"
    },
    56: {
      "zh-tw": '/ hh""mm""ss""',
      "zh-cn": '/ h""mm""ss""',
      "ja-jp": 'm""d""',
      "ko-kr": "yyyy-mm-dd"
    },
    57: {
      "zh-tw": "[$-404]e/m/d",
      "zh-cn": 'yyyy""m""',
      "ja-jp": "[$-411]ge.m.d",
      "ko-kr": 'yyyy"" mm"" dd""'
    },
    58: {
      "zh-tw": '[$-404]e""m""d""',
      "zh-cn": 'm""d""',
      "ja-jp": '[$-411]ggge""m""d""',
      "ko-kr": "mm-dd"
    },
    59: { "th-th": "t0" },
    60: { "th-th": "t0.00" },
    61: { "th-th": "t#,##0" },
    62: { "th-th": "t#,##0.00" },
    67: { "th-th": "t0%" },
    68: { "th-th": "t0.00%" },
    69: { "th-th": "t# ?/?" },
    70: { "th-th": "t# ??/??" },
    81: { "th-th": "d/m/bb" }
  };
  return defaultnumformats;
}
var numfmtXform;
var hasRequiredNumfmtXform;
function requireNumfmtXform() {
  if (hasRequiredNumfmtXform) return numfmtXform;
  hasRequiredNumfmtXform = 1;
  const _2 = requireUnderDash();
  const defaultNumFormats = requireDefaultnumformats();
  const BaseXform = requireBaseXform();
  function hashDefaultFormats() {
    const hash = {};
    _2.each(defaultNumFormats, (dnf, id) => {
      if (dnf.f) {
        hash[dnf.f] = parseInt(id, 10);
      }
    });
    return hash;
  }
  const defaultFmtHash = hashDefaultFormats();
  class NumFmtXform extends BaseXform {
    constructor(id, formatCode) {
      super();
      this.id = id;
      this.formatCode = formatCode;
    }
    get tag() {
      return "numFmt";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode("numFmt", { numFmtId: model.id, formatCode: model.formatCode });
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "numFmt":
          this.model = {
            id: parseInt(node2.attributes.numFmtId, 10),
            formatCode: node2.attributes.formatCode.replace(/[\\](.)/g, "$1")
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  NumFmtXform.getDefaultFmtId = function getDefaultFmtId(formatCode) {
    return defaultFmtHash[formatCode];
  };
  NumFmtXform.getDefaultFmtCode = function getDefaultFmtCode(numFmtId) {
    return defaultNumFormats[numFmtId] && defaultNumFormats[numFmtId].f;
  };
  numfmtXform = NumFmtXform;
  return numfmtXform;
}
var alignmentXform;
var hasRequiredAlignmentXform;
function requireAlignmentXform() {
  if (hasRequiredAlignmentXform) return alignmentXform;
  hasRequiredAlignmentXform = 1;
  const Enums = requireEnums();
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  const validation = {
    horizontalValues: [
      "left",
      "center",
      "right",
      "fill",
      "centerContinuous",
      "distributed",
      "justify"
    ].reduce((p, v) => {
      p[v] = true;
      return p;
    }, {}),
    horizontal(value) {
      return this.horizontalValues[value] ? value : void 0;
    },
    verticalValues: ["top", "middle", "bottom", "distributed", "justify"].reduce((p, v) => {
      p[v] = true;
      return p;
    }, {}),
    vertical(value) {
      if (value === "middle") return "center";
      return this.verticalValues[value] ? value : void 0;
    },
    wrapText(value) {
      return value ? true : void 0;
    },
    shrinkToFit(value) {
      return value ? true : void 0;
    },
    textRotation(value) {
      switch (value) {
        case "vertical":
          return value;
        default:
          value = utils2.validInt(value);
          return value >= -90 && value <= 90 ? value : void 0;
      }
    },
    indent(value) {
      value = utils2.validInt(value);
      return Math.max(0, value);
    },
    readingOrder(value) {
      switch (value) {
        case "ltr":
          return Enums.ReadingOrder.LeftToRight;
        case "rtl":
          return Enums.ReadingOrder.RightToLeft;
        default:
          return void 0;
      }
    }
  };
  const textRotationXform = {
    toXml(textRotation) {
      textRotation = validation.textRotation(textRotation);
      if (textRotation) {
        if (textRotation === "vertical") {
          return 255;
        }
        const tr = Math.round(textRotation);
        if (tr >= 0 && tr <= 90) {
          return tr;
        }
        if (tr < 0 && tr >= -90) {
          return 90 - tr;
        }
      }
      return void 0;
    },
    toModel(textRotation) {
      const tr = utils2.validInt(textRotation);
      if (tr !== void 0) {
        if (tr === 255) {
          return "vertical";
        }
        if (tr >= 0 && tr <= 90) {
          return tr;
        }
        if (tr > 90 && tr <= 180) {
          return 90 - tr;
        }
      }
      return void 0;
    }
  };
  class AlignmentXform extends BaseXform {
    get tag() {
      return "alignment";
    }
    render(xmlStream2, model) {
      xmlStream2.addRollback();
      xmlStream2.openNode("alignment");
      let isValid = false;
      function add(name, value) {
        if (value) {
          xmlStream2.addAttribute(name, value);
          isValid = true;
        }
      }
      add("horizontal", validation.horizontal(model.horizontal));
      add("vertical", validation.vertical(model.vertical));
      add("wrapText", validation.wrapText(model.wrapText) ? "1" : false);
      add("shrinkToFit", validation.shrinkToFit(model.shrinkToFit) ? "1" : false);
      add("indent", validation.indent(model.indent));
      add("textRotation", textRotationXform.toXml(model.textRotation));
      add("readingOrder", validation.readingOrder(model.readingOrder));
      xmlStream2.closeNode();
      if (isValid) {
        xmlStream2.commit();
      } else {
        xmlStream2.rollback();
      }
    }
    parseOpen(node2) {
      const model = {};
      let valid = false;
      function add(truthy, name, value) {
        if (truthy) {
          model[name] = value;
          valid = true;
        }
      }
      add(node2.attributes.horizontal, "horizontal", node2.attributes.horizontal);
      add(
        node2.attributes.vertical,
        "vertical",
        node2.attributes.vertical === "center" ? "middle" : node2.attributes.vertical
      );
      add(node2.attributes.wrapText, "wrapText", utils2.parseBoolean(node2.attributes.wrapText));
      add(node2.attributes.shrinkToFit, "shrinkToFit", utils2.parseBoolean(node2.attributes.shrinkToFit));
      add(node2.attributes.indent, "indent", parseInt(node2.attributes.indent, 10));
      add(
        node2.attributes.textRotation,
        "textRotation",
        textRotationXform.toModel(node2.attributes.textRotation)
      );
      add(
        node2.attributes.readingOrder,
        "readingOrder",
        node2.attributes.readingOrder === "2" ? "rtl" : "ltr"
      );
      this.model = valid ? model : null;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  alignmentXform = AlignmentXform;
  return alignmentXform;
}
var protectionXform;
var hasRequiredProtectionXform;
function requireProtectionXform() {
  if (hasRequiredProtectionXform) return protectionXform;
  hasRequiredProtectionXform = 1;
  const BaseXform = requireBaseXform();
  const validation = {
    boolean(value, dflt) {
      if (value === void 0) {
        return dflt;
      }
      return value;
    }
  };
  class ProtectionXform extends BaseXform {
    get tag() {
      return "protection";
    }
    render(xmlStream2, model) {
      xmlStream2.addRollback();
      xmlStream2.openNode("protection");
      let isValid = false;
      function add(name, value) {
        if (value !== void 0) {
          xmlStream2.addAttribute(name, value);
          isValid = true;
        }
      }
      add("locked", validation.boolean(model.locked, true) ? void 0 : "0");
      add("hidden", validation.boolean(model.hidden, false) ? "1" : void 0);
      xmlStream2.closeNode();
      if (isValid) {
        xmlStream2.commit();
      } else {
        xmlStream2.rollback();
      }
    }
    parseOpen(node2) {
      const model = {
        locked: !(node2.attributes.locked === "0"),
        hidden: node2.attributes.hidden === "1"
      };
      const isSignificant = !model.locked || model.hidden;
      this.model = isSignificant ? model : null;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  protectionXform = ProtectionXform;
  return protectionXform;
}
var styleXform;
var hasRequiredStyleXform;
function requireStyleXform() {
  if (hasRequiredStyleXform) return styleXform;
  hasRequiredStyleXform = 1;
  const BaseXform = requireBaseXform();
  const AlignmentXform = requireAlignmentXform();
  const ProtectionXform = requireProtectionXform();
  class StyleXform extends BaseXform {
    constructor(options) {
      super();
      this.xfId = !!(options && options.xfId);
      this.map = {
        alignment: new AlignmentXform(),
        protection: new ProtectionXform()
      };
    }
    get tag() {
      return "xf";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("xf", {
        numFmtId: model.numFmtId || 0,
        fontId: model.fontId || 0,
        fillId: model.fillId || 0,
        borderId: model.borderId || 0
      });
      if (this.xfId) {
        xmlStream2.addAttribute("xfId", model.xfId || 0);
      }
      if (model.numFmtId) {
        xmlStream2.addAttribute("applyNumberFormat", "1");
      }
      if (model.fontId) {
        xmlStream2.addAttribute("applyFont", "1");
      }
      if (model.fillId) {
        xmlStream2.addAttribute("applyFill", "1");
      }
      if (model.borderId) {
        xmlStream2.addAttribute("applyBorder", "1");
      }
      if (model.alignment) {
        xmlStream2.addAttribute("applyAlignment", "1");
      }
      if (model.protection) {
        xmlStream2.addAttribute("applyProtection", "1");
      }
      if (model.alignment) {
        this.map.alignment.render(xmlStream2, model.alignment);
      }
      if (model.protection) {
        this.map.protection.render(xmlStream2, model.protection);
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "xf":
          this.model = {
            numFmtId: parseInt(node2.attributes.numFmtId, 10),
            fontId: parseInt(node2.attributes.fontId, 10),
            fillId: parseInt(node2.attributes.fillId, 10),
            borderId: parseInt(node2.attributes.borderId, 10)
          };
          if (this.xfId) {
            this.model.xfId = parseInt(node2.attributes.xfId, 10);
          }
          return true;
        case "alignment":
          this.parser = this.map.alignment;
          this.parser.parseOpen(node2);
          return true;
        case "protection":
          this.parser = this.map.protection;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          if (this.map.protection === this.parser) {
            this.model.protection = this.parser.model;
          } else {
            this.model.alignment = this.parser.model;
          }
          this.parser = void 0;
        }
        return true;
      }
      return name !== "xf";
    }
  }
  styleXform = StyleXform;
  return styleXform;
}
var dxfXform;
var hasRequiredDxfXform;
function requireDxfXform() {
  if (hasRequiredDxfXform) return dxfXform;
  hasRequiredDxfXform = 1;
  const BaseXform = requireBaseXform();
  const AlignmentXform = requireAlignmentXform();
  const BorderXform = requireBorderXform();
  const FillXform = requireFillXform();
  const FontXform = requireFontXform();
  const NumFmtXform = requireNumfmtXform();
  const ProtectionXform = requireProtectionXform();
  class DxfXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        alignment: new AlignmentXform(),
        border: new BorderXform(),
        fill: new FillXform(),
        font: new FontXform(),
        numFmt: new NumFmtXform(),
        protection: new ProtectionXform()
      };
    }
    get tag() {
      return "dxf";
    }
    // how do we generate dxfid?
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      if (model.font) {
        this.map.font.render(xmlStream2, model.font);
      }
      if (model.numFmt && model.numFmtId) {
        const numFmtModel = { id: model.numFmtId, formatCode: model.numFmt };
        this.map.numFmt.render(xmlStream2, numFmtModel);
      }
      if (model.fill) {
        this.map.fill.render(xmlStream2, model.fill);
      }
      if (model.alignment) {
        this.map.alignment.render(xmlStream2, model.alignment);
      }
      if (model.border) {
        this.map.border.render(xmlStream2, model.border);
      }
      if (model.protection) {
        this.map.protection.render(xmlStream2, model.protection);
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          return true;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      if (name === this.tag) {
        this.model = {
          alignment: this.map.alignment.model,
          border: this.map.border.model,
          fill: this.map.fill.model,
          font: this.map.font.model,
          numFmt: this.map.numFmt.model,
          protection: this.map.protection.model
        };
        return false;
      }
      return true;
    }
  }
  dxfXform = DxfXform;
  return dxfXform;
}
var stylesXform;
var hasRequiredStylesXform;
function requireStylesXform() {
  if (hasRequiredStylesXform) return stylesXform;
  hasRequiredStylesXform = 1;
  const Enums = requireEnums();
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const StaticXform = requireStaticXform();
  const ListXform = requireListXform();
  const FontXform = requireFontXform();
  const FillXform = requireFillXform();
  const BorderXform = requireBorderXform();
  const NumFmtXform = requireNumfmtXform();
  const StyleXform = requireStyleXform();
  const DxfXform = requireDxfXform();
  const NUMFMT_BASE = 164;
  class StylesXform extends BaseXform {
    constructor(initialise) {
      super();
      this.map = {
        numFmts: new ListXform({ tag: "numFmts", count: true, childXform: new NumFmtXform() }),
        fonts: new ListXform({
          tag: "fonts",
          count: true,
          childXform: new FontXform(),
          $: { "x14ac:knownFonts": 1 }
        }),
        fills: new ListXform({ tag: "fills", count: true, childXform: new FillXform() }),
        borders: new ListXform({ tag: "borders", count: true, childXform: new BorderXform() }),
        cellStyleXfs: new ListXform({ tag: "cellStyleXfs", count: true, childXform: new StyleXform() }),
        cellXfs: new ListXform({
          tag: "cellXfs",
          count: true,
          childXform: new StyleXform({ xfId: true })
        }),
        dxfs: new ListXform({ tag: "dxfs", always: true, count: true, childXform: new DxfXform() }),
        // for style manager
        numFmt: new NumFmtXform(),
        font: new FontXform(),
        fill: new FillXform(),
        border: new BorderXform(),
        style: new StyleXform({ xfId: true }),
        cellStyles: StylesXform.STATIC_XFORMS.cellStyles,
        tableStyles: StylesXform.STATIC_XFORMS.tableStyles,
        extLst: StylesXform.STATIC_XFORMS.extLst
      };
      if (initialise) {
        this.init();
      }
    }
    initIndex() {
      this.index = {
        style: {},
        numFmt: {},
        numFmtNextId: 164,
        // start custom format ids here
        font: {},
        border: {},
        fill: {}
      };
    }
    init() {
      this.model = {
        styles: [],
        numFmts: [],
        fonts: [],
        borders: [],
        fills: [],
        dxfs: []
      };
      this.initIndex();
      this._addBorder({});
      this._addStyle({ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 });
      this._addFill({ type: "pattern", pattern: "none" });
      this._addFill({ type: "pattern", pattern: "gray125" });
      this.weakMap = /* @__PURE__ */ new WeakMap();
    }
    render(xmlStream2, model) {
      model = model || this.model;
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("styleSheet", StylesXform.STYLESHEET_ATTRIBUTES);
      if (this.index) {
        if (model.numFmts && model.numFmts.length) {
          xmlStream2.openNode("numFmts", { count: model.numFmts.length });
          model.numFmts.forEach((numFmtXml) => {
            xmlStream2.writeXml(numFmtXml);
          });
          xmlStream2.closeNode();
        }
        if (!model.fonts.length) {
          this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
        }
        xmlStream2.openNode("fonts", { count: model.fonts.length, "x14ac:knownFonts": 1 });
        model.fonts.forEach((fontXml) => {
          xmlStream2.writeXml(fontXml);
        });
        xmlStream2.closeNode();
        xmlStream2.openNode("fills", { count: model.fills.length });
        model.fills.forEach((fillXml) => {
          xmlStream2.writeXml(fillXml);
        });
        xmlStream2.closeNode();
        xmlStream2.openNode("borders", { count: model.borders.length });
        model.borders.forEach((borderXml) => {
          xmlStream2.writeXml(borderXml);
        });
        xmlStream2.closeNode();
        this.map.cellStyleXfs.render(xmlStream2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
        xmlStream2.openNode("cellXfs", { count: model.styles.length });
        model.styles.forEach((styleXml) => {
          xmlStream2.writeXml(styleXml);
        });
        xmlStream2.closeNode();
      } else {
        this.map.numFmts.render(xmlStream2, model.numFmts);
        this.map.fonts.render(xmlStream2, model.fonts);
        this.map.fills.render(xmlStream2, model.fills);
        this.map.borders.render(xmlStream2, model.borders);
        this.map.cellStyleXfs.render(xmlStream2, [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }]);
        this.map.cellXfs.render(xmlStream2, model.styles);
      }
      StylesXform.STATIC_XFORMS.cellStyles.render(xmlStream2);
      this.map.dxfs.render(xmlStream2, model.dxfs);
      StylesXform.STATIC_XFORMS.tableStyles.render(xmlStream2);
      StylesXform.STATIC_XFORMS.extLst.render(xmlStream2);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "styleSheet":
          this.initIndex();
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          return true;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "styleSheet": {
          this.model = {};
          const add = (propName, xform) => {
            if (xform.model && xform.model.length) {
              this.model[propName] = xform.model;
            }
          };
          add("numFmts", this.map.numFmts);
          add("fonts", this.map.fonts);
          add("fills", this.map.fills);
          add("borders", this.map.borders);
          add("styles", this.map.cellXfs);
          add("dxfs", this.map.dxfs);
          this.index = {
            model: [],
            numFmt: []
          };
          if (this.model.numFmts) {
            const numFmtIndex = this.index.numFmt;
            this.model.numFmts.forEach((numFmt) => {
              numFmtIndex[numFmt.id] = numFmt.formatCode;
            });
          }
          return false;
        }
        default:
          return true;
      }
    }
    // add a cell's style model to the collection
    // each style property is processed and cross-referenced, etc.
    // the styleId is returned. Note: cellType is used when numFmt not defined
    addStyleModel(model, cellType) {
      if (!model) {
        return 0;
      }
      if (!this.model.fonts.length) {
        this._addFont({ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" });
      }
      if (this.weakMap && this.weakMap.has(model)) {
        return this.weakMap.get(model);
      }
      const style = {};
      cellType = cellType || Enums.ValueType.Number;
      if (model.numFmt) {
        style.numFmtId = this._addNumFmtStr(model.numFmt);
      } else {
        switch (cellType) {
          case Enums.ValueType.Number:
            style.numFmtId = this._addNumFmtStr("General");
            break;
          case Enums.ValueType.Date:
            style.numFmtId = this._addNumFmtStr("mm-dd-yy");
            break;
        }
      }
      if (model.font) {
        style.fontId = this._addFont(model.font);
      }
      if (model.border) {
        style.borderId = this._addBorder(model.border);
      }
      if (model.fill) {
        style.fillId = this._addFill(model.fill);
      }
      if (model.alignment) {
        style.alignment = model.alignment;
      }
      if (model.protection) {
        style.protection = model.protection;
      }
      const styleId = this._addStyle(style);
      if (this.weakMap) {
        this.weakMap.set(model, styleId);
      }
      return styleId;
    }
    // given a styleId (i.e. s="n"), get the cell's style model
    // objects are shared where possible.
    getStyleModel(id) {
      const style = this.model.styles[id];
      if (!style) return null;
      let model = this.index.model[id];
      if (model) return model;
      model = this.index.model[id] = {};
      if (style.numFmtId) {
        const numFmt = this.index.numFmt[style.numFmtId] || NumFmtXform.getDefaultFmtCode(style.numFmtId);
        if (numFmt) {
          model.numFmt = numFmt;
        }
      }
      function addStyle(name, group, styleId) {
        if (styleId || styleId === 0) {
          const part = group[styleId];
          if (part) {
            model[name] = part;
          }
        }
      }
      addStyle("font", this.model.fonts, style.fontId);
      addStyle("border", this.model.borders, style.borderId);
      addStyle("fill", this.model.fills, style.fillId);
      if (style.alignment) {
        model.alignment = style.alignment;
      }
      if (style.protection) {
        model.protection = style.protection;
      }
      return model;
    }
    addDxfStyle(style) {
      if (style.numFmt) {
        style.numFmtId = this._addNumFmtStr(style.numFmt);
      }
      this.model.dxfs.push(style);
      return this.model.dxfs.length - 1;
    }
    getDxfStyle(id) {
      return this.model.dxfs[id];
    }
    // =========================================================================
    // Private Interface
    _addStyle(style) {
      const xml = this.map.style.toXml(style);
      let index2 = this.index.style[xml];
      if (index2 === void 0) {
        index2 = this.index.style[xml] = this.model.styles.length;
        this.model.styles.push(xml);
      }
      return index2;
    }
    // =========================================================================
    // Number Formats
    _addNumFmtStr(formatCode) {
      let index2 = NumFmtXform.getDefaultFmtId(formatCode);
      if (index2 !== void 0) return index2;
      index2 = this.index.numFmt[formatCode];
      if (index2 !== void 0) return index2;
      index2 = this.index.numFmt[formatCode] = NUMFMT_BASE + this.model.numFmts.length;
      const xml = this.map.numFmt.toXml({ id: index2, formatCode });
      this.model.numFmts.push(xml);
      return index2;
    }
    // =========================================================================
    // Fonts
    _addFont(font) {
      const xml = this.map.font.toXml(font);
      let index2 = this.index.font[xml];
      if (index2 === void 0) {
        index2 = this.index.font[xml] = this.model.fonts.length;
        this.model.fonts.push(xml);
      }
      return index2;
    }
    // =========================================================================
    // Borders
    _addBorder(border) {
      const xml = this.map.border.toXml(border);
      let index2 = this.index.border[xml];
      if (index2 === void 0) {
        index2 = this.index.border[xml] = this.model.borders.length;
        this.model.borders.push(xml);
      }
      return index2;
    }
    // =========================================================================
    // Fills
    _addFill(fill) {
      const xml = this.map.fill.toXml(fill);
      let index2 = this.index.fill[xml];
      if (index2 === void 0) {
        index2 = this.index.fill[xml] = this.model.fills.length;
        this.model.fills.push(xml);
      }
      return index2;
    }
    // =========================================================================
  }
  StylesXform.STYLESHEET_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x14ac x16r2",
    "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac",
    "xmlns:x16r2": "http://schemas.microsoft.com/office/spreadsheetml/2015/02/main"
  };
  StylesXform.STATIC_XFORMS = {
    cellStyles: new StaticXform({
      tag: "cellStyles",
      $: { count: 1 },
      c: [{ tag: "cellStyle", $: { name: "Normal", xfId: 0, builtinId: 0 } }]
    }),
    dxfs: new StaticXform({ tag: "dxfs", $: { count: 0 } }),
    tableStyles: new StaticXform({
      tag: "tableStyles",
      $: { count: 0, defaultTableStyle: "TableStyleMedium2", defaultPivotStyle: "PivotStyleLight16" }
    }),
    extLst: new StaticXform({
      tag: "extLst",
      c: [
        {
          tag: "ext",
          $: {
            uri: "{EB79DEF2-80B8-43e5-95BD-54CBDDF9020C}",
            "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
          },
          c: [{ tag: "x14:slicerStyles", $: { defaultSlicerStyle: "SlicerStyleLight1" } }]
        },
        {
          tag: "ext",
          $: {
            uri: "{9260A510-F301-46a8-8635-F512D64BE5F5}",
            "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
          },
          c: [{ tag: "x15:timelineStyles", $: { defaultTimelineStyle: "TimeSlicerStyleLight1" } }]
        }
      ]
    })
  };
  class StylesXformMock extends StylesXform {
    constructor() {
      super();
      this.model = {
        styles: [{ numFmtId: 0, fontId: 0, fillId: 0, borderId: 0, xfId: 0 }],
        numFmts: [],
        fonts: [{ size: 11, color: { theme: 1 }, name: "Calibri", family: 2, scheme: "minor" }],
        borders: [{}],
        fills: [
          { type: "pattern", pattern: "none" },
          { type: "pattern", pattern: "gray125" }
        ]
      };
    }
    // =========================================================================
    // Style Manager Interface
    // override normal behaviour - consume and dispose
    parseStream(stream2) {
      stream2.autodrain();
      return Promise.resolve();
    }
    // add a cell's style model to the collection
    // each style property is processed and cross-referenced, etc.
    // the styleId is returned. Note: cellType is used when numFmt not defined
    addStyleModel(model, cellType) {
      switch (cellType) {
        case Enums.ValueType.Date:
          return this.dateStyleId;
        default:
          return 0;
      }
    }
    get dateStyleId() {
      if (!this._dateStyleId) {
        const dateStyle = {
          numFmtId: NumFmtXform.getDefaultFmtId("mm-dd-yy")
        };
        this._dateStyleId = this.model.styles.length;
        this.model.styles.push(dateStyle);
      }
      return this._dateStyleId;
    }
    // given a styleId (i.e. s="n"), get the cell's style model
    // objects are shared where possible.
    getStyleModel() {
      return {};
    }
  }
  StylesXform.Mock = StylesXformMock;
  stylesXform = StylesXform;
  return stylesXform;
}
var dateXform;
var hasRequiredDateXform;
function requireDateXform() {
  if (hasRequiredDateXform) return dateXform;
  hasRequiredDateXform = 1;
  const BaseXform = requireBaseXform();
  class DateXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.attr = options.attr;
      this.attrs = options.attrs;
      this._format = options.format || function(dt) {
        try {
          if (Number.isNaN(dt.getTime())) return "";
          return dt.toISOString();
        } catch (e) {
          return "";
        }
      };
      this._parse = options.parse || function(str) {
        return new Date(str);
      };
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.openNode(this.tag);
        if (this.attrs) {
          xmlStream2.addAttributes(this.attrs);
        }
        if (this.attr) {
          xmlStream2.addAttribute(this.attr, this._format(model));
        } else {
          xmlStream2.writeText(this._format(model));
        }
        xmlStream2.closeNode();
      }
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        if (this.attr) {
          this.model = this._parse(node2.attributes[this.attr]);
        } else {
          this.text = [];
        }
      }
    }
    parseText(text) {
      if (!this.attr) {
        this.text.push(text);
      }
    }
    parseClose() {
      if (!this.attr) {
        this.model = this._parse(this.text.join(""));
      }
      return false;
    }
  }
  dateXform = DateXform;
  return dateXform;
}
var coreXform;
var hasRequiredCoreXform;
function requireCoreXform() {
  if (hasRequiredCoreXform) return coreXform;
  hasRequiredCoreXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const DateXform = requireDateXform();
  const StringXform = requireStringXform();
  const IntegerXform = requireIntegerXform();
  class CoreXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "dc:creator": new StringXform({ tag: "dc:creator" }),
        "dc:title": new StringXform({ tag: "dc:title" }),
        "dc:subject": new StringXform({ tag: "dc:subject" }),
        "dc:description": new StringXform({ tag: "dc:description" }),
        "dc:identifier": new StringXform({ tag: "dc:identifier" }),
        "dc:language": new StringXform({ tag: "dc:language" }),
        "cp:keywords": new StringXform({ tag: "cp:keywords" }),
        "cp:category": new StringXform({ tag: "cp:category" }),
        "cp:lastModifiedBy": new StringXform({ tag: "cp:lastModifiedBy" }),
        "cp:lastPrinted": new DateXform({ tag: "cp:lastPrinted", format: CoreXform.DateFormat }),
        "cp:revision": new IntegerXform({ tag: "cp:revision" }),
        "cp:version": new StringXform({ tag: "cp:version" }),
        "cp:contentStatus": new StringXform({ tag: "cp:contentStatus" }),
        "cp:contentType": new StringXform({ tag: "cp:contentType" }),
        "dcterms:created": new DateXform({
          tag: "dcterms:created",
          attrs: CoreXform.DateAttrs,
          format: CoreXform.DateFormat
        }),
        "dcterms:modified": new DateXform({
          tag: "dcterms:modified",
          attrs: CoreXform.DateAttrs,
          format: CoreXform.DateFormat
        })
      };
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("cp:coreProperties", CoreXform.CORE_PROPERTY_ATTRIBUTES);
      this.map["dc:creator"].render(xmlStream2, model.creator);
      this.map["dc:title"].render(xmlStream2, model.title);
      this.map["dc:subject"].render(xmlStream2, model.subject);
      this.map["dc:description"].render(xmlStream2, model.description);
      this.map["dc:identifier"].render(xmlStream2, model.identifier);
      this.map["dc:language"].render(xmlStream2, model.language);
      this.map["cp:keywords"].render(xmlStream2, model.keywords);
      this.map["cp:category"].render(xmlStream2, model.category);
      this.map["cp:lastModifiedBy"].render(xmlStream2, model.lastModifiedBy);
      this.map["cp:lastPrinted"].render(xmlStream2, model.lastPrinted);
      this.map["cp:revision"].render(xmlStream2, model.revision);
      this.map["cp:version"].render(xmlStream2, model.version);
      this.map["cp:contentStatus"].render(xmlStream2, model.contentStatus);
      this.map["cp:contentType"].render(xmlStream2, model.contentType);
      this.map["dcterms:created"].render(xmlStream2, model.created);
      this.map["dcterms:modified"].render(xmlStream2, model.modified);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "cp:coreProperties":
        case "coreProperties":
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "cp:coreProperties":
        case "coreProperties":
          this.model = {
            creator: this.map["dc:creator"].model,
            title: this.map["dc:title"].model,
            subject: this.map["dc:subject"].model,
            description: this.map["dc:description"].model,
            identifier: this.map["dc:identifier"].model,
            language: this.map["dc:language"].model,
            keywords: this.map["cp:keywords"].model,
            category: this.map["cp:category"].model,
            lastModifiedBy: this.map["cp:lastModifiedBy"].model,
            lastPrinted: this.map["cp:lastPrinted"].model,
            revision: this.map["cp:revision"].model,
            contentStatus: this.map["cp:contentStatus"].model,
            contentType: this.map["cp:contentType"].model,
            created: this.map["dcterms:created"].model,
            modified: this.map["dcterms:modified"].model
          };
          return false;
        default:
          throw new Error(`Unexpected xml node in parseClose: ${name}`);
      }
    }
  }
  CoreXform.DateFormat = function(dt) {
    return dt.toISOString().replace(/[.]\d{3}/, "");
  };
  CoreXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
  CoreXform.CORE_PROPERTY_ATTRIBUTES = {
    "xmlns:cp": "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:dcterms": "http://purl.org/dc/terms/",
    "xmlns:dcmitype": "http://purl.org/dc/dcmitype/",
    "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance"
  };
  coreXform = CoreXform;
  return coreXform;
}
var textXform;
var hasRequiredTextXform;
function requireTextXform() {
  if (hasRequiredTextXform) return textXform;
  hasRequiredTextXform = 1;
  const BaseXform = requireBaseXform();
  class TextXform extends BaseXform {
    get tag() {
      return "t";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("t");
      if (/^\s|\n|\s$/.test(model)) {
        xmlStream2.addAttribute("xml:space", "preserve");
      }
      xmlStream2.writeText(model);
      xmlStream2.closeNode();
    }
    get model() {
      return this._text.join("").replace(/_x([0-9A-F]{4})_/g, ($0, $1) => String.fromCharCode(parseInt($1, 16)));
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "t":
          this._text = [];
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      this._text.push(text);
    }
    parseClose() {
      return false;
    }
  }
  textXform = TextXform;
  return textXform;
}
var richTextXform;
var hasRequiredRichTextXform;
function requireRichTextXform() {
  if (hasRequiredRichTextXform) return richTextXform;
  hasRequiredRichTextXform = 1;
  const TextXform = requireTextXform();
  const FontXform = requireFontXform();
  const BaseXform = requireBaseXform();
  class RichTextXform extends BaseXform {
    constructor(model) {
      super();
      this.model = model;
    }
    get tag() {
      return "r";
    }
    get textXform() {
      return this._textXform || (this._textXform = new TextXform());
    }
    get fontXform() {
      return this._fontXform || (this._fontXform = new FontXform(RichTextXform.FONT_OPTIONS));
    }
    render(xmlStream2, model) {
      model = model || this.model;
      xmlStream2.openNode("r");
      if (model.font) {
        this.fontXform.render(xmlStream2, model.font);
      }
      this.textXform.render(xmlStream2, model.text);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "r":
          this.model = {};
          return true;
        case "t":
          this.parser = this.textXform;
          this.parser.parseOpen(node2);
          return true;
        case "rPr":
          this.parser = this.fontXform;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      switch (name) {
        case "r":
          return false;
        case "t":
          this.model.text = this.parser.model;
          this.parser = void 0;
          return true;
        case "rPr":
          this.model.font = this.parser.model;
          this.parser = void 0;
          return true;
        default:
          if (this.parser) {
            this.parser.parseClose(name);
          }
          return true;
      }
    }
  }
  RichTextXform.FONT_OPTIONS = {
    tagName: "rPr",
    fontNameTag: "rFont"
  };
  richTextXform = RichTextXform;
  return richTextXform;
}
var phoneticTextXform;
var hasRequiredPhoneticTextXform;
function requirePhoneticTextXform() {
  if (hasRequiredPhoneticTextXform) return phoneticTextXform;
  hasRequiredPhoneticTextXform = 1;
  const TextXform = requireTextXform();
  const RichTextXform = requireRichTextXform();
  const BaseXform = requireBaseXform();
  class PhoneticTextXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        r: new RichTextXform(),
        t: new TextXform()
      };
    }
    get tag() {
      return "rPh";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        sb: model.sb || 0,
        eb: model.eb || 0
      });
      if (model && model.hasOwnProperty("richText") && model.richText) {
        const { r } = this.map;
        model.richText.forEach((text) => {
          r.render(xmlStream2, text);
        });
      } else if (model) {
        this.map.t.render(xmlStream2, model.text);
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      const { name } = node2;
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (name === this.tag) {
        this.model = {
          sb: parseInt(node2.attributes.sb, 10),
          eb: parseInt(node2.attributes.eb, 10)
        };
        return true;
      }
      this.parser = this.map[name];
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      return false;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          switch (name) {
            case "r": {
              let rt = this.model.richText;
              if (!rt) {
                rt = this.model.richText = [];
              }
              rt.push(this.parser.model);
              break;
            }
            case "t":
              this.model.text = this.parser.model;
              break;
          }
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  phoneticTextXform = PhoneticTextXform;
  return phoneticTextXform;
}
var sharedStringXform;
var hasRequiredSharedStringXform;
function requireSharedStringXform() {
  if (hasRequiredSharedStringXform) return sharedStringXform;
  hasRequiredSharedStringXform = 1;
  const TextXform = requireTextXform();
  const RichTextXform = requireRichTextXform();
  const PhoneticTextXform = requirePhoneticTextXform();
  const BaseXform = requireBaseXform();
  class SharedStringXform extends BaseXform {
    constructor(model) {
      super();
      this.model = model;
      this.map = {
        r: new RichTextXform(),
        t: new TextXform(),
        rPh: new PhoneticTextXform()
      };
    }
    get tag() {
      return "si";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      if (model && model.hasOwnProperty("richText") && model.richText) {
        if (model.richText.length) {
          model.richText.forEach((text) => {
            this.map.r.render(xmlStream2, text);
          });
        } else {
          this.map.t.render(xmlStream2, "");
        }
      } else if (model !== void 0 && model !== null) {
        this.map.t.render(xmlStream2, model);
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      const { name } = node2;
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (name === this.tag) {
        this.model = {};
        return true;
      }
      this.parser = this.map[name];
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      return false;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          switch (name) {
            case "r": {
              let rt = this.model.richText;
              if (!rt) {
                rt = this.model.richText = [];
              }
              rt.push(this.parser.model);
              break;
            }
            case "t":
              this.model = this.parser.model;
              break;
          }
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  sharedStringXform = SharedStringXform;
  return sharedStringXform;
}
var sharedStringsXform;
var hasRequiredSharedStringsXform;
function requireSharedStringsXform() {
  if (hasRequiredSharedStringsXform) return sharedStringsXform;
  hasRequiredSharedStringsXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const SharedStringXform = requireSharedStringXform();
  class SharedStringsXform extends BaseXform {
    constructor(model) {
      super();
      this.model = model || {
        values: [],
        count: 0
      };
      this.hash = /* @__PURE__ */ Object.create(null);
      this.rich = /* @__PURE__ */ Object.create(null);
    }
    get sharedStringXform() {
      return this._sharedStringXform || (this._sharedStringXform = new SharedStringXform());
    }
    get values() {
      return this.model.values;
    }
    get uniqueCount() {
      return this.model.values.length;
    }
    get count() {
      return this.model.count;
    }
    getString(index2) {
      return this.model.values[index2];
    }
    add(value) {
      return value.richText ? this.addRichText(value) : this.addText(value);
    }
    addText(value) {
      let index2 = this.hash[value];
      if (index2 === void 0) {
        index2 = this.hash[value] = this.model.values.length;
        this.model.values.push(value);
      }
      this.model.count++;
      return index2;
    }
    addRichText(value) {
      const xml = this.sharedStringXform.toXml(value);
      let index2 = this.rich[xml];
      if (index2 === void 0) {
        index2 = this.rich[xml] = this.model.values.length;
        this.model.values.push(value);
      }
      this.model.count++;
      return index2;
    }
    // <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
    // <sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="<%=totalRefs%>" uniqueCount="<%=count%>">
    //   <si><t><%=text%></t></si>
    //   <si><r><rPr></rPr><t></t></r></si>
    // </sst>
    render(xmlStream2, model) {
      model = model || this._values;
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("sst", {
        xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
        count: model.count,
        uniqueCount: model.values.length
      });
      const sx = this.sharedStringXform;
      model.values.forEach((sharedString) => {
        sx.render(xmlStream2, sharedString);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "sst":
          return true;
        case "si":
          this.parser = this.sharedStringXform;
          this.parser.parseOpen(node2);
          return true;
        default:
          throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.values.push(this.parser.model);
          this.model.count++;
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "sst":
          return false;
        default:
          throw new Error(`Unexpected xml node in parseClose: ${name}`);
      }
    }
  }
  sharedStringsXform = SharedStringsXform;
  return sharedStringsXform;
}
var relationshipXform;
var hasRequiredRelationshipXform;
function requireRelationshipXform() {
  if (hasRequiredRelationshipXform) return relationshipXform;
  hasRequiredRelationshipXform = 1;
  const BaseXform = requireBaseXform();
  class RelationshipXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.leafNode("Relationship", model);
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "Relationship":
          this.model = node2.attributes;
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  relationshipXform = RelationshipXform;
  return relationshipXform;
}
var relationshipsXform;
var hasRequiredRelationshipsXform;
function requireRelationshipsXform() {
  if (hasRequiredRelationshipsXform) return relationshipsXform;
  hasRequiredRelationshipsXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const RelationshipXform = requireRelationshipXform();
  class RelationshipsXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        Relationship: new RelationshipXform()
      };
    }
    render(xmlStream2, model) {
      model = model || this._values;
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("Relationships", RelationshipsXform.RELATIONSHIPS_ATTRIBUTES);
      model.forEach((relationship) => {
        this.map.Relationship.render(xmlStream2, relationship);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "Relationships":
          this.model = [];
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.push(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "Relationships":
          return false;
        default:
          throw new Error(`Unexpected xml node in parseClose: ${name}`);
      }
    }
  }
  RelationshipsXform.RELATIONSHIPS_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/package/2006/relationships"
  };
  relationshipsXform = RelationshipsXform;
  return relationshipsXform;
}
var contentTypesXform;
var hasRequiredContentTypesXform;
function requireContentTypesXform() {
  if (hasRequiredContentTypesXform) return contentTypesXform;
  hasRequiredContentTypesXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  class ContentTypesXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("Types", ContentTypesXform.PROPERTY_ATTRIBUTES);
      const mediaHash = {};
      (model.media || []).forEach((medium) => {
        if (medium.type === "image") {
          const imageType = medium.extension;
          if (!mediaHash[imageType]) {
            mediaHash[imageType] = true;
            xmlStream2.leafNode("Default", { Extension: imageType, ContentType: `image/${imageType}` });
          }
        }
      });
      xmlStream2.leafNode("Default", {
        Extension: "rels",
        ContentType: "application/vnd.openxmlformats-package.relationships+xml"
      });
      xmlStream2.leafNode("Default", { Extension: "xml", ContentType: "application/xml" });
      xmlStream2.leafNode("Override", {
        PartName: "/xl/workbook.xml",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"
      });
      model.worksheets.forEach((worksheet2) => {
        const name = `/xl/worksheets/sheet${worksheet2.id}.xml`;
        xmlStream2.leafNode("Override", {
          PartName: name,
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"
        });
      });
      xmlStream2.leafNode("Override", {
        PartName: "/xl/theme/theme1.xml",
        ContentType: "application/vnd.openxmlformats-officedocument.theme+xml"
      });
      xmlStream2.leafNode("Override", {
        PartName: "/xl/styles.xml",
        ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"
      });
      const hasSharedStrings = model.sharedStrings && model.sharedStrings.count;
      if (hasSharedStrings) {
        xmlStream2.leafNode("Override", {
          PartName: "/xl/sharedStrings.xml",
          ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"
        });
      }
      if (model.tables) {
        model.tables.forEach((table2) => {
          xmlStream2.leafNode("Override", {
            PartName: `/xl/tables/${table2.target}`,
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml"
          });
        });
      }
      if (model.drawings) {
        model.drawings.forEach((drawing) => {
          xmlStream2.leafNode("Override", {
            PartName: `/xl/drawings/${drawing.name}.xml`,
            ContentType: "application/vnd.openxmlformats-officedocument.drawing+xml"
          });
        });
      }
      if (model.commentRefs) {
        xmlStream2.leafNode("Default", {
          Extension: "vml",
          ContentType: "application/vnd.openxmlformats-officedocument.vmlDrawing"
        });
        model.commentRefs.forEach(({ commentName }) => {
          xmlStream2.leafNode("Override", {
            PartName: `/xl/${commentName}.xml`,
            ContentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"
          });
        });
      }
      xmlStream2.leafNode("Override", {
        PartName: "/docProps/core.xml",
        ContentType: "application/vnd.openxmlformats-package.core-properties+xml"
      });
      xmlStream2.leafNode("Override", {
        PartName: "/docProps/app.xml",
        ContentType: "application/vnd.openxmlformats-officedocument.extended-properties+xml"
      });
      xmlStream2.closeNode();
    }
    parseOpen() {
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  ContentTypesXform.PROPERTY_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/package/2006/content-types"
  };
  contentTypesXform = ContentTypesXform;
  return contentTypesXform;
}
var appHeadingPairsXform;
var hasRequiredAppHeadingPairsXform;
function requireAppHeadingPairsXform() {
  if (hasRequiredAppHeadingPairsXform) return appHeadingPairsXform;
  hasRequiredAppHeadingPairsXform = 1;
  const BaseXform = requireBaseXform();
  class AppHeadingPairsXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.openNode("HeadingPairs");
      xmlStream2.openNode("vt:vector", { size: 2, baseType: "variant" });
      xmlStream2.openNode("vt:variant");
      xmlStream2.leafNode("vt:lpstr", void 0, "Worksheets");
      xmlStream2.closeNode();
      xmlStream2.openNode("vt:variant");
      xmlStream2.leafNode("vt:i4", void 0, model.length);
      xmlStream2.closeNode();
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      return node2.name === "HeadingPairs";
    }
    parseText() {
    }
    parseClose(name) {
      return name !== "HeadingPairs";
    }
  }
  appHeadingPairsXform = AppHeadingPairsXform;
  return appHeadingPairsXform;
}
var appTitlesOfPartsXform;
var hasRequiredAppTitlesOfPartsXform;
function requireAppTitlesOfPartsXform() {
  if (hasRequiredAppTitlesOfPartsXform) return appTitlesOfPartsXform;
  hasRequiredAppTitlesOfPartsXform = 1;
  const BaseXform = requireBaseXform();
  class AppTitlesOfPartsXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.openNode("TitlesOfParts");
      xmlStream2.openNode("vt:vector", { size: model.length, baseType: "lpstr" });
      model.forEach((sheet) => {
        xmlStream2.leafNode("vt:lpstr", void 0, sheet.name);
      });
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      return node2.name === "TitlesOfParts";
    }
    parseText() {
    }
    parseClose(name) {
      return name !== "TitlesOfParts";
    }
  }
  appTitlesOfPartsXform = AppTitlesOfPartsXform;
  return appTitlesOfPartsXform;
}
var appXform;
var hasRequiredAppXform;
function requireAppXform() {
  if (hasRequiredAppXform) return appXform;
  hasRequiredAppXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const StringXform = requireStringXform();
  const AppHeadingPairsXform = requireAppHeadingPairsXform();
  const AppTitleOfPartsXform = requireAppTitlesOfPartsXform();
  class AppXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        Company: new StringXform({ tag: "Company" }),
        Manager: new StringXform({ tag: "Manager" }),
        HeadingPairs: new AppHeadingPairsXform(),
        TitleOfParts: new AppTitleOfPartsXform()
      };
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("Properties", AppXform.PROPERTY_ATTRIBUTES);
      xmlStream2.leafNode("Application", void 0, "Microsoft Excel");
      xmlStream2.leafNode("DocSecurity", void 0, "0");
      xmlStream2.leafNode("ScaleCrop", void 0, "false");
      this.map.HeadingPairs.render(xmlStream2, model.worksheets);
      this.map.TitleOfParts.render(xmlStream2, model.worksheets);
      this.map.Company.render(xmlStream2, model.company || "");
      this.map.Manager.render(xmlStream2, model.manager);
      xmlStream2.leafNode("LinksUpToDate", void 0, "false");
      xmlStream2.leafNode("SharedDoc", void 0, "false");
      xmlStream2.leafNode("HyperlinksChanged", void 0, "false");
      xmlStream2.leafNode("AppVersion", void 0, "16.0300");
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "Properties":
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
            return true;
          }
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "Properties":
          this.model = {
            worksheets: this.map.TitleOfParts.model,
            company: this.map.Company.model,
            manager: this.map.Manager.model
          };
          return false;
        default:
          return true;
      }
    }
  }
  AppXform.DateFormat = function(dt) {
    return dt.toISOString().replace(/[.]\d{3,6}/, "");
  };
  AppXform.DateAttrs = { "xsi:type": "dcterms:W3CDTF" };
  AppXform.PROPERTY_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
    "xmlns:vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes"
  };
  appXform = AppXform;
  return appXform;
}
var definedNameXform;
var hasRequiredDefinedNameXform;
function requireDefinedNameXform() {
  if (hasRequiredDefinedNameXform) return definedNameXform;
  hasRequiredDefinedNameXform = 1;
  const BaseXform = requireBaseXform();
  const colCache = requireColCache();
  class DefinedNamesXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.openNode("definedName", {
        name: model.name,
        localSheetId: model.localSheetId
      });
      xmlStream2.writeText(model.ranges.join(","));
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "definedName":
          this._parsedName = node2.attributes.name;
          this._parsedLocalSheetId = node2.attributes.localSheetId;
          this._parsedText = [];
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      this._parsedText.push(text);
    }
    parseClose() {
      this.model = {
        name: this._parsedName,
        ranges: extractRanges(this._parsedText.join(""))
      };
      if (this._parsedLocalSheetId !== void 0) {
        this.model.localSheetId = parseInt(this._parsedLocalSheetId, 10);
      }
      return false;
    }
  }
  function isValidRange(range2) {
    try {
      colCache.decodeEx(range2);
      return true;
    } catch (err) {
      return false;
    }
  }
  function extractRanges(parsedText) {
    const ranges = [];
    let quotesOpened = false;
    let last = "";
    parsedText.split(",").forEach((item) => {
      if (!item) {
        return;
      }
      const quotes = (item.match(/'/g) || []).length;
      if (!quotes) {
        if (quotesOpened) {
          last += `${item},`;
        } else if (isValidRange(item)) {
          ranges.push(item);
        }
        return;
      }
      const quotesEven = quotes % 2 === 0;
      if (!quotesOpened && quotesEven && isValidRange(item)) {
        ranges.push(item);
      } else if (quotesOpened && !quotesEven) {
        quotesOpened = false;
        if (isValidRange(last + item)) {
          ranges.push(last + item);
        }
        last = "";
      } else {
        quotesOpened = true;
        last += `${item},`;
      }
    });
    return ranges;
  }
  definedNameXform = DefinedNamesXform;
  return definedNameXform;
}
var sheetXform;
var hasRequiredSheetXform;
function requireSheetXform() {
  if (hasRequiredSheetXform) return sheetXform;
  hasRequiredSheetXform = 1;
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  class WorksheetXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.leafNode("sheet", {
        sheetId: model.id,
        name: model.name,
        state: model.state,
        "r:id": model.rId
      });
    }
    parseOpen(node2) {
      if (node2.name === "sheet") {
        this.model = {
          name: utils2.xmlDecode(node2.attributes.name),
          id: parseInt(node2.attributes.sheetId, 10),
          state: node2.attributes.state,
          rId: node2.attributes["r:id"]
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  sheetXform = WorksheetXform;
  return sheetXform;
}
var workbookViewXform;
var hasRequiredWorkbookViewXform;
function requireWorkbookViewXform() {
  if (hasRequiredWorkbookViewXform) return workbookViewXform;
  hasRequiredWorkbookViewXform = 1;
  const BaseXform = requireBaseXform();
  class WorkbookViewXform extends BaseXform {
    render(xmlStream2, model) {
      const attributes = {
        xWindow: model.x || 0,
        yWindow: model.y || 0,
        windowWidth: model.width || 12e3,
        windowHeight: model.height || 24e3,
        firstSheet: model.firstSheet,
        activeTab: model.activeTab
      };
      if (model.visibility && model.visibility !== "visible") {
        attributes.visibility = model.visibility;
      }
      xmlStream2.leafNode("workbookView", attributes);
    }
    parseOpen(node2) {
      if (node2.name === "workbookView") {
        const model = this.model = {};
        const addS = function(name, value, dflt) {
          const s = value !== void 0 ? model[name] = value : dflt;
          if (s !== void 0) {
            model[name] = s;
          }
        };
        const addN = function(name, value, dflt) {
          const n = value !== void 0 ? model[name] = parseInt(value, 10) : dflt;
          if (n !== void 0) {
            model[name] = n;
          }
        };
        addN("x", node2.attributes.xWindow, 0);
        addN("y", node2.attributes.yWindow, 0);
        addN("width", node2.attributes.windowWidth, 25e3);
        addN("height", node2.attributes.windowHeight, 1e4);
        addS("visibility", node2.attributes.visibility, "visible");
        addN("activeTab", node2.attributes.activeTab, void 0);
        addN("firstSheet", node2.attributes.firstSheet, void 0);
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  workbookViewXform = WorkbookViewXform;
  return workbookViewXform;
}
var workbookPropertiesXform;
var hasRequiredWorkbookPropertiesXform;
function requireWorkbookPropertiesXform() {
  if (hasRequiredWorkbookPropertiesXform) return workbookPropertiesXform;
  hasRequiredWorkbookPropertiesXform = 1;
  const BaseXform = requireBaseXform();
  class WorksheetPropertiesXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.leafNode("workbookPr", {
        date1904: model.date1904 ? 1 : void 0,
        defaultThemeVersion: 164011,
        filterPrivacy: 1
      });
    }
    parseOpen(node2) {
      if (node2.name === "workbookPr") {
        this.model = {
          date1904: node2.attributes.date1904 === "1"
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  workbookPropertiesXform = WorksheetPropertiesXform;
  return workbookPropertiesXform;
}
var workbookCalcPropertiesXform;
var hasRequiredWorkbookCalcPropertiesXform;
function requireWorkbookCalcPropertiesXform() {
  if (hasRequiredWorkbookCalcPropertiesXform) return workbookCalcPropertiesXform;
  hasRequiredWorkbookCalcPropertiesXform = 1;
  const BaseXform = requireBaseXform();
  class WorkbookCalcPropertiesXform extends BaseXform {
    render(xmlStream2, model) {
      xmlStream2.leafNode("calcPr", {
        calcId: 171027,
        fullCalcOnLoad: model.fullCalcOnLoad ? 1 : void 0
      });
    }
    parseOpen(node2) {
      if (node2.name === "calcPr") {
        this.model = {};
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  workbookCalcPropertiesXform = WorkbookCalcPropertiesXform;
  return workbookCalcPropertiesXform;
}
var workbookXform;
var hasRequiredWorkbookXform;
function requireWorkbookXform() {
  if (hasRequiredWorkbookXform) return workbookXform;
  hasRequiredWorkbookXform = 1;
  const _2 = requireUnderDash();
  const colCache = requireColCache();
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const StaticXform = requireStaticXform();
  const ListXform = requireListXform();
  const DefinedNameXform = requireDefinedNameXform();
  const SheetXform = requireSheetXform();
  const WorkbookViewXform = requireWorkbookViewXform();
  const WorkbookPropertiesXform = requireWorkbookPropertiesXform();
  const WorkbookCalcPropertiesXform = requireWorkbookCalcPropertiesXform();
  class WorkbookXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        fileVersion: WorkbookXform.STATIC_XFORMS.fileVersion,
        workbookPr: new WorkbookPropertiesXform(),
        bookViews: new ListXform({
          tag: "bookViews",
          count: false,
          childXform: new WorkbookViewXform()
        }),
        sheets: new ListXform({ tag: "sheets", count: false, childXform: new SheetXform() }),
        definedNames: new ListXform({
          tag: "definedNames",
          count: false,
          childXform: new DefinedNameXform()
        }),
        calcPr: new WorkbookCalcPropertiesXform()
      };
    }
    prepare(model) {
      model.sheets = model.worksheets;
      const printAreas = [];
      let index2 = 0;
      model.sheets.forEach((sheet) => {
        if (sheet.pageSetup && sheet.pageSetup.printArea) {
          sheet.pageSetup.printArea.split("&&").forEach((printArea) => {
            const printAreaComponents = printArea.split(":");
            const definedName = {
              name: "_xlnm.Print_Area",
              ranges: [`'${sheet.name}'!$${printAreaComponents[0]}:$${printAreaComponents[1]}`],
              localSheetId: index2
            };
            printAreas.push(definedName);
          });
        }
        if (sheet.pageSetup && (sheet.pageSetup.printTitlesRow || sheet.pageSetup.printTitlesColumn)) {
          const ranges = [];
          if (sheet.pageSetup.printTitlesColumn) {
            const titlesColumns = sheet.pageSetup.printTitlesColumn.split(":");
            ranges.push(`'${sheet.name}'!$${titlesColumns[0]}:$${titlesColumns[1]}`);
          }
          if (sheet.pageSetup.printTitlesRow) {
            const titlesRows = sheet.pageSetup.printTitlesRow.split(":");
            ranges.push(`'${sheet.name}'!$${titlesRows[0]}:$${titlesRows[1]}`);
          }
          const definedName = {
            name: "_xlnm.Print_Titles",
            ranges,
            localSheetId: index2
          };
          printAreas.push(definedName);
        }
        index2++;
      });
      if (printAreas.length) {
        model.definedNames = model.definedNames.concat(printAreas);
      }
      (model.media || []).forEach((medium, i) => {
        medium.name = medium.type + (i + 1);
      });
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("workbook", WorkbookXform.WORKBOOK_ATTRIBUTES);
      this.map.fileVersion.render(xmlStream2);
      this.map.workbookPr.render(xmlStream2, model.properties);
      this.map.bookViews.render(xmlStream2, model.views);
      this.map.sheets.render(xmlStream2, model.sheets);
      this.map.definedNames.render(xmlStream2, model.definedNames);
      this.map.calcPr.render(xmlStream2, model.calcProperties);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "workbook":
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          return true;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "workbook":
          this.model = {
            sheets: this.map.sheets.model,
            properties: this.map.workbookPr.model || {},
            views: this.map.bookViews.model,
            calcProperties: {}
          };
          if (this.map.definedNames.model) {
            this.model.definedNames = this.map.definedNames.model;
          }
          return false;
        default:
          return true;
      }
    }
    reconcile(model) {
      const rels = (model.workbookRels || []).reduce((map2, rel) => {
        map2[rel.Id] = rel;
        return map2;
      }, {});
      const worksheets = [];
      let worksheet2;
      let index2 = 0;
      (model.sheets || []).forEach((sheet) => {
        const rel = rels[sheet.rId];
        if (!rel) {
          return;
        }
        worksheet2 = model.worksheetHash[`xl/${rel.Target.replace(/^(\s|\/xl\/)+/, "")}`];
        if (worksheet2) {
          worksheet2.name = sheet.name;
          worksheet2.id = sheet.id;
          worksheet2.state = sheet.state;
          worksheets[index2++] = worksheet2;
        }
      });
      const definedNames2 = [];
      _2.each(model.definedNames, (definedName) => {
        if (definedName.name === "_xlnm.Print_Area") {
          worksheet2 = worksheets[definedName.localSheetId];
          if (worksheet2) {
            if (!worksheet2.pageSetup) {
              worksheet2.pageSetup = {};
            }
            const range2 = colCache.decodeEx(definedName.ranges[0]);
            worksheet2.pageSetup.printArea = worksheet2.pageSetup.printArea ? `${worksheet2.pageSetup.printArea}&&${range2.dimensions}` : range2.dimensions;
          }
        } else if (definedName.name === "_xlnm.Print_Titles") {
          worksheet2 = worksheets[definedName.localSheetId];
          if (worksheet2) {
            if (!worksheet2.pageSetup) {
              worksheet2.pageSetup = {};
            }
            const rangeString = definedName.ranges.join(",");
            const dollarRegex = /\$/g;
            const rowRangeRegex = /\$\d+:\$\d+/;
            const rowRangeMatches = rangeString.match(rowRangeRegex);
            if (rowRangeMatches && rowRangeMatches.length) {
              const range2 = rowRangeMatches[0];
              worksheet2.pageSetup.printTitlesRow = range2.replace(dollarRegex, "");
            }
            const columnRangeRegex = /\$[A-Z]+:\$[A-Z]+/;
            const columnRangeMatches = rangeString.match(columnRangeRegex);
            if (columnRangeMatches && columnRangeMatches.length) {
              const range2 = columnRangeMatches[0];
              worksheet2.pageSetup.printTitlesColumn = range2.replace(dollarRegex, "");
            }
          }
        } else {
          definedNames2.push(definedName);
        }
      });
      model.definedNames = definedNames2;
      model.media.forEach((media, i) => {
        media.index = i;
      });
    }
  }
  WorkbookXform.WORKBOOK_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x15",
    "xmlns:x15": "http://schemas.microsoft.com/office/spreadsheetml/2010/11/main"
  };
  WorkbookXform.STATIC_XFORMS = {
    fileVersion: new StaticXform({
      tag: "fileVersion",
      $: { appName: "xl", lastEdited: 5, lowestEdited: 5, rupBuild: 9303 }
    })
  };
  workbookXform = WorkbookXform;
  return workbookXform;
}
var relType;
var hasRequiredRelType;
function requireRelType() {
  if (hasRequiredRelType) return relType;
  hasRequiredRelType = 1;
  relType = {
    OfficeDocument: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
    Worksheet: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    CalcChain: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/calcChain",
    SharedStrings: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
    Styles: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
    Theme: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
    Hyperlink: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
    Image: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
    CoreProperties: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
    ExtenderProperties: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
    Comments: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
    VmlDrawing: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
    Table: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/table"
  };
  return relType;
}
var merges;
var hasRequiredMerges;
function requireMerges() {
  if (hasRequiredMerges) return merges;
  hasRequiredMerges = 1;
  const _2 = requireUnderDash();
  const Range = requireRange();
  const colCache = requireColCache();
  const Enums = requireEnums();
  class Merges {
    constructor() {
      this.merges = {};
    }
    add(merge2) {
      if (this.merges[merge2.master]) {
        this.merges[merge2.master].expandToAddress(merge2.address);
      } else {
        const range2 = `${merge2.master}:${merge2.address}`;
        this.merges[merge2.master] = new Range(range2);
      }
    }
    get mergeCells() {
      return _2.map(this.merges, (merge2) => merge2.range);
    }
    reconcile(mergeCells, rows) {
      _2.each(mergeCells, (merge2) => {
        const dimensions = colCache.decode(merge2);
        for (let i = dimensions.top; i <= dimensions.bottom; i++) {
          const row2 = rows[i - 1];
          for (let j = dimensions.left; j <= dimensions.right; j++) {
            const cell2 = row2.cells[j - 1];
            if (!cell2) {
              row2.cells[j] = {
                type: Enums.ValueType.Null,
                address: colCache.encodeAddress(i, j)
              };
            } else if (cell2.type === Enums.ValueType.Merge) {
              cell2.master = dimensions.tl;
            }
          }
        }
      });
    }
    getMasterAddress(address) {
      const range2 = this.hash[address];
      return range2 && range2.tl;
    }
  }
  merges = Merges;
  return merges;
}
var cellXform;
var hasRequiredCellXform;
function requireCellXform() {
  if (hasRequiredCellXform) return cellXform;
  hasRequiredCellXform = 1;
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  const Range = requireRange();
  const Enums = requireEnums();
  const RichTextXform = requireRichTextXform();
  function getValueType(v) {
    if (v === null || v === void 0) {
      return Enums.ValueType.Null;
    }
    if (v instanceof String || typeof v === "string") {
      return Enums.ValueType.String;
    }
    if (typeof v === "number") {
      return Enums.ValueType.Number;
    }
    if (typeof v === "boolean") {
      return Enums.ValueType.Boolean;
    }
    if (v instanceof Date) {
      return Enums.ValueType.Date;
    }
    if (v.text && v.hyperlink) {
      return Enums.ValueType.Hyperlink;
    }
    if (v.formula) {
      return Enums.ValueType.Formula;
    }
    if (v.error) {
      return Enums.ValueType.Error;
    }
    throw new Error("I could not understand type of value");
  }
  function getEffectiveCellType(cell2) {
    switch (cell2.type) {
      case Enums.ValueType.Formula:
        return getValueType(cell2.result);
      default:
        return cell2.type;
    }
  }
  class CellXform extends BaseXform {
    constructor() {
      super();
      this.richTextXForm = new RichTextXform();
    }
    get tag() {
      return "c";
    }
    prepare(model, options) {
      const styleId = options.styles.addStyleModel(model.style || {}, getEffectiveCellType(model));
      if (styleId) {
        model.styleId = styleId;
      }
      if (model.comment) {
        options.comments.push({ ...model.comment, ref: model.address });
      }
      switch (model.type) {
        case Enums.ValueType.String:
        case Enums.ValueType.RichText:
          if (options.sharedStrings) {
            model.ssId = options.sharedStrings.add(model.value);
          }
          break;
        case Enums.ValueType.Date:
          if (options.date1904) {
            model.date1904 = true;
          }
          break;
        case Enums.ValueType.Hyperlink:
          if (options.sharedStrings && model.text !== void 0 && model.text !== null) {
            model.ssId = options.sharedStrings.add(model.text);
          }
          options.hyperlinks.push({
            address: model.address,
            target: model.hyperlink,
            tooltip: model.tooltip
          });
          break;
        case Enums.ValueType.Merge:
          options.merges.add(model);
          break;
        case Enums.ValueType.Formula:
          if (options.date1904) {
            model.date1904 = true;
          }
          if (model.shareType === "shared") {
            model.si = options.siFormulae++;
          }
          if (model.formula) {
            options.formulae[model.address] = model;
          } else if (model.sharedFormula) {
            const master = options.formulae[model.sharedFormula];
            if (!master) {
              throw new Error(
                `Shared Formula master must exist above and or left of clone for cell ${model.address}`
              );
            }
            if (master.si === void 0) {
              master.shareType = "shared";
              master.si = options.siFormulae++;
              master.range = new Range(master.address, model.address);
            } else if (master.range) {
              master.range.expandToAddress(model.address);
            }
            model.si = master.si;
          }
          break;
      }
    }
    renderFormula(xmlStream2, model) {
      let attrs = null;
      switch (model.shareType) {
        case "shared":
          attrs = {
            t: "shared",
            ref: model.ref || model.range.range,
            si: model.si
          };
          break;
        case "array":
          attrs = {
            t: "array",
            ref: model.ref
          };
          break;
        default:
          if (model.si !== void 0) {
            attrs = {
              t: "shared",
              si: model.si
            };
          }
          break;
      }
      switch (getValueType(model.result)) {
        case Enums.ValueType.Null:
          xmlStream2.leafNode("f", attrs, model.formula);
          break;
        case Enums.ValueType.String:
          xmlStream2.addAttribute("t", "str");
          xmlStream2.leafNode("f", attrs, model.formula);
          xmlStream2.leafNode("v", null, model.result);
          break;
        case Enums.ValueType.Number:
          xmlStream2.leafNode("f", attrs, model.formula);
          xmlStream2.leafNode("v", null, model.result);
          break;
        case Enums.ValueType.Boolean:
          xmlStream2.addAttribute("t", "b");
          xmlStream2.leafNode("f", attrs, model.formula);
          xmlStream2.leafNode("v", null, model.result ? 1 : 0);
          break;
        case Enums.ValueType.Error:
          xmlStream2.addAttribute("t", "e");
          xmlStream2.leafNode("f", attrs, model.formula);
          xmlStream2.leafNode("v", null, model.result.error);
          break;
        case Enums.ValueType.Date:
          xmlStream2.leafNode("f", attrs, model.formula);
          xmlStream2.leafNode("v", null, utils2.dateToExcel(model.result, model.date1904));
          break;
        // case Enums.ValueType.Hyperlink: // ??
        // case Enums.ValueType.Formula:
        default:
          throw new Error("I could not understand type of value");
      }
    }
    render(xmlStream2, model) {
      if (model.type === Enums.ValueType.Null && !model.styleId) {
        return;
      }
      xmlStream2.openNode("c");
      xmlStream2.addAttribute("r", model.address);
      if (model.styleId) {
        xmlStream2.addAttribute("s", model.styleId);
      }
      switch (model.type) {
        case Enums.ValueType.Null:
          break;
        case Enums.ValueType.Number:
          xmlStream2.leafNode("v", null, model.value);
          break;
        case Enums.ValueType.Boolean:
          xmlStream2.addAttribute("t", "b");
          xmlStream2.leafNode("v", null, model.value ? "1" : "0");
          break;
        case Enums.ValueType.Error:
          xmlStream2.addAttribute("t", "e");
          xmlStream2.leafNode("v", null, model.value.error);
          break;
        case Enums.ValueType.String:
        case Enums.ValueType.RichText:
          if (model.ssId !== void 0) {
            xmlStream2.addAttribute("t", "s");
            xmlStream2.leafNode("v", null, model.ssId);
          } else if (model.value && model.value.richText) {
            xmlStream2.addAttribute("t", "inlineStr");
            xmlStream2.openNode("is");
            model.value.richText.forEach((text) => {
              this.richTextXForm.render(xmlStream2, text);
            });
            xmlStream2.closeNode("is");
          } else {
            xmlStream2.addAttribute("t", "str");
            xmlStream2.leafNode("v", null, model.value);
          }
          break;
        case Enums.ValueType.Date:
          xmlStream2.leafNode("v", null, utils2.dateToExcel(model.value, model.date1904));
          break;
        case Enums.ValueType.Hyperlink:
          if (model.ssId !== void 0) {
            xmlStream2.addAttribute("t", "s");
            xmlStream2.leafNode("v", null, model.ssId);
          } else {
            xmlStream2.addAttribute("t", "str");
            xmlStream2.leafNode("v", null, model.text);
          }
          break;
        case Enums.ValueType.Formula:
          this.renderFormula(xmlStream2, model);
          break;
        case Enums.ValueType.Merge:
          break;
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "c":
          this.model = {
            address: node2.attributes.r
          };
          this.t = node2.attributes.t;
          if (node2.attributes.s) {
            this.model.styleId = parseInt(node2.attributes.s, 10);
          }
          return true;
        case "f":
          this.currentNode = "f";
          this.model.si = node2.attributes.si;
          this.model.shareType = node2.attributes.t;
          this.model.ref = node2.attributes.ref;
          return true;
        case "v":
          this.currentNode = "v";
          return true;
        case "t":
          this.currentNode = "t";
          return true;
        case "r":
          this.parser = this.richTextXForm;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
        return;
      }
      switch (this.currentNode) {
        case "f":
          this.model.formula = this.model.formula ? this.model.formula + text : text;
          break;
        case "v":
        case "t":
          if (this.model.value && this.model.value.richText) {
            this.model.value.richText.text = this.model.value.richText.text ? this.model.value.richText.text + text : text;
          } else {
            this.model.value = this.model.value ? this.model.value + text : text;
          }
          break;
      }
    }
    parseClose(name) {
      switch (name) {
        case "c": {
          const { model } = this;
          if (model.formula || model.shareType) {
            model.type = Enums.ValueType.Formula;
            if (model.value) {
              if (this.t === "str") {
                model.result = utils2.xmlDecode(model.value);
              } else if (this.t === "b") {
                model.result = parseInt(model.value, 10) !== 0;
              } else if (this.t === "e") {
                model.result = { error: model.value };
              } else {
                model.result = parseFloat(model.value);
              }
              model.value = void 0;
            }
          } else if (model.value !== void 0) {
            switch (this.t) {
              case "s":
                model.type = Enums.ValueType.String;
                model.value = parseInt(model.value, 10);
                break;
              case "str":
                model.type = Enums.ValueType.String;
                model.value = utils2.xmlDecode(model.value);
                break;
              case "inlineStr":
                model.type = Enums.ValueType.String;
                break;
              case "b":
                model.type = Enums.ValueType.Boolean;
                model.value = parseInt(model.value, 10) !== 0;
                break;
              case "e":
                model.type = Enums.ValueType.Error;
                model.value = { error: model.value };
                break;
              default:
                model.type = Enums.ValueType.Number;
                model.value = parseFloat(model.value);
                break;
            }
          } else if (model.styleId) {
            model.type = Enums.ValueType.Null;
          } else {
            model.type = Enums.ValueType.Merge;
          }
          return false;
        }
        case "f":
        case "v":
        case "is":
          this.currentNode = void 0;
          return true;
        case "t":
          if (this.parser) {
            this.parser.parseClose(name);
            return true;
          }
          this.currentNode = void 0;
          return true;
        case "r":
          this.model.value = this.model.value || {};
          this.model.value.richText = this.model.value.richText || [];
          this.model.value.richText.push(this.parser.model);
          this.parser = void 0;
          this.currentNode = void 0;
          return true;
        default:
          if (this.parser) {
            this.parser.parseClose(name);
            return true;
          }
          return false;
      }
    }
    reconcile(model, options) {
      const style = model.styleId && options.styles && options.styles.getStyleModel(model.styleId);
      if (style) {
        model.style = style;
      }
      if (model.styleId !== void 0) {
        model.styleId = void 0;
      }
      switch (model.type) {
        case Enums.ValueType.String:
          if (typeof model.value === "number") {
            if (options.sharedStrings) {
              model.value = options.sharedStrings.getString(model.value);
            }
          }
          if (model.value.richText) {
            model.type = Enums.ValueType.RichText;
          }
          break;
        case Enums.ValueType.Number:
          if (style && utils2.isDateFmt(style.numFmt)) {
            model.type = Enums.ValueType.Date;
            model.value = utils2.excelToDate(model.value, options.date1904);
          }
          break;
        case Enums.ValueType.Formula:
          if (model.result !== void 0 && style && utils2.isDateFmt(style.numFmt)) {
            model.result = utils2.excelToDate(model.result, options.date1904);
          }
          if (model.shareType === "shared") {
            if (model.ref) {
              options.formulae[model.si] = model.address;
            } else {
              model.sharedFormula = options.formulae[model.si];
              delete model.shareType;
            }
            delete model.si;
          }
          break;
      }
      const hyperlink = options.hyperlinkMap[model.address];
      if (hyperlink) {
        if (model.type === Enums.ValueType.Formula) {
          model.text = model.result;
          model.result = void 0;
        } else {
          model.text = model.value;
          model.value = void 0;
        }
        model.type = Enums.ValueType.Hyperlink;
        model.hyperlink = hyperlink;
      }
      const comment = options.commentsMap && options.commentsMap[model.address];
      if (comment) {
        model.comment = comment;
      }
    }
  }
  cellXform = CellXform;
  return cellXform;
}
var rowXform;
var hasRequiredRowXform;
function requireRowXform() {
  if (hasRequiredRowXform) return rowXform;
  hasRequiredRowXform = 1;
  const BaseXform = requireBaseXform();
  const utils2 = requireUtils();
  const CellXform = requireCellXform();
  class RowXform extends BaseXform {
    constructor(options) {
      super();
      this.maxItems = options && options.maxItems;
      this.map = {
        c: new CellXform()
      };
    }
    get tag() {
      return "row";
    }
    prepare(model, options) {
      const styleId = options.styles.addStyleModel(model.style);
      if (styleId) {
        model.styleId = styleId;
      }
      const cellXform2 = this.map.c;
      model.cells.forEach((cellModel) => {
        cellXform2.prepare(cellModel, options);
      });
    }
    render(xmlStream2, model, options) {
      xmlStream2.openNode("row");
      xmlStream2.addAttribute("r", model.number);
      if (model.height) {
        xmlStream2.addAttribute("ht", model.height);
        xmlStream2.addAttribute("customHeight", "1");
      }
      if (model.hidden) {
        xmlStream2.addAttribute("hidden", "1");
      }
      if (model.min > 0 && model.max > 0 && model.min <= model.max) {
        xmlStream2.addAttribute("spans", `${model.min}:${model.max}`);
      }
      if (model.styleId) {
        xmlStream2.addAttribute("s", model.styleId);
        xmlStream2.addAttribute("customFormat", "1");
      }
      xmlStream2.addAttribute("x14ac:dyDescent", "0.25");
      if (model.outlineLevel) {
        xmlStream2.addAttribute("outlineLevel", model.outlineLevel);
      }
      if (model.collapsed) {
        xmlStream2.addAttribute("collapsed", "1");
      }
      const cellXform2 = this.map.c;
      model.cells.forEach((cellModel) => {
        cellXform2.render(xmlStream2, cellModel, options);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (node2.name === "row") {
        this.numRowsSeen += 1;
        const spans = node2.attributes.spans ? node2.attributes.spans.split(":").map((span) => parseInt(span, 10)) : [void 0, void 0];
        const model = this.model = {
          number: parseInt(node2.attributes.r, 10),
          min: spans[0],
          max: spans[1],
          cells: []
        };
        if (node2.attributes.s) {
          model.styleId = parseInt(node2.attributes.s, 10);
        }
        if (utils2.parseBoolean(node2.attributes.hidden)) {
          model.hidden = true;
        }
        if (utils2.parseBoolean(node2.attributes.bestFit)) {
          model.bestFit = true;
        }
        if (node2.attributes.ht) {
          model.height = parseFloat(node2.attributes.ht);
        }
        if (node2.attributes.outlineLevel) {
          model.outlineLevel = parseInt(node2.attributes.outlineLevel, 10);
        }
        if (utils2.parseBoolean(node2.attributes.collapsed)) {
          model.collapsed = true;
        }
        return true;
      }
      this.parser = this.map[node2.name];
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      return false;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.cells.push(this.parser.model);
          if (this.maxItems && this.model.cells.length > this.maxItems) {
            throw new Error(`Max column count (${this.maxItems}) exceeded`);
          }
          this.parser = void 0;
        }
        return true;
      }
      return false;
    }
    reconcile(model, options) {
      model.style = model.styleId ? options.styles.getStyleModel(model.styleId) : {};
      if (model.styleId !== void 0) {
        model.styleId = void 0;
      }
      const cellXform2 = this.map.c;
      model.cells.forEach((cellModel) => {
        cellXform2.reconcile(cellModel, options);
      });
    }
  }
  rowXform = RowXform;
  return rowXform;
}
var colXform;
var hasRequiredColXform;
function requireColXform() {
  if (hasRequiredColXform) return colXform;
  hasRequiredColXform = 1;
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  class ColXform extends BaseXform {
    get tag() {
      return "col";
    }
    prepare(model, options) {
      const styleId = options.styles.addStyleModel(model.style || {});
      if (styleId) {
        model.styleId = styleId;
      }
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("col");
      xmlStream2.addAttribute("min", model.min);
      xmlStream2.addAttribute("max", model.max);
      if (model.width) {
        xmlStream2.addAttribute("width", model.width);
      }
      if (model.styleId) {
        xmlStream2.addAttribute("style", model.styleId);
      }
      if (model.hidden) {
        xmlStream2.addAttribute("hidden", "1");
      }
      if (model.bestFit) {
        xmlStream2.addAttribute("bestFit", "1");
      }
      if (model.outlineLevel) {
        xmlStream2.addAttribute("outlineLevel", model.outlineLevel);
      }
      if (model.collapsed) {
        xmlStream2.addAttribute("collapsed", "1");
      }
      xmlStream2.addAttribute("customWidth", "1");
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (node2.name === "col") {
        const model = this.model = {
          min: parseInt(node2.attributes.min || "0", 10),
          max: parseInt(node2.attributes.max || "0", 10),
          width: node2.attributes.width === void 0 ? void 0 : parseFloat(node2.attributes.width || "0")
        };
        if (node2.attributes.style) {
          model.styleId = parseInt(node2.attributes.style, 10);
        }
        if (utils2.parseBoolean(node2.attributes.hidden)) {
          model.hidden = true;
        }
        if (utils2.parseBoolean(node2.attributes.bestFit)) {
          model.bestFit = true;
        }
        if (node2.attributes.outlineLevel) {
          model.outlineLevel = parseInt(node2.attributes.outlineLevel, 10);
        }
        if (utils2.parseBoolean(node2.attributes.collapsed)) {
          model.collapsed = true;
        }
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
    reconcile(model, options) {
      if (model.styleId) {
        model.style = options.styles.getStyleModel(model.styleId);
      }
    }
  }
  colXform = ColXform;
  return colXform;
}
var dimensionXform;
var hasRequiredDimensionXform;
function requireDimensionXform() {
  if (hasRequiredDimensionXform) return dimensionXform;
  hasRequiredDimensionXform = 1;
  const BaseXform = requireBaseXform();
  class DimensionXform extends BaseXform {
    get tag() {
      return "dimension";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.leafNode("dimension", { ref: model });
      }
    }
    parseOpen(node2) {
      if (node2.name === "dimension") {
        this.model = node2.attributes.ref;
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  dimensionXform = DimensionXform;
  return dimensionXform;
}
var hyperlinkXform;
var hasRequiredHyperlinkXform;
function requireHyperlinkXform() {
  if (hasRequiredHyperlinkXform) return hyperlinkXform;
  hasRequiredHyperlinkXform = 1;
  const BaseXform = requireBaseXform();
  class HyperlinkXform extends BaseXform {
    get tag() {
      return "hyperlink";
    }
    render(xmlStream2, model) {
      if (this.isInternalLink(model)) {
        xmlStream2.leafNode("hyperlink", {
          ref: model.address,
          "r:id": model.rId,
          tooltip: model.tooltip,
          location: model.target
        });
      } else {
        xmlStream2.leafNode("hyperlink", {
          ref: model.address,
          "r:id": model.rId,
          tooltip: model.tooltip
        });
      }
    }
    parseOpen(node2) {
      if (node2.name === "hyperlink") {
        this.model = {
          address: node2.attributes.ref,
          rId: node2.attributes["r:id"],
          tooltip: node2.attributes.tooltip
        };
        if (node2.attributes.location) {
          this.model.target = node2.attributes.location;
        }
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
    isInternalLink(model) {
      return model.target && /^[^!]+![a-zA-Z]+[\d]+$/.test(model.target);
    }
  }
  hyperlinkXform = HyperlinkXform;
  return hyperlinkXform;
}
var mergeCellXform;
var hasRequiredMergeCellXform;
function requireMergeCellXform() {
  if (hasRequiredMergeCellXform) return mergeCellXform;
  hasRequiredMergeCellXform = 1;
  const BaseXform = requireBaseXform();
  class MergeCellXform extends BaseXform {
    get tag() {
      return "mergeCell";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode("mergeCell", { ref: model });
    }
    parseOpen(node2) {
      if (node2.name === "mergeCell") {
        this.model = node2.attributes.ref;
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  mergeCellXform = MergeCellXform;
  return mergeCellXform;
}
var dataValidationsXform;
var hasRequiredDataValidationsXform;
function requireDataValidationsXform() {
  if (hasRequiredDataValidationsXform) return dataValidationsXform;
  hasRequiredDataValidationsXform = 1;
  const _2 = requireUnderDash();
  const utils2 = requireUtils();
  const colCache = requireColCache();
  const BaseXform = requireBaseXform();
  const Range = requireRange();
  function assign(definedName, attributes, name, defaultValue) {
    const value = attributes[name];
    if (value !== void 0) {
      definedName[name] = value;
    } else if (defaultValue !== void 0) {
      definedName[name] = defaultValue;
    }
  }
  function assignBool(definedName, attributes, name, defaultValue) {
    const value = attributes[name];
    if (value !== void 0) {
      definedName[name] = utils2.parseBoolean(value);
    }
  }
  function optimiseDataValidations(model) {
    const dvList = _2.map(model, (dataValidation, address) => ({
      address,
      dataValidation,
      marked: false
    })).sort((a, b) => _2.strcmp(a.address, b.address));
    const dvMap = _2.keyBy(dvList, "address");
    const matchCol = (addr, height, col) => {
      for (let i = 0; i < height; i++) {
        const otherAddress = colCache.encodeAddress(addr.row + i, col);
        if (!model[otherAddress] || !_2.isEqual(model[addr.address], model[otherAddress])) {
          return false;
        }
      }
      return true;
    };
    return dvList.map((dv) => {
      if (!dv.marked) {
        const addr = colCache.decodeEx(dv.address);
        if (addr.dimensions) {
          dvMap[addr.dimensions].marked = true;
          return {
            ...dv.dataValidation,
            sqref: dv.address
          };
        }
        let height = 1;
        let otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
        while (model[otherAddress] && _2.isEqual(dv.dataValidation, model[otherAddress])) {
          height++;
          otherAddress = colCache.encodeAddress(addr.row + height, addr.col);
        }
        let width = 1;
        while (matchCol(addr, height, addr.col + width)) {
          width++;
        }
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            otherAddress = colCache.encodeAddress(addr.row + i, addr.col + j);
            dvMap[otherAddress].marked = true;
          }
        }
        if (height > 1 || width > 1) {
          const bottom = addr.row + (height - 1);
          const right = addr.col + (width - 1);
          return {
            ...dv.dataValidation,
            sqref: `${dv.address}:${colCache.encodeAddress(bottom, right)}`
          };
        }
        return {
          ...dv.dataValidation,
          sqref: dv.address
        };
      }
      return null;
    }).filter(Boolean);
  }
  class DataValidationsXform extends BaseXform {
    get tag() {
      return "dataValidations";
    }
    render(xmlStream2, model) {
      const optimizedModel = optimiseDataValidations(model);
      if (optimizedModel.length) {
        xmlStream2.openNode("dataValidations", { count: optimizedModel.length });
        optimizedModel.forEach((value) => {
          xmlStream2.openNode("dataValidation");
          if (value.type !== "any") {
            xmlStream2.addAttribute("type", value.type);
            if (value.operator && value.type !== "list" && value.operator !== "between") {
              xmlStream2.addAttribute("operator", value.operator);
            }
            if (value.allowBlank) {
              xmlStream2.addAttribute("allowBlank", "1");
            }
          }
          if (value.showInputMessage) {
            xmlStream2.addAttribute("showInputMessage", "1");
          }
          if (value.promptTitle) {
            xmlStream2.addAttribute("promptTitle", value.promptTitle);
          }
          if (value.prompt) {
            xmlStream2.addAttribute("prompt", value.prompt);
          }
          if (value.showErrorMessage) {
            xmlStream2.addAttribute("showErrorMessage", "1");
          }
          if (value.errorStyle) {
            xmlStream2.addAttribute("errorStyle", value.errorStyle);
          }
          if (value.errorTitle) {
            xmlStream2.addAttribute("errorTitle", value.errorTitle);
          }
          if (value.error) {
            xmlStream2.addAttribute("error", value.error);
          }
          xmlStream2.addAttribute("sqref", value.sqref);
          (value.formulae || []).forEach((formula, index2) => {
            xmlStream2.openNode(`formula${index2 + 1}`);
            if (value.type === "date") {
              xmlStream2.writeText(utils2.dateToExcel(new Date(formula)));
            } else {
              xmlStream2.writeText(formula);
            }
            xmlStream2.closeNode();
          });
          xmlStream2.closeNode();
        });
        xmlStream2.closeNode();
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "dataValidations":
          this.model = {};
          return true;
        case "dataValidation": {
          this._address = node2.attributes.sqref;
          const dataValidation = { type: node2.attributes.type || "any", formulae: [] };
          if (node2.attributes.type) {
            assignBool(dataValidation, node2.attributes, "allowBlank");
          }
          assignBool(dataValidation, node2.attributes, "showInputMessage");
          assignBool(dataValidation, node2.attributes, "showErrorMessage");
          switch (dataValidation.type) {
            case "any":
            case "list":
            case "custom":
              break;
            default:
              assign(dataValidation, node2.attributes, "operator", "between");
              break;
          }
          assign(dataValidation, node2.attributes, "promptTitle");
          assign(dataValidation, node2.attributes, "prompt");
          assign(dataValidation, node2.attributes, "errorStyle");
          assign(dataValidation, node2.attributes, "errorTitle");
          assign(dataValidation, node2.attributes, "error");
          this._dataValidation = dataValidation;
          return true;
        }
        case "formula1":
        case "formula2":
          this._formula = [];
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this._formula) {
        this._formula.push(text);
      }
    }
    parseClose(name) {
      switch (name) {
        case "dataValidations":
          return false;
        case "dataValidation": {
          if (!this._dataValidation.formulae || !this._dataValidation.formulae.length) {
            delete this._dataValidation.formulae;
            delete this._dataValidation.operator;
          }
          const list = this._address.split(/\s+/g) || [];
          list.forEach((addr) => {
            if (addr.includes(":")) {
              const range2 = new Range(addr);
              range2.forEachAddress((address) => {
                this.model[address] = this._dataValidation;
              });
            } else {
              this.model[addr] = this._dataValidation;
            }
          });
          return true;
        }
        case "formula1":
        case "formula2": {
          let formula = this._formula.join("");
          switch (this._dataValidation.type) {
            case "whole":
            case "textLength":
              formula = parseInt(formula, 10);
              break;
            case "decimal":
              formula = parseFloat(formula);
              break;
            case "date":
              formula = utils2.excelToDate(parseFloat(formula));
              break;
          }
          this._dataValidation.formulae.push(formula);
          this._formula = void 0;
          return true;
        }
        default:
          return true;
      }
    }
  }
  dataValidationsXform = DataValidationsXform;
  return dataValidationsXform;
}
var pageSetupPropertiesXform;
var hasRequiredPageSetupPropertiesXform;
function requirePageSetupPropertiesXform() {
  if (hasRequiredPageSetupPropertiesXform) return pageSetupPropertiesXform;
  hasRequiredPageSetupPropertiesXform = 1;
  const BaseXform = requireBaseXform();
  class PageSetupPropertiesXform extends BaseXform {
    get tag() {
      return "pageSetUpPr";
    }
    render(xmlStream2, model) {
      if (model && model.fitToPage) {
        xmlStream2.leafNode(this.tag, {
          fitToPage: model.fitToPage ? "1" : void 0
        });
        return true;
      }
      return false;
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = {
          fitToPage: node2.attributes.fitToPage === "1"
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  pageSetupPropertiesXform = PageSetupPropertiesXform;
  return pageSetupPropertiesXform;
}
var outlinePropertiesXform;
var hasRequiredOutlinePropertiesXform;
function requireOutlinePropertiesXform() {
  if (hasRequiredOutlinePropertiesXform) return outlinePropertiesXform;
  hasRequiredOutlinePropertiesXform = 1;
  const BaseXform = requireBaseXform();
  const isDefined = (attr) => typeof attr !== "undefined";
  class OutlinePropertiesXform extends BaseXform {
    get tag() {
      return "outlinePr";
    }
    render(xmlStream2, model) {
      if (model && (isDefined(model.summaryBelow) || isDefined(model.summaryRight))) {
        xmlStream2.leafNode(this.tag, {
          summaryBelow: isDefined(model.summaryBelow) ? Number(model.summaryBelow) : void 0,
          summaryRight: isDefined(model.summaryRight) ? Number(model.summaryRight) : void 0
        });
        return true;
      }
      return false;
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = {
          summaryBelow: isDefined(node2.attributes.summaryBelow) ? Boolean(Number(node2.attributes.summaryBelow)) : void 0,
          summaryRight: isDefined(node2.attributes.summaryRight) ? Boolean(Number(node2.attributes.summaryRight)) : void 0
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  outlinePropertiesXform = OutlinePropertiesXform;
  return outlinePropertiesXform;
}
var sheetPropertiesXform;
var hasRequiredSheetPropertiesXform;
function requireSheetPropertiesXform() {
  if (hasRequiredSheetPropertiesXform) return sheetPropertiesXform;
  hasRequiredSheetPropertiesXform = 1;
  const BaseXform = requireBaseXform();
  const ColorXform = requireColorXform();
  const PageSetupPropertiesXform = requirePageSetupPropertiesXform();
  const OutlinePropertiesXform = requireOutlinePropertiesXform();
  class SheetPropertiesXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        tabColor: new ColorXform("tabColor"),
        pageSetUpPr: new PageSetupPropertiesXform(),
        outlinePr: new OutlinePropertiesXform()
      };
    }
    get tag() {
      return "sheetPr";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.addRollback();
        xmlStream2.openNode("sheetPr");
        let inner = false;
        inner = this.map.tabColor.render(xmlStream2, model.tabColor) || inner;
        inner = this.map.pageSetUpPr.render(xmlStream2, model.pageSetup) || inner;
        inner = this.map.outlinePr.render(xmlStream2, model.outlineProperties) || inner;
        if (inner) {
          xmlStream2.closeNode();
          xmlStream2.commit();
        } else {
          xmlStream2.rollback();
        }
      }
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (node2.name === this.tag) {
        this.reset();
        return true;
      }
      if (this.map[node2.name]) {
        this.parser = this.map[node2.name];
        this.parser.parseOpen(node2);
        return true;
      }
      return false;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
        return true;
      }
      return false;
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      if (this.map.tabColor.model || this.map.pageSetUpPr.model || this.map.outlinePr.model) {
        this.model = {};
        if (this.map.tabColor.model) {
          this.model.tabColor = this.map.tabColor.model;
        }
        if (this.map.pageSetUpPr.model) {
          this.model.pageSetup = this.map.pageSetUpPr.model;
        }
        if (this.map.outlinePr.model) {
          this.model.outlineProperties = this.map.outlinePr.model;
        }
      } else {
        this.model = null;
      }
      return false;
    }
  }
  sheetPropertiesXform = SheetPropertiesXform;
  return sheetPropertiesXform;
}
var sheetFormatPropertiesXform;
var hasRequiredSheetFormatPropertiesXform;
function requireSheetFormatPropertiesXform() {
  if (hasRequiredSheetFormatPropertiesXform) return sheetFormatPropertiesXform;
  hasRequiredSheetFormatPropertiesXform = 1;
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  class SheetFormatPropertiesXform extends BaseXform {
    get tag() {
      return "sheetFormatPr";
    }
    render(xmlStream2, model) {
      if (model) {
        const attributes = {
          defaultRowHeight: model.defaultRowHeight,
          outlineLevelRow: model.outlineLevelRow,
          outlineLevelCol: model.outlineLevelCol,
          "x14ac:dyDescent": model.dyDescent
        };
        if (model.defaultColWidth) {
          attributes.defaultColWidth = model.defaultColWidth;
        }
        if (!model.defaultRowHeight || model.defaultRowHeight !== 15) {
          attributes.customHeight = "1";
        }
        if (_2.some(attributes, (value) => value !== void 0)) {
          xmlStream2.leafNode("sheetFormatPr", attributes);
        }
      }
    }
    parseOpen(node2) {
      if (node2.name === "sheetFormatPr") {
        this.model = {
          defaultRowHeight: parseFloat(node2.attributes.defaultRowHeight || "0"),
          dyDescent: parseFloat(node2.attributes["x14ac:dyDescent"] || "0"),
          outlineLevelRow: parseInt(node2.attributes.outlineLevelRow || "0", 10),
          outlineLevelCol: parseInt(node2.attributes.outlineLevelCol || "0", 10)
        };
        if (node2.attributes.defaultColWidth) {
          this.model.defaultColWidth = parseFloat(node2.attributes.defaultColWidth);
        }
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  sheetFormatPropertiesXform = SheetFormatPropertiesXform;
  return sheetFormatPropertiesXform;
}
var sheetViewXform;
var hasRequiredSheetViewXform;
function requireSheetViewXform() {
  if (hasRequiredSheetViewXform) return sheetViewXform;
  hasRequiredSheetViewXform = 1;
  const colCache = requireColCache();
  const BaseXform = requireBaseXform();
  const VIEW_STATES = {
    frozen: "frozen",
    frozenSplit: "frozen",
    split: "split"
  };
  class SheetViewXform extends BaseXform {
    get tag() {
      return "sheetView";
    }
    prepare(model) {
      switch (model.state) {
        case "frozen":
        case "split":
          break;
        default:
          model.state = "normal";
          break;
      }
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("sheetView", {
        workbookViewId: model.workbookViewId || 0
      });
      const add = function(name, value, included) {
        if (included) {
          xmlStream2.addAttribute(name, value);
        }
      };
      add("rightToLeft", "1", model.rightToLeft === true);
      add("tabSelected", "1", model.tabSelected);
      add("showRuler", "0", model.showRuler === false);
      add("showRowColHeaders", "0", model.showRowColHeaders === false);
      add("showGridLines", "0", model.showGridLines === false);
      add("zoomScale", model.zoomScale, model.zoomScale);
      add("zoomScaleNormal", model.zoomScaleNormal, model.zoomScaleNormal);
      add("view", model.style, model.style);
      let topLeftCell;
      let xSplit;
      let ySplit;
      let activePane;
      switch (model.state) {
        case "frozen":
          xSplit = model.xSplit || 0;
          ySplit = model.ySplit || 0;
          topLeftCell = model.topLeftCell || colCache.getAddress(ySplit + 1, xSplit + 1).address;
          activePane = model.xSplit && model.ySplit && "bottomRight" || model.xSplit && "topRight" || "bottomLeft";
          xmlStream2.leafNode("pane", {
            xSplit: model.xSplit || void 0,
            ySplit: model.ySplit || void 0,
            topLeftCell,
            activePane,
            state: "frozen"
          });
          xmlStream2.leafNode("selection", {
            pane: activePane,
            activeCell: model.activeCell,
            sqref: model.activeCell
          });
          break;
        case "split":
          if (model.activePane === "topLeft") {
            model.activePane = void 0;
          }
          xmlStream2.leafNode("pane", {
            xSplit: model.xSplit || void 0,
            ySplit: model.ySplit || void 0,
            topLeftCell: model.topLeftCell,
            activePane: model.activePane
          });
          xmlStream2.leafNode("selection", {
            pane: model.activePane,
            activeCell: model.activeCell,
            sqref: model.activeCell
          });
          break;
        case "normal":
          if (model.activeCell) {
            xmlStream2.leafNode("selection", {
              activeCell: model.activeCell,
              sqref: model.activeCell
            });
          }
          break;
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "sheetView":
          this.sheetView = {
            workbookViewId: parseInt(node2.attributes.workbookViewId, 10),
            rightToLeft: node2.attributes.rightToLeft === "1",
            tabSelected: node2.attributes.tabSelected === "1",
            showRuler: !(node2.attributes.showRuler === "0"),
            showRowColHeaders: !(node2.attributes.showRowColHeaders === "0"),
            showGridLines: !(node2.attributes.showGridLines === "0"),
            zoomScale: parseInt(node2.attributes.zoomScale || "100", 10),
            zoomScaleNormal: parseInt(node2.attributes.zoomScaleNormal || "100", 10),
            style: node2.attributes.view
          };
          this.pane = void 0;
          this.selections = {};
          return true;
        case "pane":
          this.pane = {
            xSplit: parseInt(node2.attributes.xSplit || "0", 10),
            ySplit: parseInt(node2.attributes.ySplit || "0", 10),
            topLeftCell: node2.attributes.topLeftCell,
            activePane: node2.attributes.activePane || "topLeft",
            state: node2.attributes.state
          };
          return true;
        case "selection": {
          const name = node2.attributes.pane || "topLeft";
          this.selections[name] = {
            pane: name,
            activeCell: node2.attributes.activeCell
          };
          return true;
        }
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose(name) {
      let model;
      let selection;
      switch (name) {
        case "sheetView":
          if (this.sheetView && this.pane) {
            model = this.model = {
              workbookViewId: this.sheetView.workbookViewId,
              rightToLeft: this.sheetView.rightToLeft,
              state: VIEW_STATES[this.pane.state] || "split",
              // split is default
              xSplit: this.pane.xSplit,
              ySplit: this.pane.ySplit,
              topLeftCell: this.pane.topLeftCell,
              showRuler: this.sheetView.showRuler,
              showRowColHeaders: this.sheetView.showRowColHeaders,
              showGridLines: this.sheetView.showGridLines,
              zoomScale: this.sheetView.zoomScale,
              zoomScaleNormal: this.sheetView.zoomScaleNormal
            };
            if (this.model.state === "split") {
              model.activePane = this.pane.activePane;
            }
            selection = this.selections[this.pane.activePane];
            if (selection && selection.activeCell) {
              model.activeCell = selection.activeCell;
            }
            if (this.sheetView.style) {
              model.style = this.sheetView.style;
            }
          } else {
            model = this.model = {
              workbookViewId: this.sheetView.workbookViewId,
              rightToLeft: this.sheetView.rightToLeft,
              state: "normal",
              showRuler: this.sheetView.showRuler,
              showRowColHeaders: this.sheetView.showRowColHeaders,
              showGridLines: this.sheetView.showGridLines,
              zoomScale: this.sheetView.zoomScale,
              zoomScaleNormal: this.sheetView.zoomScaleNormal
            };
            selection = this.selections.topLeft;
            if (selection && selection.activeCell) {
              model.activeCell = selection.activeCell;
            }
            if (this.sheetView.style) {
              model.style = this.sheetView.style;
            }
          }
          return false;
        default:
          return true;
      }
    }
    reconcile() {
    }
  }
  sheetViewXform = SheetViewXform;
  return sheetViewXform;
}
var sheetProtectionXform;
var hasRequiredSheetProtectionXform;
function requireSheetProtectionXform() {
  if (hasRequiredSheetProtectionXform) return sheetProtectionXform;
  hasRequiredSheetProtectionXform = 1;
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  function booleanToXml(model, value) {
    return model ? value : void 0;
  }
  function xmlToBoolean(value, equals) {
    return value === equals ? true : void 0;
  }
  class SheetProtectionXform extends BaseXform {
    get tag() {
      return "sheetProtection";
    }
    render(xmlStream2, model) {
      if (model) {
        const attributes = {
          sheet: booleanToXml(model.sheet, "1"),
          selectLockedCells: model.selectLockedCells === false ? "1" : void 0,
          selectUnlockedCells: model.selectUnlockedCells === false ? "1" : void 0,
          formatCells: booleanToXml(model.formatCells, "0"),
          formatColumns: booleanToXml(model.formatColumns, "0"),
          formatRows: booleanToXml(model.formatRows, "0"),
          insertColumns: booleanToXml(model.insertColumns, "0"),
          insertRows: booleanToXml(model.insertRows, "0"),
          insertHyperlinks: booleanToXml(model.insertHyperlinks, "0"),
          deleteColumns: booleanToXml(model.deleteColumns, "0"),
          deleteRows: booleanToXml(model.deleteRows, "0"),
          sort: booleanToXml(model.sort, "0"),
          autoFilter: booleanToXml(model.autoFilter, "0"),
          pivotTables: booleanToXml(model.pivotTables, "0")
        };
        if (model.sheet) {
          attributes.algorithmName = model.algorithmName;
          attributes.hashValue = model.hashValue;
          attributes.saltValue = model.saltValue;
          attributes.spinCount = model.spinCount;
          attributes.objects = booleanToXml(model.objects === false, "1");
          attributes.scenarios = booleanToXml(model.scenarios === false, "1");
        }
        if (_2.some(attributes, (value) => value !== void 0)) {
          xmlStream2.leafNode(this.tag, attributes);
        }
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            sheet: xmlToBoolean(node2.attributes.sheet, "1"),
            objects: node2.attributes.objects === "1" ? false : void 0,
            scenarios: node2.attributes.scenarios === "1" ? false : void 0,
            selectLockedCells: node2.attributes.selectLockedCells === "1" ? false : void 0,
            selectUnlockedCells: node2.attributes.selectUnlockedCells === "1" ? false : void 0,
            formatCells: xmlToBoolean(node2.attributes.formatCells, "0"),
            formatColumns: xmlToBoolean(node2.attributes.formatColumns, "0"),
            formatRows: xmlToBoolean(node2.attributes.formatRows, "0"),
            insertColumns: xmlToBoolean(node2.attributes.insertColumns, "0"),
            insertRows: xmlToBoolean(node2.attributes.insertRows, "0"),
            insertHyperlinks: xmlToBoolean(node2.attributes.insertHyperlinks, "0"),
            deleteColumns: xmlToBoolean(node2.attributes.deleteColumns, "0"),
            deleteRows: xmlToBoolean(node2.attributes.deleteRows, "0"),
            sort: xmlToBoolean(node2.attributes.sort, "0"),
            autoFilter: xmlToBoolean(node2.attributes.autoFilter, "0"),
            pivotTables: xmlToBoolean(node2.attributes.pivotTables, "0")
          };
          if (node2.attributes.algorithmName) {
            this.model.algorithmName = node2.attributes.algorithmName;
            this.model.hashValue = node2.attributes.hashValue;
            this.model.saltValue = node2.attributes.saltValue;
            this.model.spinCount = parseInt(node2.attributes.spinCount, 10);
          }
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  sheetProtectionXform = SheetProtectionXform;
  return sheetProtectionXform;
}
var pageMarginsXform;
var hasRequiredPageMarginsXform;
function requirePageMarginsXform() {
  if (hasRequiredPageMarginsXform) return pageMarginsXform;
  hasRequiredPageMarginsXform = 1;
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  class PageMarginsXform extends BaseXform {
    get tag() {
      return "pageMargins";
    }
    render(xmlStream2, model) {
      if (model) {
        const attributes = {
          left: model.left,
          right: model.right,
          top: model.top,
          bottom: model.bottom,
          header: model.header,
          footer: model.footer
        };
        if (_2.some(attributes, (value) => value !== void 0)) {
          xmlStream2.leafNode(this.tag, attributes);
        }
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            left: parseFloat(node2.attributes.left || 0.7),
            right: parseFloat(node2.attributes.right || 0.7),
            top: parseFloat(node2.attributes.top || 0.75),
            bottom: parseFloat(node2.attributes.bottom || 0.75),
            header: parseFloat(node2.attributes.header || 0.3),
            footer: parseFloat(node2.attributes.footer || 0.3)
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  pageMarginsXform = PageMarginsXform;
  return pageMarginsXform;
}
var pageSetupXform;
var hasRequiredPageSetupXform;
function requirePageSetupXform() {
  if (hasRequiredPageSetupXform) return pageSetupXform;
  hasRequiredPageSetupXform = 1;
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  function booleanToXml(model) {
    return model ? "1" : void 0;
  }
  function pageOrderToXml(model) {
    switch (model) {
      case "overThenDown":
        return model;
      default:
        return void 0;
    }
  }
  function cellCommentsToXml(model) {
    switch (model) {
      case "atEnd":
      case "asDisplyed":
        return model;
      default:
        return void 0;
    }
  }
  function errorsToXml(model) {
    switch (model) {
      case "dash":
      case "blank":
      case "NA":
        return model;
      default:
        return void 0;
    }
  }
  function pageSizeToModel(value) {
    return value !== void 0 ? parseInt(value, 10) : void 0;
  }
  class PageSetupXform extends BaseXform {
    get tag() {
      return "pageSetup";
    }
    render(xmlStream2, model) {
      if (model) {
        const attributes = {
          paperSize: model.paperSize,
          orientation: model.orientation,
          horizontalDpi: model.horizontalDpi,
          verticalDpi: model.verticalDpi,
          pageOrder: pageOrderToXml(model.pageOrder),
          blackAndWhite: booleanToXml(model.blackAndWhite),
          draft: booleanToXml(model.draft),
          cellComments: cellCommentsToXml(model.cellComments),
          errors: errorsToXml(model.errors),
          scale: model.scale,
          fitToWidth: model.fitToWidth,
          fitToHeight: model.fitToHeight,
          firstPageNumber: model.firstPageNumber,
          useFirstPageNumber: booleanToXml(model.firstPageNumber),
          usePrinterDefaults: booleanToXml(model.usePrinterDefaults),
          copies: model.copies
        };
        if (_2.some(attributes, (value) => value !== void 0)) {
          xmlStream2.leafNode(this.tag, attributes);
        }
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            paperSize: pageSizeToModel(node2.attributes.paperSize),
            orientation: node2.attributes.orientation || "portrait",
            horizontalDpi: parseInt(node2.attributes.horizontalDpi || "4294967295", 10),
            verticalDpi: parseInt(node2.attributes.verticalDpi || "4294967295", 10),
            pageOrder: node2.attributes.pageOrder || "downThenOver",
            blackAndWhite: node2.attributes.blackAndWhite === "1",
            draft: node2.attributes.draft === "1",
            cellComments: node2.attributes.cellComments || "None",
            errors: node2.attributes.errors || "displayed",
            scale: parseInt(node2.attributes.scale || "100", 10),
            fitToWidth: parseInt(node2.attributes.fitToWidth || "1", 10),
            fitToHeight: parseInt(node2.attributes.fitToHeight || "1", 10),
            firstPageNumber: parseInt(node2.attributes.firstPageNumber || "1", 10),
            useFirstPageNumber: node2.attributes.useFirstPageNumber === "1",
            usePrinterDefaults: node2.attributes.usePrinterDefaults === "1",
            copies: parseInt(node2.attributes.copies || "1", 10)
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  pageSetupXform = PageSetupXform;
  return pageSetupXform;
}
var printOptionsXform;
var hasRequiredPrintOptionsXform;
function requirePrintOptionsXform() {
  if (hasRequiredPrintOptionsXform) return printOptionsXform;
  hasRequiredPrintOptionsXform = 1;
  const _2 = requireUnderDash();
  const BaseXform = requireBaseXform();
  function booleanToXml(model) {
    return model ? "1" : void 0;
  }
  class PrintOptionsXform extends BaseXform {
    get tag() {
      return "printOptions";
    }
    render(xmlStream2, model) {
      if (model) {
        const attributes = {
          headings: booleanToXml(model.showRowColHeaders),
          gridLines: booleanToXml(model.showGridLines),
          horizontalCentered: booleanToXml(model.horizontalCentered),
          verticalCentered: booleanToXml(model.verticalCentered)
        };
        if (_2.some(attributes, (value) => value !== void 0)) {
          xmlStream2.leafNode(this.tag, attributes);
        }
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            showRowColHeaders: node2.attributes.headings === "1",
            showGridLines: node2.attributes.gridLines === "1",
            horizontalCentered: node2.attributes.horizontalCentered === "1",
            verticalCentered: node2.attributes.verticalCentered === "1"
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  printOptionsXform = PrintOptionsXform;
  return printOptionsXform;
}
var autoFilterXform$1;
var hasRequiredAutoFilterXform$1;
function requireAutoFilterXform$1() {
  if (hasRequiredAutoFilterXform$1) return autoFilterXform$1;
  hasRequiredAutoFilterXform$1 = 1;
  const colCache = requireColCache();
  const BaseXform = requireBaseXform();
  class AutoFilterXform extends BaseXform {
    get tag() {
      return "autoFilter";
    }
    render(xmlStream2, model) {
      if (model) {
        if (typeof model === "string") {
          xmlStream2.leafNode("autoFilter", { ref: model });
        } else {
          const getAddress = function(addr) {
            if (typeof addr === "string") {
              return addr;
            }
            return colCache.getAddress(addr.row, addr.column).address;
          };
          const firstAddress = getAddress(model.from);
          const secondAddress = getAddress(model.to);
          if (firstAddress && secondAddress) {
            xmlStream2.leafNode("autoFilter", { ref: `${firstAddress}:${secondAddress}` });
          }
        }
      }
    }
    parseOpen(node2) {
      if (node2.name === "autoFilter") {
        this.model = node2.attributes.ref;
      }
    }
  }
  autoFilterXform$1 = AutoFilterXform;
  return autoFilterXform$1;
}
var pictureXform;
var hasRequiredPictureXform;
function requirePictureXform() {
  if (hasRequiredPictureXform) return pictureXform;
  hasRequiredPictureXform = 1;
  const BaseXform = requireBaseXform();
  class PictureXform extends BaseXform {
    get tag() {
      return "picture";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.leafNode(this.tag, { "r:id": model.rId });
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            rId: node2.attributes["r:id"]
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  pictureXform = PictureXform;
  return pictureXform;
}
var drawingXform$1;
var hasRequiredDrawingXform$1;
function requireDrawingXform$1() {
  if (hasRequiredDrawingXform$1) return drawingXform$1;
  hasRequiredDrawingXform$1 = 1;
  const BaseXform = requireBaseXform();
  class DrawingXform extends BaseXform {
    get tag() {
      return "drawing";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.leafNode(this.tag, { "r:id": model.rId });
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            rId: node2.attributes["r:id"]
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  drawingXform$1 = DrawingXform;
  return drawingXform$1;
}
var tablePartXform;
var hasRequiredTablePartXform;
function requireTablePartXform() {
  if (hasRequiredTablePartXform) return tablePartXform;
  hasRequiredTablePartXform = 1;
  const BaseXform = requireBaseXform();
  class TablePartXform extends BaseXform {
    get tag() {
      return "tablePart";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.leafNode(this.tag, { "r:id": model.rId });
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            rId: node2.attributes["r:id"]
          };
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  tablePartXform = TablePartXform;
  return tablePartXform;
}
var pageBreaksXform;
var hasRequiredPageBreaksXform;
function requirePageBreaksXform() {
  if (hasRequiredPageBreaksXform) return pageBreaksXform;
  hasRequiredPageBreaksXform = 1;
  const BaseXform = requireBaseXform();
  class PageBreaksXform extends BaseXform {
    get tag() {
      return "brk";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode("brk", model);
    }
    parseOpen(node2) {
      if (node2.name === "brk") {
        this.model = node2.attributes.ref;
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  pageBreaksXform = PageBreaksXform;
  return pageBreaksXform;
}
var rowBreaksXform;
var hasRequiredRowBreaksXform;
function requireRowBreaksXform() {
  if (hasRequiredRowBreaksXform) return rowBreaksXform;
  hasRequiredRowBreaksXform = 1;
  const PageBreaksXform = requirePageBreaksXform();
  const ListXform = requireListXform();
  class RowBreaksXform extends ListXform {
    constructor() {
      const options = {
        tag: "rowBreaks",
        count: true,
        childXform: new PageBreaksXform()
      };
      super(options);
    }
    // get tag() { return 'rowBreaks'; }
    render(xmlStream2, model) {
      if (model && model.length) {
        xmlStream2.openNode(this.tag, this.$);
        if (this.count) {
          xmlStream2.addAttribute(this.$count, model.length);
          xmlStream2.addAttribute("manualBreakCount", model.length);
        }
        const { childXform } = this;
        model.forEach((childModel) => {
          childXform.render(xmlStream2, childModel);
        });
        xmlStream2.closeNode();
      } else if (this.empty) {
        xmlStream2.leafNode(this.tag);
      }
    }
  }
  rowBreaksXform = RowBreaksXform;
  return rowBreaksXform;
}
var headerFooterXform;
var hasRequiredHeaderFooterXform;
function requireHeaderFooterXform() {
  if (hasRequiredHeaderFooterXform) return headerFooterXform;
  hasRequiredHeaderFooterXform = 1;
  const BaseXform = requireBaseXform();
  class HeaderFooterXform extends BaseXform {
    get tag() {
      return "headerFooter";
    }
    render(xmlStream2, model) {
      if (model) {
        xmlStream2.addRollback();
        let createTag = false;
        xmlStream2.openNode("headerFooter");
        if (model.differentFirst) {
          xmlStream2.addAttribute("differentFirst", "1");
          createTag = true;
        }
        if (model.differentOddEven) {
          xmlStream2.addAttribute("differentOddEven", "1");
          createTag = true;
        }
        if (model.oddHeader && typeof model.oddHeader === "string") {
          xmlStream2.leafNode("oddHeader", null, model.oddHeader);
          createTag = true;
        }
        if (model.oddFooter && typeof model.oddFooter === "string") {
          xmlStream2.leafNode("oddFooter", null, model.oddFooter);
          createTag = true;
        }
        if (model.evenHeader && typeof model.evenHeader === "string") {
          xmlStream2.leafNode("evenHeader", null, model.evenHeader);
          createTag = true;
        }
        if (model.evenFooter && typeof model.evenFooter === "string") {
          xmlStream2.leafNode("evenFooter", null, model.evenFooter);
          createTag = true;
        }
        if (model.firstHeader && typeof model.firstHeader === "string") {
          xmlStream2.leafNode("firstHeader", null, model.firstHeader);
          createTag = true;
        }
        if (model.firstFooter && typeof model.firstFooter === "string") {
          xmlStream2.leafNode("firstFooter", null, model.firstFooter);
          createTag = true;
        }
        if (createTag) {
          xmlStream2.closeNode();
          xmlStream2.commit();
        } else {
          xmlStream2.rollback();
        }
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case "headerFooter":
          this.model = {};
          if (node2.attributes.differentFirst) {
            this.model.differentFirst = parseInt(node2.attributes.differentFirst, 0) === 1;
          }
          if (node2.attributes.differentOddEven) {
            this.model.differentOddEven = parseInt(node2.attributes.differentOddEven, 0) === 1;
          }
          return true;
        case "oddHeader":
          this.currentNode = "oddHeader";
          return true;
        case "oddFooter":
          this.currentNode = "oddFooter";
          return true;
        case "evenHeader":
          this.currentNode = "evenHeader";
          return true;
        case "evenFooter":
          this.currentNode = "evenFooter";
          return true;
        case "firstHeader":
          this.currentNode = "firstHeader";
          return true;
        case "firstFooter":
          this.currentNode = "firstFooter";
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      switch (this.currentNode) {
        case "oddHeader":
          this.model.oddHeader = text;
          break;
        case "oddFooter":
          this.model.oddFooter = text;
          break;
        case "evenHeader":
          this.model.evenHeader = text;
          break;
        case "evenFooter":
          this.model.evenFooter = text;
          break;
        case "firstHeader":
          this.model.firstHeader = text;
          break;
        case "firstFooter":
          this.model.firstFooter = text;
          break;
      }
    }
    parseClose() {
      switch (this.currentNode) {
        case "oddHeader":
        case "oddFooter":
        case "evenHeader":
        case "evenFooter":
        case "firstHeader":
        case "firstFooter":
          this.currentNode = void 0;
          return true;
        default:
          return false;
      }
    }
  }
  headerFooterXform = HeaderFooterXform;
  return headerFooterXform;
}
var compositeXform;
var hasRequiredCompositeXform;
function requireCompositeXform() {
  if (hasRequiredCompositeXform) return compositeXform;
  hasRequiredCompositeXform = 1;
  const BaseXform = requireBaseXform();
  class CompositeXform extends BaseXform {
    createNewModel(node2) {
      return {};
    }
    parseOpen(node2) {
      this.parser = this.parser || this.map[node2.name];
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (node2.name === this.tag) {
        this.model = this.createNewModel(node2);
        return true;
      }
      return false;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    onParserClose(name, parser2) {
      this.model[name] = parser2.model;
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.onParserClose(name, this.parser);
          this.parser = void 0;
        }
        return true;
      }
      return name !== this.tag;
    }
  }
  compositeXform = CompositeXform;
  return compositeXform;
}
var cfvoXform;
var hasRequiredCfvoXform;
function requireCfvoXform() {
  if (hasRequiredCfvoXform) return cfvoXform;
  hasRequiredCfvoXform = 1;
  const BaseXform = requireBaseXform();
  class CfvoXform extends BaseXform {
    get tag() {
      return "cfvo";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        type: model.type,
        val: model.value
      });
    }
    parseOpen(node2) {
      this.model = {
        type: node2.attributes.type,
        value: BaseXform.toFloatValue(node2.attributes.val)
      };
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  cfvoXform = CfvoXform;
  return cfvoXform;
}
var databarXform;
var hasRequiredDatabarXform;
function requireDatabarXform() {
  if (hasRequiredDatabarXform) return databarXform;
  hasRequiredDatabarXform = 1;
  const CompositeXform = requireCompositeXform();
  const ColorXform = requireColorXform();
  const CfvoXform = requireCfvoXform();
  class DatabarXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        cfvo: this.cfvoXform = new CfvoXform(),
        color: this.colorXform = new ColorXform()
      };
    }
    get tag() {
      return "dataBar";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      model.cfvo.forEach((cfvo) => {
        this.cfvoXform.render(xmlStream2, cfvo);
      });
      this.colorXform.render(xmlStream2, model.color);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {
        cfvo: []
      };
    }
    onParserClose(name, parser2) {
      switch (name) {
        case "cfvo":
          this.model.cfvo.push(parser2.model);
          break;
        case "color":
          this.model.color = parser2.model;
          break;
      }
    }
  }
  databarXform = DatabarXform;
  return databarXform;
}
var extLstRefXform;
var hasRequiredExtLstRefXform;
function requireExtLstRefXform() {
  if (hasRequiredExtLstRefXform) return extLstRefXform;
  hasRequiredExtLstRefXform = 1;
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  class X14IdXform extends BaseXform {
    get tag() {
      return "x14:id";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, null, model);
    }
    parseOpen() {
      this.model = "";
    }
    parseText(text) {
      this.model += text;
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  class ExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:id": this.idXform = new X14IdXform()
      };
    }
    get tag() {
      return "ext";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        uri: "{B025F937-C7B1-47D3-B67F-A62EFF666E3E}",
        "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
      });
      this.idXform.render(xmlStream2, model.x14Id);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {};
    }
    onParserClose(name, parser2) {
      this.model.x14Id = parser2.model;
    }
  }
  class ExtLstRefXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        ext: new ExtXform()
      };
    }
    get tag() {
      return "extLst";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      this.map.ext.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {};
    }
    onParserClose(name, parser2) {
      Object.assign(this.model, parser2.model);
    }
  }
  extLstRefXform = ExtLstRefXform;
  return extLstRefXform;
}
var formulaXform;
var hasRequiredFormulaXform;
function requireFormulaXform() {
  if (hasRequiredFormulaXform) return formulaXform;
  hasRequiredFormulaXform = 1;
  const BaseXform = requireBaseXform();
  class FormulaXform extends BaseXform {
    get tag() {
      return "formula";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, null, model);
    }
    parseOpen() {
      this.model = "";
    }
    parseText(text) {
      this.model += text;
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  formulaXform = FormulaXform;
  return formulaXform;
}
var colorScaleXform;
var hasRequiredColorScaleXform;
function requireColorScaleXform() {
  if (hasRequiredColorScaleXform) return colorScaleXform;
  hasRequiredColorScaleXform = 1;
  const CompositeXform = requireCompositeXform();
  const ColorXform = requireColorXform();
  const CfvoXform = requireCfvoXform();
  class ColorScaleXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        cfvo: this.cfvoXform = new CfvoXform(),
        color: this.colorXform = new ColorXform()
      };
    }
    get tag() {
      return "colorScale";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      model.cfvo.forEach((cfvo) => {
        this.cfvoXform.render(xmlStream2, cfvo);
      });
      model.color.forEach((color) => {
        this.colorXform.render(xmlStream2, color);
      });
      xmlStream2.closeNode();
    }
    createNewModel(node2) {
      return {
        cfvo: [],
        color: []
      };
    }
    onParserClose(name, parser2) {
      this.model[name].push(parser2.model);
    }
  }
  colorScaleXform = ColorScaleXform;
  return colorScaleXform;
}
var iconSetXform;
var hasRequiredIconSetXform;
function requireIconSetXform() {
  if (hasRequiredIconSetXform) return iconSetXform;
  hasRequiredIconSetXform = 1;
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  const CfvoXform = requireCfvoXform();
  class IconSetXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        cfvo: this.cfvoXform = new CfvoXform()
      };
    }
    get tag() {
      return "iconSet";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        iconSet: BaseXform.toStringAttribute(model.iconSet, "3TrafficLights"),
        reverse: BaseXform.toBoolAttribute(model.reverse, false),
        showValue: BaseXform.toBoolAttribute(model.showValue, true)
      });
      model.cfvo.forEach((cfvo) => {
        this.cfvoXform.render(xmlStream2, cfvo);
      });
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
        reverse: BaseXform.toBoolValue(attributes.reverse),
        showValue: BaseXform.toBoolValue(attributes.showValue),
        cfvo: []
      };
    }
    onParserClose(name, parser2) {
      this.model[name].push(parser2.model);
    }
  }
  iconSetXform = IconSetXform;
  return iconSetXform;
}
var cfRuleXform;
var hasRequiredCfRuleXform;
function requireCfRuleXform() {
  if (hasRequiredCfRuleXform) return cfRuleXform;
  hasRequiredCfRuleXform = 1;
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  const Range = requireRange();
  const DatabarXform = requireDatabarXform();
  const ExtLstRefXform = requireExtLstRefXform();
  const FormulaXform = requireFormulaXform();
  const ColorScaleXform = requireColorScaleXform();
  const IconSetXform = requireIconSetXform();
  const extIcons = {
    "3Triangles": true,
    "3Stars": true,
    "5Boxes": true
  };
  const getTextFormula = (model) => {
    if (model.formulae && model.formulae[0]) {
      return model.formulae[0];
    }
    const range2 = new Range(model.ref);
    const { tl } = range2;
    switch (model.operator) {
      case "containsText":
        return `NOT(ISERROR(SEARCH("${model.text}",${tl})))`;
      case "containsBlanks":
        return `LEN(TRIM(${tl}))=0`;
      case "notContainsBlanks":
        return `LEN(TRIM(${tl}))>0`;
      case "containsErrors":
        return `ISERROR(${tl})`;
      case "notContainsErrors":
        return `NOT(ISERROR(${tl}))`;
      default:
        return void 0;
    }
  };
  const getTimePeriodFormula = (model) => {
    if (model.formulae && model.formulae[0]) {
      return model.formulae[0];
    }
    const range2 = new Range(model.ref);
    const { tl } = range2;
    switch (model.timePeriod) {
      case "thisWeek":
        return `AND(TODAY()-ROUNDDOWN(${tl},0)<=WEEKDAY(TODAY())-1,ROUNDDOWN(${tl},0)-TODAY()<=7-WEEKDAY(TODAY()))`;
      case "lastWeek":
        return `AND(TODAY()-ROUNDDOWN(${tl},0)>=(WEEKDAY(TODAY())),TODAY()-ROUNDDOWN(${tl},0)<(WEEKDAY(TODAY())+7))`;
      case "nextWeek":
        return `AND(ROUNDDOWN(${tl},0)-TODAY()>(7-WEEKDAY(TODAY())),ROUNDDOWN(${tl},0)-TODAY()<(15-WEEKDAY(TODAY())))`;
      case "yesterday":
        return `FLOOR(${tl},1)=TODAY()-1`;
      case "today":
        return `FLOOR(${tl},1)=TODAY()`;
      case "tomorrow":
        return `FLOOR(${tl},1)=TODAY()+1`;
      case "last7Days":
        return `AND(TODAY()-FLOOR(${tl},1)<=6,FLOOR(${tl},1)<=TODAY())`;
      case "lastMonth":
        return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0-1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0-1)))`;
      case "thisMonth":
        return `AND(MONTH(${tl})=MONTH(TODAY()),YEAR(${tl})=YEAR(TODAY()))`;
      case "nextMonth":
        return `AND(MONTH(${tl})=MONTH(EDATE(TODAY(),0+1)),YEAR(${tl})=YEAR(EDATE(TODAY(),0+1)))`;
      default:
        return void 0;
    }
  };
  const opType = (attributes) => {
    const { type: type2, operator } = attributes;
    switch (type2) {
      case "containsText":
      case "containsBlanks":
      case "notContainsBlanks":
      case "containsErrors":
      case "notContainsErrors":
        return {
          type: "containsText",
          operator: type2
        };
      default:
        return { type: type2, operator };
    }
  };
  class CfRuleXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        dataBar: this.databarXform = new DatabarXform(),
        extLst: this.extLstRefXform = new ExtLstRefXform(),
        formula: this.formulaXform = new FormulaXform(),
        colorScale: this.colorScaleXform = new ColorScaleXform(),
        iconSet: this.iconSetXform = new IconSetXform()
      };
    }
    get tag() {
      return "cfRule";
    }
    static isPrimitive(rule) {
      if (rule.type === "iconSet") {
        if (rule.custom || extIcons[rule.iconSet]) {
          return false;
        }
      }
      return true;
    }
    render(xmlStream2, model) {
      switch (model.type) {
        case "expression":
          this.renderExpression(xmlStream2, model);
          break;
        case "cellIs":
          this.renderCellIs(xmlStream2, model);
          break;
        case "top10":
          this.renderTop10(xmlStream2, model);
          break;
        case "aboveAverage":
          this.renderAboveAverage(xmlStream2, model);
          break;
        case "dataBar":
          this.renderDataBar(xmlStream2, model);
          break;
        case "colorScale":
          this.renderColorScale(xmlStream2, model);
          break;
        case "iconSet":
          this.renderIconSet(xmlStream2, model);
          break;
        case "containsText":
          this.renderText(xmlStream2, model);
          break;
        case "timePeriod":
          this.renderTimePeriod(xmlStream2, model);
          break;
      }
    }
    renderExpression(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "expression",
        dxfId: model.dxfId,
        priority: model.priority
      });
      this.formulaXform.render(xmlStream2, model.formulae[0]);
      xmlStream2.closeNode();
    }
    renderCellIs(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "cellIs",
        dxfId: model.dxfId,
        priority: model.priority,
        operator: model.operator
      });
      model.formulae.forEach((formula) => {
        this.formulaXform.render(xmlStream2, formula);
      });
      xmlStream2.closeNode();
    }
    renderTop10(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        type: "top10",
        dxfId: model.dxfId,
        priority: model.priority,
        percent: BaseXform.toBoolAttribute(model.percent, false),
        bottom: BaseXform.toBoolAttribute(model.bottom, false),
        rank: BaseXform.toIntValue(model.rank, 10, true)
      });
    }
    renderAboveAverage(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        type: "aboveAverage",
        dxfId: model.dxfId,
        priority: model.priority,
        aboveAverage: BaseXform.toBoolAttribute(model.aboveAverage, true)
      });
    }
    renderDataBar(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "dataBar",
        priority: model.priority
      });
      this.databarXform.render(xmlStream2, model);
      this.extLstRefXform.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    renderColorScale(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "colorScale",
        priority: model.priority
      });
      this.colorScaleXform.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    renderIconSet(xmlStream2, model) {
      if (!CfRuleXform.isPrimitive(model)) {
        return;
      }
      xmlStream2.openNode(this.tag, {
        type: "iconSet",
        priority: model.priority
      });
      this.iconSetXform.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    renderText(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: model.operator,
        dxfId: model.dxfId,
        priority: model.priority,
        operator: BaseXform.toStringAttribute(model.operator, "containsText")
      });
      const formula = getTextFormula(model);
      if (formula) {
        this.formulaXform.render(xmlStream2, formula);
      }
      xmlStream2.closeNode();
    }
    renderTimePeriod(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "timePeriod",
        dxfId: model.dxfId,
        priority: model.priority,
        timePeriod: model.timePeriod
      });
      const formula = getTimePeriodFormula(model);
      if (formula) {
        this.formulaXform.render(xmlStream2, formula);
      }
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        ...opType(attributes),
        dxfId: BaseXform.toIntValue(attributes.dxfId),
        priority: BaseXform.toIntValue(attributes.priority),
        timePeriod: attributes.timePeriod,
        percent: BaseXform.toBoolValue(attributes.percent),
        bottom: BaseXform.toBoolValue(attributes.bottom),
        rank: BaseXform.toIntValue(attributes.rank),
        aboveAverage: BaseXform.toBoolValue(attributes.aboveAverage)
      };
    }
    onParserClose(name, parser2) {
      switch (name) {
        case "dataBar":
        case "extLst":
        case "colorScale":
        case "iconSet":
          Object.assign(this.model, parser2.model);
          break;
        case "formula":
          this.model.formulae = this.model.formulae || [];
          this.model.formulae.push(parser2.model);
          break;
      }
    }
  }
  cfRuleXform = CfRuleXform;
  return cfRuleXform;
}
var conditionalFormattingXform;
var hasRequiredConditionalFormattingXform;
function requireConditionalFormattingXform() {
  if (hasRequiredConditionalFormattingXform) return conditionalFormattingXform;
  hasRequiredConditionalFormattingXform = 1;
  const CompositeXform = requireCompositeXform();
  const CfRuleXform = requireCfRuleXform();
  class ConditionalFormattingXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        cfRule: new CfRuleXform()
      };
    }
    get tag() {
      return "conditionalFormatting";
    }
    render(xmlStream2, model) {
      if (!model.rules.some(CfRuleXform.isPrimitive)) {
        return;
      }
      xmlStream2.openNode(this.tag, { sqref: model.ref });
      model.rules.forEach((rule) => {
        if (CfRuleXform.isPrimitive(rule)) {
          rule.ref = model.ref;
          this.map.cfRule.render(xmlStream2, rule);
        }
      });
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        ref: attributes.sqref,
        rules: []
      };
    }
    onParserClose(name, parser2) {
      this.model.rules.push(parser2.model);
    }
  }
  conditionalFormattingXform = ConditionalFormattingXform;
  return conditionalFormattingXform;
}
var conditionalFormattingsXform;
var hasRequiredConditionalFormattingsXform;
function requireConditionalFormattingsXform() {
  if (hasRequiredConditionalFormattingsXform) return conditionalFormattingsXform;
  hasRequiredConditionalFormattingsXform = 1;
  const BaseXform = requireBaseXform();
  const ConditionalFormattingXform = requireConditionalFormattingXform();
  class ConditionalFormattingsXform extends BaseXform {
    constructor() {
      super();
      this.cfXform = new ConditionalFormattingXform();
    }
    get tag() {
      return "conditionalFormatting";
    }
    reset() {
      this.model = [];
    }
    prepare(model, options) {
      let nextPriority = model.reduce(
        (p, cf) => Math.max(p, ...cf.rules.map((rule) => rule.priority || 0)),
        1
      );
      model.forEach((cf) => {
        cf.rules.forEach((rule) => {
          if (!rule.priority) {
            rule.priority = nextPriority++;
          }
          if (rule.style) {
            rule.dxfId = options.styles.addDxfStyle(rule.style);
          }
        });
      });
    }
    render(xmlStream2, model) {
      model.forEach((cf) => {
        this.cfXform.render(xmlStream2, cf);
      });
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "conditionalFormatting":
          this.parser = this.cfXform;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.push(this.parser.model);
          this.parser = void 0;
          return false;
        }
        return true;
      }
      return false;
    }
    reconcile(model, options) {
      model.forEach((cf) => {
        cf.rules.forEach((rule) => {
          if (rule.dxfId !== void 0) {
            rule.style = options.styles.getDxfStyle(rule.dxfId);
            delete rule.dxfId;
          }
        });
      });
    }
  }
  conditionalFormattingsXform = ConditionalFormattingsXform;
  return conditionalFormattingsXform;
}
var dist = {};
var v1 = {};
var rng = {};
var hasRequiredRng;
function requireRng() {
  if (hasRequiredRng) return rng;
  hasRequiredRng = 1;
  Object.defineProperty(rng, "__esModule", {
    value: true
  });
  rng.default = rng$1;
  var _crypto = _interopRequireDefault(require$$0$5);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const rnds8Pool = new Uint8Array(256);
  let poolPtr = rnds8Pool.length;
  function rng$1() {
    if (poolPtr > rnds8Pool.length - 16) {
      _crypto.default.randomFillSync(rnds8Pool);
      poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
  }
  return rng;
}
var stringify = {};
var validate = {};
var regex = {};
var hasRequiredRegex;
function requireRegex() {
  if (hasRequiredRegex) return regex;
  hasRequiredRegex = 1;
  Object.defineProperty(regex, "__esModule", {
    value: true
  });
  regex.default = void 0;
  var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  regex.default = _default;
  return regex;
}
var hasRequiredValidate;
function requireValidate() {
  if (hasRequiredValidate) return validate;
  hasRequiredValidate = 1;
  Object.defineProperty(validate, "__esModule", {
    value: true
  });
  validate.default = void 0;
  var _regex = _interopRequireDefault(/* @__PURE__ */ requireRegex());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function validate$1(uuid) {
    return typeof uuid === "string" && _regex.default.test(uuid);
  }
  var _default = validate$1;
  validate.default = _default;
  return validate;
}
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify;
  hasRequiredStringify = 1;
  Object.defineProperty(stringify, "__esModule", {
    value: true
  });
  stringify.default = void 0;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const byteToHex = [];
  for (let i = 0; i < 256; ++i) {
    byteToHex.push((i + 256).toString(16).substr(1));
  }
  function stringify$1(arr, offset = 0) {
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
  }
  var _default = stringify$1;
  stringify.default = _default;
  return stringify;
}
var hasRequiredV1;
function requireV1() {
  if (hasRequiredV1) return v1;
  hasRequiredV1 = 1;
  Object.defineProperty(v1, "__esModule", {
    value: true
  });
  v1.default = void 0;
  var _rng = _interopRequireDefault(/* @__PURE__ */ requireRng());
  var _stringify = _interopRequireDefault(/* @__PURE__ */ requireStringify());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  let _nodeId;
  let _clockseq;
  let _lastMSecs = 0;
  let _lastNSecs = 0;
  function v1$1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node2 = options.node || _nodeId;
    let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
    if (node2 == null || clockseq == null) {
      const seedBytes = options.random || (options.rng || _rng.default)();
      if (node2 == null) {
        node2 = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
      }
      if (clockseq == null) {
        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      }
    }
    let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
    let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
    if (dt < 0 && options.clockseq === void 0) {
      clockseq = clockseq + 1 & 16383;
    }
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
      nsecs = 0;
    }
    if (nsecs >= 1e4) {
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;
    msecs += 122192928e5;
    const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
    b[i++] = tl >>> 24 & 255;
    b[i++] = tl >>> 16 & 255;
    b[i++] = tl >>> 8 & 255;
    b[i++] = tl & 255;
    const tmh = msecs / 4294967296 * 1e4 & 268435455;
    b[i++] = tmh >>> 8 & 255;
    b[i++] = tmh & 255;
    b[i++] = tmh >>> 24 & 15 | 16;
    b[i++] = tmh >>> 16 & 255;
    b[i++] = clockseq >>> 8 | 128;
    b[i++] = clockseq & 255;
    for (let n = 0; n < 6; ++n) {
      b[i + n] = node2[n];
    }
    return buf || (0, _stringify.default)(b);
  }
  var _default = v1$1;
  v1.default = _default;
  return v1;
}
var v3 = {};
var v35 = {};
var parse$1 = {};
var hasRequiredParse$1;
function requireParse$1() {
  if (hasRequiredParse$1) return parse$1;
  hasRequiredParse$1 = 1;
  Object.defineProperty(parse$1, "__esModule", {
    value: true
  });
  parse$1.default = void 0;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function parse2(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16);
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 255;
    arr[2] = v >>> 8 & 255;
    arr[3] = v & 255;
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 255;
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 255;
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 255;
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
    arr[11] = v / 4294967296 & 255;
    arr[12] = v >>> 24 & 255;
    arr[13] = v >>> 16 & 255;
    arr[14] = v >>> 8 & 255;
    arr[15] = v & 255;
    return arr;
  }
  var _default = parse2;
  parse$1.default = _default;
  return parse$1;
}
var hasRequiredV35;
function requireV35() {
  if (hasRequiredV35) return v35;
  hasRequiredV35 = 1;
  Object.defineProperty(v35, "__esModule", {
    value: true
  });
  v35.default = _default;
  v35.URL = v35.DNS = void 0;
  var _stringify = _interopRequireDefault(/* @__PURE__ */ requireStringify());
  var _parse = _interopRequireDefault(/* @__PURE__ */ requireParse$1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function stringToBytes(str) {
    str = unescape(encodeURIComponent(str));
    const bytes = [];
    for (let i = 0; i < str.length; ++i) {
      bytes.push(str.charCodeAt(i));
    }
    return bytes;
  }
  const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  v35.DNS = DNS;
  const URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  v35.URL = URL2;
  function _default(name, version2, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
      if (typeof value === "string") {
        value = stringToBytes(value);
      }
      if (typeof namespace === "string") {
        namespace = (0, _parse.default)(namespace);
      }
      if (namespace.length !== 16) {
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      }
      let bytes = new Uint8Array(16 + value.length);
      bytes.set(namespace);
      bytes.set(value, namespace.length);
      bytes = hashfunc(bytes);
      bytes[6] = bytes[6] & 15 | version2;
      bytes[8] = bytes[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = bytes[i];
        }
        return buf;
      }
      return (0, _stringify.default)(bytes);
    }
    try {
      generateUUID.name = name;
    } catch (err) {
    }
    generateUUID.DNS = DNS;
    generateUUID.URL = URL2;
    return generateUUID;
  }
  return v35;
}
var md5 = {};
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5;
  hasRequiredMd5 = 1;
  Object.defineProperty(md5, "__esModule", {
    value: true
  });
  md5.default = void 0;
  var _crypto = _interopRequireDefault(require$$0$5);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function md5$1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("md5").update(bytes).digest();
  }
  var _default = md5$1;
  md5.default = _default;
  return md5;
}
var hasRequiredV3;
function requireV3() {
  if (hasRequiredV3) return v3;
  hasRequiredV3 = 1;
  Object.defineProperty(v3, "__esModule", {
    value: true
  });
  v3.default = void 0;
  var _v = _interopRequireDefault(/* @__PURE__ */ requireV35());
  var _md = _interopRequireDefault(/* @__PURE__ */ requireMd5());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const v3$1 = (0, _v.default)("v3", 48, _md.default);
  var _default = v3$1;
  v3.default = _default;
  return v3;
}
var v4 = {};
var hasRequiredV4;
function requireV4() {
  if (hasRequiredV4) return v4;
  hasRequiredV4 = 1;
  Object.defineProperty(v4, "__esModule", {
    value: true
  });
  v4.default = void 0;
  var _rng = _interopRequireDefault(/* @__PURE__ */ requireRng());
  var _stringify = _interopRequireDefault(/* @__PURE__ */ requireStringify());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function v4$1(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || _rng.default)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }
      return buf;
    }
    return (0, _stringify.default)(rnds);
  }
  var _default = v4$1;
  v4.default = _default;
  return v4;
}
var v5 = {};
var sha1 = {};
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1;
  hasRequiredSha1 = 1;
  Object.defineProperty(sha1, "__esModule", {
    value: true
  });
  sha1.default = void 0;
  var _crypto = _interopRequireDefault(require$$0$5);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function sha1$1(bytes) {
    if (Array.isArray(bytes)) {
      bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
      bytes = Buffer.from(bytes, "utf8");
    }
    return _crypto.default.createHash("sha1").update(bytes).digest();
  }
  var _default = sha1$1;
  sha1.default = _default;
  return sha1;
}
var hasRequiredV5;
function requireV5() {
  if (hasRequiredV5) return v5;
  hasRequiredV5 = 1;
  Object.defineProperty(v5, "__esModule", {
    value: true
  });
  v5.default = void 0;
  var _v = _interopRequireDefault(/* @__PURE__ */ requireV35());
  var _sha = _interopRequireDefault(/* @__PURE__ */ requireSha1());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  const v5$1 = (0, _v.default)("v5", 80, _sha.default);
  var _default = v5$1;
  v5.default = _default;
  return v5;
}
var nil = {};
var hasRequiredNil;
function requireNil() {
  if (hasRequiredNil) return nil;
  hasRequiredNil = 1;
  Object.defineProperty(nil, "__esModule", {
    value: true
  });
  nil.default = void 0;
  var _default = "00000000-0000-0000-0000-000000000000";
  nil.default = _default;
  return nil;
}
var version = {};
var hasRequiredVersion;
function requireVersion() {
  if (hasRequiredVersion) return version;
  hasRequiredVersion = 1;
  Object.defineProperty(version, "__esModule", {
    value: true
  });
  version.default = void 0;
  var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function version$1(uuid) {
    if (!(0, _validate.default)(uuid)) {
      throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
  }
  var _default = version$1;
  version.default = _default;
  return version;
}
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(/* @__PURE__ */ requireV1());
    var _v2 = _interopRequireDefault(/* @__PURE__ */ requireV3());
    var _v3 = _interopRequireDefault(/* @__PURE__ */ requireV4());
    var _v4 = _interopRequireDefault(/* @__PURE__ */ requireV5());
    var _nil = _interopRequireDefault(/* @__PURE__ */ requireNil());
    var _version = _interopRequireDefault(/* @__PURE__ */ requireVersion());
    var _validate = _interopRequireDefault(/* @__PURE__ */ requireValidate());
    var _stringify = _interopRequireDefault(/* @__PURE__ */ requireStringify());
    var _parse = _interopRequireDefault(/* @__PURE__ */ requireParse$1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  })(dist);
  return dist;
}
var fExtXform;
var hasRequiredFExtXform;
function requireFExtXform() {
  if (hasRequiredFExtXform) return fExtXform;
  hasRequiredFExtXform = 1;
  const BaseXform = requireBaseXform();
  class FExtXform extends BaseXform {
    get tag() {
      return "xm:f";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, null, model);
    }
    parseOpen() {
      this.model = "";
    }
    parseText(text) {
      this.model += text;
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  fExtXform = FExtXform;
  return fExtXform;
}
var cfvoExtXform;
var hasRequiredCfvoExtXform;
function requireCfvoExtXform() {
  if (hasRequiredCfvoExtXform) return cfvoExtXform;
  hasRequiredCfvoExtXform = 1;
  const CompositeXform = requireCompositeXform();
  const FExtXform = requireFExtXform();
  class CfvoExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "xm:f": this.fExtXform = new FExtXform()
      };
    }
    get tag() {
      return "x14:cfvo";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: model.type
      });
      if (model.value !== void 0) {
        this.fExtXform.render(xmlStream2, model.value);
      }
      xmlStream2.closeNode();
    }
    createNewModel(node2) {
      return {
        type: node2.attributes.type
      };
    }
    onParserClose(name, parser2) {
      switch (name) {
        case "xm:f":
          this.model.value = parser2.model ? parseFloat(parser2.model) : 0;
          break;
      }
    }
  }
  cfvoExtXform = CfvoExtXform;
  return cfvoExtXform;
}
var databarExtXform;
var hasRequiredDatabarExtXform;
function requireDatabarExtXform() {
  if (hasRequiredDatabarExtXform) return databarExtXform;
  hasRequiredDatabarExtXform = 1;
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  const ColorXform = requireColorXform();
  const CfvoExtXform = requireCfvoExtXform();
  class DatabarExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
        "x14:borderColor": this.borderColorXform = new ColorXform("x14:borderColor"),
        "x14:negativeBorderColor": this.negativeBorderColorXform = new ColorXform(
          "x14:negativeBorderColor"
        ),
        "x14:negativeFillColor": this.negativeFillColorXform = new ColorXform(
          "x14:negativeFillColor"
        ),
        "x14:axisColor": this.axisColorXform = new ColorXform("x14:axisColor")
      };
    }
    static isExt(rule) {
      return !rule.gradient;
    }
    get tag() {
      return "x14:dataBar";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        minLength: BaseXform.toIntAttribute(model.minLength, 0, true),
        maxLength: BaseXform.toIntAttribute(model.maxLength, 100, true),
        border: BaseXform.toBoolAttribute(model.border, false),
        gradient: BaseXform.toBoolAttribute(model.gradient, true),
        negativeBarColorSameAsPositive: BaseXform.toBoolAttribute(
          model.negativeBarColorSameAsPositive,
          true
        ),
        negativeBarBorderColorSameAsPositive: BaseXform.toBoolAttribute(
          model.negativeBarBorderColorSameAsPositive,
          true
        ),
        axisPosition: BaseXform.toAttribute(model.axisPosition, "auto"),
        direction: BaseXform.toAttribute(model.direction, "leftToRight")
      });
      model.cfvo.forEach((cfvo) => {
        this.cfvoXform.render(xmlStream2, cfvo);
      });
      this.borderColorXform.render(xmlStream2, model.borderColor);
      this.negativeBorderColorXform.render(xmlStream2, model.negativeBorderColor);
      this.negativeFillColorXform.render(xmlStream2, model.negativeFillColor);
      this.axisColorXform.render(xmlStream2, model.axisColor);
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        cfvo: [],
        minLength: BaseXform.toIntValue(attributes.minLength, 0),
        maxLength: BaseXform.toIntValue(attributes.maxLength, 100),
        border: BaseXform.toBoolValue(attributes.border, false),
        gradient: BaseXform.toBoolValue(attributes.gradient, true),
        negativeBarColorSameAsPositive: BaseXform.toBoolValue(
          attributes.negativeBarColorSameAsPositive,
          true
        ),
        negativeBarBorderColorSameAsPositive: BaseXform.toBoolValue(
          attributes.negativeBarBorderColorSameAsPositive,
          true
        ),
        axisPosition: BaseXform.toStringValue(attributes.axisPosition, "auto"),
        direction: BaseXform.toStringValue(attributes.direction, "leftToRight")
      };
    }
    onParserClose(name, parser2) {
      const [, prop] = name.split(":");
      switch (prop) {
        case "cfvo":
          this.model.cfvo.push(parser2.model);
          break;
        default:
          this.model[prop] = parser2.model;
          break;
      }
    }
  }
  databarExtXform = DatabarExtXform;
  return databarExtXform;
}
var cfIconExtXform;
var hasRequiredCfIconExtXform;
function requireCfIconExtXform() {
  if (hasRequiredCfIconExtXform) return cfIconExtXform;
  hasRequiredCfIconExtXform = 1;
  const BaseXform = requireBaseXform();
  class CfIconExtXform extends BaseXform {
    get tag() {
      return "x14:cfIcon";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        iconSet: model.iconSet,
        iconId: model.iconId
      });
    }
    parseOpen({ attributes }) {
      this.model = {
        iconSet: attributes.iconSet,
        iconId: BaseXform.toIntValue(attributes.iconId)
      };
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  cfIconExtXform = CfIconExtXform;
  return cfIconExtXform;
}
var iconSetExtXform;
var hasRequiredIconSetExtXform;
function requireIconSetExtXform() {
  if (hasRequiredIconSetExtXform) return iconSetExtXform;
  hasRequiredIconSetExtXform = 1;
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  const CfvoExtXform = requireCfvoExtXform();
  const CfIconExtXform = requireCfIconExtXform();
  class IconSetExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:cfvo": this.cfvoXform = new CfvoExtXform(),
        "x14:cfIcon": this.cfIconXform = new CfIconExtXform()
      };
    }
    get tag() {
      return "x14:iconSet";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        iconSet: BaseXform.toStringAttribute(model.iconSet),
        reverse: BaseXform.toBoolAttribute(model.reverse, false),
        showValue: BaseXform.toBoolAttribute(model.showValue, true),
        custom: BaseXform.toBoolAttribute(model.icons, false)
      });
      model.cfvo.forEach((cfvo) => {
        this.cfvoXform.render(xmlStream2, cfvo);
      });
      if (model.icons) {
        model.icons.forEach((icon, i) => {
          icon.iconId = i;
          this.cfIconXform.render(xmlStream2, icon);
        });
      }
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        cfvo: [],
        iconSet: BaseXform.toStringValue(attributes.iconSet, "3TrafficLights"),
        reverse: BaseXform.toBoolValue(attributes.reverse, false),
        showValue: BaseXform.toBoolValue(attributes.showValue, true)
      };
    }
    onParserClose(name, parser2) {
      const [, prop] = name.split(":");
      switch (prop) {
        case "cfvo":
          this.model.cfvo.push(parser2.model);
          break;
        case "cfIcon":
          if (!this.model.icons) {
            this.model.icons = [];
          }
          this.model.icons.push(parser2.model);
          break;
        default:
          this.model[prop] = parser2.model;
          break;
      }
    }
  }
  iconSetExtXform = IconSetExtXform;
  return iconSetExtXform;
}
var cfRuleExtXform;
var hasRequiredCfRuleExtXform;
function requireCfRuleExtXform() {
  if (hasRequiredCfRuleExtXform) return cfRuleExtXform;
  hasRequiredCfRuleExtXform = 1;
  const { v4: uuidv4 } = /* @__PURE__ */ requireDist();
  const BaseXform = requireBaseXform();
  const CompositeXform = requireCompositeXform();
  const DatabarExtXform = requireDatabarExtXform();
  const IconSetExtXform = requireIconSetExtXform();
  const extIcons = {
    "3Triangles": true,
    "3Stars": true,
    "5Boxes": true
  };
  class CfRuleExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:dataBar": this.databarXform = new DatabarExtXform(),
        "x14:iconSet": this.iconSetXform = new IconSetExtXform()
      };
    }
    get tag() {
      return "x14:cfRule";
    }
    static isExt(rule) {
      if (rule.type === "dataBar") {
        return DatabarExtXform.isExt(rule);
      }
      if (rule.type === "iconSet") {
        if (rule.custom || extIcons[rule.iconSet]) {
          return true;
        }
      }
      return false;
    }
    prepare(model) {
      if (CfRuleExtXform.isExt(model)) {
        model.x14Id = `{${uuidv4()}}`.toUpperCase();
      }
    }
    render(xmlStream2, model) {
      if (!CfRuleExtXform.isExt(model)) {
        return;
      }
      switch (model.type) {
        case "dataBar":
          this.renderDataBar(xmlStream2, model);
          break;
        case "iconSet":
          this.renderIconSet(xmlStream2, model);
          break;
      }
    }
    renderDataBar(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "dataBar",
        id: model.x14Id
      });
      this.databarXform.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    renderIconSet(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        type: "iconSet",
        priority: model.priority,
        id: model.x14Id || `{${uuidv4()}}`
      });
      this.iconSetXform.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    createNewModel({ attributes }) {
      return {
        type: attributes.type,
        x14Id: attributes.id,
        priority: BaseXform.toIntValue(attributes.priority)
      };
    }
    onParserClose(name, parser2) {
      Object.assign(this.model, parser2.model);
    }
  }
  cfRuleExtXform = CfRuleExtXform;
  return cfRuleExtXform;
}
var sqrefExtXform;
var hasRequiredSqrefExtXform;
function requireSqrefExtXform() {
  if (hasRequiredSqrefExtXform) return sqrefExtXform;
  hasRequiredSqrefExtXform = 1;
  const BaseXform = requireBaseXform();
  class SqrefExtXform extends BaseXform {
    get tag() {
      return "xm:sqref";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, null, model);
    }
    parseOpen() {
      this.model = "";
    }
    parseText(text) {
      this.model += text;
    }
    parseClose(name) {
      return name !== this.tag;
    }
  }
  sqrefExtXform = SqrefExtXform;
  return sqrefExtXform;
}
var conditionalFormattingExtXform;
var hasRequiredConditionalFormattingExtXform;
function requireConditionalFormattingExtXform() {
  if (hasRequiredConditionalFormattingExtXform) return conditionalFormattingExtXform;
  hasRequiredConditionalFormattingExtXform = 1;
  const CompositeXform = requireCompositeXform();
  const SqRefExtXform = requireSqrefExtXform();
  const CfRuleExtXform = requireCfRuleExtXform();
  class ConditionalFormattingExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "xm:sqref": this.sqRef = new SqRefExtXform(),
        "x14:cfRule": this.cfRule = new CfRuleExtXform()
      };
    }
    get tag() {
      return "x14:conditionalFormatting";
    }
    prepare(model, options) {
      model.rules.forEach((rule) => {
        this.cfRule.prepare(rule, options);
      });
    }
    render(xmlStream2, model) {
      if (!model.rules.some(CfRuleExtXform.isExt)) {
        return;
      }
      xmlStream2.openNode(this.tag, {
        "xmlns:xm": "http://schemas.microsoft.com/office/excel/2006/main"
      });
      model.rules.filter(CfRuleExtXform.isExt).forEach((rule) => this.cfRule.render(xmlStream2, rule));
      this.sqRef.render(xmlStream2, model.ref);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {
        rules: []
      };
    }
    onParserClose(name, parser2) {
      switch (name) {
        case "xm:sqref":
          this.model.ref = parser2.model;
          break;
        case "x14:cfRule":
          this.model.rules.push(parser2.model);
          break;
      }
    }
  }
  conditionalFormattingExtXform = ConditionalFormattingExtXform;
  return conditionalFormattingExtXform;
}
var conditionalFormattingsExtXform;
var hasRequiredConditionalFormattingsExtXform;
function requireConditionalFormattingsExtXform() {
  if (hasRequiredConditionalFormattingsExtXform) return conditionalFormattingsExtXform;
  hasRequiredConditionalFormattingsExtXform = 1;
  const CompositeXform = requireCompositeXform();
  const CfRuleExtXform = requireCfRuleExtXform();
  const ConditionalFormattingExtXform = requireConditionalFormattingExtXform();
  class ConditionalFormattingsExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:conditionalFormatting": this.cfXform = new ConditionalFormattingExtXform()
      };
    }
    get tag() {
      return "x14:conditionalFormattings";
    }
    hasContent(model) {
      if (model.hasExtContent === void 0) {
        model.hasExtContent = model.some((cf) => cf.rules.some(CfRuleExtXform.isExt));
      }
      return model.hasExtContent;
    }
    prepare(model, options) {
      model.forEach((cf) => {
        this.cfXform.prepare(cf, options);
      });
    }
    render(xmlStream2, model) {
      if (this.hasContent(model)) {
        xmlStream2.openNode(this.tag);
        model.forEach((cf) => this.cfXform.render(xmlStream2, cf));
        xmlStream2.closeNode();
      }
    }
    createNewModel() {
      return [];
    }
    onParserClose(name, parser2) {
      this.model.push(parser2.model);
    }
  }
  conditionalFormattingsExtXform = ConditionalFormattingsExtXform;
  return conditionalFormattingsExtXform;
}
var extLstXform$1;
var hasRequiredExtLstXform$1;
function requireExtLstXform$1() {
  if (hasRequiredExtLstXform$1) return extLstXform$1;
  hasRequiredExtLstXform$1 = 1;
  const CompositeXform = requireCompositeXform();
  const ConditionalFormattingsExt = requireConditionalFormattingsExtXform();
  class ExtXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        "x14:conditionalFormattings": this.conditionalFormattings = new ConditionalFormattingsExt()
      };
    }
    get tag() {
      return "ext";
    }
    hasContent(model) {
      return this.conditionalFormattings.hasContent(model.conditionalFormattings);
    }
    prepare(model, options) {
      this.conditionalFormattings.prepare(model.conditionalFormattings, options);
    }
    render(xmlStream2, model) {
      xmlStream2.openNode("ext", {
        uri: "{78C0D931-6437-407d-A8EE-F0AAD7539E65}",
        "xmlns:x14": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/main"
      });
      this.conditionalFormattings.render(xmlStream2, model.conditionalFormattings);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {};
    }
    onParserClose(name, parser2) {
      this.model[name] = parser2.model;
    }
  }
  class ExtLstXform extends CompositeXform {
    constructor() {
      super();
      this.map = {
        ext: this.ext = new ExtXform()
      };
    }
    get tag() {
      return "extLst";
    }
    prepare(model, options) {
      this.ext.prepare(model, options);
    }
    hasContent(model) {
      return this.ext.hasContent(model);
    }
    render(xmlStream2, model) {
      if (!this.hasContent(model)) {
        return;
      }
      xmlStream2.openNode("extLst");
      this.ext.render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    createNewModel() {
      return {};
    }
    onParserClose(name, parser2) {
      Object.assign(this.model, parser2.model);
    }
  }
  extLstXform$1 = ExtLstXform;
  return extLstXform$1;
}
var worksheetXform;
var hasRequiredWorksheetXform;
function requireWorksheetXform() {
  if (hasRequiredWorksheetXform) return worksheetXform;
  hasRequiredWorksheetXform = 1;
  const _2 = requireUnderDash();
  const colCache = requireColCache();
  const XmlStream = requireXmlStream();
  const RelType = requireRelType();
  const Merges = requireMerges();
  const BaseXform = requireBaseXform();
  const ListXform = requireListXform();
  const RowXform = requireRowXform();
  const ColXform = requireColXform();
  const DimensionXform = requireDimensionXform();
  const HyperlinkXform = requireHyperlinkXform();
  const MergeCellXform = requireMergeCellXform();
  const DataValidationsXform = requireDataValidationsXform();
  const SheetPropertiesXform = requireSheetPropertiesXform();
  const SheetFormatPropertiesXform = requireSheetFormatPropertiesXform();
  const SheetViewXform = requireSheetViewXform();
  const SheetProtectionXform = requireSheetProtectionXform();
  const PageMarginsXform = requirePageMarginsXform();
  const PageSetupXform = requirePageSetupXform();
  const PrintOptionsXform = requirePrintOptionsXform();
  const AutoFilterXform = requireAutoFilterXform$1();
  const PictureXform = requirePictureXform();
  const DrawingXform = requireDrawingXform$1();
  const TablePartXform = requireTablePartXform();
  const RowBreaksXform = requireRowBreaksXform();
  const HeaderFooterXform = requireHeaderFooterXform();
  const ConditionalFormattingsXform = requireConditionalFormattingsXform();
  const ExtListXform = requireExtLstXform$1();
  const mergeRule = (rule, extRule) => {
    Object.keys(extRule).forEach((key) => {
      const value = rule[key];
      const extValue = extRule[key];
      if (value === void 0 && extValue !== void 0) {
        rule[key] = extValue;
      }
    });
  };
  const mergeConditionalFormattings = (model, extModel) => {
    if (!extModel || !extModel.length) {
      return model;
    }
    if (!model || !model.length) {
      return extModel;
    }
    const cfMap = {};
    const ruleMap = {};
    model.forEach((cf) => {
      cfMap[cf.ref] = cf;
      cf.rules.forEach((rule) => {
        const { x14Id } = rule;
        if (x14Id) {
          ruleMap[x14Id] = rule;
        }
      });
    });
    extModel.forEach((extCf) => {
      extCf.rules.forEach((extRule) => {
        const rule = ruleMap[extRule.x14Id];
        if (rule) {
          mergeRule(rule, extRule);
        } else if (cfMap[extCf.ref]) {
          cfMap[extCf.ref].rules.push(extRule);
        } else {
          model.push({
            ref: extCf.ref,
            rules: [extRule]
          });
        }
      });
    });
    return model;
  };
  class WorkSheetXform extends BaseXform {
    constructor(options) {
      super();
      const { maxRows, maxCols, ignoreNodes } = options || {};
      this.ignoreNodes = ignoreNodes || [];
      this.map = {
        sheetPr: new SheetPropertiesXform(),
        dimension: new DimensionXform(),
        sheetViews: new ListXform({
          tag: "sheetViews",
          count: false,
          childXform: new SheetViewXform()
        }),
        sheetFormatPr: new SheetFormatPropertiesXform(),
        cols: new ListXform({ tag: "cols", count: false, childXform: new ColXform() }),
        sheetData: new ListXform({
          tag: "sheetData",
          count: false,
          empty: true,
          childXform: new RowXform({ maxItems: maxCols }),
          maxItems: maxRows
        }),
        autoFilter: new AutoFilterXform(),
        mergeCells: new ListXform({ tag: "mergeCells", count: true, childXform: new MergeCellXform() }),
        rowBreaks: new RowBreaksXform(),
        hyperlinks: new ListXform({
          tag: "hyperlinks",
          count: false,
          childXform: new HyperlinkXform()
        }),
        pageMargins: new PageMarginsXform(),
        dataValidations: new DataValidationsXform(),
        pageSetup: new PageSetupXform(),
        headerFooter: new HeaderFooterXform(),
        printOptions: new PrintOptionsXform(),
        picture: new PictureXform(),
        drawing: new DrawingXform(),
        sheetProtection: new SheetProtectionXform(),
        tableParts: new ListXform({ tag: "tableParts", count: true, childXform: new TablePartXform() }),
        conditionalFormatting: new ConditionalFormattingsXform(),
        extLst: new ExtListXform()
      };
    }
    prepare(model, options) {
      options.merges = new Merges();
      model.hyperlinks = options.hyperlinks = [];
      model.comments = options.comments = [];
      options.formulae = {};
      options.siFormulae = 0;
      this.map.cols.prepare(model.cols, options);
      this.map.sheetData.prepare(model.rows, options);
      this.map.conditionalFormatting.prepare(model.conditionalFormattings, options);
      model.mergeCells = options.merges.mergeCells;
      const rels = model.rels = [];
      function nextRid(r) {
        return `rId${r.length + 1}`;
      }
      model.hyperlinks.forEach((hyperlink) => {
        const rId = nextRid(rels);
        hyperlink.rId = rId;
        rels.push({
          Id: rId,
          Type: RelType.Hyperlink,
          Target: hyperlink.target,
          TargetMode: "External"
        });
      });
      if (model.comments.length > 0) {
        const comment = {
          Id: nextRid(rels),
          Type: RelType.Comments,
          Target: `../comments${model.id}.xml`
        };
        rels.push(comment);
        const vmlDrawing = {
          Id: nextRid(rels),
          Type: RelType.VmlDrawing,
          Target: `../drawings/vmlDrawing${model.id}.vml`
        };
        rels.push(vmlDrawing);
        model.comments.forEach((item) => {
          item.refAddress = colCache.decodeAddress(item.ref);
        });
        options.commentRefs.push({
          commentName: `comments${model.id}`,
          vmlDrawing: `vmlDrawing${model.id}`
        });
      }
      const drawingRelsHash = [];
      let bookImage;
      model.media.forEach((medium) => {
        if (medium.type === "background") {
          const rId = nextRid(rels);
          bookImage = options.media[medium.imageId];
          rels.push({
            Id: rId,
            Type: RelType.Image,
            Target: `../media/${bookImage.name}.${bookImage.extension}`
          });
          model.background = {
            rId
          };
          model.image = options.media[medium.imageId];
        } else if (medium.type === "image") {
          let { drawing } = model;
          bookImage = options.media[medium.imageId];
          if (!drawing) {
            drawing = model.drawing = {
              rId: nextRid(rels),
              name: `drawing${++options.drawingsCount}`,
              anchors: [],
              rels: []
            };
            options.drawings.push(drawing);
            rels.push({
              Id: drawing.rId,
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
              Target: `../drawings/${drawing.name}.xml`
            });
          }
          let rIdImage = this.preImageId === medium.imageId ? drawingRelsHash[medium.imageId] : drawingRelsHash[drawing.rels.length];
          if (!rIdImage) {
            rIdImage = nextRid(drawing.rels);
            drawingRelsHash[drawing.rels.length] = rIdImage;
            drawing.rels.push({
              Id: rIdImage,
              Type: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
              Target: `../media/${bookImage.name}.${bookImage.extension}`
            });
          }
          const anchor2 = {
            picture: {
              rId: rIdImage
            },
            range: medium.range
          };
          if (medium.hyperlinks && medium.hyperlinks.hyperlink) {
            const rIdHyperLink = nextRid(drawing.rels);
            drawingRelsHash[drawing.rels.length] = rIdHyperLink;
            anchor2.picture.hyperlinks = {
              tooltip: medium.hyperlinks.tooltip,
              rId: rIdHyperLink
            };
            drawing.rels.push({
              Id: rIdHyperLink,
              Type: RelType.Hyperlink,
              Target: medium.hyperlinks.hyperlink,
              TargetMode: "External"
            });
          }
          this.preImageId = medium.imageId;
          drawing.anchors.push(anchor2);
        }
      });
      model.tables.forEach((table2) => {
        const rId = nextRid(rels);
        table2.rId = rId;
        rels.push({
          Id: rId,
          Type: RelType.Table,
          Target: `../tables/${table2.target}`
        });
        table2.columns.forEach((column2) => {
          const { style } = column2;
          if (style) {
            column2.dxfId = options.styles.addDxfStyle(style);
          }
        });
      });
      this.map.extLst.prepare(model, options);
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode("worksheet", WorkSheetXform.WORKSHEET_ATTRIBUTES);
      const sheetFormatPropertiesModel = model.properties ? {
        defaultRowHeight: model.properties.defaultRowHeight,
        dyDescent: model.properties.dyDescent,
        outlineLevelCol: model.properties.outlineLevelCol,
        outlineLevelRow: model.properties.outlineLevelRow
      } : void 0;
      if (model.properties && model.properties.defaultColWidth) {
        sheetFormatPropertiesModel.defaultColWidth = model.properties.defaultColWidth;
      }
      const sheetPropertiesModel = {
        outlineProperties: model.properties && model.properties.outlineProperties,
        tabColor: model.properties && model.properties.tabColor,
        pageSetup: model.pageSetup && model.pageSetup.fitToPage ? {
          fitToPage: model.pageSetup.fitToPage
        } : void 0
      };
      const pageMarginsModel = model.pageSetup && model.pageSetup.margins;
      const printOptionsModel = {
        showRowColHeaders: model.pageSetup && model.pageSetup.showRowColHeaders,
        showGridLines: model.pageSetup && model.pageSetup.showGridLines,
        horizontalCentered: model.pageSetup && model.pageSetup.horizontalCentered,
        verticalCentered: model.pageSetup && model.pageSetup.verticalCentered
      };
      const sheetProtectionModel = model.sheetProtection;
      this.map.sheetPr.render(xmlStream2, sheetPropertiesModel);
      this.map.dimension.render(xmlStream2, model.dimensions);
      this.map.sheetViews.render(xmlStream2, model.views);
      this.map.sheetFormatPr.render(xmlStream2, sheetFormatPropertiesModel);
      this.map.cols.render(xmlStream2, model.cols);
      this.map.sheetData.render(xmlStream2, model.rows);
      this.map.sheetProtection.render(xmlStream2, sheetProtectionModel);
      this.map.autoFilter.render(xmlStream2, model.autoFilter);
      this.map.mergeCells.render(xmlStream2, model.mergeCells);
      this.map.conditionalFormatting.render(xmlStream2, model.conditionalFormattings);
      this.map.dataValidations.render(xmlStream2, model.dataValidations);
      this.map.hyperlinks.render(xmlStream2, model.hyperlinks);
      this.map.printOptions.render(xmlStream2, printOptionsModel);
      this.map.pageMargins.render(xmlStream2, pageMarginsModel);
      this.map.pageSetup.render(xmlStream2, model.pageSetup);
      this.map.headerFooter.render(xmlStream2, model.headerFooter);
      this.map.rowBreaks.render(xmlStream2, model.rowBreaks);
      this.map.drawing.render(xmlStream2, model.drawing);
      this.map.picture.render(xmlStream2, model.background);
      this.map.tableParts.render(xmlStream2, model.tables);
      this.map.extLst.render(xmlStream2, model);
      if (model.rels) {
        model.rels.forEach((rel) => {
          if (rel.Type === RelType.VmlDrawing) {
            xmlStream2.leafNode("legacyDrawing", { "r:id": rel.Id });
          }
        });
      }
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      if (node2.name === "worksheet") {
        _2.each(this.map, (xform) => {
          xform.reset();
        });
        return true;
      }
      if (this.map[node2.name] && !this.ignoreNodes.includes(node2.name)) {
        this.parser = this.map[node2.name];
        this.parser.parseOpen(node2);
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case "worksheet": {
          const properties = this.map.sheetFormatPr.model || {};
          if (this.map.sheetPr.model && this.map.sheetPr.model.tabColor) {
            properties.tabColor = this.map.sheetPr.model.tabColor;
          }
          if (this.map.sheetPr.model && this.map.sheetPr.model.outlineProperties) {
            properties.outlineProperties = this.map.sheetPr.model.outlineProperties;
          }
          const sheetProperties = {
            fitToPage: this.map.sheetPr.model && this.map.sheetPr.model.pageSetup && this.map.sheetPr.model.pageSetup.fitToPage || false,
            margins: this.map.pageMargins.model
          };
          const pageSetup = Object.assign(sheetProperties, this.map.pageSetup.model, this.map.printOptions.model);
          const conditionalFormattings = mergeConditionalFormattings(
            this.map.conditionalFormatting.model,
            this.map.extLst.model && this.map.extLst.model["x14:conditionalFormattings"]
          );
          this.model = {
            dimensions: this.map.dimension.model,
            cols: this.map.cols.model,
            rows: this.map.sheetData.model,
            mergeCells: this.map.mergeCells.model,
            hyperlinks: this.map.hyperlinks.model,
            dataValidations: this.map.dataValidations.model,
            properties,
            views: this.map.sheetViews.model,
            pageSetup,
            headerFooter: this.map.headerFooter.model,
            background: this.map.picture.model,
            drawing: this.map.drawing.model,
            tables: this.map.tableParts.model,
            conditionalFormattings
          };
          if (this.map.autoFilter.model) {
            this.model.autoFilter = this.map.autoFilter.model;
          }
          if (this.map.sheetProtection.model) {
            this.model.sheetProtection = this.map.sheetProtection.model;
          }
          return false;
        }
        default:
          return true;
      }
    }
    reconcile(model, options) {
      const rels = (model.relationships || []).reduce((h, rel) => {
        h[rel.Id] = rel;
        if (rel.Type === RelType.Comments) {
          model.comments = options.comments[rel.Target].comments;
        }
        if (rel.Type === RelType.VmlDrawing && model.comments && model.comments.length) {
          const vmlComment = options.vmlDrawings[rel.Target].comments;
          model.comments.forEach((comment, index2) => {
            comment.note = Object.assign({}, comment.note, vmlComment[index2]);
          });
        }
        return h;
      }, {});
      options.commentsMap = (model.comments || []).reduce((h, comment) => {
        if (comment.ref) {
          h[comment.ref] = comment;
        }
        return h;
      }, {});
      options.hyperlinkMap = (model.hyperlinks || []).reduce((h, hyperlink) => {
        if (hyperlink.rId) {
          h[hyperlink.address] = rels[hyperlink.rId].Target;
        }
        return h;
      }, {});
      options.formulae = {};
      model.rows = model.rows && model.rows.filter(Boolean) || [];
      model.rows.forEach((row2) => {
        row2.cells = row2.cells && row2.cells.filter(Boolean) || [];
      });
      this.map.cols.reconcile(model.cols, options);
      this.map.sheetData.reconcile(model.rows, options);
      this.map.conditionalFormatting.reconcile(model.conditionalFormattings, options);
      model.media = [];
      if (model.drawing) {
        const drawingRel = rels[model.drawing.rId];
        const match = drawingRel.Target.match(/\/drawings\/([a-zA-Z0-9]+)[.][a-zA-Z]{3,4}$/);
        if (match) {
          const drawingName = match[1];
          const drawing = options.drawings[drawingName];
          drawing.anchors.forEach((anchor2) => {
            if (anchor2.medium) {
              const image2 = {
                type: "image",
                imageId: anchor2.medium.index,
                range: anchor2.range,
                hyperlinks: anchor2.picture.hyperlinks
              };
              model.media.push(image2);
            }
          });
        }
      }
      const backgroundRel = model.background && rels[model.background.rId];
      if (backgroundRel) {
        const target = backgroundRel.Target.split("/media/")[1];
        const imageId = options.mediaIndex && options.mediaIndex[target];
        if (imageId !== void 0) {
          model.media.push({
            type: "background",
            imageId
          });
        }
      }
      model.tables = (model.tables || []).map((tablePart) => {
        const rel = rels[tablePart.rId];
        return options.tables[rel.Target];
      });
      delete model.relationships;
      delete model.hyperlinks;
      delete model.comments;
    }
  }
  WorkSheetXform.WORKSHEET_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "x14ac",
    "xmlns:x14ac": "http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac"
  };
  worksheetXform = WorkSheetXform;
  return worksheetXform;
}
var baseCellAnchorXform;
var hasRequiredBaseCellAnchorXform;
function requireBaseCellAnchorXform() {
  if (hasRequiredBaseCellAnchorXform) return baseCellAnchorXform;
  hasRequiredBaseCellAnchorXform = 1;
  const BaseXform = requireBaseXform();
  class BaseCellAnchorXform extends BaseXform {
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          this.model = {
            range: {
              editAs: node2.attributes.editAs || "oneCell"
            }
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    reconcilePicture(model, options) {
      if (model && model.rId) {
        const rel = options.rels[model.rId];
        const match = rel.Target.match(/.*\/media\/(.+[.][a-zA-Z]{3,4})/);
        if (match) {
          const name = match[1];
          const mediaId = options.mediaIndex[name];
          return options.media[mediaId];
        }
      }
      return void 0;
    }
  }
  baseCellAnchorXform = BaseCellAnchorXform;
  return baseCellAnchorXform;
}
var cellPositionXform;
var hasRequiredCellPositionXform;
function requireCellPositionXform() {
  if (hasRequiredCellPositionXform) return cellPositionXform;
  hasRequiredCellPositionXform = 1;
  const BaseXform = requireBaseXform();
  const IntegerXform = requireIntegerXform();
  class CellPositionXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.map = {
        "xdr:col": new IntegerXform({ tag: "xdr:col", zero: true }),
        "xdr:colOff": new IntegerXform({ tag: "xdr:colOff", zero: true }),
        "xdr:row": new IntegerXform({ tag: "xdr:row", zero: true }),
        "xdr:rowOff": new IntegerXform({ tag: "xdr:rowOff", zero: true })
      };
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      this.map["xdr:col"].render(xmlStream2, model.nativeCol);
      this.map["xdr:colOff"].render(xmlStream2, model.nativeColOff);
      this.map["xdr:row"].render(xmlStream2, model.nativeRow);
      this.map["xdr:rowOff"].render(xmlStream2, model.nativeRowOff);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model = {
            nativeCol: this.map["xdr:col"].model,
            nativeColOff: this.map["xdr:colOff"].model,
            nativeRow: this.map["xdr:row"].model,
            nativeRowOff: this.map["xdr:rowOff"].model
          };
          return false;
        default:
          return true;
      }
    }
  }
  cellPositionXform = CellPositionXform;
  return cellPositionXform;
}
var blipXform;
var hasRequiredBlipXform;
function requireBlipXform() {
  if (hasRequiredBlipXform) return blipXform;
  hasRequiredBlipXform = 1;
  const BaseXform = requireBaseXform();
  class BlipXform extends BaseXform {
    get tag() {
      return "a:blip";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "r:embed": model.rId,
        cstate: "print"
      });
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            rId: node2.attributes["r:embed"]
          };
          return true;
        default:
          return true;
      }
    }
    parseText() {
    }
    parseClose(name) {
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  blipXform = BlipXform;
  return blipXform;
}
var blipFillXform;
var hasRequiredBlipFillXform;
function requireBlipFillXform() {
  if (hasRequiredBlipFillXform) return blipFillXform;
  hasRequiredBlipFillXform = 1;
  const BaseXform = requireBaseXform();
  const BlipXform = requireBlipXform();
  class BlipFillXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "a:blip": new BlipXform()
      };
    }
    get tag() {
      return "xdr:blipFill";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      this.map["a:blip"].render(xmlStream2, model);
      xmlStream2.openNode("a:stretch");
      xmlStream2.leafNode("a:fillRect");
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model = this.map["a:blip"].model;
          return false;
        default:
          return true;
      }
    }
  }
  blipFillXform = BlipFillXform;
  return blipFillXform;
}
var hlinkClickXform;
var hasRequiredHlinkClickXform;
function requireHlinkClickXform() {
  if (hasRequiredHlinkClickXform) return hlinkClickXform;
  hasRequiredHlinkClickXform = 1;
  const BaseXform = requireBaseXform();
  class HLinkClickXform extends BaseXform {
    get tag() {
      return "a:hlinkClick";
    }
    render(xmlStream2, model) {
      if (!(model.hyperlinks && model.hyperlinks.rId)) {
        return;
      }
      xmlStream2.leafNode(this.tag, {
        "xmlns:r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
        "r:id": model.hyperlinks.rId,
        tooltip: model.hyperlinks.tooltip
      });
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            hyperlinks: {
              rId: node2.attributes["r:id"],
              tooltip: node2.attributes.tooltip
            }
          };
          return true;
        default:
          return true;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  hlinkClickXform = HLinkClickXform;
  return hlinkClickXform;
}
var extLstXform;
var hasRequiredExtLstXform;
function requireExtLstXform() {
  if (hasRequiredExtLstXform) return extLstXform;
  hasRequiredExtLstXform = 1;
  const BaseXform = requireBaseXform();
  class ExtLstXform extends BaseXform {
    get tag() {
      return "a:extLst";
    }
    render(xmlStream2) {
      xmlStream2.openNode(this.tag);
      xmlStream2.openNode("a:ext", {
        uri: "{FF2B5EF4-FFF2-40B4-BE49-F238E27FC236}"
      });
      xmlStream2.leafNode("a16:creationId", {
        "xmlns:a16": "http://schemas.microsoft.com/office/drawing/2014/main",
        id: "{00000000-0008-0000-0000-000002000000}"
      });
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          return true;
        default:
          return true;
      }
    }
    parseText() {
    }
    parseClose(name) {
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  extLstXform = ExtLstXform;
  return extLstXform;
}
var cNvPrXform;
var hasRequiredCNvPrXform;
function requireCNvPrXform() {
  if (hasRequiredCNvPrXform) return cNvPrXform;
  hasRequiredCNvPrXform = 1;
  const BaseXform = requireBaseXform();
  const HlickClickXform = requireHlinkClickXform();
  const ExtLstXform = requireExtLstXform();
  class CNvPrXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "a:hlinkClick": new HlickClickXform(),
        "a:extLst": new ExtLstXform()
      };
    }
    get tag() {
      return "xdr:cNvPr";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, {
        id: model.index,
        name: `Picture ${model.index}`
      });
      this.map["a:hlinkClick"].render(xmlStream2, model);
      this.map["a:extLst"].render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model = this.map["a:hlinkClick"].model;
          return false;
        default:
          return true;
      }
    }
  }
  cNvPrXform = CNvPrXform;
  return cNvPrXform;
}
var cNvPicPrXform;
var hasRequiredCNvPicPrXform;
function requireCNvPicPrXform() {
  if (hasRequiredCNvPicPrXform) return cNvPicPrXform;
  hasRequiredCNvPicPrXform = 1;
  const BaseXform = requireBaseXform();
  class CNvPicPrXform extends BaseXform {
    get tag() {
      return "xdr:cNvPicPr";
    }
    render(xmlStream2) {
      xmlStream2.openNode(this.tag);
      xmlStream2.leafNode("a:picLocks", {
        noChangeAspect: "1"
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          return true;
        default:
          return true;
      }
    }
    parseText() {
    }
    parseClose(name) {
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  cNvPicPrXform = CNvPicPrXform;
  return cNvPicPrXform;
}
var nvPicPrXform;
var hasRequiredNvPicPrXform;
function requireNvPicPrXform() {
  if (hasRequiredNvPicPrXform) return nvPicPrXform;
  hasRequiredNvPicPrXform = 1;
  const BaseXform = requireBaseXform();
  const CNvPrXform = requireCNvPrXform();
  const CNvPicPrXform = requireCNvPicPrXform();
  class NvPicPrXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "xdr:cNvPr": new CNvPrXform(),
        "xdr:cNvPicPr": new CNvPicPrXform()
      };
    }
    get tag() {
      return "xdr:nvPicPr";
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      this.map["xdr:cNvPr"].render(xmlStream2, model);
      this.map["xdr:cNvPicPr"].render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model = this.map["xdr:cNvPr"].model;
          return false;
        default:
          return true;
      }
    }
  }
  nvPicPrXform = NvPicPrXform;
  return nvPicPrXform;
}
var spPr;
var hasRequiredSpPr;
function requireSpPr() {
  if (hasRequiredSpPr) return spPr;
  hasRequiredSpPr = 1;
  spPr = {
    tag: "xdr:spPr",
    c: [
      {
        tag: "a:xfrm",
        c: [
          { tag: "a:off", $: { x: "0", y: "0" } },
          { tag: "a:ext", $: { cx: "0", cy: "0" } }
        ]
      },
      {
        tag: "a:prstGeom",
        $: { prst: "rect" },
        c: [{ tag: "a:avLst" }]
      }
    ]
  };
  return spPr;
}
var picXform;
var hasRequiredPicXform;
function requirePicXform() {
  if (hasRequiredPicXform) return picXform;
  hasRequiredPicXform = 1;
  const BaseXform = requireBaseXform();
  const StaticXform = requireStaticXform();
  const BlipFillXform = requireBlipFillXform();
  const NvPicPrXform = requireNvPicPrXform();
  const spPrJSON = requireSpPr();
  class PicXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "xdr:nvPicPr": new NvPicPrXform(),
        "xdr:blipFill": new BlipFillXform(),
        "xdr:spPr": new StaticXform(spPrJSON)
      };
    }
    get tag() {
      return "xdr:pic";
    }
    prepare(model, options) {
      model.index = options.index + 1;
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      this.map["xdr:nvPicPr"].render(xmlStream2, model);
      this.map["xdr:blipFill"].render(xmlStream2, model);
      this.map["xdr:spPr"].render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.mergeModel(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  picXform = PicXform;
  return picXform;
}
var twoCellAnchorXform;
var hasRequiredTwoCellAnchorXform;
function requireTwoCellAnchorXform() {
  if (hasRequiredTwoCellAnchorXform) return twoCellAnchorXform;
  hasRequiredTwoCellAnchorXform = 1;
  const BaseCellAnchorXform = requireBaseCellAnchorXform();
  const StaticXform = requireStaticXform();
  const CellPositionXform = requireCellPositionXform();
  const PicXform = requirePicXform();
  class TwoCellAnchorXform extends BaseCellAnchorXform {
    constructor() {
      super();
      this.map = {
        "xdr:from": new CellPositionXform({ tag: "xdr:from" }),
        "xdr:to": new CellPositionXform({ tag: "xdr:to" }),
        "xdr:pic": new PicXform(),
        "xdr:clientData": new StaticXform({ tag: "xdr:clientData" })
      };
    }
    get tag() {
      return "xdr:twoCellAnchor";
    }
    prepare(model, options) {
      this.map["xdr:pic"].prepare(model.picture, options);
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
      this.map["xdr:from"].render(xmlStream2, model.range.tl);
      this.map["xdr:to"].render(xmlStream2, model.range.br);
      this.map["xdr:pic"].render(xmlStream2, model.picture);
      this.map["xdr:clientData"].render(xmlStream2, {});
      xmlStream2.closeNode();
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model.range.tl = this.map["xdr:from"].model;
          this.model.range.br = this.map["xdr:to"].model;
          this.model.picture = this.map["xdr:pic"].model;
          return false;
        default:
          return true;
      }
    }
    reconcile(model, options) {
      model.medium = this.reconcilePicture(model.picture, options);
    }
  }
  twoCellAnchorXform = TwoCellAnchorXform;
  return twoCellAnchorXform;
}
var extXform;
var hasRequiredExtXform;
function requireExtXform() {
  if (hasRequiredExtXform) return extXform;
  hasRequiredExtXform = 1;
  const BaseXform = requireBaseXform();
  const EMU_PER_PIXEL_AT_96_DPI = 9525;
  class ExtXform extends BaseXform {
    constructor(options) {
      super();
      this.tag = options.tag;
      this.map = {};
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag);
      const width = Math.floor(model.width * EMU_PER_PIXEL_AT_96_DPI);
      const height = Math.floor(model.height * EMU_PER_PIXEL_AT_96_DPI);
      xmlStream2.addAttribute("cx", width);
      xmlStream2.addAttribute("cy", height);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = {
          width: parseInt(node2.attributes.cx || "0", 10) / EMU_PER_PIXEL_AT_96_DPI,
          height: parseInt(node2.attributes.cy || "0", 10) / EMU_PER_PIXEL_AT_96_DPI
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  extXform = ExtXform;
  return extXform;
}
var oneCellAnchorXform;
var hasRequiredOneCellAnchorXform;
function requireOneCellAnchorXform() {
  if (hasRequiredOneCellAnchorXform) return oneCellAnchorXform;
  hasRequiredOneCellAnchorXform = 1;
  const BaseCellAnchorXform = requireBaseCellAnchorXform();
  const StaticXform = requireStaticXform();
  const CellPositionXform = requireCellPositionXform();
  const ExtXform = requireExtXform();
  const PicXform = requirePicXform();
  class OneCellAnchorXform extends BaseCellAnchorXform {
    constructor() {
      super();
      this.map = {
        "xdr:from": new CellPositionXform({ tag: "xdr:from" }),
        "xdr:ext": new ExtXform({ tag: "xdr:ext" }),
        "xdr:pic": new PicXform(),
        "xdr:clientData": new StaticXform({ tag: "xdr:clientData" })
      };
    }
    get tag() {
      return "xdr:oneCellAnchor";
    }
    prepare(model, options) {
      this.map["xdr:pic"].prepare(model.picture, options);
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, { editAs: model.range.editAs || "oneCell" });
      this.map["xdr:from"].render(xmlStream2, model.range.tl);
      this.map["xdr:ext"].render(xmlStream2, model.range.ext);
      this.map["xdr:pic"].render(xmlStream2, model.picture);
      this.map["xdr:clientData"].render(xmlStream2, {});
      xmlStream2.closeNode();
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model.range.tl = this.map["xdr:from"].model;
          this.model.range.ext = this.map["xdr:ext"].model;
          this.model.picture = this.map["xdr:pic"].model;
          return false;
        default:
          return true;
      }
    }
    reconcile(model, options) {
      model.medium = this.reconcilePicture(model.picture, options);
    }
  }
  oneCellAnchorXform = OneCellAnchorXform;
  return oneCellAnchorXform;
}
var drawingXform;
var hasRequiredDrawingXform;
function requireDrawingXform() {
  if (hasRequiredDrawingXform) return drawingXform;
  hasRequiredDrawingXform = 1;
  const colCache = requireColCache();
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const TwoCellAnchorXform = requireTwoCellAnchorXform();
  const OneCellAnchorXform = requireOneCellAnchorXform();
  function getAnchorType(model) {
    const range2 = typeof model.range === "string" ? colCache.decode(model.range) : model.range;
    return range2.br ? "xdr:twoCellAnchor" : "xdr:oneCellAnchor";
  }
  class DrawingXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "xdr:twoCellAnchor": new TwoCellAnchorXform(),
        "xdr:oneCellAnchor": new OneCellAnchorXform()
      };
    }
    prepare(model) {
      model.anchors.forEach((item, index2) => {
        item.anchorType = getAnchorType(item);
        const anchor2 = this.map[item.anchorType];
        anchor2.prepare(item, { index: index2 });
      });
    }
    get tag() {
      return "xdr:wsDr";
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode(this.tag, DrawingXform.DRAWING_ATTRIBUTES);
      model.anchors.forEach((item) => {
        const anchor2 = this.map[item.anchorType];
        anchor2.render(xmlStream2, item);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          this.model = {
            anchors: []
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.anchors.push(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
    reconcile(model, options) {
      model.anchors.forEach((anchor2) => {
        if (anchor2.br) {
          this.map["xdr:twoCellAnchor"].reconcile(anchor2, options);
        } else {
          this.map["xdr:oneCellAnchor"].reconcile(anchor2, options);
        }
      });
    }
  }
  DrawingXform.DRAWING_ATTRIBUTES = {
    "xmlns:xdr": "http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing",
    "xmlns:a": "http://schemas.openxmlformats.org/drawingml/2006/main"
  };
  drawingXform = DrawingXform;
  return drawingXform;
}
var customFilterXform;
var hasRequiredCustomFilterXform;
function requireCustomFilterXform() {
  if (hasRequiredCustomFilterXform) return customFilterXform;
  hasRequiredCustomFilterXform = 1;
  const BaseXform = requireBaseXform();
  class CustomFilterXform extends BaseXform {
    get tag() {
      return "customFilter";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        val: model.val,
        operator: model.operator
      });
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = {
          val: node2.attributes.val,
          operator: node2.attributes.operator
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  customFilterXform = CustomFilterXform;
  return customFilterXform;
}
var filterXform;
var hasRequiredFilterXform;
function requireFilterXform() {
  if (hasRequiredFilterXform) return filterXform;
  hasRequiredFilterXform = 1;
  const BaseXform = requireBaseXform();
  class FilterXform extends BaseXform {
    get tag() {
      return "filter";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        val: model.val
      });
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        this.model = {
          val: node2.attributes.val
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  filterXform = FilterXform;
  return filterXform;
}
var filterColumnXform;
var hasRequiredFilterColumnXform;
function requireFilterColumnXform() {
  if (hasRequiredFilterColumnXform) return filterColumnXform;
  hasRequiredFilterColumnXform = 1;
  const BaseXform = requireBaseXform();
  const ListXform = requireListXform();
  const CustomFilterXform = requireCustomFilterXform();
  const FilterXform = requireFilterXform();
  class FilterColumnXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        customFilters: new ListXform({
          tag: "customFilters",
          count: false,
          empty: true,
          childXform: new CustomFilterXform()
        }),
        filters: new ListXform({
          tag: "filters",
          count: false,
          empty: true,
          childXform: new FilterXform()
        })
      };
    }
    get tag() {
      return "filterColumn";
    }
    prepare(model, options) {
      model.colId = options.index.toString();
    }
    render(xmlStream2, model) {
      if (model.customFilters) {
        xmlStream2.openNode(this.tag, {
          colId: model.colId,
          hiddenButton: model.filterButton ? "0" : "1"
        });
        this.map.customFilters.render(xmlStream2, model.customFilters);
        xmlStream2.closeNode();
        return true;
      }
      xmlStream2.leafNode(this.tag, {
        colId: model.colId,
        hiddenButton: model.filterButton ? "0" : "1"
      });
      return true;
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      const { attributes } = node2;
      switch (node2.name) {
        case this.tag:
          this.model = {
            filterButton: attributes.hiddenButton === "0"
          };
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parseOpen(node2);
            return true;
          }
          throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
      }
    }
    parseText() {
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model.customFilters = this.map.customFilters.model;
          return false;
        default:
          return true;
      }
    }
  }
  filterColumnXform = FilterColumnXform;
  return filterColumnXform;
}
var autoFilterXform;
var hasRequiredAutoFilterXform;
function requireAutoFilterXform() {
  if (hasRequiredAutoFilterXform) return autoFilterXform;
  hasRequiredAutoFilterXform = 1;
  const BaseXform = requireBaseXform();
  const FilterColumnXform = requireFilterColumnXform();
  class AutoFilterXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        filterColumn: new FilterColumnXform()
      };
    }
    get tag() {
      return "autoFilter";
    }
    prepare(model) {
      model.columns.forEach((column2, index2) => {
        this.map.filterColumn.prepare(column2, { index: index2 });
      });
    }
    render(xmlStream2, model) {
      xmlStream2.openNode(this.tag, { ref: model.autoFilterRef });
      model.columns.forEach((column2) => {
        this.map.filterColumn.render(xmlStream2, column2);
      });
      xmlStream2.closeNode();
      return true;
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.model = {
            autoFilterRef: node2.attributes.ref,
            columns: []
          };
          return true;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parseOpen(node2);
            return true;
          }
          throw new Error(`Unexpected xml node in parseOpen: ${JSON.stringify(node2)}`);
      }
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.columns.push(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          throw new Error(`Unexpected xml node in parseClose: ${name}`);
      }
    }
  }
  autoFilterXform = AutoFilterXform;
  return autoFilterXform;
}
var tableColumnXform;
var hasRequiredTableColumnXform;
function requireTableColumnXform() {
  if (hasRequiredTableColumnXform) return tableColumnXform;
  hasRequiredTableColumnXform = 1;
  const BaseXform = requireBaseXform();
  class TableColumnXform extends BaseXform {
    get tag() {
      return "tableColumn";
    }
    prepare(model, options) {
      model.id = options.index + 1;
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        id: model.id.toString(),
        name: model.name,
        totalsRowLabel: model.totalsRowLabel,
        totalsRowFunction: model.totalsRowFunction,
        dxfId: model.dxfId
      });
      return true;
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        const { attributes } = node2;
        this.model = {
          name: attributes.name,
          totalsRowLabel: attributes.totalsRowLabel,
          totalsRowFunction: attributes.totalsRowFunction,
          dxfId: attributes.dxfId
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  tableColumnXform = TableColumnXform;
  return tableColumnXform;
}
var tableStyleInfoXform;
var hasRequiredTableStyleInfoXform;
function requireTableStyleInfoXform() {
  if (hasRequiredTableStyleInfoXform) return tableStyleInfoXform;
  hasRequiredTableStyleInfoXform = 1;
  const BaseXform = requireBaseXform();
  class TableStyleInfoXform extends BaseXform {
    get tag() {
      return "tableStyleInfo";
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, {
        name: model.theme ? model.theme : void 0,
        showFirstColumn: model.showFirstColumn ? "1" : "0",
        showLastColumn: model.showLastColumn ? "1" : "0",
        showRowStripes: model.showRowStripes ? "1" : "0",
        showColumnStripes: model.showColumnStripes ? "1" : "0"
      });
      return true;
    }
    parseOpen(node2) {
      if (node2.name === this.tag) {
        const { attributes } = node2;
        this.model = {
          theme: attributes.name ? attributes.name : null,
          showFirstColumn: attributes.showFirstColumn === "1",
          showLastColumn: attributes.showLastColumn === "1",
          showRowStripes: attributes.showRowStripes === "1",
          showColumnStripes: attributes.showColumnStripes === "1"
        };
        return true;
      }
      return false;
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  tableStyleInfoXform = TableStyleInfoXform;
  return tableStyleInfoXform;
}
var tableXform;
var hasRequiredTableXform;
function requireTableXform() {
  if (hasRequiredTableXform) return tableXform;
  hasRequiredTableXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const ListXform = requireListXform();
  const AutoFilterXform = requireAutoFilterXform();
  const TableColumnXform = requireTableColumnXform();
  const TableStyleInfoXform = requireTableStyleInfoXform();
  class TableXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        autoFilter: new AutoFilterXform(),
        tableColumns: new ListXform({
          tag: "tableColumns",
          count: true,
          empty: true,
          childXform: new TableColumnXform()
        }),
        tableStyleInfo: new TableStyleInfoXform()
      };
    }
    prepare(model, options) {
      this.map.autoFilter.prepare(model);
      this.map.tableColumns.prepare(model.columns, options);
    }
    get tag() {
      return "table";
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode(this.tag, {
        ...TableXform.TABLE_ATTRIBUTES,
        id: model.id,
        name: model.name,
        displayName: model.displayName || model.name,
        ref: model.tableRef,
        totalsRowCount: model.totalsRow ? "1" : void 0,
        totalsRowShown: model.totalsRow ? void 0 : "1",
        headerRowCount: model.headerRow ? "1" : "0"
      });
      this.map.autoFilter.render(xmlStream2, model);
      this.map.tableColumns.render(xmlStream2, model.columns);
      this.map.tableStyleInfo.render(xmlStream2, model.style);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      const { name, attributes } = node2;
      switch (name) {
        case this.tag:
          this.reset();
          this.model = {
            name: attributes.name,
            displayName: attributes.displayName || attributes.name,
            tableRef: attributes.ref,
            totalsRow: attributes.totalsRowCount === "1",
            headerRow: attributes.headerRowCount === "1"
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model.columns = this.map.tableColumns.model;
          if (this.map.autoFilter.model) {
            this.model.autoFilterRef = this.map.autoFilter.model.autoFilterRef;
            this.map.autoFilter.model.columns.forEach((column2, index2) => {
              this.model.columns[index2].filterButton = column2.filterButton;
            });
          }
          this.model.style = this.map.tableStyleInfo.model;
          return false;
        default:
          return true;
      }
    }
    reconcile(model, options) {
      model.columns.forEach((column2) => {
        if (column2.dxfId !== void 0) {
          column2.style = options.styles.getDxfStyle(column2.dxfId);
        }
      });
    }
  }
  TableXform.TABLE_ATTRIBUTES = {
    xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
    "xmlns:mc": "http://schemas.openxmlformats.org/markup-compatibility/2006",
    "mc:Ignorable": "xr xr3",
    "xmlns:xr": "http://schemas.microsoft.com/office/spreadsheetml/2014/revision",
    "xmlns:xr3": "http://schemas.microsoft.com/office/spreadsheetml/2016/revision3"
    // 'xr:uid': '{00000000-000C-0000-FFFF-FFFF00000000}',
  };
  tableXform = TableXform;
  return tableXform;
}
var commentsXform = { exports: {} };
var commentXform = { exports: {} };
var hasRequiredCommentXform;
function requireCommentXform() {
  if (hasRequiredCommentXform) return commentXform.exports;
  hasRequiredCommentXform = 1;
  const RichTextXform = requireRichTextXform();
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  const CommentXform = commentXform.exports = function(model) {
    this.model = model;
  };
  utils2.inherits(CommentXform, BaseXform, {
    get tag() {
      return "r";
    },
    get richTextXform() {
      if (!this._richTextXform) {
        this._richTextXform = new RichTextXform();
      }
      return this._richTextXform;
    },
    render(xmlStream2, model) {
      model = model || this.model;
      xmlStream2.openNode("comment", {
        ref: model.ref,
        authorId: 0
      });
      xmlStream2.openNode("text");
      if (model && model.note && model.note.texts) {
        model.note.texts.forEach((text) => {
          this.richTextXform.render(xmlStream2, text);
        });
      }
      xmlStream2.closeNode();
      xmlStream2.closeNode();
    },
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case "comment":
          this.model = {
            type: "note",
            note: {
              texts: []
            },
            ...node2.attributes
          };
          return true;
        case "r":
          this.parser = this.richTextXform;
          this.parser.parseOpen(node2);
          return true;
        default:
          return false;
      }
    },
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    },
    parseClose(name) {
      switch (name) {
        case "comment":
          return false;
        case "r":
          this.model.note.texts.push(this.parser.model);
          this.parser = void 0;
          return true;
        default:
          if (this.parser) {
            this.parser.parseClose(name);
          }
          return true;
      }
    }
  });
  return commentXform.exports;
}
var hasRequiredCommentsXform;
function requireCommentsXform() {
  if (hasRequiredCommentsXform) return commentsXform.exports;
  hasRequiredCommentsXform = 1;
  const XmlStream = requireXmlStream();
  const utils2 = requireUtils();
  const BaseXform = requireBaseXform();
  const CommentXform = requireCommentXform();
  const CommentsXform = commentsXform.exports = function() {
    this.map = {
      comment: new CommentXform()
    };
  };
  utils2.inherits(
    CommentsXform,
    BaseXform,
    {
      COMMENTS_ATTRIBUTES: {
        xmlns: "http://schemas.openxmlformats.org/spreadsheetml/2006/main"
      }
    },
    {
      render(xmlStream2, model) {
        model = model || this.model;
        xmlStream2.openXml(XmlStream.StdDocAttributes);
        xmlStream2.openNode("comments", CommentsXform.COMMENTS_ATTRIBUTES);
        xmlStream2.openNode("authors");
        xmlStream2.leafNode("author", null, "Author");
        xmlStream2.closeNode();
        xmlStream2.openNode("commentList");
        model.comments.forEach((comment) => {
          this.map.comment.render(xmlStream2, comment);
        });
        xmlStream2.closeNode();
        xmlStream2.closeNode();
      },
      parseOpen(node2) {
        if (this.parser) {
          this.parser.parseOpen(node2);
          return true;
        }
        switch (node2.name) {
          case "commentList":
            this.model = {
              comments: []
            };
            return true;
          case "comment":
            this.parser = this.map.comment;
            this.parser.parseOpen(node2);
            return true;
          default:
            return false;
        }
      },
      parseText(text) {
        if (this.parser) {
          this.parser.parseText(text);
        }
      },
      parseClose(name) {
        switch (name) {
          case "commentList":
            return false;
          case "comment":
            this.model.comments.push(this.parser.model);
            this.parser = void 0;
            return true;
          default:
            if (this.parser) {
              this.parser.parseClose(name);
            }
            return true;
        }
      }
    }
  );
  return commentsXform.exports;
}
var vmlTextboxXform;
var hasRequiredVmlTextboxXform;
function requireVmlTextboxXform() {
  if (hasRequiredVmlTextboxXform) return vmlTextboxXform;
  hasRequiredVmlTextboxXform = 1;
  const BaseXform = requireBaseXform();
  class VmlTextboxXform extends BaseXform {
    get tag() {
      return "v:textbox";
    }
    conversionUnit(value, multiple, unit) {
      return `${parseFloat(value) * multiple.toFixed(2)}${unit}`;
    }
    reverseConversionUnit(inset) {
      return (inset || "").split(",").map((margin) => {
        return Number(parseFloat(this.conversionUnit(parseFloat(margin), 0.1, "")).toFixed(2));
      });
    }
    render(xmlStream2, model) {
      const attributes = {
        style: "mso-direction-alt:auto"
      };
      if (model && model.note) {
        let { inset } = model.note && model.note.margins;
        if (Array.isArray(inset)) {
          inset = inset.map((margin) => {
            return this.conversionUnit(margin, 10, "mm");
          }).join(",");
        }
        if (inset) {
          attributes.inset = inset;
        }
      }
      xmlStream2.openNode("v:textbox", attributes);
      xmlStream2.leafNode("div", { style: "text-align:left" });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {
            inset: this.reverseConversionUnit(node2.attributes.inset)
          };
          return true;
        default:
          return true;
      }
    }
    parseText() {
    }
    parseClose(name) {
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
  }
  vmlTextboxXform = VmlTextboxXform;
  return vmlTextboxXform;
}
var vmlAnchorXform;
var hasRequiredVmlAnchorXform;
function requireVmlAnchorXform() {
  if (hasRequiredVmlAnchorXform) return vmlAnchorXform;
  hasRequiredVmlAnchorXform = 1;
  const BaseXform = requireBaseXform();
  class VmlAnchorXform extends BaseXform {
    get tag() {
      return "x:Anchor";
    }
    getAnchorRect(anchor2) {
      const l = Math.floor(anchor2.left);
      const lf = Math.floor((anchor2.left - l) * 68);
      const t = Math.floor(anchor2.top);
      const tf = Math.floor((anchor2.top - t) * 18);
      const r = Math.floor(anchor2.right);
      const rf = Math.floor((anchor2.right - r) * 68);
      const b = Math.floor(anchor2.bottom);
      const bf = Math.floor((anchor2.bottom - b) * 18);
      return [l, lf, t, tf, r, rf, b, bf];
    }
    getDefaultRect(ref2) {
      const l = ref2.col;
      const lf = 6;
      const t = Math.max(ref2.row - 2, 0);
      const tf = 14;
      const r = l + 2;
      const rf = 2;
      const b = t + 4;
      const bf = 16;
      return [l, lf, t, tf, r, rf, b, bf];
    }
    render(xmlStream2, model) {
      const rect = model.anchor ? this.getAnchorRect(model.anchor) : this.getDefaultRect(model.refAddress);
      xmlStream2.leafNode("x:Anchor", null, rect.join(", "));
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.text = "";
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      this.text = text;
    }
    parseClose() {
      return false;
    }
  }
  vmlAnchorXform = VmlAnchorXform;
  return vmlAnchorXform;
}
var vmlProtectionXform;
var hasRequiredVmlProtectionXform;
function requireVmlProtectionXform() {
  if (hasRequiredVmlProtectionXform) return vmlProtectionXform;
  hasRequiredVmlProtectionXform = 1;
  const BaseXform = requireBaseXform();
  class VmlProtectionXform extends BaseXform {
    constructor(model) {
      super();
      this._model = model;
    }
    get tag() {
      return this._model && this._model.tag;
    }
    render(xmlStream2, model) {
      xmlStream2.leafNode(this.tag, null, model);
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.text = "";
          return true;
        default:
          return false;
      }
    }
    parseText(text) {
      this.text = text;
    }
    parseClose() {
      return false;
    }
  }
  vmlProtectionXform = VmlProtectionXform;
  return vmlProtectionXform;
}
var vmlPositionXform;
var hasRequiredVmlPositionXform;
function requireVmlPositionXform() {
  if (hasRequiredVmlPositionXform) return vmlPositionXform;
  hasRequiredVmlPositionXform = 1;
  const BaseXform = requireBaseXform();
  class VmlPositionXform extends BaseXform {
    constructor(model) {
      super();
      this._model = model;
    }
    get tag() {
      return this._model && this._model.tag;
    }
    render(xmlStream2, model, type2) {
      if (model === type2[2]) {
        xmlStream2.leafNode(this.tag);
      } else if (this.tag === "x:SizeWithCells" && model === type2[1]) {
        xmlStream2.leafNode(this.tag);
      }
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.model = {};
          this.model[this.tag] = true;
          return true;
        default:
          return false;
      }
    }
    parseText() {
    }
    parseClose() {
      return false;
    }
  }
  vmlPositionXform = VmlPositionXform;
  return vmlPositionXform;
}
var vmlClientDataXform;
var hasRequiredVmlClientDataXform;
function requireVmlClientDataXform() {
  if (hasRequiredVmlClientDataXform) return vmlClientDataXform;
  hasRequiredVmlClientDataXform = 1;
  const BaseXform = requireBaseXform();
  const VmlAnchorXform = requireVmlAnchorXform();
  const VmlProtectionXform = requireVmlProtectionXform();
  const VmlPositionXform = requireVmlPositionXform();
  const POSITION_TYPE = ["twoCells", "oneCells", "absolute"];
  class VmlClientDataXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "x:Anchor": new VmlAnchorXform(),
        "x:Locked": new VmlProtectionXform({ tag: "x:Locked" }),
        "x:LockText": new VmlProtectionXform({ tag: "x:LockText" }),
        "x:SizeWithCells": new VmlPositionXform({ tag: "x:SizeWithCells" }),
        "x:MoveWithCells": new VmlPositionXform({ tag: "x:MoveWithCells" })
      };
    }
    get tag() {
      return "x:ClientData";
    }
    render(xmlStream2, model) {
      const { protection, editAs } = model.note;
      xmlStream2.openNode(this.tag, { ObjectType: "Note" });
      this.map["x:MoveWithCells"].render(xmlStream2, editAs, POSITION_TYPE);
      this.map["x:SizeWithCells"].render(xmlStream2, editAs, POSITION_TYPE);
      this.map["x:Anchor"].render(xmlStream2, model);
      this.map["x:Locked"].render(xmlStream2, protection.locked);
      xmlStream2.leafNode("x:AutoFill", null, "False");
      this.map["x:LockText"].render(xmlStream2, protection.lockText);
      xmlStream2.leafNode("x:Row", null, model.refAddress.row - 1);
      xmlStream2.leafNode("x:Column", null, model.refAddress.col - 1);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      switch (node2.name) {
        case this.tag:
          this.reset();
          this.model = {
            anchor: [],
            protection: {},
            editAs: ""
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.normalizeModel();
          return false;
        default:
          return true;
      }
    }
    normalizeModel() {
      const position = Object.assign(
        {},
        this.map["x:MoveWithCells"].model,
        this.map["x:SizeWithCells"].model
      );
      const len = Object.keys(position).length;
      this.model.editAs = POSITION_TYPE[len];
      this.model.anchor = this.map["x:Anchor"].text;
      this.model.protection.locked = this.map["x:Locked"].text;
      this.model.protection.lockText = this.map["x:LockText"].text;
    }
  }
  vmlClientDataXform = VmlClientDataXform;
  return vmlClientDataXform;
}
var vmlShapeXform;
var hasRequiredVmlShapeXform;
function requireVmlShapeXform() {
  if (hasRequiredVmlShapeXform) return vmlShapeXform;
  hasRequiredVmlShapeXform = 1;
  const BaseXform = requireBaseXform();
  const VmlTextboxXform = requireVmlTextboxXform();
  const VmlClientDataXform = requireVmlClientDataXform();
  class VmlShapeXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "v:textbox": new VmlTextboxXform(),
        "x:ClientData": new VmlClientDataXform()
      };
    }
    get tag() {
      return "v:shape";
    }
    render(xmlStream2, model, index2) {
      xmlStream2.openNode("v:shape", VmlShapeXform.V_SHAPE_ATTRIBUTES(model, index2));
      xmlStream2.leafNode("v:fill", { color2: "infoBackground [80]" });
      xmlStream2.leafNode("v:shadow", { color: "none [81]", obscured: "t" });
      xmlStream2.leafNode("v:path", { "o:connecttype": "none" });
      this.map["v:textbox"].render(xmlStream2, model);
      this.map["x:ClientData"].render(xmlStream2, model);
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          this.model = {
            margins: {
              insetmode: node2.attributes["o:insetmode"]
            },
            anchor: "",
            editAs: "",
            protection: {}
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          this.model.margins.inset = this.map["v:textbox"].model && this.map["v:textbox"].model.inset;
          this.model.protection = this.map["x:ClientData"].model && this.map["x:ClientData"].model.protection;
          this.model.anchor = this.map["x:ClientData"].model && this.map["x:ClientData"].model.anchor;
          this.model.editAs = this.map["x:ClientData"].model && this.map["x:ClientData"].model.editAs;
          return false;
        default:
          return true;
      }
    }
  }
  VmlShapeXform.V_SHAPE_ATTRIBUTES = (model, index2) => ({
    id: `_x0000_s${1025 + index2}`,
    type: "#_x0000_t202",
    style: "position:absolute; margin-left:105.3pt;margin-top:10.5pt;width:97.8pt;height:59.1pt;z-index:1;visibility:hidden",
    fillcolor: "infoBackground [80]",
    strokecolor: "none [81]",
    "o:insetmode": model.note.margins && model.note.margins.insetmode
  });
  vmlShapeXform = VmlShapeXform;
  return vmlShapeXform;
}
var vmlNotesXform;
var hasRequiredVmlNotesXform;
function requireVmlNotesXform() {
  if (hasRequiredVmlNotesXform) return vmlNotesXform;
  hasRequiredVmlNotesXform = 1;
  const XmlStream = requireXmlStream();
  const BaseXform = requireBaseXform();
  const VmlShapeXform = requireVmlShapeXform();
  class VmlNotesXform extends BaseXform {
    constructor() {
      super();
      this.map = {
        "v:shape": new VmlShapeXform()
      };
    }
    get tag() {
      return "xml";
    }
    render(xmlStream2, model) {
      xmlStream2.openXml(XmlStream.StdDocAttributes);
      xmlStream2.openNode(this.tag, VmlNotesXform.DRAWING_ATTRIBUTES);
      xmlStream2.openNode("o:shapelayout", { "v:ext": "edit" });
      xmlStream2.leafNode("o:idmap", { "v:ext": "edit", data: 1 });
      xmlStream2.closeNode();
      xmlStream2.openNode("v:shapetype", {
        id: "_x0000_t202",
        coordsize: "21600,21600",
        "o:spt": 202,
        path: "m,l,21600r21600,l21600,xe"
      });
      xmlStream2.leafNode("v:stroke", { joinstyle: "miter" });
      xmlStream2.leafNode("v:path", { gradientshapeok: "t", "o:connecttype": "rect" });
      xmlStream2.closeNode();
      model.comments.forEach((item, index2) => {
        this.map["v:shape"].render(xmlStream2, item, index2);
      });
      xmlStream2.closeNode();
    }
    parseOpen(node2) {
      if (this.parser) {
        this.parser.parseOpen(node2);
        return true;
      }
      switch (node2.name) {
        case this.tag:
          this.reset();
          this.model = {
            comments: []
          };
          break;
        default:
          this.parser = this.map[node2.name];
          if (this.parser) {
            this.parser.parseOpen(node2);
          }
          break;
      }
      return true;
    }
    parseText(text) {
      if (this.parser) {
        this.parser.parseText(text);
      }
    }
    parseClose(name) {
      if (this.parser) {
        if (!this.parser.parseClose(name)) {
          this.model.comments.push(this.parser.model);
          this.parser = void 0;
        }
        return true;
      }
      switch (name) {
        case this.tag:
          return false;
        default:
          return true;
      }
    }
    reconcile(model, options) {
      model.anchors.forEach((anchor2) => {
        if (anchor2.br) {
          this.map["xdr:twoCellAnchor"].reconcile(anchor2, options);
        } else {
          this.map["xdr:oneCellAnchor"].reconcile(anchor2, options);
        }
      });
    }
  }
  VmlNotesXform.DRAWING_ATTRIBUTES = {
    "xmlns:v": "urn:schemas-microsoft-com:vml",
    "xmlns:o": "urn:schemas-microsoft-com:office:office",
    "xmlns:x": "urn:schemas-microsoft-com:office:excel"
  };
  vmlNotesXform = VmlNotesXform;
  return vmlNotesXform;
}
var theme1;
var hasRequiredTheme1;
function requireTheme1() {
  if (hasRequiredTheme1) return theme1;
  hasRequiredTheme1 = 1;
  theme1 = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme"> <a:themeElements> <a:clrScheme name="Office"> <a:dk1> <a:sysClr val="windowText" lastClr="000000"/> </a:dk1> <a:lt1> <a:sysClr val="window" lastClr="FFFFFF"/> </a:lt1> <a:dk2> <a:srgbClr val="1F497D"/> </a:dk2> <a:lt2> <a:srgbClr val="EEECE1"/> </a:lt2> <a:accent1> <a:srgbClr val="4F81BD"/> </a:accent1> <a:accent2> <a:srgbClr val="C0504D"/> </a:accent2> <a:accent3> <a:srgbClr val="9BBB59"/> </a:accent3> <a:accent4> <a:srgbClr val="8064A2"/> </a:accent4> <a:accent5> <a:srgbClr val="4BACC6"/> </a:accent5> <a:accent6> <a:srgbClr val="F79646"/> </a:accent6> <a:hlink> <a:srgbClr val="0000FF"/> </a:hlink> <a:folHlink> <a:srgbClr val="800080"/> </a:folHlink> </a:clrScheme> <a:fontScheme name="Office"> <a:majorFont> <a:latin typeface="Cambria"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Times New Roman"/> <a:font script="Hebr" typeface="Times New Roman"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="MoolBoran"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Times New Roman"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:majorFont> <a:minorFont> <a:latin typeface="Calibri"/> <a:ea typeface=""/> <a:cs typeface=""/> <a:font script="Jpan" typeface=" "/> <a:font script="Hang" typeface=" "/> <a:font script="Hans" typeface=""/> <a:font script="Hant" typeface=""/> <a:font script="Arab" typeface="Arial"/> <a:font script="Hebr" typeface="Arial"/> <a:font script="Thai" typeface="Tahoma"/> <a:font script="Ethi" typeface="Nyala"/> <a:font script="Beng" typeface="Vrinda"/> <a:font script="Gujr" typeface="Shruti"/> <a:font script="Khmr" typeface="DaunPenh"/> <a:font script="Knda" typeface="Tunga"/> <a:font script="Guru" typeface="Raavi"/> <a:font script="Cans" typeface="Euphemia"/> <a:font script="Cher" typeface="Plantagenet Cherokee"/> <a:font script="Yiii" typeface="Microsoft Yi Baiti"/> <a:font script="Tibt" typeface="Microsoft Himalaya"/> <a:font script="Thaa" typeface="MV Boli"/> <a:font script="Deva" typeface="Mangal"/> <a:font script="Telu" typeface="Gautami"/> <a:font script="Taml" typeface="Latha"/> <a:font script="Syrc" typeface="Estrangelo Edessa"/> <a:font script="Orya" typeface="Kalinga"/> <a:font script="Mlym" typeface="Kartika"/> <a:font script="Laoo" typeface="DokChampa"/> <a:font script="Sinh" typeface="Iskoola Pota"/> <a:font script="Mong" typeface="Mongolian Baiti"/> <a:font script="Viet" typeface="Arial"/> <a:font script="Uigh" typeface="Microsoft Uighur"/> <a:font script="Geor" typeface="Sylfaen"/> </a:minorFont> </a:fontScheme> <a:fmtScheme name="Office"> <a:fillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="35000"> <a:schemeClr val="phClr"> <a:tint val="37000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="15000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="1"/> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="100000"/> <a:shade val="100000"/> <a:satMod val="130000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:tint val="50000"/> <a:shade val="100000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:lin ang="16200000" scaled="0"/> </a:gradFill> </a:fillStyleLst> <a:lnStyleLst> <a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"> <a:shade val="95000"/> <a:satMod val="105000"/> </a:schemeClr> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> <a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:prstDash val="solid"/> </a:ln> </a:lnStyleLst> <a:effectStyleLst> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="38000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> </a:effectStyle> <a:effectStyle> <a:effectLst> <a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"> <a:srgbClr val="000000"> <a:alpha val="35000"/> </a:srgbClr> </a:outerShdw> </a:effectLst> <a:scene3d> <a:camera prst="orthographicFront"> <a:rot lat="0" lon="0" rev="0"/> </a:camera> <a:lightRig rig="threePt" dir="t"> <a:rot lat="0" lon="0" rev="1200000"/> </a:lightRig> </a:scene3d> <a:sp3d> <a:bevelT w="63500" h="25400"/> </a:sp3d> </a:effectStyle> </a:effectStyleLst> <a:bgFillStyleLst> <a:solidFill> <a:schemeClr val="phClr"/> </a:solidFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="40000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="40000"> <a:schemeClr val="phClr"> <a:tint val="45000"/> <a:shade val="99000"/> <a:satMod val="350000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="20000"/> <a:satMod val="255000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="-80000" r="50000" b="180000"/> </a:path> </a:gradFill> <a:gradFill rotWithShape="1"> <a:gsLst> <a:gs pos="0"> <a:schemeClr val="phClr"> <a:tint val="80000"/> <a:satMod val="300000"/> </a:schemeClr> </a:gs> <a:gs pos="100000"> <a:schemeClr val="phClr"> <a:shade val="30000"/> <a:satMod val="200000"/> </a:schemeClr> </a:gs> </a:gsLst> <a:path path="circle"> <a:fillToRect l="50000" t="50000" r="50000" b="50000"/> </a:path> </a:gradFill> </a:bgFillStyleLst> </a:fmtScheme> </a:themeElements> <a:objectDefaults> <a:spDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="1"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="3"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="2"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="lt1"/> </a:fontRef> </a:style> </a:spDef> <a:lnDef> <a:spPr/> <a:bodyPr/> <a:lstStyle/> <a:style> <a:lnRef idx="2"> <a:schemeClr val="accent1"/> </a:lnRef> <a:fillRef idx="0"> <a:schemeClr val="accent1"/> </a:fillRef> <a:effectRef idx="1"> <a:schemeClr val="accent1"/> </a:effectRef> <a:fontRef idx="minor"> <a:schemeClr val="tx1"/> </a:fontRef> </a:style> </a:lnDef> </a:objectDefaults> <a:extraClrSchemeLst/> </a:theme>';
  return theme1;
}
var xlsx;
var hasRequiredXlsx;
function requireXlsx() {
  if (hasRequiredXlsx) return xlsx;
  hasRequiredXlsx = 1;
  const fs2 = require$$0$4;
  const JSZip = requireLib$1();
  const { PassThrough } = requireReadable$4();
  const ZipStream = requireZipStream$1();
  const StreamBuf = requireStreamBuf();
  const utils2 = requireUtils();
  const XmlStream = requireXmlStream();
  const { bufferToString } = requireBrowserBufferDecode();
  const StylesXform = requireStylesXform();
  const CoreXform = requireCoreXform();
  const SharedStringsXform = requireSharedStringsXform();
  const RelationshipsXform = requireRelationshipsXform();
  const ContentTypesXform = requireContentTypesXform();
  const AppXform = requireAppXform();
  const WorkbookXform = requireWorkbookXform();
  const WorksheetXform = requireWorksheetXform();
  const DrawingXform = requireDrawingXform();
  const TableXform = requireTableXform();
  const CommentsXform = requireCommentsXform();
  const VmlNotesXform = requireVmlNotesXform();
  const theme1Xml = requireTheme1();
  function fsReadFileAsync(filename, options) {
    return new Promise((resolve, reject2) => {
      fs2.readFile(filename, options, (error2, data2) => {
        if (error2) {
          reject2(error2);
        } else {
          resolve(data2);
        }
      });
    });
  }
  class XLSX {
    constructor(workbook2) {
      this.workbook = workbook2;
    }
    // ===============================================================================
    // Workbook
    // =========================================================================
    // Read
    async readFile(filename, options) {
      if (!await utils2.fs.exists(filename)) {
        throw new Error(`File not found: ${filename}`);
      }
      const stream2 = fs2.createReadStream(filename);
      try {
        const workbook2 = await this.read(stream2, options);
        stream2.close();
        return workbook2;
      } catch (error2) {
        stream2.close();
        throw error2;
      }
    }
    parseRels(stream2) {
      const xform = new RelationshipsXform();
      return xform.parseStream(stream2);
    }
    parseWorkbook(stream2) {
      const xform = new WorkbookXform();
      return xform.parseStream(stream2);
    }
    parseSharedStrings(stream2) {
      const xform = new SharedStringsXform();
      return xform.parseStream(stream2);
    }
    reconcile(model, options) {
      const workbookXform2 = new WorkbookXform();
      const worksheetXform2 = new WorksheetXform(options);
      const drawingXform2 = new DrawingXform();
      const tableXform2 = new TableXform();
      workbookXform2.reconcile(model);
      const drawingOptions = {
        media: model.media,
        mediaIndex: model.mediaIndex
      };
      Object.keys(model.drawings).forEach((name) => {
        const drawing = model.drawings[name];
        const drawingRel = model.drawingRels[name];
        if (drawingRel) {
          drawingOptions.rels = drawingRel.reduce((o, rel) => {
            o[rel.Id] = rel;
            return o;
          }, {});
          (drawing.anchors || []).forEach((anchor2) => {
            const hyperlinks = anchor2.picture && anchor2.picture.hyperlinks;
            if (hyperlinks && drawingOptions.rels[hyperlinks.rId]) {
              hyperlinks.hyperlink = drawingOptions.rels[hyperlinks.rId].Target;
              delete hyperlinks.rId;
            }
          });
          drawingXform2.reconcile(drawing, drawingOptions);
        }
      });
      const tableOptions = {
        styles: model.styles
      };
      Object.values(model.tables).forEach((table2) => {
        tableXform2.reconcile(table2, tableOptions);
      });
      const sheetOptions = {
        styles: model.styles,
        sharedStrings: model.sharedStrings,
        media: model.media,
        mediaIndex: model.mediaIndex,
        date1904: model.properties && model.properties.date1904,
        drawings: model.drawings,
        comments: model.comments,
        tables: model.tables,
        vmlDrawings: model.vmlDrawings
      };
      model.worksheets.forEach((worksheet2) => {
        worksheet2.relationships = model.worksheetRels[worksheet2.sheetNo];
        worksheetXform2.reconcile(worksheet2, sheetOptions);
      });
      delete model.worksheetHash;
      delete model.worksheetRels;
      delete model.globalRels;
      delete model.sharedStrings;
      delete model.workbookRels;
      delete model.sheetDefs;
      delete model.styles;
      delete model.mediaIndex;
      delete model.drawings;
      delete model.drawingRels;
      delete model.vmlDrawings;
    }
    async _processWorksheetEntry(stream2, model, sheetNo, options, path2) {
      const xform = new WorksheetXform(options);
      const worksheet2 = await xform.parseStream(stream2);
      worksheet2.sheetNo = sheetNo;
      model.worksheetHash[path2] = worksheet2;
      model.worksheets.push(worksheet2);
    }
    async _processCommentEntry(stream2, model, name) {
      const xform = new CommentsXform();
      const comments = await xform.parseStream(stream2);
      model.comments[`../${name}.xml`] = comments;
    }
    async _processTableEntry(stream2, model, name) {
      const xform = new TableXform();
      const table2 = await xform.parseStream(stream2);
      model.tables[`../tables/${name}.xml`] = table2;
    }
    async _processWorksheetRelsEntry(stream2, model, sheetNo) {
      const xform = new RelationshipsXform();
      const relationships = await xform.parseStream(stream2);
      model.worksheetRels[sheetNo] = relationships;
    }
    async _processMediaEntry(entry, model, filename) {
      const lastDot = filename.lastIndexOf(".");
      if (lastDot >= 1) {
        const extension = filename.substr(lastDot + 1);
        const name = filename.substr(0, lastDot);
        await new Promise((resolve, reject2) => {
          const streamBuf2 = new StreamBuf();
          streamBuf2.on("finish", () => {
            model.mediaIndex[filename] = model.media.length;
            model.mediaIndex[name] = model.media.length;
            const medium = {
              type: "image",
              name,
              extension,
              buffer: streamBuf2.toBuffer()
            };
            model.media.push(medium);
            resolve();
          });
          entry.on("error", (error2) => {
            reject2(error2);
          });
          entry.pipe(streamBuf2);
        });
      }
    }
    async _processDrawingEntry(entry, model, name) {
      const xform = new DrawingXform();
      const drawing = await xform.parseStream(entry);
      model.drawings[name] = drawing;
    }
    async _processDrawingRelsEntry(entry, model, name) {
      const xform = new RelationshipsXform();
      const relationships = await xform.parseStream(entry);
      model.drawingRels[name] = relationships;
    }
    async _processVmlDrawingEntry(entry, model, name) {
      const xform = new VmlNotesXform();
      const vmlDrawing = await xform.parseStream(entry);
      model.vmlDrawings[`../drawings/${name}.vml`] = vmlDrawing;
    }
    async _processThemeEntry(entry, model, name) {
      await new Promise((resolve, reject2) => {
        const stream2 = new StreamBuf();
        entry.on("error", reject2);
        stream2.on("error", reject2);
        stream2.on("finish", () => {
          model.themes[name] = stream2.read().toString();
          resolve();
        });
        entry.pipe(stream2);
      });
    }
    /**
     * @deprecated since version 4.0. You should use `#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
     */
    createInputStream() {
      throw new Error(
        "`XLSX#createInputStream` is deprecated. You should use `XLSX#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
      );
    }
    async read(stream2, options) {
      if (!stream2[Symbol.asyncIterator] && stream2.pipe) {
        stream2 = stream2.pipe(new PassThrough());
      }
      const chunks = [];
      for await (const chunk of stream2) {
        chunks.push(chunk);
      }
      return this.load(Buffer.concat(chunks), options);
    }
    async load(data2, options) {
      let buffer;
      if (options && options.base64) {
        buffer = Buffer.from(data2.toString(), "base64");
      } else {
        buffer = data2;
      }
      const model = {
        worksheets: [],
        worksheetHash: {},
        worksheetRels: [],
        themes: {},
        media: [],
        mediaIndex: {},
        drawings: {},
        drawingRels: {},
        comments: {},
        tables: {},
        vmlDrawings: {}
      };
      const zip2 = await JSZip.loadAsync(buffer);
      for (const entry of Object.values(zip2.files)) {
        if (!entry.dir) {
          let entryName = entry.name;
          if (entryName[0] === "/") {
            entryName = entryName.substr(1);
          }
          let stream2;
          if (entryName.match(/xl\/media\//) || // themes are not parsed as stream
          entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/)) {
            stream2 = new PassThrough();
            stream2.write(await entry.async("nodebuffer"));
          } else {
            stream2 = new PassThrough({
              writableObjectMode: true,
              readableObjectMode: true
            });
            let content;
            if (process.browser) {
              content = bufferToString(await entry.async("nodebuffer"));
            } else {
              content = await entry.async("string");
            }
            const chunkSize = 16 * 1024;
            for (let i = 0; i < content.length; i += chunkSize) {
              stream2.write(content.substring(i, i + chunkSize));
            }
          }
          stream2.end();
          switch (entryName) {
            case "_rels/.rels":
              model.globalRels = await this.parseRels(stream2);
              break;
            case "xl/workbook.xml": {
              const workbook2 = await this.parseWorkbook(stream2);
              model.sheets = workbook2.sheets;
              model.definedNames = workbook2.definedNames;
              model.views = workbook2.views;
              model.properties = workbook2.properties;
              model.calcProperties = workbook2.calcProperties;
              break;
            }
            case "xl/_rels/workbook.xml.rels":
              model.workbookRels = await this.parseRels(stream2);
              break;
            case "xl/sharedStrings.xml":
              model.sharedStrings = new SharedStringsXform();
              await model.sharedStrings.parseStream(stream2);
              break;
            case "xl/styles.xml":
              model.styles = new StylesXform();
              await model.styles.parseStream(stream2);
              break;
            case "docProps/app.xml": {
              const appXform2 = new AppXform();
              const appProperties = await appXform2.parseStream(stream2);
              model.company = appProperties.company;
              model.manager = appProperties.manager;
              break;
            }
            case "docProps/core.xml": {
              const coreXform2 = new CoreXform();
              const coreProperties = await coreXform2.parseStream(stream2);
              Object.assign(model, coreProperties);
              break;
            }
            default: {
              let match = entryName.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
              if (match) {
                await this._processWorksheetEntry(stream2, model, match[1], options, entryName);
                break;
              }
              match = entryName.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
              if (match) {
                await this._processWorksheetRelsEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/theme\/([a-zA-Z0-9]+)[.]xml/);
              if (match) {
                await this._processThemeEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/media\/([a-zA-Z0-9]+[.][a-zA-Z0-9]{3,4})$/);
              if (match) {
                await this._processMediaEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/drawings\/([a-zA-Z0-9]+)[.]xml/);
              if (match) {
                await this._processDrawingEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/(comments\d+)[.]xml/);
              if (match) {
                await this._processCommentEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/tables\/(table\d+)[.]xml/);
              if (match) {
                await this._processTableEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/drawings\/_rels\/([a-zA-Z0-9]+)[.]xml[.]rels/);
              if (match) {
                await this._processDrawingRelsEntry(stream2, model, match[1]);
                break;
              }
              match = entryName.match(/xl\/drawings\/(vmlDrawing\d+)[.]vml/);
              if (match) {
                await this._processVmlDrawingEntry(stream2, model, match[1]);
                break;
              }
            }
          }
        }
      }
      this.reconcile(model, options);
      this.workbook.model = model;
      return this.workbook;
    }
    // =========================================================================
    // Write
    async addMedia(zip2, model) {
      await Promise.all(
        model.media.map(async (medium) => {
          if (medium.type === "image") {
            const filename = `xl/media/${medium.name}.${medium.extension}`;
            if (medium.filename) {
              const data2 = await fsReadFileAsync(medium.filename);
              return zip2.append(data2, { name: filename });
            }
            if (medium.buffer) {
              return zip2.append(medium.buffer, { name: filename });
            }
            if (medium.base64) {
              const dataimg64 = medium.base64;
              const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
              return zip2.append(content, { name: filename, base64: true });
            }
          }
          throw new Error("Unsupported media");
        })
      );
    }
    addDrawings(zip2, model) {
      const drawingXform2 = new DrawingXform();
      const relsXform = new RelationshipsXform();
      model.worksheets.forEach((worksheet2) => {
        const { drawing } = worksheet2;
        if (drawing) {
          drawingXform2.prepare(drawing, {});
          let xml = drawingXform2.toXml(drawing);
          zip2.append(xml, { name: `xl/drawings/${drawing.name}.xml` });
          xml = relsXform.toXml(drawing.rels);
          zip2.append(xml, { name: `xl/drawings/_rels/${drawing.name}.xml.rels` });
        }
      });
    }
    addTables(zip2, model) {
      const tableXform2 = new TableXform();
      model.worksheets.forEach((worksheet2) => {
        const { tables } = worksheet2;
        tables.forEach((table2) => {
          tableXform2.prepare(table2, {});
          const tableXml = tableXform2.toXml(table2);
          zip2.append(tableXml, { name: `xl/tables/${table2.target}` });
        });
      });
    }
    async addContentTypes(zip2, model) {
      const xform = new ContentTypesXform();
      const xml = xform.toXml(model);
      zip2.append(xml, { name: "[Content_Types].xml" });
    }
    async addApp(zip2, model) {
      const xform = new AppXform();
      const xml = xform.toXml(model);
      zip2.append(xml, { name: "docProps/app.xml" });
    }
    async addCore(zip2, model) {
      const coreXform2 = new CoreXform();
      zip2.append(coreXform2.toXml(model), { name: "docProps/core.xml" });
    }
    async addThemes(zip2, model) {
      const themes = model.themes || { theme1: theme1Xml };
      Object.keys(themes).forEach((name) => {
        const xml = themes[name];
        const path2 = `xl/theme/${name}.xml`;
        zip2.append(xml, { name: path2 });
      });
    }
    async addOfficeRels(zip2) {
      const xform = new RelationshipsXform();
      const xml = xform.toXml([
        { Id: "rId1", Type: XLSX.RelType.OfficeDocument, Target: "xl/workbook.xml" },
        { Id: "rId2", Type: XLSX.RelType.CoreProperties, Target: "docProps/core.xml" },
        { Id: "rId3", Type: XLSX.RelType.ExtenderProperties, Target: "docProps/app.xml" }
      ]);
      zip2.append(xml, { name: "_rels/.rels" });
    }
    async addWorkbookRels(zip2, model) {
      let count = 1;
      const relationships = [
        { Id: `rId${count++}`, Type: XLSX.RelType.Styles, Target: "styles.xml" },
        { Id: `rId${count++}`, Type: XLSX.RelType.Theme, Target: "theme/theme1.xml" }
      ];
      if (model.sharedStrings.count) {
        relationships.push({
          Id: `rId${count++}`,
          Type: XLSX.RelType.SharedStrings,
          Target: "sharedStrings.xml"
        });
      }
      model.worksheets.forEach((worksheet2) => {
        worksheet2.rId = `rId${count++}`;
        relationships.push({
          Id: worksheet2.rId,
          Type: XLSX.RelType.Worksheet,
          Target: `worksheets/sheet${worksheet2.id}.xml`
        });
      });
      const xform = new RelationshipsXform();
      const xml = xform.toXml(relationships);
      zip2.append(xml, { name: "xl/_rels/workbook.xml.rels" });
    }
    async addSharedStrings(zip2, model) {
      if (model.sharedStrings && model.sharedStrings.count) {
        zip2.append(model.sharedStrings.xml, { name: "xl/sharedStrings.xml" });
      }
    }
    async addStyles(zip2, model) {
      const { xml } = model.styles;
      if (xml) {
        zip2.append(xml, { name: "xl/styles.xml" });
      }
    }
    async addWorkbook(zip2, model) {
      const xform = new WorkbookXform();
      zip2.append(xform.toXml(model), { name: "xl/workbook.xml" });
    }
    async addWorksheets(zip2, model) {
      const worksheetXform2 = new WorksheetXform();
      const relationshipsXform2 = new RelationshipsXform();
      const commentsXform2 = new CommentsXform();
      const vmlNotesXform2 = new VmlNotesXform();
      model.worksheets.forEach((worksheet2) => {
        let xmlStream2 = new XmlStream();
        worksheetXform2.render(xmlStream2, worksheet2);
        zip2.append(xmlStream2.xml, { name: `xl/worksheets/sheet${worksheet2.id}.xml` });
        if (worksheet2.rels && worksheet2.rels.length) {
          xmlStream2 = new XmlStream();
          relationshipsXform2.render(xmlStream2, worksheet2.rels);
          zip2.append(xmlStream2.xml, { name: `xl/worksheets/_rels/sheet${worksheet2.id}.xml.rels` });
        }
        if (worksheet2.comments.length > 0) {
          xmlStream2 = new XmlStream();
          commentsXform2.render(xmlStream2, worksheet2);
          zip2.append(xmlStream2.xml, { name: `xl/comments${worksheet2.id}.xml` });
          xmlStream2 = new XmlStream();
          vmlNotesXform2.render(xmlStream2, worksheet2);
          zip2.append(xmlStream2.xml, { name: `xl/drawings/vmlDrawing${worksheet2.id}.vml` });
        }
      });
    }
    _finalize(zip2) {
      return new Promise((resolve, reject2) => {
        zip2.on("finish", () => {
          resolve(this);
        });
        zip2.on("error", reject2);
        zip2.finalize();
      });
    }
    prepareModel(model, options) {
      model.creator = model.creator || "ExcelJS";
      model.lastModifiedBy = model.lastModifiedBy || "ExcelJS";
      model.created = model.created || /* @__PURE__ */ new Date();
      model.modified = model.modified || /* @__PURE__ */ new Date();
      model.useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : true;
      model.useStyles = options.useStyles !== void 0 ? options.useStyles : true;
      model.sharedStrings = new SharedStringsXform();
      model.styles = model.useStyles ? new StylesXform(true) : new StylesXform.Mock();
      const workbookXform2 = new WorkbookXform();
      const worksheetXform2 = new WorksheetXform();
      workbookXform2.prepare(model);
      const worksheetOptions = {
        sharedStrings: model.sharedStrings,
        styles: model.styles,
        date1904: model.properties.date1904,
        drawingsCount: 0,
        media: model.media
      };
      worksheetOptions.drawings = model.drawings = [];
      worksheetOptions.commentRefs = model.commentRefs = [];
      let tableCount = 0;
      model.tables = [];
      model.worksheets.forEach((worksheet2) => {
        worksheet2.tables.forEach((table2) => {
          tableCount++;
          table2.target = `table${tableCount}.xml`;
          table2.id = tableCount;
          model.tables.push(table2);
        });
        worksheetXform2.prepare(worksheet2, worksheetOptions);
      });
    }
    async write(stream2, options) {
      options = options || {};
      const { model } = this.workbook;
      const zip2 = new ZipStream.ZipWriter(options.zip);
      zip2.pipe(stream2);
      this.prepareModel(model, options);
      await this.addContentTypes(zip2, model);
      await this.addOfficeRels(zip2, model);
      await this.addWorkbookRels(zip2, model);
      await this.addWorksheets(zip2, model);
      await this.addSharedStrings(zip2, model);
      await this.addDrawings(zip2, model);
      await this.addTables(zip2, model);
      await Promise.all([this.addThemes(zip2, model), this.addStyles(zip2, model)]);
      await this.addMedia(zip2, model);
      await Promise.all([this.addApp(zip2, model), this.addCore(zip2, model)]);
      await this.addWorkbook(zip2, model);
      return this._finalize(zip2);
    }
    writeFile(filename, options) {
      const stream2 = fs2.createWriteStream(filename);
      return new Promise((resolve, reject2) => {
        stream2.on("finish", () => {
          resolve();
        });
        stream2.on("error", (error2) => {
          reject2(error2);
        });
        this.write(stream2, options).then(() => {
          stream2.end();
        }).catch((err) => {
          reject2(err);
        });
      });
    }
    async writeBuffer(options) {
      const stream2 = new StreamBuf();
      await this.write(stream2, options);
      return stream2.read();
    }
  }
  XLSX.RelType = requireRelType();
  xlsx = XLSX;
  return xlsx;
}
var src$2 = {};
var src$1 = {};
var FormatterOptions = {};
var hasRequiredFormatterOptions;
function requireFormatterOptions() {
  if (hasRequiredFormatterOptions) return FormatterOptions;
  hasRequiredFormatterOptions = 1;
  Object.defineProperty(FormatterOptions, "__esModule", { value: true });
  FormatterOptions.FormatterOptions = void 0;
  let FormatterOptions$1 = class FormatterOptions {
    constructor(opts = {}) {
      var _a;
      this.objectMode = true;
      this.delimiter = ",";
      this.rowDelimiter = "\n";
      this.quote = '"';
      this.escape = this.quote;
      this.quoteColumns = false;
      this.quoteHeaders = this.quoteColumns;
      this.headers = null;
      this.includeEndRowDelimiter = false;
      this.writeBOM = false;
      this.BOM = "\uFEFF";
      this.alwaysWriteHeaders = false;
      Object.assign(this, opts || {});
      if (typeof (opts === null || opts === void 0 ? void 0 : opts.quoteHeaders) === "undefined") {
        this.quoteHeaders = this.quoteColumns;
      }
      if ((opts === null || opts === void 0 ? void 0 : opts.quote) === true) {
        this.quote = '"';
      } else if ((opts === null || opts === void 0 ? void 0 : opts.quote) === false) {
        this.quote = "";
      }
      if (typeof (opts === null || opts === void 0 ? void 0 : opts.escape) !== "string") {
        this.escape = this.quote;
      }
      this.shouldWriteHeaders = !!this.headers && ((_a = opts.writeHeaders) !== null && _a !== void 0 ? _a : true);
      this.headers = Array.isArray(this.headers) ? this.headers : null;
      this.escapedQuote = `${this.escape}${this.quote}`;
    }
  };
  FormatterOptions.FormatterOptions = FormatterOptions$1;
  return FormatterOptions;
}
var CsvFormatterStream = {};
var formatter = {};
var RowFormatter = {};
var lodash_isfunction;
var hasRequiredLodash_isfunction;
function requireLodash_isfunction() {
  if (hasRequiredLodash_isfunction) return lodash_isfunction;
  hasRequiredLodash_isfunction = 1;
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", nullTag = "[object Null]", proxyTag = "[object Proxy]", undefinedTag = "[object Undefined]";
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var nativeObjectToString = objectProto.toString;
  var Symbol2 = root.Symbol, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function isFunction2(value) {
    if (!isObject2(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  lodash_isfunction = isFunction2;
  return lodash_isfunction;
}
var lodash_isequal = { exports: {} };
lodash_isequal.exports;
var hasRequiredLodash_isequal;
function requireLodash_isequal() {
  if (hasRequiredLodash_isequal) return lodash_isequal.exports;
  hasRequiredLodash_isequal = 1;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var nativeObjectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0, Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0, nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index2, 1);
      }
      --this.size;
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        ++this.size;
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      var result = getMapData(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      var data2 = getMapData(this, key), size = data2.size;
      data2.set(key, value);
      this.size += data2.size == size ? 0 : 1;
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values == null ? 0 : values.length;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      var data2 = this.__data__ = new ListCache(entries);
      this.size = data2.size;
    }
    function stackClear() {
      this.__data__ = new ListCache();
      this.size = 0;
    }
    function stackDelete(key) {
      var data2 = this.__data__, result = data2["delete"](key);
      this.size = data2.size;
      return result;
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var data2 = this.__data__;
      if (data2 instanceof ListCache) {
        var pairs = data2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          this.size = ++data2.size;
          return this;
        }
        data2 = this.__data__ = new MapCache(pairs);
      }
      data2.set(key, value);
      this.size = data2.size;
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if (hasOwnProperty2.call(value, key) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray2(object2) ? result : arrayPush(result, symbolsFunc(object2));
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }
    function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;
      var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer2(object2)) {
        if (!isBuffer2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getAllKeys(object2) {
      return baseGetAllKeys(object2, keys, getSymbols);
    }
    function getMapData(map2, key) {
      var data2 = map2.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
      });
    };
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    var isArguments = baseIsArguments(/* @__PURE__ */ function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }
    function isFunction2(value) {
      if (!isObject2(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return value != null && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function keys(object2) {
      return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = isEqual;
  })(lodash_isequal, lodash_isequal.exports);
  return lodash_isequal.exports;
}
var FieldFormatter = {};
var lodash_isboolean;
var hasRequiredLodash_isboolean;
function requireLodash_isboolean() {
  if (hasRequiredLodash_isboolean) return lodash_isboolean;
  hasRequiredLodash_isboolean = 1;
  var boolTag = "[object Boolean]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function isBoolean2(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  lodash_isboolean = isBoolean2;
  return lodash_isboolean;
}
var lodash_isnil;
var hasRequiredLodash_isnil;
function requireLodash_isnil() {
  if (hasRequiredLodash_isnil) return lodash_isnil;
  hasRequiredLodash_isnil = 1;
  function isNil(value) {
    return value == null;
  }
  lodash_isnil = isNil;
  return lodash_isnil;
}
var lodash_escaperegexp;
var hasRequiredLodash_escaperegexp;
function requireLodash_escaperegexp() {
  if (hasRequiredLodash_escaperegexp) return lodash_escaperegexp;
  hasRequiredLodash_escaperegexp = 1;
  var symbolTag = "[object Symbol]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -Infinity ? "-0" : result;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toString3(value) {
    return value == null ? "" : baseToString(value);
  }
  function escapeRegExp(string) {
    string = toString3(string);
    return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
  }
  lodash_escaperegexp = escapeRegExp;
  return lodash_escaperegexp;
}
var hasRequiredFieldFormatter;
function requireFieldFormatter() {
  if (hasRequiredFieldFormatter) return FieldFormatter;
  hasRequiredFieldFormatter = 1;
  var __importDefault = FieldFormatter && FieldFormatter.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(FieldFormatter, "__esModule", { value: true });
  FieldFormatter.FieldFormatter = void 0;
  const lodash_isboolean_1 = __importDefault(requireLodash_isboolean());
  const lodash_isnil_1 = __importDefault(requireLodash_isnil());
  const lodash_escaperegexp_1 = __importDefault(requireLodash_escaperegexp());
  let FieldFormatter$1 = class FieldFormatter {
    constructor(formatterOptions) {
      this._headers = null;
      this.formatterOptions = formatterOptions;
      if (formatterOptions.headers !== null) {
        this.headers = formatterOptions.headers;
      }
      this.REPLACE_REGEXP = new RegExp(formatterOptions.quote, "g");
      const escapePattern = `[${formatterOptions.delimiter}${lodash_escaperegexp_1.default(formatterOptions.rowDelimiter)}|\r|
]`;
      this.ESCAPE_REGEXP = new RegExp(escapePattern);
    }
    set headers(headers2) {
      this._headers = headers2;
    }
    shouldQuote(fieldIndex, isHeader) {
      const quoteConfig = isHeader ? this.formatterOptions.quoteHeaders : this.formatterOptions.quoteColumns;
      if (lodash_isboolean_1.default(quoteConfig)) {
        return quoteConfig;
      }
      if (Array.isArray(quoteConfig)) {
        return quoteConfig[fieldIndex];
      }
      if (this._headers !== null) {
        return quoteConfig[this._headers[fieldIndex]];
      }
      return false;
    }
    format(field, fieldIndex, isHeader) {
      const preparedField = `${lodash_isnil_1.default(field) ? "" : field}`.replace(/\0/g, "");
      const { formatterOptions } = this;
      if (formatterOptions.quote !== "") {
        const shouldEscape = preparedField.indexOf(formatterOptions.quote) !== -1;
        if (shouldEscape) {
          return this.quoteField(preparedField.replace(this.REPLACE_REGEXP, formatterOptions.escapedQuote));
        }
      }
      const hasEscapeCharacters = preparedField.search(this.ESCAPE_REGEXP) !== -1;
      if (hasEscapeCharacters || this.shouldQuote(fieldIndex, isHeader)) {
        return this.quoteField(preparedField);
      }
      return preparedField;
    }
    quoteField(field) {
      const { quote } = this.formatterOptions;
      return `${quote}${field}${quote}`;
    }
  };
  FieldFormatter.FieldFormatter = FieldFormatter$1;
  return FieldFormatter;
}
var types$1 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$1;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.isSyncTransform = void 0;
  types$1.isSyncTransform = (transform2) => transform2.length === 1;
  return types$1;
}
var hasRequiredRowFormatter;
function requireRowFormatter() {
  if (hasRequiredRowFormatter) return RowFormatter;
  hasRequiredRowFormatter = 1;
  var __importDefault = RowFormatter && RowFormatter.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(RowFormatter, "__esModule", { value: true });
  RowFormatter.RowFormatter = void 0;
  const lodash_isfunction_1 = __importDefault(requireLodash_isfunction());
  const lodash_isequal_1 = __importDefault(requireLodash_isequal());
  const FieldFormatter_1 = requireFieldFormatter();
  const types_1 = requireTypes$1();
  let RowFormatter$1 = class RowFormatter2 {
    constructor(formatterOptions) {
      this.rowCount = 0;
      this.formatterOptions = formatterOptions;
      this.fieldFormatter = new FieldFormatter_1.FieldFormatter(formatterOptions);
      this.headers = formatterOptions.headers;
      this.shouldWriteHeaders = formatterOptions.shouldWriteHeaders;
      this.hasWrittenHeaders = false;
      if (this.headers !== null) {
        this.fieldFormatter.headers = this.headers;
      }
      if (formatterOptions.transform) {
        this.rowTransform = formatterOptions.transform;
      }
    }
    static isRowHashArray(row2) {
      if (Array.isArray(row2)) {
        return Array.isArray(row2[0]) && row2[0].length === 2;
      }
      return false;
    }
    static isRowArray(row2) {
      return Array.isArray(row2) && !this.isRowHashArray(row2);
    }
    // get headers from a row item
    static gatherHeaders(row2) {
      if (RowFormatter2.isRowHashArray(row2)) {
        return row2.map((it) => it[0]);
      }
      if (Array.isArray(row2)) {
        return row2;
      }
      return Object.keys(row2);
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static createTransform(transformFunction) {
      if (types_1.isSyncTransform(transformFunction)) {
        return (row2, cb) => {
          let transformedRow = null;
          try {
            transformedRow = transformFunction(row2);
          } catch (e) {
            return cb(e);
          }
          return cb(null, transformedRow);
        };
      }
      return (row2, cb) => {
        transformFunction(row2, cb);
      };
    }
    set rowTransform(transformFunction) {
      if (!lodash_isfunction_1.default(transformFunction)) {
        throw new TypeError("The transform should be a function");
      }
      this._rowTransform = RowFormatter2.createTransform(transformFunction);
    }
    format(row2, cb) {
      this.callTransformer(row2, (err, transformedRow) => {
        if (err) {
          return cb(err);
        }
        if (!row2) {
          return cb(null);
        }
        const rows = [];
        if (transformedRow) {
          const { shouldFormatColumns, headers: headers2 } = this.checkHeaders(transformedRow);
          if (this.shouldWriteHeaders && headers2 && !this.hasWrittenHeaders) {
            rows.push(this.formatColumns(headers2, true));
            this.hasWrittenHeaders = true;
          }
          if (shouldFormatColumns) {
            const columns = this.gatherColumns(transformedRow);
            rows.push(this.formatColumns(columns, false));
          }
        }
        return cb(null, rows);
      });
    }
    finish(cb) {
      const rows = [];
      if (this.formatterOptions.alwaysWriteHeaders && this.rowCount === 0) {
        if (!this.headers) {
          return cb(new Error("`alwaysWriteHeaders` option is set to true but `headers` option not provided."));
        }
        rows.push(this.formatColumns(this.headers, true));
      }
      if (this.formatterOptions.includeEndRowDelimiter) {
        rows.push(this.formatterOptions.rowDelimiter);
      }
      return cb(null, rows);
    }
    // check if we need to write header return true if we should also write a row
    // could be false if headers is true and the header row(first item) is passed in
    checkHeaders(row2) {
      if (this.headers) {
        return { shouldFormatColumns: true, headers: this.headers };
      }
      const headers2 = RowFormatter2.gatherHeaders(row2);
      this.headers = headers2;
      this.fieldFormatter.headers = headers2;
      if (!this.shouldWriteHeaders) {
        return { shouldFormatColumns: true, headers: null };
      }
      return { shouldFormatColumns: !lodash_isequal_1.default(headers2, row2), headers: headers2 };
    }
    // todo change this method to unknown[]
    gatherColumns(row2) {
      if (this.headers === null) {
        throw new Error("Headers is currently null");
      }
      if (!Array.isArray(row2)) {
        return this.headers.map((header) => row2[header]);
      }
      if (RowFormatter2.isRowHashArray(row2)) {
        return this.headers.map((header, i) => {
          const col = row2[i];
          if (col) {
            return col[1];
          }
          return "";
        });
      }
      if (RowFormatter2.isRowArray(row2) && !this.shouldWriteHeaders) {
        return row2;
      }
      return this.headers.map((header, i) => row2[i]);
    }
    callTransformer(row2, cb) {
      if (!this._rowTransform) {
        return cb(null, row2);
      }
      return this._rowTransform(row2, cb);
    }
    formatColumns(columns, isHeadersRow) {
      const formattedCols = columns.map((field, i) => this.fieldFormatter.format(field, i, isHeadersRow)).join(this.formatterOptions.delimiter);
      const { rowCount } = this;
      this.rowCount += 1;
      if (rowCount) {
        return [this.formatterOptions.rowDelimiter, formattedCols].join("");
      }
      return formattedCols;
    }
  };
  RowFormatter.RowFormatter = RowFormatter$1;
  return RowFormatter;
}
var hasRequiredFormatter;
function requireFormatter() {
  if (hasRequiredFormatter) return formatter;
  hasRequiredFormatter = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FieldFormatter = exports.RowFormatter = void 0;
    var RowFormatter_1 = requireRowFormatter();
    Object.defineProperty(exports, "RowFormatter", { enumerable: true, get: function() {
      return RowFormatter_1.RowFormatter;
    } });
    var FieldFormatter_1 = requireFieldFormatter();
    Object.defineProperty(exports, "FieldFormatter", { enumerable: true, get: function() {
      return FieldFormatter_1.FieldFormatter;
    } });
  })(formatter);
  return formatter;
}
var hasRequiredCsvFormatterStream;
function requireCsvFormatterStream() {
  if (hasRequiredCsvFormatterStream) return CsvFormatterStream;
  hasRequiredCsvFormatterStream = 1;
  Object.defineProperty(CsvFormatterStream, "__esModule", { value: true });
  CsvFormatterStream.CsvFormatterStream = void 0;
  const stream_1 = require$$0$1;
  const formatter_1 = requireFormatter();
  let CsvFormatterStream$1 = class CsvFormatterStream extends stream_1.Transform {
    constructor(formatterOptions) {
      super({ writableObjectMode: formatterOptions.objectMode });
      this.hasWrittenBOM = false;
      this.formatterOptions = formatterOptions;
      this.rowFormatter = new formatter_1.RowFormatter(formatterOptions);
      this.hasWrittenBOM = !formatterOptions.writeBOM;
    }
    transform(transformFunction) {
      this.rowFormatter.rowTransform = transformFunction;
      return this;
    }
    _transform(row2, encoding, cb) {
      let cbCalled = false;
      try {
        if (!this.hasWrittenBOM) {
          this.push(this.formatterOptions.BOM);
          this.hasWrittenBOM = true;
        }
        this.rowFormatter.format(row2, (err, rows) => {
          if (err) {
            cbCalled = true;
            return cb(err);
          }
          if (rows) {
            rows.forEach((r) => {
              this.push(Buffer.from(r, "utf8"));
            });
          }
          cbCalled = true;
          return cb();
        });
      } catch (e) {
        if (cbCalled) {
          throw e;
        }
        cb(e);
      }
    }
    _flush(cb) {
      this.rowFormatter.finish((err, rows) => {
        if (err) {
          return cb(err);
        }
        if (rows) {
          rows.forEach((r) => {
            this.push(Buffer.from(r, "utf8"));
          });
        }
        return cb();
      });
    }
  };
  CsvFormatterStream.CsvFormatterStream = CsvFormatterStream$1;
  return CsvFormatterStream;
}
var hasRequiredSrc$2;
function requireSrc$2() {
  if (hasRequiredSrc$2) return src$1;
  hasRequiredSrc$2 = 1;
  (function(exports) {
    var __createBinding = src$1 && src$1.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = src$1 && src$1.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = src$1 && src$1.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = src$1 && src$1.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = exports.FormatterOptions = exports.CsvFormatterStream = void 0;
    const util_1 = require$$0$2;
    const stream_1 = require$$0$1;
    const fs2 = __importStar(require$$0$4);
    const FormatterOptions_1 = requireFormatterOptions();
    const CsvFormatterStream_1 = requireCsvFormatterStream();
    __exportStar(requireTypes$1(), exports);
    var CsvFormatterStream_2 = requireCsvFormatterStream();
    Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function() {
      return CsvFormatterStream_2.CsvFormatterStream;
    } });
    var FormatterOptions_2 = requireFormatterOptions();
    Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function() {
      return FormatterOptions_2.FormatterOptions;
    } });
    exports.format = (options) => new CsvFormatterStream_1.CsvFormatterStream(new FormatterOptions_1.FormatterOptions(options));
    exports.write = (rows, options) => {
      const csvStream = exports.format(options);
      const promiseWrite = util_1.promisify((row2, cb) => {
        csvStream.write(row2, void 0, cb);
      });
      rows.reduce((prev, row2) => prev.then(() => promiseWrite(row2)), Promise.resolve()).then(() => csvStream.end()).catch((err) => {
        csvStream.emit("error", err);
      });
      return csvStream;
    };
    exports.writeToStream = (ws, rows, options) => exports.write(rows, options).pipe(ws);
    exports.writeToBuffer = (rows, opts = {}) => {
      const buffers2 = [];
      const ws = new stream_1.Writable({
        write(data2, enc, writeCb) {
          buffers2.push(data2);
          writeCb();
        }
      });
      return new Promise((res, rej) => {
        ws.on("error", rej).on("finish", () => res(Buffer.concat(buffers2)));
        exports.write(rows, opts).pipe(ws);
      });
    };
    exports.writeToString = (rows, options) => exports.writeToBuffer(rows, options).then((buffer) => buffer.toString());
    exports.writeToPath = (path2, rows, options) => {
      const stream2 = fs2.createWriteStream(path2, { encoding: "utf8" });
      return exports.write(rows, options).pipe(stream2);
    };
  })(src$1);
  return src$1;
}
var src = {};
var ParserOptions = {};
var hasRequiredParserOptions;
function requireParserOptions() {
  if (hasRequiredParserOptions) return ParserOptions;
  hasRequiredParserOptions = 1;
  var __importDefault = ParserOptions && ParserOptions.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(ParserOptions, "__esModule", { value: true });
  ParserOptions.ParserOptions = void 0;
  const lodash_escaperegexp_1 = __importDefault(requireLodash_escaperegexp());
  const lodash_isnil_1 = __importDefault(requireLodash_isnil());
  let ParserOptions$1 = class ParserOptions {
    constructor(opts) {
      var _a;
      this.objectMode = true;
      this.delimiter = ",";
      this.ignoreEmpty = false;
      this.quote = '"';
      this.escape = null;
      this.escapeChar = this.quote;
      this.comment = null;
      this.supportsComments = false;
      this.ltrim = false;
      this.rtrim = false;
      this.trim = false;
      this.headers = null;
      this.renameHeaders = false;
      this.strictColumnHandling = false;
      this.discardUnmappedColumns = false;
      this.carriageReturn = "\r";
      this.encoding = "utf8";
      this.limitRows = false;
      this.maxRows = 0;
      this.skipLines = 0;
      this.skipRows = 0;
      Object.assign(this, opts || {});
      if (this.delimiter.length > 1) {
        throw new Error("delimiter option must be one character long");
      }
      this.escapedDelimiter = lodash_escaperegexp_1.default(this.delimiter);
      this.escapeChar = (_a = this.escape) !== null && _a !== void 0 ? _a : this.quote;
      this.supportsComments = !lodash_isnil_1.default(this.comment);
      this.NEXT_TOKEN_REGEXP = new RegExp(`([^\\s]|\\r\\n|\\n|\\r|${this.escapedDelimiter})`);
      if (this.maxRows > 0) {
        this.limitRows = true;
      }
    }
  };
  ParserOptions.ParserOptions = ParserOptions$1;
  return ParserOptions;
}
var CsvParserStream = {};
var transforms = {};
var RowTransformerValidator = {};
var types = {};
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types;
  hasRequiredTypes = 1;
  Object.defineProperty(types, "__esModule", { value: true });
  types.isSyncValidate = types.isSyncTransform = void 0;
  types.isSyncTransform = (transform2) => transform2.length === 1;
  types.isSyncValidate = (validate2) => validate2.length === 1;
  return types;
}
var hasRequiredRowTransformerValidator;
function requireRowTransformerValidator() {
  if (hasRequiredRowTransformerValidator) return RowTransformerValidator;
  hasRequiredRowTransformerValidator = 1;
  var __importDefault = RowTransformerValidator && RowTransformerValidator.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(RowTransformerValidator, "__esModule", { value: true });
  RowTransformerValidator.RowTransformerValidator = void 0;
  const lodash_isfunction_1 = __importDefault(requireLodash_isfunction());
  const types_1 = requireTypes();
  let RowTransformerValidator$1 = class RowTransformerValidator2 {
    constructor() {
      this._rowTransform = null;
      this._rowValidator = null;
    }
    // eslint-disable-next-line @typescript-eslint/no-shadow
    static createTransform(transformFunction) {
      if (types_1.isSyncTransform(transformFunction)) {
        return (row2, cb) => {
          let transformed = null;
          try {
            transformed = transformFunction(row2);
          } catch (e) {
            return cb(e);
          }
          return cb(null, transformed);
        };
      }
      return transformFunction;
    }
    static createValidator(validateFunction) {
      if (types_1.isSyncValidate(validateFunction)) {
        return (row2, cb) => {
          cb(null, { row: row2, isValid: validateFunction(row2) });
        };
      }
      return (row2, cb) => {
        validateFunction(row2, (err, isValid, reason) => {
          if (err) {
            return cb(err);
          }
          if (isValid) {
            return cb(null, { row: row2, isValid, reason });
          }
          return cb(null, { row: row2, isValid: false, reason });
        });
      };
    }
    set rowTransform(transformFunction) {
      if (!lodash_isfunction_1.default(transformFunction)) {
        throw new TypeError("The transform should be a function");
      }
      this._rowTransform = RowTransformerValidator2.createTransform(transformFunction);
    }
    set rowValidator(validateFunction) {
      if (!lodash_isfunction_1.default(validateFunction)) {
        throw new TypeError("The validate should be a function");
      }
      this._rowValidator = RowTransformerValidator2.createValidator(validateFunction);
    }
    transformAndValidate(row2, cb) {
      return this.callTransformer(row2, (transformErr, transformedRow) => {
        if (transformErr) {
          return cb(transformErr);
        }
        if (!transformedRow) {
          return cb(null, { row: null, isValid: true });
        }
        return this.callValidator(transformedRow, (validateErr, validationResult) => {
          if (validateErr) {
            return cb(validateErr);
          }
          if (validationResult && !validationResult.isValid) {
            return cb(null, { row: transformedRow, isValid: false, reason: validationResult.reason });
          }
          return cb(null, { row: transformedRow, isValid: true });
        });
      });
    }
    callTransformer(row2, cb) {
      if (!this._rowTransform) {
        return cb(null, row2);
      }
      return this._rowTransform(row2, cb);
    }
    callValidator(row2, cb) {
      if (!this._rowValidator) {
        return cb(null, { row: row2, isValid: true });
      }
      return this._rowValidator(row2, cb);
    }
  };
  RowTransformerValidator.RowTransformerValidator = RowTransformerValidator$1;
  return RowTransformerValidator;
}
var HeaderTransformer = {};
var lodash_isundefined;
var hasRequiredLodash_isundefined;
function requireLodash_isundefined() {
  if (hasRequiredLodash_isundefined) return lodash_isundefined;
  hasRequiredLodash_isundefined = 1;
  function isUndefined2(value) {
    return value === void 0;
  }
  lodash_isundefined = isUndefined2;
  return lodash_isundefined;
}
var lodash_uniq;
var hasRequiredLodash_uniq;
function requireLodash_uniq() {
  if (hasRequiredLodash_uniq) return lodash_uniq;
  hasRequiredLodash_uniq = 1;
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0;
  var funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index2 = fromIndex + -1;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var splice = arrayProto.splice;
  var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (length >= LARGE_ARRAY_SIZE) {
      var set = createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = result;
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
    return new Set2(values);
  };
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function uniq(array) {
    return array && array.length ? baseUniq(array) : [];
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function noop2() {
  }
  lodash_uniq = uniq;
  return lodash_uniq;
}
var lodash_groupby = { exports: {} };
lodash_groupby.exports;
var hasRequiredLodash_groupby;
function requireLodash_groupby() {
  if (hasRequiredLodash_groupby) return lodash_groupby.exports;
  hasRequiredLodash_groupby = 1;
  (function(module, exports) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1, PARTIAL_COMPARE_FLAG = 2;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", promiseTag = "[object Promise]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, reLeadingDot = /^\./, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array ? array.length : 0;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array ? array.length : 0;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    function baseTimes(n, iteratee) {
      var index2 = -1, result = Array(n);
      while (++index2 < n) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map2) {
      var index2 = -1, result = Array(map2.size);
      map2.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function setToArray(set) {
      var index2 = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol, Uint8Array2 = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView"), Map2 = getNative(root, "Map"), Promise2 = getNative(root, "Promise"), Set2 = getNative(root, "Set"), WeakMap2 = getNative(root, "WeakMap"), nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data2 = this.__data__;
      if (nativeCreate) {
        var result = data2[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
    }
    function hashHas(key) {
      var data2 = this.__data__;
      return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
    }
    function hashSet(key, value) {
      var data2 = this.__data__;
      data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data2.length - 1;
      if (index2 == lastIndex) {
        data2.pop();
      } else {
        splice.call(data2, index2, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      return index2 < 0 ? void 0 : data2[index2][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data2 = this.__data__, index2 = assocIndexOf(data2, key);
      if (index2 < 0) {
        data2.push([key, value]);
      } else {
        data2[index2][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index2 = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index2 = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index2 < length) {
        this.add(values[index2]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if (hasOwnProperty2.call(value, key) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection2) {
        setter(accumulator, value, iteratee(value), collection2);
      });
      return accumulator;
    }
    var baseEach = createBaseEach(baseForOwn);
    var baseFor = createBaseFor();
    function baseForOwn(object2, iteratee) {
      return object2 && baseFor(object2, iteratee, keys);
    }
    function baseGet(object2, path2) {
      path2 = isKey(path2, object2) ? [path2] : castPath(path2);
      var index2 = 0, length = path2.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey(path2[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object2, key) {
      return object2 != null && key in Object(object2);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject2(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object2, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray2(object2), othIsArr = isArray2(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object2);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object2), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray2(object2) ? equalArrays(object2, other, equalFunc, customizer, bitmask, stack) : equalByTag(object2, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object2, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object2, source, matchData, customizer) {
      var index2 = matchData.length, length = index2;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index2--) {
        var data2 = matchData[index2];
        if (data2[2] ? data2[1] !== object2[data2[0]] : !(data2[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length) {
        data2 = matchData[index2];
        var key = data2[0], objValue = object2[key], srcValue = data2[1];
        if (data2[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack();
          var result;
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object2) {
      if (!isPrototype(object2)) {
        return nativeKeys(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty2.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch(object2, source, matchData);
      };
    }
    function baseMatchesProperty(path2, srcValue) {
      if (isKey(path2) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path2), srcValue);
      }
      return function(object2) {
        var objValue = get2(object2, path2);
        return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function basePropertyDeep(path2) {
      return function(object2) {
        return baseGet(object2, path2);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function castPath(value) {
      return isArray2(value) ? value : stringToPath(value);
    }
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = {};
        return func(collection, setter, baseIteratee(iteratee), accumulator);
      };
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike2(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index2 = -1, iterable = Object(collection);
        while (++index2 < length) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props2 = keysFunc(object2), length = props2.length;
        while (length--) {
          var key = props2[++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index2 = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index2 < arrLength) {
        var arrValue = array[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object2, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object2, +other);
        case errorTag:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
          return object2 == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object2, other);
          var result = equalArrays(convert(object2), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object2);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object2) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object2, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object2), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object2);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    function getMapData(map2, key) {
      var data2 = map2.__data__;
      return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
    }
    function getMatchData(object2) {
      var result = keys(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object2, key) {
      var value = getValue(object2, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object2, path2, hasFunc) {
      path2 = isKey(path2, object2) ? [path2] : castPath(path2);
      var result, index2 = -1, length = path2.length;
      while (++index2 < length) {
        var key = toKey(path2[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result) {
        return result;
      }
      var length = object2 ? object2.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray2(object2) || isArguments(object2));
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKey(value, object2) {
      if (isArray2(value)) {
        return false;
      }
      var type2 = typeof value;
      if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
    }
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject2(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    var stringToPath = memoize2(function(string) {
      string = toString3(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -Infinity ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var groupBy2 = createAggregator(function(result, value, key) {
      if (hasOwnProperty2.call(result, key)) {
        result[key].push(value);
      } else {
        result[key] = [value];
      }
    });
    function memoize2(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize2.Cache || MapCache)();
      return memoized;
    }
    memoize2.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    function isFunction2(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString3(value) {
      return value == null ? "" : baseToString(value);
    }
    function get2(object2, path2, defaultValue) {
      var result = object2 == null ? void 0 : baseGet(object2, path2);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object2, path2) {
      return object2 != null && hasPath(object2, path2, baseHasIn);
    }
    function keys(object2) {
      return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
    }
    function identity(value) {
      return value;
    }
    function property(path2) {
      return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
    }
    module.exports = groupBy2;
  })(lodash_groupby, lodash_groupby.exports);
  return lodash_groupby.exports;
}
var hasRequiredHeaderTransformer;
function requireHeaderTransformer() {
  if (hasRequiredHeaderTransformer) return HeaderTransformer;
  hasRequiredHeaderTransformer = 1;
  var __importDefault = HeaderTransformer && HeaderTransformer.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(HeaderTransformer, "__esModule", { value: true });
  HeaderTransformer.HeaderTransformer = void 0;
  const lodash_isundefined_1 = __importDefault(requireLodash_isundefined());
  const lodash_isfunction_1 = __importDefault(requireLodash_isfunction());
  const lodash_uniq_1 = __importDefault(requireLodash_uniq());
  const lodash_groupby_1 = __importDefault(requireLodash_groupby());
  let HeaderTransformer$1 = class HeaderTransformer {
    constructor(parserOptions) {
      this.headers = null;
      this.receivedHeaders = false;
      this.shouldUseFirstRow = false;
      this.processedFirstRow = false;
      this.headersLength = 0;
      this.parserOptions = parserOptions;
      if (parserOptions.headers === true) {
        this.shouldUseFirstRow = true;
      } else if (Array.isArray(parserOptions.headers)) {
        this.setHeaders(parserOptions.headers);
      } else if (lodash_isfunction_1.default(parserOptions.headers)) {
        this.headersTransform = parserOptions.headers;
      }
    }
    transform(row2, cb) {
      if (!this.shouldMapRow(row2)) {
        return cb(null, { row: null, isValid: true });
      }
      return cb(null, this.processRow(row2));
    }
    shouldMapRow(row2) {
      const { parserOptions } = this;
      if (!this.headersTransform && parserOptions.renameHeaders && !this.processedFirstRow) {
        if (!this.receivedHeaders) {
          throw new Error("Error renaming headers: new headers must be provided in an array");
        }
        this.processedFirstRow = true;
        return false;
      }
      if (!this.receivedHeaders && Array.isArray(row2)) {
        if (this.headersTransform) {
          this.setHeaders(this.headersTransform(row2));
        } else if (this.shouldUseFirstRow) {
          this.setHeaders(row2);
        } else {
          return true;
        }
        return false;
      }
      return true;
    }
    processRow(row2) {
      if (!this.headers) {
        return { row: row2, isValid: true };
      }
      const { parserOptions } = this;
      if (!parserOptions.discardUnmappedColumns && row2.length > this.headersLength) {
        if (!parserOptions.strictColumnHandling) {
          throw new Error(`Unexpected Error: column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`);
        }
        return {
          row: row2,
          isValid: false,
          reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`
        };
      }
      if (parserOptions.strictColumnHandling && row2.length < this.headersLength) {
        return {
          row: row2,
          isValid: false,
          reason: `Column header mismatch expected: ${this.headersLength} columns got: ${row2.length}`
        };
      }
      return { row: this.mapHeaders(row2), isValid: true };
    }
    mapHeaders(row2) {
      const rowMap = {};
      const { headers: headers2, headersLength } = this;
      for (let i = 0; i < headersLength; i += 1) {
        const header = headers2[i];
        if (!lodash_isundefined_1.default(header)) {
          const val = row2[i];
          if (lodash_isundefined_1.default(val)) {
            rowMap[header] = "";
          } else {
            rowMap[header] = val;
          }
        }
      }
      return rowMap;
    }
    setHeaders(headers2) {
      var _a;
      const filteredHeaders = headers2.filter((h) => !!h);
      if (lodash_uniq_1.default(filteredHeaders).length !== filteredHeaders.length) {
        const grouped = lodash_groupby_1.default(filteredHeaders);
        const duplicates = Object.keys(grouped).filter((dup) => grouped[dup].length > 1);
        throw new Error(`Duplicate headers found ${JSON.stringify(duplicates)}`);
      }
      this.headers = headers2;
      this.receivedHeaders = true;
      this.headersLength = ((_a = this.headers) === null || _a === void 0 ? void 0 : _a.length) || 0;
    }
  };
  HeaderTransformer.HeaderTransformer = HeaderTransformer$1;
  return HeaderTransformer;
}
var hasRequiredTransforms;
function requireTransforms() {
  if (hasRequiredTransforms) return transforms;
  hasRequiredTransforms = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HeaderTransformer = exports.RowTransformerValidator = void 0;
    var RowTransformerValidator_1 = requireRowTransformerValidator();
    Object.defineProperty(exports, "RowTransformerValidator", { enumerable: true, get: function() {
      return RowTransformerValidator_1.RowTransformerValidator;
    } });
    var HeaderTransformer_1 = requireHeaderTransformer();
    Object.defineProperty(exports, "HeaderTransformer", { enumerable: true, get: function() {
      return HeaderTransformer_1.HeaderTransformer;
    } });
  })(transforms);
  return transforms;
}
var parser = {};
var Parser = {};
var Scanner = {};
var Token = {};
var hasRequiredToken;
function requireToken() {
  if (hasRequiredToken) return Token;
  hasRequiredToken = 1;
  Object.defineProperty(Token, "__esModule", { value: true });
  Token.Token = void 0;
  let Token$1 = class Token {
    constructor(tokenArgs) {
      this.token = tokenArgs.token;
      this.startCursor = tokenArgs.startCursor;
      this.endCursor = tokenArgs.endCursor;
    }
    static isTokenRowDelimiter(token) {
      const content = token.token;
      return content === "\r" || content === "\n" || content === "\r\n";
    }
    static isTokenCarriageReturn(token, parserOptions) {
      return token.token === parserOptions.carriageReturn;
    }
    static isTokenComment(token, parserOptions) {
      return parserOptions.supportsComments && !!token && token.token === parserOptions.comment;
    }
    static isTokenEscapeCharacter(token, parserOptions) {
      return token.token === parserOptions.escapeChar;
    }
    static isTokenQuote(token, parserOptions) {
      return token.token === parserOptions.quote;
    }
    static isTokenDelimiter(token, parserOptions) {
      return token.token === parserOptions.delimiter;
    }
  };
  Token.Token = Token$1;
  return Token;
}
var hasRequiredScanner;
function requireScanner() {
  if (hasRequiredScanner) return Scanner;
  hasRequiredScanner = 1;
  Object.defineProperty(Scanner, "__esModule", { value: true });
  Scanner.Scanner = void 0;
  const Token_1 = requireToken();
  const ROW_DELIMITER = /((?:\r\n)|\n|\r)/;
  let Scanner$1 = class Scanner {
    constructor(args) {
      this.cursor = 0;
      this.line = args.line;
      this.lineLength = this.line.length;
      this.parserOptions = args.parserOptions;
      this.hasMoreData = args.hasMoreData;
      this.cursor = args.cursor || 0;
    }
    get hasMoreCharacters() {
      return this.lineLength > this.cursor;
    }
    get nextNonSpaceToken() {
      const { lineFromCursor } = this;
      const regex2 = this.parserOptions.NEXT_TOKEN_REGEXP;
      if (lineFromCursor.search(regex2) === -1) {
        return null;
      }
      const match = regex2.exec(lineFromCursor);
      if (match == null) {
        return null;
      }
      const token = match[1];
      const startCursor = this.cursor + (match.index || 0);
      return new Token_1.Token({
        token,
        startCursor,
        endCursor: startCursor + token.length - 1
      });
    }
    get nextCharacterToken() {
      const { cursor, lineLength } = this;
      if (lineLength <= cursor) {
        return null;
      }
      return new Token_1.Token({
        token: this.line[cursor],
        startCursor: cursor,
        endCursor: cursor
      });
    }
    get lineFromCursor() {
      return this.line.substr(this.cursor);
    }
    advancePastLine() {
      const match = ROW_DELIMITER.exec(this.lineFromCursor);
      if (!match) {
        if (this.hasMoreData) {
          return null;
        }
        this.cursor = this.lineLength;
        return this;
      }
      this.cursor += (match.index || 0) + match[0].length;
      return this;
    }
    advanceTo(cursor) {
      this.cursor = cursor;
      return this;
    }
    advanceToToken(token) {
      this.cursor = token.startCursor;
      return this;
    }
    advancePastToken(token) {
      this.cursor = token.endCursor + 1;
      return this;
    }
    truncateToCursor() {
      this.line = this.lineFromCursor;
      this.lineLength = this.line.length;
      this.cursor = 0;
      return this;
    }
  };
  Scanner.Scanner = Scanner$1;
  return Scanner;
}
var RowParser = {};
var column = {};
var ColumnParser = {};
var NonQuotedColumnParser = {};
var ColumnFormatter = {};
var hasRequiredColumnFormatter;
function requireColumnFormatter() {
  if (hasRequiredColumnFormatter) return ColumnFormatter;
  hasRequiredColumnFormatter = 1;
  Object.defineProperty(ColumnFormatter, "__esModule", { value: true });
  ColumnFormatter.ColumnFormatter = void 0;
  let ColumnFormatter$1 = class ColumnFormatter {
    constructor(parserOptions) {
      if (parserOptions.trim) {
        this.format = (col) => col.trim();
      } else if (parserOptions.ltrim) {
        this.format = (col) => col.trimLeft();
      } else if (parserOptions.rtrim) {
        this.format = (col) => col.trimRight();
      } else {
        this.format = (col) => col;
      }
    }
  };
  ColumnFormatter.ColumnFormatter = ColumnFormatter$1;
  return ColumnFormatter;
}
var hasRequiredNonQuotedColumnParser;
function requireNonQuotedColumnParser() {
  if (hasRequiredNonQuotedColumnParser) return NonQuotedColumnParser;
  hasRequiredNonQuotedColumnParser = 1;
  Object.defineProperty(NonQuotedColumnParser, "__esModule", { value: true });
  NonQuotedColumnParser.NonQuotedColumnParser = void 0;
  const ColumnFormatter_1 = requireColumnFormatter();
  const Token_1 = requireToken();
  let NonQuotedColumnParser$1 = class NonQuotedColumnParser {
    constructor(parserOptions) {
      this.parserOptions = parserOptions;
      this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
    }
    parse(scanner) {
      if (!scanner.hasMoreCharacters) {
        return null;
      }
      const { parserOptions } = this;
      const characters = [];
      let nextToken = scanner.nextCharacterToken;
      for (; nextToken; nextToken = scanner.nextCharacterToken) {
        if (Token_1.Token.isTokenDelimiter(nextToken, parserOptions) || Token_1.Token.isTokenRowDelimiter(nextToken)) {
          break;
        }
        characters.push(nextToken.token);
        scanner.advancePastToken(nextToken);
      }
      return this.columnFormatter.format(characters.join(""));
    }
  };
  NonQuotedColumnParser.NonQuotedColumnParser = NonQuotedColumnParser$1;
  return NonQuotedColumnParser;
}
var QuotedColumnParser = {};
var hasRequiredQuotedColumnParser;
function requireQuotedColumnParser() {
  if (hasRequiredQuotedColumnParser) return QuotedColumnParser;
  hasRequiredQuotedColumnParser = 1;
  Object.defineProperty(QuotedColumnParser, "__esModule", { value: true });
  QuotedColumnParser.QuotedColumnParser = void 0;
  const ColumnFormatter_1 = requireColumnFormatter();
  const Token_1 = requireToken();
  let QuotedColumnParser$1 = class QuotedColumnParser {
    constructor(parserOptions) {
      this.parserOptions = parserOptions;
      this.columnFormatter = new ColumnFormatter_1.ColumnFormatter(parserOptions);
    }
    parse(scanner) {
      if (!scanner.hasMoreCharacters) {
        return null;
      }
      const originalCursor = scanner.cursor;
      const { foundClosingQuote, col } = this.gatherDataBetweenQuotes(scanner);
      if (!foundClosingQuote) {
        scanner.advanceTo(originalCursor);
        if (!scanner.hasMoreData) {
          throw new Error(`Parse Error: missing closing: '${this.parserOptions.quote || ""}' in line: at '${scanner.lineFromCursor.replace(/[\r\n]/g, "\\n'")}'`);
        }
        return null;
      }
      this.checkForMalformedColumn(scanner);
      return col;
    }
    gatherDataBetweenQuotes(scanner) {
      const { parserOptions } = this;
      let foundStartingQuote = false;
      let foundClosingQuote = false;
      const characters = [];
      let nextToken = scanner.nextCharacterToken;
      for (; !foundClosingQuote && nextToken !== null; nextToken = scanner.nextCharacterToken) {
        const isQuote = Token_1.Token.isTokenQuote(nextToken, parserOptions);
        if (!foundStartingQuote && isQuote) {
          foundStartingQuote = true;
        } else if (foundStartingQuote) {
          if (Token_1.Token.isTokenEscapeCharacter(nextToken, parserOptions)) {
            scanner.advancePastToken(nextToken);
            const tokenFollowingEscape = scanner.nextCharacterToken;
            if (tokenFollowingEscape !== null && (Token_1.Token.isTokenQuote(tokenFollowingEscape, parserOptions) || Token_1.Token.isTokenEscapeCharacter(tokenFollowingEscape, parserOptions))) {
              characters.push(tokenFollowingEscape.token);
              nextToken = tokenFollowingEscape;
            } else if (isQuote) {
              foundClosingQuote = true;
            } else {
              characters.push(nextToken.token);
            }
          } else if (isQuote) {
            foundClosingQuote = true;
          } else {
            characters.push(nextToken.token);
          }
        }
        scanner.advancePastToken(nextToken);
      }
      return { col: this.columnFormatter.format(characters.join("")), foundClosingQuote };
    }
    checkForMalformedColumn(scanner) {
      const { parserOptions } = this;
      const { nextNonSpaceToken } = scanner;
      if (nextNonSpaceToken) {
        const isNextTokenADelimiter = Token_1.Token.isTokenDelimiter(nextNonSpaceToken, parserOptions);
        const isNextTokenARowDelimiter = Token_1.Token.isTokenRowDelimiter(nextNonSpaceToken);
        if (!(isNextTokenADelimiter || isNextTokenARowDelimiter)) {
          const linePreview = scanner.lineFromCursor.substr(0, 10).replace(/[\r\n]/g, "\\n'");
          throw new Error(`Parse Error: expected: '${parserOptions.escapedDelimiter}' OR new line got: '${nextNonSpaceToken.token}'. at '${linePreview}`);
        }
        scanner.advanceToToken(nextNonSpaceToken);
      } else if (!scanner.hasMoreData) {
        scanner.advancePastLine();
      }
    }
  };
  QuotedColumnParser.QuotedColumnParser = QuotedColumnParser$1;
  return QuotedColumnParser;
}
var hasRequiredColumnParser;
function requireColumnParser() {
  if (hasRequiredColumnParser) return ColumnParser;
  hasRequiredColumnParser = 1;
  Object.defineProperty(ColumnParser, "__esModule", { value: true });
  ColumnParser.ColumnParser = void 0;
  const NonQuotedColumnParser_1 = requireNonQuotedColumnParser();
  const QuotedColumnParser_1 = requireQuotedColumnParser();
  const Token_1 = requireToken();
  let ColumnParser$1 = class ColumnParser {
    constructor(parserOptions) {
      this.parserOptions = parserOptions;
      this.quotedColumnParser = new QuotedColumnParser_1.QuotedColumnParser(parserOptions);
      this.nonQuotedColumnParser = new NonQuotedColumnParser_1.NonQuotedColumnParser(parserOptions);
    }
    parse(scanner) {
      const { nextNonSpaceToken } = scanner;
      if (nextNonSpaceToken !== null && Token_1.Token.isTokenQuote(nextNonSpaceToken, this.parserOptions)) {
        scanner.advanceToToken(nextNonSpaceToken);
        return this.quotedColumnParser.parse(scanner);
      }
      return this.nonQuotedColumnParser.parse(scanner);
    }
  };
  ColumnParser.ColumnParser = ColumnParser$1;
  return ColumnParser;
}
var hasRequiredColumn;
function requireColumn() {
  if (hasRequiredColumn) return column;
  hasRequiredColumn = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ColumnFormatter = exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = void 0;
    var ColumnParser_1 = requireColumnParser();
    Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function() {
      return ColumnParser_1.ColumnParser;
    } });
    var NonQuotedColumnParser_1 = requireNonQuotedColumnParser();
    Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function() {
      return NonQuotedColumnParser_1.NonQuotedColumnParser;
    } });
    var QuotedColumnParser_1 = requireQuotedColumnParser();
    Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function() {
      return QuotedColumnParser_1.QuotedColumnParser;
    } });
    var ColumnFormatter_1 = requireColumnFormatter();
    Object.defineProperty(exports, "ColumnFormatter", { enumerable: true, get: function() {
      return ColumnFormatter_1.ColumnFormatter;
    } });
  })(column);
  return column;
}
var hasRequiredRowParser;
function requireRowParser() {
  if (hasRequiredRowParser) return RowParser;
  hasRequiredRowParser = 1;
  Object.defineProperty(RowParser, "__esModule", { value: true });
  RowParser.RowParser = void 0;
  const column_1 = requireColumn();
  const Token_1 = requireToken();
  const EMPTY_STRING = "";
  let RowParser$1 = class RowParser {
    constructor(parserOptions) {
      this.parserOptions = parserOptions;
      this.columnParser = new column_1.ColumnParser(parserOptions);
    }
    static isEmptyRow(row2) {
      return row2.join(EMPTY_STRING).replace(/\s+/g, EMPTY_STRING) === EMPTY_STRING;
    }
    parse(scanner) {
      const { parserOptions } = this;
      const { hasMoreData } = scanner;
      const currentScanner = scanner;
      const columns = [];
      let currentToken = this.getStartToken(currentScanner, columns);
      while (currentToken) {
        if (Token_1.Token.isTokenRowDelimiter(currentToken)) {
          currentScanner.advancePastToken(currentToken);
          if (!currentScanner.hasMoreCharacters && Token_1.Token.isTokenCarriageReturn(currentToken, parserOptions) && hasMoreData) {
            return null;
          }
          currentScanner.truncateToCursor();
          return columns;
        }
        if (!this.shouldSkipColumnParse(currentScanner, currentToken, columns)) {
          const item = this.columnParser.parse(currentScanner);
          if (item === null) {
            return null;
          }
          columns.push(item);
        }
        currentToken = currentScanner.nextNonSpaceToken;
      }
      if (!hasMoreData) {
        currentScanner.truncateToCursor();
        return columns;
      }
      return null;
    }
    getStartToken(scanner, columns) {
      const currentToken = scanner.nextNonSpaceToken;
      if (currentToken !== null && Token_1.Token.isTokenDelimiter(currentToken, this.parserOptions)) {
        columns.push("");
        return scanner.nextNonSpaceToken;
      }
      return currentToken;
    }
    shouldSkipColumnParse(scanner, currentToken, columns) {
      const { parserOptions } = this;
      if (Token_1.Token.isTokenDelimiter(currentToken, parserOptions)) {
        scanner.advancePastToken(currentToken);
        const nextToken = scanner.nextCharacterToken;
        if (!scanner.hasMoreCharacters || nextToken !== null && Token_1.Token.isTokenRowDelimiter(nextToken)) {
          columns.push("");
          return true;
        }
        if (nextToken !== null && Token_1.Token.isTokenDelimiter(nextToken, parserOptions)) {
          columns.push("");
          return true;
        }
      }
      return false;
    }
  };
  RowParser.RowParser = RowParser$1;
  return RowParser;
}
var hasRequiredParser$1;
function requireParser$1() {
  if (hasRequiredParser$1) return Parser;
  hasRequiredParser$1 = 1;
  Object.defineProperty(Parser, "__esModule", { value: true });
  Parser.Parser = void 0;
  const Scanner_1 = requireScanner();
  const RowParser_1 = requireRowParser();
  const Token_1 = requireToken();
  let Parser$1 = class Parser2 {
    constructor(parserOptions) {
      this.parserOptions = parserOptions;
      this.rowParser = new RowParser_1.RowParser(this.parserOptions);
    }
    static removeBOM(line) {
      if (line && line.charCodeAt(0) === 65279) {
        return line.slice(1);
      }
      return line;
    }
    parse(line, hasMoreData) {
      const scanner = new Scanner_1.Scanner({
        line: Parser2.removeBOM(line),
        parserOptions: this.parserOptions,
        hasMoreData
      });
      if (this.parserOptions.supportsComments) {
        return this.parseWithComments(scanner);
      }
      return this.parseWithoutComments(scanner);
    }
    parseWithoutComments(scanner) {
      const rows = [];
      let shouldContinue = true;
      while (shouldContinue) {
        shouldContinue = this.parseRow(scanner, rows);
      }
      return { line: scanner.line, rows };
    }
    parseWithComments(scanner) {
      const { parserOptions } = this;
      const rows = [];
      for (let nextToken = scanner.nextCharacterToken; nextToken !== null; nextToken = scanner.nextCharacterToken) {
        if (Token_1.Token.isTokenComment(nextToken, parserOptions)) {
          const cursor = scanner.advancePastLine();
          if (cursor === null) {
            return { line: scanner.lineFromCursor, rows };
          }
          if (!scanner.hasMoreCharacters) {
            return { line: scanner.lineFromCursor, rows };
          }
          scanner.truncateToCursor();
        } else if (!this.parseRow(scanner, rows)) {
          break;
        }
      }
      return { line: scanner.line, rows };
    }
    parseRow(scanner, rows) {
      const nextToken = scanner.nextNonSpaceToken;
      if (!nextToken) {
        return false;
      }
      const row2 = this.rowParser.parse(scanner);
      if (row2 === null) {
        return false;
      }
      if (this.parserOptions.ignoreEmpty && RowParser_1.RowParser.isEmptyRow(row2)) {
        return true;
      }
      rows.push(row2);
      return true;
    }
  };
  Parser.Parser = Parser$1;
  return Parser;
}
var hasRequiredParser;
function requireParser() {
  if (hasRequiredParser) return parser;
  hasRequiredParser = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuotedColumnParser = exports.NonQuotedColumnParser = exports.ColumnParser = exports.Token = exports.Scanner = exports.RowParser = exports.Parser = void 0;
    var Parser_1 = requireParser$1();
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return Parser_1.Parser;
    } });
    var RowParser_1 = requireRowParser();
    Object.defineProperty(exports, "RowParser", { enumerable: true, get: function() {
      return RowParser_1.RowParser;
    } });
    var Scanner_1 = requireScanner();
    Object.defineProperty(exports, "Scanner", { enumerable: true, get: function() {
      return Scanner_1.Scanner;
    } });
    var Token_1 = requireToken();
    Object.defineProperty(exports, "Token", { enumerable: true, get: function() {
      return Token_1.Token;
    } });
    var column_1 = requireColumn();
    Object.defineProperty(exports, "ColumnParser", { enumerable: true, get: function() {
      return column_1.ColumnParser;
    } });
    Object.defineProperty(exports, "NonQuotedColumnParser", { enumerable: true, get: function() {
      return column_1.NonQuotedColumnParser;
    } });
    Object.defineProperty(exports, "QuotedColumnParser", { enumerable: true, get: function() {
      return column_1.QuotedColumnParser;
    } });
  })(parser);
  return parser;
}
var hasRequiredCsvParserStream;
function requireCsvParserStream() {
  if (hasRequiredCsvParserStream) return CsvParserStream;
  hasRequiredCsvParserStream = 1;
  Object.defineProperty(CsvParserStream, "__esModule", { value: true });
  CsvParserStream.CsvParserStream = void 0;
  const string_decoder_1 = require$$0$8;
  const stream_1 = require$$0$1;
  const transforms_1 = requireTransforms();
  const parser_1 = requireParser();
  let CsvParserStream$1 = class CsvParserStream2 extends stream_1.Transform {
    constructor(parserOptions) {
      super({ objectMode: parserOptions.objectMode });
      this.lines = "";
      this.rowCount = 0;
      this.parsedRowCount = 0;
      this.parsedLineCount = 0;
      this.endEmitted = false;
      this.headersEmitted = false;
      this.parserOptions = parserOptions;
      this.parser = new parser_1.Parser(parserOptions);
      this.headerTransformer = new transforms_1.HeaderTransformer(parserOptions);
      this.decoder = new string_decoder_1.StringDecoder(parserOptions.encoding);
      this.rowTransformerValidator = new transforms_1.RowTransformerValidator();
    }
    get hasHitRowLimit() {
      return this.parserOptions.limitRows && this.rowCount >= this.parserOptions.maxRows;
    }
    get shouldEmitRows() {
      return this.parsedRowCount > this.parserOptions.skipRows;
    }
    get shouldSkipLine() {
      return this.parsedLineCount <= this.parserOptions.skipLines;
    }
    transform(transformFunction) {
      this.rowTransformerValidator.rowTransform = transformFunction;
      return this;
    }
    validate(validateFunction) {
      this.rowTransformerValidator.rowValidator = validateFunction;
      return this;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    emit(event, ...rest) {
      if (event === "end") {
        if (!this.endEmitted) {
          this.endEmitted = true;
          super.emit("end", this.rowCount);
        }
        return false;
      }
      return super.emit(event, ...rest);
    }
    _transform(data2, encoding, done) {
      if (this.hasHitRowLimit) {
        return done();
      }
      const wrappedCallback = CsvParserStream2.wrapDoneCallback(done);
      try {
        const { lines } = this;
        const newLine = lines + this.decoder.write(data2);
        const rows = this.parse(newLine, true);
        return this.processRows(rows, wrappedCallback);
      } catch (e) {
        return wrappedCallback(e);
      }
    }
    _flush(done) {
      const wrappedCallback = CsvParserStream2.wrapDoneCallback(done);
      if (this.hasHitRowLimit) {
        return wrappedCallback();
      }
      try {
        const newLine = this.lines + this.decoder.end();
        const rows = this.parse(newLine, false);
        return this.processRows(rows, wrappedCallback);
      } catch (e) {
        return wrappedCallback(e);
      }
    }
    parse(data2, hasMoreData) {
      if (!data2) {
        return [];
      }
      const { line, rows } = this.parser.parse(data2, hasMoreData);
      this.lines = line;
      return rows;
    }
    processRows(rows, cb) {
      const rowsLength = rows.length;
      const iterate = (i) => {
        const callNext = (err) => {
          if (err) {
            return cb(err);
          }
          if (i % 100 === 0) {
            setImmediate(() => iterate(i + 1));
            return void 0;
          }
          return iterate(i + 1);
        };
        this.checkAndEmitHeaders();
        if (i >= rowsLength || this.hasHitRowLimit) {
          return cb();
        }
        this.parsedLineCount += 1;
        if (this.shouldSkipLine) {
          return callNext();
        }
        const row2 = rows[i];
        this.rowCount += 1;
        this.parsedRowCount += 1;
        const nextRowCount = this.rowCount;
        return this.transformRow(row2, (err, transformResult) => {
          if (err) {
            this.rowCount -= 1;
            return callNext(err);
          }
          if (!transformResult) {
            return callNext(new Error("expected transform result"));
          }
          if (!transformResult.isValid) {
            this.emit("data-invalid", transformResult.row, nextRowCount, transformResult.reason);
          } else if (transformResult.row) {
            return this.pushRow(transformResult.row, callNext);
          }
          return callNext();
        });
      };
      iterate(0);
    }
    transformRow(parsedRow, cb) {
      try {
        this.headerTransformer.transform(parsedRow, (err, withHeaders) => {
          if (err) {
            return cb(err);
          }
          if (!withHeaders) {
            return cb(new Error("Expected result from header transform"));
          }
          if (!withHeaders.isValid) {
            if (this.shouldEmitRows) {
              return cb(null, { isValid: false, row: parsedRow });
            }
            return this.skipRow(cb);
          }
          if (withHeaders.row) {
            if (this.shouldEmitRows) {
              return this.rowTransformerValidator.transformAndValidate(withHeaders.row, cb);
            }
            return this.skipRow(cb);
          }
          this.rowCount -= 1;
          this.parsedRowCount -= 1;
          return cb(null, { row: null, isValid: true });
        });
      } catch (e) {
        cb(e);
      }
    }
    checkAndEmitHeaders() {
      if (!this.headersEmitted && this.headerTransformer.headers) {
        this.headersEmitted = true;
        this.emit("headers", this.headerTransformer.headers);
      }
    }
    skipRow(cb) {
      this.rowCount -= 1;
      return cb(null, { row: null, isValid: true });
    }
    pushRow(row2, cb) {
      try {
        if (!this.parserOptions.objectMode) {
          this.push(JSON.stringify(row2));
        } else {
          this.push(row2);
        }
        cb();
      } catch (e) {
        cb(e);
      }
    }
    static wrapDoneCallback(done) {
      let errorCalled = false;
      return (err, ...args) => {
        if (err) {
          if (errorCalled) {
            throw err;
          }
          errorCalled = true;
          done(err);
          return;
        }
        done(...args);
      };
    }
  };
  CsvParserStream.CsvParserStream = CsvParserStream$1;
  return CsvParserStream;
}
var hasRequiredSrc$1;
function requireSrc$1() {
  if (hasRequiredSrc$1) return src;
  hasRequiredSrc$1 = 1;
  (function(exports) {
    var __createBinding = src && src.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = src && src.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = src && src.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = src && src.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseString = exports.parseFile = exports.parseStream = exports.parse = exports.ParserOptions = exports.CsvParserStream = void 0;
    const fs2 = __importStar(require$$0$4);
    const stream_1 = require$$0$1;
    const ParserOptions_1 = requireParserOptions();
    const CsvParserStream_1 = requireCsvParserStream();
    __exportStar(requireTypes(), exports);
    var CsvParserStream_2 = requireCsvParserStream();
    Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function() {
      return CsvParserStream_2.CsvParserStream;
    } });
    var ParserOptions_2 = requireParserOptions();
    Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function() {
      return ParserOptions_2.ParserOptions;
    } });
    exports.parse = (args) => new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(args));
    exports.parseStream = (stream2, options) => stream2.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    exports.parseFile = (location, options = {}) => fs2.createReadStream(location).pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    exports.parseString = (string, options) => {
      const rs = new stream_1.Readable();
      rs.push(string);
      rs.push(null);
      return rs.pipe(new CsvParserStream_1.CsvParserStream(new ParserOptions_1.ParserOptions(options)));
    };
  })(src);
  return src;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src$2;
  hasRequiredSrc = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CsvParserStream = exports.ParserOptions = exports.parseFile = exports.parseStream = exports.parseString = exports.parse = exports.FormatterOptions = exports.CsvFormatterStream = exports.writeToPath = exports.writeToString = exports.writeToBuffer = exports.writeToStream = exports.write = exports.format = void 0;
    var format_1 = requireSrc$2();
    Object.defineProperty(exports, "format", { enumerable: true, get: function() {
      return format_1.format;
    } });
    Object.defineProperty(exports, "write", { enumerable: true, get: function() {
      return format_1.write;
    } });
    Object.defineProperty(exports, "writeToStream", { enumerable: true, get: function() {
      return format_1.writeToStream;
    } });
    Object.defineProperty(exports, "writeToBuffer", { enumerable: true, get: function() {
      return format_1.writeToBuffer;
    } });
    Object.defineProperty(exports, "writeToString", { enumerable: true, get: function() {
      return format_1.writeToString;
    } });
    Object.defineProperty(exports, "writeToPath", { enumerable: true, get: function() {
      return format_1.writeToPath;
    } });
    Object.defineProperty(exports, "CsvFormatterStream", { enumerable: true, get: function() {
      return format_1.CsvFormatterStream;
    } });
    Object.defineProperty(exports, "FormatterOptions", { enumerable: true, get: function() {
      return format_1.FormatterOptions;
    } });
    var parse_1 = requireSrc$1();
    Object.defineProperty(exports, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    Object.defineProperty(exports, "parseString", { enumerable: true, get: function() {
      return parse_1.parseString;
    } });
    Object.defineProperty(exports, "parseStream", { enumerable: true, get: function() {
      return parse_1.parseStream;
    } });
    Object.defineProperty(exports, "parseFile", { enumerable: true, get: function() {
      return parse_1.parseFile;
    } });
    Object.defineProperty(exports, "ParserOptions", { enumerable: true, get: function() {
      return parse_1.ParserOptions;
    } });
    Object.defineProperty(exports, "CsvParserStream", { enumerable: true, get: function() {
      return parse_1.CsvParserStream;
    } });
  })(src$2);
  return src$2;
}
var customParseFormat$1 = { exports: {} };
var customParseFormat = customParseFormat$1.exports;
var hasRequiredCustomParseFormat;
function requireCustomParseFormat() {
  if (hasRequiredCustomParseFormat) return customParseFormat$1.exports;
  hasRequiredCustomParseFormat = 1;
  (function(module, exports) {
    !function(e, t) {
      module.exports = t();
    }(customParseFormat, function() {
      var e = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, n = /\d/, r = /\d\d/, i = /\d\d?/, o = /\d*[^-_:/,()\s\d]+/, s = {}, a = function(e2) {
        return (e2 = +e2) + (e2 > 68 ? 1900 : 2e3);
      };
      var f = function(e2) {
        return function(t2) {
          this[e2] = +t2;
        };
      }, h = [/[+-]\d\d:?(\d\d)?|Z/, function(e2) {
        (this.zone || (this.zone = {})).offset = function(e3) {
          if (!e3) return 0;
          if ("Z" === e3) return 0;
          var t2 = e3.match(/([+-]|\d\d)/g), n2 = 60 * t2[1] + (+t2[2] || 0);
          return 0 === n2 ? 0 : "+" === t2[0] ? -n2 : n2;
        }(e2);
      }], u = function(e2) {
        var t2 = s[e2];
        return t2 && (t2.indexOf ? t2 : t2.s.concat(t2.f));
      }, d = function(e2, t2) {
        var n2, r2 = s.meridiem;
        if (r2) {
          for (var i2 = 1; i2 <= 24; i2 += 1) if (e2.indexOf(r2(i2, 0, t2)) > -1) {
            n2 = i2 > 12;
            break;
          }
        } else n2 = e2 === (t2 ? "pm" : "PM");
        return n2;
      }, c = { A: [o, function(e2) {
        this.afternoon = d(e2, false);
      }], a: [o, function(e2) {
        this.afternoon = d(e2, true);
      }], Q: [n, function(e2) {
        this.month = 3 * (e2 - 1) + 1;
      }], S: [n, function(e2) {
        this.milliseconds = 100 * +e2;
      }], SS: [r, function(e2) {
        this.milliseconds = 10 * +e2;
      }], SSS: [/\d{3}/, function(e2) {
        this.milliseconds = +e2;
      }], s: [i, f("seconds")], ss: [i, f("seconds")], m: [i, f("minutes")], mm: [i, f("minutes")], H: [i, f("hours")], h: [i, f("hours")], HH: [i, f("hours")], hh: [i, f("hours")], D: [i, f("day")], DD: [r, f("day")], Do: [o, function(e2) {
        var t2 = s.ordinal, n2 = e2.match(/\d+/);
        if (this.day = n2[0], t2) for (var r2 = 1; r2 <= 31; r2 += 1) t2(r2).replace(/\[|\]/g, "") === e2 && (this.day = r2);
      }], w: [i, f("week")], ww: [r, f("week")], M: [i, f("month")], MM: [r, f("month")], MMM: [o, function(e2) {
        var t2 = u("months"), n2 = (u("monthsShort") || t2.map(function(e3) {
          return e3.slice(0, 3);
        })).indexOf(e2) + 1;
        if (n2 < 1) throw new Error();
        this.month = n2 % 12 || n2;
      }], MMMM: [o, function(e2) {
        var t2 = u("months").indexOf(e2) + 1;
        if (t2 < 1) throw new Error();
        this.month = t2 % 12 || t2;
      }], Y: [/[+-]?\d+/, f("year")], YY: [r, function(e2) {
        this.year = a(e2);
      }], YYYY: [/\d{4}/, f("year")], Z: h, ZZ: h };
      function l(n2) {
        var r2, i2;
        r2 = n2, i2 = s && s.formats;
        for (var o2 = (n2 = r2.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(t2, n3, r3) {
          var o3 = r3 && r3.toUpperCase();
          return n3 || i2[r3] || e[r3] || i2[o3].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(e2, t3, n4) {
            return t3 || n4.slice(1);
          });
        })).match(t), a2 = o2.length, f2 = 0; f2 < a2; f2 += 1) {
          var h2 = o2[f2], u2 = c[h2], d2 = u2 && u2[0], l2 = u2 && u2[1];
          o2[f2] = l2 ? { regex: d2, parser: l2 } : h2.replace(/^\[|\]$/g, "");
        }
        return function(e2) {
          for (var t2 = {}, n3 = 0, r3 = 0; n3 < a2; n3 += 1) {
            var i3 = o2[n3];
            if ("string" == typeof i3) r3 += i3.length;
            else {
              var s2 = i3.regex, f3 = i3.parser, h3 = e2.slice(r3), u3 = s2.exec(h3)[0];
              f3.call(t2, u3), e2 = e2.replace(u3, "");
            }
          }
          return function(e3) {
            var t3 = e3.afternoon;
            if (void 0 !== t3) {
              var n4 = e3.hours;
              t3 ? n4 < 12 && (e3.hours += 12) : 12 === n4 && (e3.hours = 0), delete e3.afternoon;
            }
          }(t2), t2;
        };
      }
      return function(e2, t2, n2) {
        n2.p.customParseFormat = true, e2 && e2.parseTwoDigitYear && (a = e2.parseTwoDigitYear);
        var r2 = t2.prototype, i2 = r2.parse;
        r2.parse = function(e3) {
          var t3 = e3.date, r3 = e3.utc, o2 = e3.args;
          this.$u = r3;
          var a2 = o2[1];
          if ("string" == typeof a2) {
            var f2 = true === o2[2], h2 = true === o2[3], u2 = f2 || h2, d2 = o2[2];
            h2 && (d2 = o2[2]), s = this.$locale(), !f2 && d2 && (s = n2.Ls[d2]), this.$d = function(e4, t4, n3, r4) {
              try {
                if (["x", "X"].indexOf(t4) > -1) return new Date(("X" === t4 ? 1e3 : 1) * e4);
                var i3 = l(t4)(e4), o3 = i3.year, s2 = i3.month, a3 = i3.day, f3 = i3.hours, h3 = i3.minutes, u3 = i3.seconds, d3 = i3.milliseconds, c3 = i3.zone, m2 = i3.week, M2 = /* @__PURE__ */ new Date(), Y = a3 || (o3 || s2 ? 1 : M2.getDate()), p = o3 || M2.getFullYear(), v = 0;
                o3 && !s2 || (v = s2 > 0 ? s2 - 1 : M2.getMonth());
                var D, w = f3 || 0, g = h3 || 0, y = u3 || 0, L = d3 || 0;
                return c3 ? new Date(Date.UTC(p, v, Y, w, g, y, L + 60 * c3.offset * 1e3)) : n3 ? new Date(Date.UTC(p, v, Y, w, g, y, L)) : (D = new Date(p, v, Y, w, g, y, L), m2 && (D = r4(D).week(m2).toDate()), D);
              } catch (e5) {
                return /* @__PURE__ */ new Date("");
              }
            }(t3, a2, r3, n2), this.init(), d2 && true !== d2 && (this.$L = this.locale(d2).$L), u2 && t3 != this.format(a2) && (this.$d = /* @__PURE__ */ new Date("")), s = {};
          } else if (a2 instanceof Array) for (var c2 = a2.length, m = 1; m <= c2; m += 1) {
            o2[1] = a2[m - 1];
            var M = n2.apply(this, o2);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === c2 && (this.$d = /* @__PURE__ */ new Date(""));
          }
          else i2.call(this, e3);
        };
      };
    });
  })(customParseFormat$1);
  return customParseFormat$1.exports;
}
var utc$1 = { exports: {} };
var utc = utc$1.exports;
var hasRequiredUtc;
function requireUtc() {
  if (hasRequiredUtc) return utc$1.exports;
  hasRequiredUtc = 1;
  (function(module, exports) {
    !function(t, i) {
      module.exports = i();
    }(utc, function() {
      var t = "minute", i = /[+-]\d\d(?::?\d\d)?/g, e = /([+-]|\d\d)/g;
      return function(s, f, n) {
        var u = f.prototype;
        n.utc = function(t2) {
          var i2 = { date: t2, utc: true, args: arguments };
          return new f(i2);
        }, u.utc = function(i2) {
          var e2 = n(this.toDate(), { locale: this.$L, utc: true });
          return i2 ? e2.add(this.utcOffset(), t) : e2;
        }, u.local = function() {
          return n(this.toDate(), { locale: this.$L, utc: false });
        };
        var o = u.parse;
        u.parse = function(t2) {
          t2.utc && (this.$u = true), this.$utils().u(t2.$offset) || (this.$offset = t2.$offset), o.call(this, t2);
        };
        var r = u.init;
        u.init = function() {
          if (this.$u) {
            var t2 = this.$d;
            this.$y = t2.getUTCFullYear(), this.$M = t2.getUTCMonth(), this.$D = t2.getUTCDate(), this.$W = t2.getUTCDay(), this.$H = t2.getUTCHours(), this.$m = t2.getUTCMinutes(), this.$s = t2.getUTCSeconds(), this.$ms = t2.getUTCMilliseconds();
          } else r.call(this);
        };
        var a = u.utcOffset;
        u.utcOffset = function(s2, f2) {
          var n2 = this.$utils().u;
          if (n2(s2)) return this.$u ? 0 : n2(this.$offset) ? a.call(this) : this.$offset;
          if ("string" == typeof s2 && (s2 = function(t2) {
            void 0 === t2 && (t2 = "");
            var s3 = t2.match(i);
            if (!s3) return null;
            var f3 = ("" + s3[0]).match(e) || ["-", 0, 0], n3 = f3[0], u3 = 60 * +f3[1] + +f3[2];
            return 0 === u3 ? 0 : "+" === n3 ? u3 : -u3;
          }(s2), null === s2)) return this;
          var u2 = Math.abs(s2) <= 16 ? 60 * s2 : s2, o2 = this;
          if (f2) return o2.$offset = u2, o2.$u = 0 === s2, o2;
          if (0 !== s2) {
            var r2 = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
            (o2 = this.local().add(u2 + r2, t)).$offset = u2, o2.$x.$localOffset = r2;
          } else o2 = this.utc();
          return o2;
        };
        var h = u.format;
        u.format = function(t2) {
          var i2 = t2 || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
          return h.call(this, i2);
        }, u.valueOf = function() {
          var t2 = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
          return this.$d.valueOf() - 6e4 * t2;
        }, u.isUTC = function() {
          return !!this.$u;
        }, u.toISOString = function() {
          return this.toDate().toISOString();
        }, u.toString = function() {
          return this.toDate().toUTCString();
        };
        var l = u.toDate;
        u.toDate = function(t2) {
          return "s" === t2 && this.$offset ? n(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : l.call(this);
        };
        var c = u.diff;
        u.diff = function(t2, i2, e2) {
          if (t2 && this.$u === t2.$u) return c.call(this, t2, i2, e2);
          var s2 = this.local(), f2 = n(t2).local();
          return c.call(s2, f2, i2, e2);
        };
      };
    });
  })(utc$1);
  return utc$1.exports;
}
var dayjs_min$1 = { exports: {} };
var dayjs_min = dayjs_min$1.exports;
var hasRequiredDayjs_min;
function requireDayjs_min() {
  if (hasRequiredDayjs_min) return dayjs_min$1.exports;
  hasRequiredDayjs_min = 1;
  (function(module, exports) {
    !function(t, e) {
      module.exports = e();
    }(dayjs_min, function() {
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date()) return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _2 || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2) return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1) return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2)) return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _2(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _2 = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2) return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2)) return /* @__PURE__ */ new Date();
            if (e2 instanceof Date) return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c) return this.set(c, this.$M + r2);
          if ($2 === h) return this.set(h, this.$y + r2);
          if ($2 === a) return y2(1);
          if ($2 === o) return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid()) return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2) return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _2.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _2, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  })(dayjs_min$1);
  return dayjs_min$1.exports;
}
var csv;
var hasRequiredCsv;
function requireCsv() {
  if (hasRequiredCsv) return csv;
  hasRequiredCsv = 1;
  const fs2 = require$$0$4;
  const fastCsv = requireSrc();
  const customParseFormat2 = requireCustomParseFormat();
  const utc2 = requireUtc();
  const dayjs = requireDayjs_min().extend(customParseFormat2).extend(utc2);
  const StreamBuf = requireStreamBuf();
  const {
    fs: { exists }
  } = requireUtils();
  const SpecialValues = {
    true: true,
    false: false,
    "#N/A": { error: "#N/A" },
    "#REF!": { error: "#REF!" },
    "#NAME?": { error: "#NAME?" },
    "#DIV/0!": { error: "#DIV/0!" },
    "#NULL!": { error: "#NULL!" },
    "#VALUE!": { error: "#VALUE!" },
    "#NUM!": { error: "#NUM!" }
  };
  class CSV {
    constructor(workbook2) {
      this.workbook = workbook2;
      this.worksheet = null;
    }
    async readFile(filename, options) {
      options = options || {};
      if (!await exists(filename)) {
        throw new Error(`File not found: ${filename}`);
      }
      const stream2 = fs2.createReadStream(filename);
      const worksheet2 = await this.read(stream2, options);
      stream2.close();
      return worksheet2;
    }
    read(stream2, options) {
      options = options || {};
      return new Promise((resolve, reject2) => {
        const worksheet2 = this.workbook.addWorksheet(options.sheetName);
        const dateFormats = options.dateFormats || [
          "YYYY-MM-DD[T]HH:mm:ssZ",
          "YYYY-MM-DD[T]HH:mm:ss",
          "MM-DD-YYYY",
          "YYYY-MM-DD"
        ];
        const map2 = options.map || function(datum) {
          if (datum === "") {
            return null;
          }
          const datumNumber = Number(datum);
          if (!Number.isNaN(datumNumber) && datumNumber !== Infinity) {
            return datumNumber;
          }
          const dt = dateFormats.reduce((matchingDate, currentDateFormat) => {
            if (matchingDate) {
              return matchingDate;
            }
            const dayjsObj = dayjs(datum, currentDateFormat, true);
            if (dayjsObj.isValid()) {
              return dayjsObj;
            }
            return null;
          }, null);
          if (dt) {
            return new Date(dt.valueOf());
          }
          const special = SpecialValues[datum];
          if (special !== void 0) {
            return special;
          }
          return datum;
        };
        const csvStream = fastCsv.parse(options.parserOptions).on("data", (data2) => {
          worksheet2.addRow(data2.map(map2));
        }).on("end", () => {
          csvStream.emit("worksheet", worksheet2);
        });
        csvStream.on("worksheet", resolve).on("error", reject2);
        stream2.pipe(csvStream);
      });
    }
    /**
     * @deprecated since version 4.0. You should use `CSV#read` instead. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md
     */
    createInputStream() {
      throw new Error(
        "`CSV#createInputStream` is deprecated. You should use `CSV#read` instead. This method will be removed in version 5.0. Please follow upgrade instruction: https://github.com/exceljs/exceljs/blob/master/UPGRADE-4.0.md"
      );
    }
    write(stream2, options) {
      return new Promise((resolve, reject2) => {
        options = options || {};
        const worksheet2 = this.workbook.getWorksheet(options.sheetName || options.sheetId);
        const csvStream = fastCsv.format(options.formatterOptions);
        stream2.on("finish", () => {
          resolve();
        });
        csvStream.on("error", reject2);
        csvStream.pipe(stream2);
        const { dateFormat, dateUTC } = options;
        const map2 = options.map || ((value) => {
          if (value) {
            if (value.text || value.hyperlink) {
              return value.hyperlink || value.text || "";
            }
            if (value.formula || value.result) {
              return value.result || "";
            }
            if (value instanceof Date) {
              if (dateFormat) {
                return dateUTC ? dayjs.utc(value).format(dateFormat) : dayjs(value).format(dateFormat);
              }
              return dateUTC ? dayjs.utc(value).format() : dayjs(value).format();
            }
            if (value.error) {
              return value.error;
            }
            if (typeof value === "object") {
              return JSON.stringify(value);
            }
          }
          return value;
        });
        const includeEmptyRows = options.includeEmptyRows === void 0 || options.includeEmptyRows;
        let lastRow = 1;
        if (worksheet2) {
          worksheet2.eachRow((row2, rowNumber) => {
            if (includeEmptyRows) {
              while (lastRow++ < rowNumber - 1) {
                csvStream.write([]);
              }
            }
            const { values } = row2;
            values.shift();
            csvStream.write(values.map(map2));
            lastRow = rowNumber;
          });
        }
        csvStream.end();
      });
    }
    writeFile(filename, options) {
      options = options || {};
      const streamOptions = {
        encoding: options.encoding || "utf8"
      };
      const stream2 = fs2.createWriteStream(filename, streamOptions);
      return this.write(stream2, options);
    }
    async writeBuffer(options) {
      const stream2 = new StreamBuf();
      await this.write(stream2, options);
      return stream2.read();
    }
  }
  csv = CSV;
  return csv;
}
var workbook;
var hasRequiredWorkbook;
function requireWorkbook() {
  if (hasRequiredWorkbook) return workbook;
  hasRequiredWorkbook = 1;
  const Worksheet = requireWorksheet();
  const DefinedNames = requireDefinedNames();
  const XLSX = requireXlsx();
  const CSV = requireCsv();
  class Workbook {
    constructor() {
      this.category = "";
      this.company = "";
      this.created = /* @__PURE__ */ new Date();
      this.description = "";
      this.keywords = "";
      this.manager = "";
      this.modified = this.created;
      this.properties = {};
      this.calcProperties = {};
      this._worksheets = [];
      this.subject = "";
      this.title = "";
      this.views = [];
      this.media = [];
      this._definedNames = new DefinedNames();
    }
    get xlsx() {
      if (!this._xlsx) this._xlsx = new XLSX(this);
      return this._xlsx;
    }
    get csv() {
      if (!this._csv) this._csv = new CSV(this);
      return this._csv;
    }
    get nextId() {
      for (let i = 1; i < this._worksheets.length; i++) {
        if (!this._worksheets[i]) {
          return i;
        }
      }
      return this._worksheets.length || 1;
    }
    addWorksheet(name, options) {
      const id = this.nextId;
      if (options) {
        if (typeof options === "string") {
          console.trace(
            'tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { argb: "rbg value" } }'
          );
          options = {
            properties: {
              tabColor: { argb: options }
            }
          };
        } else if (options.argb || options.theme || options.indexed) {
          console.trace(
            "tabColor argument is now deprecated. Please use workbook.addWorksheet(name, {properties: { tabColor: { ... } }"
          );
          options = {
            properties: {
              tabColor: options
            }
          };
        }
      }
      const lastOrderNo = this._worksheets.reduce((acc, ws) => (ws && ws.orderNo) > acc ? ws.orderNo : acc, 0);
      const worksheetOptions = Object.assign({}, options, {
        id,
        name,
        orderNo: lastOrderNo + 1,
        workbook: this
      });
      const worksheet2 = new Worksheet(worksheetOptions);
      this._worksheets[id] = worksheet2;
      return worksheet2;
    }
    removeWorksheetEx(worksheet2) {
      delete this._worksheets[worksheet2.id];
    }
    removeWorksheet(id) {
      const worksheet2 = this.getWorksheet(id);
      if (worksheet2) {
        worksheet2.destroy();
      }
    }
    getWorksheet(id) {
      if (id === void 0) {
        return this._worksheets.find(Boolean);
      }
      if (typeof id === "number") {
        return this._worksheets[id];
      }
      if (typeof id === "string") {
        return this._worksheets.find((worksheet2) => worksheet2 && worksheet2.name === id);
      }
      return void 0;
    }
    get worksheets() {
      return this._worksheets.slice(1).sort((a, b) => a.orderNo - b.orderNo).filter(Boolean);
    }
    eachSheet(iteratee) {
      this.worksheets.forEach((sheet) => {
        iteratee(sheet, sheet.id);
      });
    }
    get definedNames() {
      return this._definedNames;
    }
    clearThemes() {
      this._themes = void 0;
    }
    addImage(image2) {
      const id = this.media.length;
      this.media.push(Object.assign({}, image2, { type: "image" }));
      return id;
    }
    getImage(id) {
      return this.media[id];
    }
    get model() {
      return {
        creator: this.creator || "Unknown",
        lastModifiedBy: this.lastModifiedBy || "Unknown",
        lastPrinted: this.lastPrinted,
        created: this.created,
        modified: this.modified,
        properties: this.properties,
        worksheets: this.worksheets.map((worksheet2) => worksheet2.model),
        sheets: this.worksheets.map((ws) => ws.model).filter(Boolean),
        definedNames: this._definedNames.model,
        views: this.views,
        company: this.company,
        manager: this.manager,
        title: this.title,
        subject: this.subject,
        keywords: this.keywords,
        category: this.category,
        description: this.description,
        language: this.language,
        revision: this.revision,
        contentStatus: this.contentStatus,
        themes: this._themes,
        media: this.media,
        calcProperties: this.calcProperties
      };
    }
    set model(value) {
      this.creator = value.creator;
      this.lastModifiedBy = value.lastModifiedBy;
      this.lastPrinted = value.lastPrinted;
      this.created = value.created;
      this.modified = value.modified;
      this.company = value.company;
      this.manager = value.manager;
      this.title = value.title;
      this.subject = value.subject;
      this.keywords = value.keywords;
      this.category = value.category;
      this.description = value.description;
      this.language = value.language;
      this.revision = value.revision;
      this.contentStatus = value.contentStatus;
      this.properties = value.properties;
      this.calcProperties = value.calcProperties;
      this._worksheets = [];
      value.worksheets.forEach((worksheetModel) => {
        const { id, name, state: state2 } = worksheetModel;
        const orderNo = value.sheets && value.sheets.findIndex((ws) => ws.id === id);
        const worksheet2 = this._worksheets[id] = new Worksheet({
          id,
          name,
          orderNo,
          state: state2,
          workbook: this
        });
        worksheet2.model = worksheetModel;
      });
      this._definedNames.model = value.definedNames;
      this.views = value.views;
      this._themes = value.themes;
      this.media = value.media || [];
    }
  }
  workbook = Workbook;
  return workbook;
}
var modelcontainer;
var hasRequiredModelcontainer;
function requireModelcontainer() {
  if (hasRequiredModelcontainer) return modelcontainer;
  hasRequiredModelcontainer = 1;
  const XLSX = requireXlsx();
  class ModelContainer {
    constructor(model) {
      this.model = model;
    }
    get xlsx() {
      if (!this._xlsx) {
        this._xlsx = new XLSX(this);
      }
      return this._xlsx;
    }
  }
  modelcontainer = ModelContainer;
  return modelcontainer;
}
var path;
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path;
  hasRequiredPath = 1;
  const isWindows = typeof process === "object" && process && process.platform === "win32";
  path = isWindows ? { sep: "\\" } : { sep: "/" };
  return path;
}
var balancedMatch;
var hasRequiredBalancedMatch;
function requireBalancedMatch() {
  if (hasRequiredBalancedMatch) return balancedMatch;
  hasRequiredBalancedMatch = 1;
  balancedMatch = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp) a = maybeMatch(a, str);
    if (b instanceof RegExp) b = maybeMatch(b, str);
    var r = range2(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range2;
  function range2(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      if (a === b) {
        return [ai, bi];
      }
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
  return balancedMatch;
}
var braceExpansion$1;
var hasRequiredBraceExpansion$1;
function requireBraceExpansion$1() {
  if (hasRequiredBraceExpansion$1) return braceExpansion$1;
  hasRequiredBraceExpansion$1 = 1;
  var balanced = requireBalancedMatch();
  braceExpansion$1 = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m) return [str];
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    if (/\$$/.test(m.pre)) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + "{" + m.body + "}" + post[k];
        expansions.push(expansion);
      }
    } else {
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test2 = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test2 = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test2(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = [];
        for (var j = 0; j < n.length; j++) {
          N.push.apply(N, expand(n[j], false));
        }
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
    }
    return expansions;
  }
  return braceExpansion$1;
}
var minimatch_1$1;
var hasRequiredMinimatch$1;
function requireMinimatch$1() {
  if (hasRequiredMinimatch$1) return minimatch_1$1;
  hasRequiredMinimatch$1 = 1;
  const minimatch = minimatch_1$1 = (p, pattern, options = {}) => {
    assertValidPattern(pattern);
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  };
  minimatch_1$1 = minimatch;
  const path2 = requirePath();
  minimatch.sep = path2.sep;
  const GLOBSTAR = Symbol("globstar **");
  minimatch.GLOBSTAR = GLOBSTAR;
  const expand = requireBraceExpansion$1();
  const plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  const qmark = "[^/]";
  const star = qmark + "*?";
  const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  const charSet = (s) => s.split("").reduce((set, c) => {
    set[c] = true;
    return set;
  }, {});
  const reSpecials = charSet("().*{}+?[]^$\\!");
  const addPatternStartSet = charSet("[.(");
  const slashSplit = /\/+/;
  minimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);
  const ext = (a, b = {}) => {
    const t = {};
    Object.keys(a).forEach((k) => t[k] = a[k]);
    Object.keys(b).forEach((k) => t[k] = b[k]);
    return t;
  };
  minimatch.defaults = (def) => {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    const orig = minimatch;
    const m = (p, pattern, options) => orig(p, pattern, ext(def, options));
    m.Minimatch = class Minimatch extends orig.Minimatch {
      constructor(pattern, options) {
        super(pattern, ext(def, options));
      }
    };
    m.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
    m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
    m.defaults = (options) => orig.defaults(ext(def, options));
    m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
    m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
    m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));
    return m;
  };
  minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
  const braceExpand = (pattern, options = {}) => {
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  };
  const MAX_PATTERN_LENGTH = 1024 * 64;
  const assertValidPattern = (pattern) => {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  const SUBPARSE = Symbol("subparse");
  minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
  minimatch.match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter((f) => mm.match(f));
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  const globUnescape = (s) => s.replace(/\\(.)/g, "$1");
  const charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
  const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  const braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
  class Minimatch {
    constructor(pattern, options) {
      assertValidPattern(pattern);
      if (!options) options = {};
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
      if (this.windowsPathsNoEscape) {
        this.pattern = this.pattern.replace(/\\/g, "/");
      }
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    debug() {
    }
    make() {
      const pattern = this.pattern;
      const options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      let set = this.globSet = this.braceExpand();
      if (options.debug) this.debug = (...args) => console.error(...args);
      this.debug(this.pattern, set);
      set = this.globParts = set.map((s) => s.split(slashSplit));
      this.debug(this.pattern, set);
      set = set.map((s, si, set2) => s.map(this.parse, this));
      this.debug(this.pattern, set);
      set = set.filter((s) => s.indexOf(false) === -1);
      this.debug(this.pattern, set);
      this.set = set;
    }
    parseNegate() {
      if (this.options.nonegate) return;
      const pattern = this.pattern;
      let negate = false;
      let negateOffset = 0;
      for (let i = 0; i < pattern.length && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset) this.pattern = pattern.slice(negateOffset);
      this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file2, pattern, partial) {
      var options = this.options;
      this.debug(
        "matchOne",
        { "this": this, file: file2, pattern }
      );
      this.debug("matchOne", file2.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file2[fi];
        this.debug(pattern, p, f);
        if (p === false) return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file2[fi] === "." || file2[fi] === ".." || !options.dot && file2[fi].charAt(0) === ".") return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file2[fr];
            this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
            if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file2, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
            if (fr === fl) return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit) return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file2[fi] === "";
      }
      throw new Error("wtf?");
    }
    braceExpand() {
      return braceExpand(this.pattern, this.options);
    }
    parse(pattern, isSub) {
      assertValidPattern(pattern);
      const options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "") return "";
      let re = "";
      let hasMagic = false;
      let escaping = false;
      const patternListStack = [];
      const negativeLists = [];
      let stateChar;
      let inClass = false;
      let reClassStart = -1;
      let classStart = -1;
      let cs;
      let pl;
      let sp;
      let dotTravAllowed = pattern.charAt(0) === ".";
      let dotFileAllowed = options.dot || dotTravAllowed;
      const patternStart = () => dotTravAllowed ? "" : dotFileAllowed ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const subPatternStart = (p) => p.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      const clearStateChar = () => {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          this.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      };
      for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping) {
          if (c === "/") {
            return false;
          }
          if (reSpecials[c]) {
            re += "\\";
          }
          re += c;
          escaping = false;
          continue;
        }
        switch (c) {
          /* istanbul ignore next */
          case "/": {
            return false;
          }
          case "\\":
            if (inClass && pattern.charAt(i + 1) === "-") {
              re += c;
              continue;
            }
            clearStateChar();
            escaping = true;
            continue;
          // the various stateChar values
          // for the "extglob" stuff.
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1) c = "^";
              re += c;
              continue;
            }
            this.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext) clearStateChar();
            continue;
          case "(": {
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            const plEntry = {
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            };
            this.debug(this.pattern, "	", plEntry);
            patternListStack.push(plEntry);
            re += plEntry.open;
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          }
          case ")": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\)";
              continue;
            }
            patternListStack.pop();
            clearStateChar();
            hasMagic = true;
            pl = plEntry;
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(Object.assign(pl, { reEnd: re.length }));
            }
            continue;
          }
          case "|": {
            const plEntry = patternListStack[patternListStack.length - 1];
            if (inClass || !plEntry) {
              re += "\\|";
              continue;
            }
            clearStateChar();
            re += "|";
            if (plEntry.start === 0 && plEntry.type !== "!") {
              dotTravAllowed = true;
              re += subPatternStart(pattern.slice(i + 1));
            }
            continue;
          }
          // these are mostly the same in regexp and glob
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              continue;
            }
            cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
              re += c;
            } catch (er) {
              re = re.substring(0, reClassStart) + "(?:$.)";
            }
            hasMagic = true;
            inClass = false;
            continue;
          default:
            clearStateChar();
            if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
            break;
        }
      }
      if (inClass) {
        cs = pattern.slice(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substring(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        let tail;
        tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        const t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      const addPatternStart = addPatternStartSet[re.charAt(0)];
      for (let n = negativeLists.length - 1; n > -1; n--) {
        const nl = negativeLists[n];
        const nlBefore = re.slice(0, nl.reStart);
        const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        let nlAfter = re.slice(nl.reEnd);
        const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
        const closeParensBefore = nlBefore.split(")").length;
        const openParensBefore = nlBefore.split("(").length - closeParensBefore;
        let cleanAfter = nlAfter;
        for (let i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        const dollar = nlAfter === "" && isSub !== SUBPARSE ? "(?:$|\\/)" : "";
        re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart() + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (options.nocase && !hasMagic) {
        hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      const flags = options.nocase ? "i" : "";
      try {
        return Object.assign(new RegExp("^" + re + "$", flags), {
          _glob: pattern,
          _src: re
        });
      } catch (er) {
        return new RegExp("$.");
      }
    }
    makeRe() {
      if (this.regexp || this.regexp === false) return this.regexp;
      const set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      const options = this.options;
      const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      const flags = options.nocase ? "i" : "";
      let re = set.map((pattern) => {
        pattern = pattern.map(
          (p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src
        ).reduce((set2, p) => {
          if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
            set2.push(p);
          }
          return set2;
        }, []);
        pattern.forEach((p, i) => {
          if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {
            return;
          }
          if (i === 0) {
            if (pattern.length > 1) {
              pattern[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern[i + 1];
            } else {
              pattern[i] = twoStar;
            }
          } else if (i === pattern.length - 1) {
            pattern[i - 1] += "(?:\\/|" + twoStar + ")?";
          } else {
            pattern[i - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern[i + 1];
            pattern[i + 1] = GLOBSTAR;
          }
        });
        return pattern.filter((p) => p !== GLOBSTAR).join("/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate) re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    match(f, partial = this.partial) {
      this.debug("match", f, this.pattern);
      if (this.comment) return false;
      if (this.empty) return f === "";
      if (f === "/" && partial) return true;
      const options = this.options;
      if (path2.sep !== "/") {
        f = f.split(path2.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      const set = this.set;
      this.debug(this.pattern, "set", set);
      let filename;
      for (let i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename) break;
      }
      for (let i = 0; i < set.length; i++) {
        const pattern = set[i];
        let file2 = f;
        if (options.matchBase && pattern.length === 1) {
          file2 = [filename];
        }
        const hit = this.matchOne(file2, pattern, partial);
        if (hit) {
          if (options.flipNegate) return true;
          return !this.negate;
        }
      }
      if (options.flipNegate) return false;
      return this.negate;
    }
    static defaults(def) {
      return minimatch.defaults(def).Minimatch;
    }
  }
  minimatch.Minimatch = Minimatch;
  return minimatch_1$1;
}
var readdirGlob_1;
var hasRequiredReaddirGlob;
function requireReaddirGlob() {
  if (hasRequiredReaddirGlob) return readdirGlob_1;
  hasRequiredReaddirGlob = 1;
  readdirGlob_1 = readdirGlob;
  const fs2 = require$$0$4;
  const { EventEmitter: EventEmitter2 } = require$$2$1;
  const { Minimatch } = requireMinimatch$1();
  const { resolve } = require$$1;
  function readdir(dir2, strict) {
    return new Promise((resolve2, reject2) => {
      fs2.readdir(dir2, { withFileTypes: true }, (err, files) => {
        if (err) {
          switch (err.code) {
            case "ENOTDIR":
              if (strict) {
                reject2(err);
              } else {
                resolve2([]);
              }
              break;
            case "ENOTSUP":
            // Operation not supported
            case "ENOENT":
            // No such file or directory
            case "ENAMETOOLONG":
            // Filename too long
            case "UNKNOWN":
              resolve2([]);
              break;
            case "ELOOP":
            // Too many levels of symbolic links
            default:
              reject2(err);
              break;
          }
        } else {
          resolve2(files);
        }
      });
    });
  }
  function stat(file2, followSymlinks) {
    return new Promise((resolve2, reject2) => {
      const statFunc = followSymlinks ? fs2.stat : fs2.lstat;
      statFunc(file2, (err, stats) => {
        if (err) {
          switch (err.code) {
            case "ENOENT":
              if (followSymlinks) {
                resolve2(stat(file2, false));
              } else {
                resolve2(null);
              }
              break;
            default:
              resolve2(null);
              break;
          }
        } else {
          resolve2(stats);
        }
      });
    });
  }
  async function* exploreWalkAsync(dir2, path2, followSymlinks, useStat, shouldSkip, strict) {
    let files = await readdir(path2 + dir2, strict);
    for (const file2 of files) {
      let name = file2.name;
      if (name === void 0) {
        name = file2;
        useStat = true;
      }
      const filename = dir2 + "/" + name;
      const relative = filename.slice(1);
      const absolute = path2 + "/" + relative;
      let stats = null;
      if (useStat || followSymlinks) {
        stats = await stat(absolute, followSymlinks);
      }
      if (!stats && file2.name !== void 0) {
        stats = file2;
      }
      if (stats === null) {
        stats = { isDirectory: () => false };
      }
      if (stats.isDirectory()) {
        if (!shouldSkip(relative)) {
          yield { relative, absolute, stats };
          yield* exploreWalkAsync(filename, path2, followSymlinks, useStat, shouldSkip, false);
        }
      } else {
        yield { relative, absolute, stats };
      }
    }
  }
  async function* explore(path2, followSymlinks, useStat, shouldSkip) {
    yield* exploreWalkAsync("", path2, followSymlinks, useStat, shouldSkip, true);
  }
  function readOptions(options) {
    return {
      pattern: options.pattern,
      dot: !!options.dot,
      noglobstar: !!options.noglobstar,
      matchBase: !!options.matchBase,
      nocase: !!options.nocase,
      ignore: options.ignore,
      skip: options.skip,
      follow: !!options.follow,
      stat: !!options.stat,
      nodir: !!options.nodir,
      mark: !!options.mark,
      silent: !!options.silent,
      absolute: !!options.absolute
    };
  }
  class ReaddirGlob extends EventEmitter2 {
    constructor(cwd, options, cb) {
      super();
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      this.options = readOptions(options || {});
      this.matchers = [];
      if (this.options.pattern) {
        const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
        this.matchers = matchers.map(
          (m) => new Minimatch(m, {
            dot: this.options.dot,
            noglobstar: this.options.noglobstar,
            matchBase: this.options.matchBase,
            nocase: this.options.nocase
          })
        );
      }
      this.ignoreMatchers = [];
      if (this.options.ignore) {
        const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
        this.ignoreMatchers = ignorePatterns.map(
          (ignore) => new Minimatch(ignore, { dot: true })
        );
      }
      this.skipMatchers = [];
      if (this.options.skip) {
        const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
        this.skipMatchers = skipPatterns.map(
          (skip) => new Minimatch(skip, { dot: true })
        );
      }
      this.iterator = explore(resolve(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
      this.paused = false;
      this.inactive = false;
      this.aborted = false;
      if (cb) {
        this._matches = [];
        this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
        this.on("error", (err) => cb(err));
        this.on("end", () => cb(null, this._matches));
      }
      setTimeout(() => this._next(), 0);
    }
    _shouldSkipDirectory(relative) {
      return this.skipMatchers.some((m) => m.match(relative));
    }
    _fileMatches(relative, isDirectory) {
      const file2 = relative + (isDirectory ? "/" : "");
      return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file2))) && !this.ignoreMatchers.some((m) => m.match(file2)) && (!this.options.nodir || !isDirectory);
    }
    _next() {
      if (!this.paused && !this.aborted) {
        this.iterator.next().then((obj) => {
          if (!obj.done) {
            const isDirectory = obj.value.stats.isDirectory();
            if (this._fileMatches(obj.value.relative, isDirectory)) {
              let relative = obj.value.relative;
              let absolute = obj.value.absolute;
              if (this.options.mark && isDirectory) {
                relative += "/";
                absolute += "/";
              }
              if (this.options.stat) {
                this.emit("match", { relative, absolute, stat: obj.value.stats });
              } else {
                this.emit("match", { relative, absolute });
              }
            }
            this._next(this.iterator);
          } else {
            this.emit("end");
          }
        }).catch((err) => {
          this.abort();
          this.emit("error", err);
          if (!err.code && !this.options.silent) {
            console.error(err);
          }
        });
      } else {
        this.inactive = true;
      }
    }
    abort() {
      this.aborted = true;
    }
    pause() {
      this.paused = true;
    }
    resume() {
      this.paused = false;
      if (this.inactive) {
        this.inactive = false;
        this._next();
      }
    }
  }
  function readdirGlob(pattern, options, cb) {
    return new ReaddirGlob(pattern, options, cb);
  }
  readdirGlob.ReaddirGlob = ReaddirGlob;
  return readdirGlob_1;
}
function apply(fn, ...args) {
  return (...callArgs) => fn(...args, ...callArgs);
}
function initialParams(fn) {
  return function(...args) {
    var callback = args.pop();
    return fn.call(this, args, callback);
  };
}
var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
function fallback(fn) {
  setTimeout(fn, 0);
}
function wrap(defer) {
  return (fn, ...args) => defer(() => fn(...args));
}
var _defer$1;
if (hasQueueMicrotask) {
  _defer$1 = queueMicrotask;
} else if (hasSetImmediate) {
  _defer$1 = setImmediate;
} else if (hasNextTick) {
  _defer$1 = process.nextTick;
} else {
  _defer$1 = fallback;
}
var setImmediate$1 = wrap(_defer$1);
function asyncify(func) {
  if (isAsync(func)) {
    return function(...args) {
      const callback = args.pop();
      const promise2 = func.apply(this, args);
      return handlePromise(promise2, callback);
    };
  }
  return initialParams(function(args, callback) {
    var result;
    try {
      result = func.apply(this, args);
    } catch (e) {
      return callback(e);
    }
    if (result && typeof result.then === "function") {
      return handlePromise(result, callback);
    } else {
      callback(null, result);
    }
  });
}
function handlePromise(promise2, callback) {
  return promise2.then((value) => {
    invokeCallback(callback, null, value);
  }, (err) => {
    invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
  });
}
function invokeCallback(callback, error2, value) {
  try {
    callback(error2, value);
  } catch (err) {
    setImmediate$1((e) => {
      throw e;
    }, err);
  }
}
function isAsync(fn) {
  return fn[Symbol.toStringTag] === "AsyncFunction";
}
function isAsyncGenerator(fn) {
  return fn[Symbol.toStringTag] === "AsyncGenerator";
}
function isAsyncIterable(obj) {
  return typeof obj[Symbol.asyncIterator] === "function";
}
function wrapAsync(asyncFn) {
  if (typeof asyncFn !== "function") throw new Error("expected a function");
  return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
}
function awaitify(asyncFn, arity) {
  if (!arity) arity = asyncFn.length;
  if (!arity) throw new Error("arity is undefined");
  function awaitable(...args) {
    if (typeof args[arity - 1] === "function") {
      return asyncFn.apply(this, args);
    }
    return new Promise((resolve, reject2) => {
      args[arity - 1] = (err, ...cbArgs) => {
        if (err) return reject2(err);
        resolve(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
      };
      asyncFn.apply(this, args);
    });
  }
  return awaitable;
}
function applyEach$1(eachfn) {
  return function applyEach2(fns, ...callArgs) {
    const go = awaitify(function(callback) {
      var that = this;
      return eachfn(fns, (fn, cb) => {
        wrapAsync(fn).apply(that, callArgs.concat(cb));
      }, callback);
    });
    return go;
  };
}
function _asyncMap(eachfn, arr, iteratee, callback) {
  arr = arr || [];
  var results = [];
  var counter = 0;
  var _iteratee = wrapAsync(iteratee);
  return eachfn(arr, (value, _2, iterCb) => {
    var index2 = counter++;
    _iteratee(value, (err, v) => {
      results[index2] = v;
      iterCb(err);
    });
  }, (err) => {
    callback(err, results);
  });
}
function isArrayLike(value) {
  return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
}
const breakLoop = {};
function once$1(fn) {
  function wrapper(...args) {
    if (fn === null) return;
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  }
  Object.assign(wrapper, fn);
  return wrapper;
}
function getIterator(coll) {
  return coll[Symbol.iterator] && coll[Symbol.iterator]();
}
function createArrayIterator(coll) {
  var i = -1;
  var len = coll.length;
  return function next() {
    return ++i < len ? { value: coll[i], key: i } : null;
  };
}
function createES2015Iterator(iterator2) {
  var i = -1;
  return function next() {
    var item = iterator2.next();
    if (item.done)
      return null;
    i++;
    return { value: item.value, key: i };
  };
}
function createObjectIterator(obj) {
  var okeys = obj ? Object.keys(obj) : [];
  var i = -1;
  var len = okeys.length;
  return function next() {
    var key = okeys[++i];
    if (key === "__proto__") {
      return next();
    }
    return i < len ? { value: obj[key], key } : null;
  };
}
function createIterator(coll) {
  if (isArrayLike(coll)) {
    return createArrayIterator(coll);
  }
  var iterator2 = getIterator(coll);
  return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
}
function onlyOnce(fn) {
  return function(...args) {
    if (fn === null) throw new Error("Callback was already called.");
    var callFn = fn;
    fn = null;
    callFn.apply(this, args);
  };
}
function asyncEachOfLimit(generator, limit, iteratee, callback) {
  let done = false;
  let canceled = false;
  let awaiting = false;
  let running = 0;
  let idx = 0;
  function replenish() {
    if (running >= limit || awaiting || done) return;
    awaiting = true;
    generator.next().then(({ value, done: iterDone }) => {
      if (canceled || done) return;
      awaiting = false;
      if (iterDone) {
        done = true;
        if (running <= 0) {
          callback(null);
        }
        return;
      }
      running++;
      iteratee(value, idx, iterateeCallback);
      idx++;
      replenish();
    }).catch(handleError);
  }
  function iterateeCallback(err, result) {
    running -= 1;
    if (canceled) return;
    if (err) return handleError(err);
    if (err === false) {
      done = true;
      canceled = true;
      return;
    }
    if (result === breakLoop || done && running <= 0) {
      done = true;
      return callback(null);
    }
    replenish();
  }
  function handleError(err) {
    if (canceled) return;
    awaiting = false;
    done = true;
    callback(err);
  }
  replenish();
}
var eachOfLimit$2 = (limit) => {
  return (obj, iteratee, callback) => {
    callback = once$1(callback);
    if (limit <= 0) {
      throw new RangeError("concurrency limit cannot be less than 1");
    }
    if (!obj) {
      return callback(null);
    }
    if (isAsyncGenerator(obj)) {
      return asyncEachOfLimit(obj, limit, iteratee, callback);
    }
    if (isAsyncIterable(obj)) {
      return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
    }
    var nextElem = createIterator(obj);
    var done = false;
    var canceled = false;
    var running = 0;
    var looping = false;
    function iterateeCallback(err, value) {
      if (canceled) return;
      running -= 1;
      if (err) {
        done = true;
        callback(err);
      } else if (err === false) {
        done = true;
        canceled = true;
      } else if (value === breakLoop || done && running <= 0) {
        done = true;
        return callback(null);
      } else if (!looping) {
        replenish();
      }
    }
    function replenish() {
      looping = true;
      while (running < limit && !done) {
        var elem = nextElem();
        if (elem === null) {
          done = true;
          if (running <= 0) {
            callback(null);
          }
          return;
        }
        running += 1;
        iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
      }
      looping = false;
    }
    replenish();
  };
};
function eachOfLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, wrapAsync(iteratee), callback);
}
var eachOfLimit$1 = awaitify(eachOfLimit, 4);
function eachOfArrayLike(coll, iteratee, callback) {
  callback = once$1(callback);
  var index2 = 0, completed = 0, { length } = coll, canceled = false;
  if (length === 0) {
    callback(null);
  }
  function iteratorCallback(err, value) {
    if (err === false) {
      canceled = true;
    }
    if (canceled === true) return;
    if (err) {
      callback(err);
    } else if (++completed === length || value === breakLoop) {
      callback(null);
    }
  }
  for (; index2 < length; index2++) {
    iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
  }
}
function eachOfGeneric(coll, iteratee, callback) {
  return eachOfLimit$1(coll, Infinity, iteratee, callback);
}
function eachOf(coll, iteratee, callback) {
  var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
  return eachOfImplementation(coll, wrapAsync(iteratee), callback);
}
var eachOf$1 = awaitify(eachOf, 3);
function map$1(coll, iteratee, callback) {
  return _asyncMap(eachOf$1, coll, iteratee, callback);
}
var map$1$1 = awaitify(map$1, 3);
var applyEach = applyEach$1(map$1$1);
function eachOfSeries(coll, iteratee, callback) {
  return eachOfLimit$1(coll, 1, iteratee, callback);
}
var eachOfSeries$1 = awaitify(eachOfSeries, 3);
function mapSeries(coll, iteratee, callback) {
  return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
}
var mapSeries$1 = awaitify(mapSeries, 3);
var applyEachSeries = applyEach$1(mapSeries$1);
const PROMISE_SYMBOL = Symbol("promiseCallback");
function promiseCallback() {
  let resolve, reject2;
  function callback(err, ...args) {
    if (err) return reject2(err);
    resolve(args.length > 1 ? args : args[0]);
  }
  callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
    resolve = res, reject2 = rej;
  });
  return callback;
}
function auto(tasks, concurrency, callback) {
  if (typeof concurrency !== "number") {
    callback = concurrency;
    concurrency = null;
  }
  callback = once$1(callback || promiseCallback());
  var numTasks = Object.keys(tasks).length;
  if (!numTasks) {
    return callback(null);
  }
  if (!concurrency) {
    concurrency = numTasks;
  }
  var results = {};
  var runningTasks = 0;
  var canceled = false;
  var hasError = false;
  var listeners = /* @__PURE__ */ Object.create(null);
  var readyTasks = [];
  var readyToCheck = [];
  var uncheckedDependencies = {};
  Object.keys(tasks).forEach((key) => {
    var task = tasks[key];
    if (!Array.isArray(task)) {
      enqueueTask(key, [task]);
      readyToCheck.push(key);
      return;
    }
    var dependencies = task.slice(0, task.length - 1);
    var remainingDependencies = dependencies.length;
    if (remainingDependencies === 0) {
      enqueueTask(key, task);
      readyToCheck.push(key);
      return;
    }
    uncheckedDependencies[key] = remainingDependencies;
    dependencies.forEach((dependencyName) => {
      if (!tasks[dependencyName]) {
        throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
      }
      addListener(dependencyName, () => {
        remainingDependencies--;
        if (remainingDependencies === 0) {
          enqueueTask(key, task);
        }
      });
    });
  });
  checkForDeadlocks();
  processQueue();
  function enqueueTask(key, task) {
    readyTasks.push(() => runTask(key, task));
  }
  function processQueue() {
    if (canceled) return;
    if (readyTasks.length === 0 && runningTasks === 0) {
      return callback(null, results);
    }
    while (readyTasks.length && runningTasks < concurrency) {
      var run = readyTasks.shift();
      run();
    }
  }
  function addListener(taskName, fn) {
    var taskListeners = listeners[taskName];
    if (!taskListeners) {
      taskListeners = listeners[taskName] = [];
    }
    taskListeners.push(fn);
  }
  function taskComplete(taskName) {
    var taskListeners = listeners[taskName] || [];
    taskListeners.forEach((fn) => fn());
    processQueue();
  }
  function runTask(key, task) {
    if (hasError) return;
    var taskCallback = onlyOnce((err, ...result) => {
      runningTasks--;
      if (err === false) {
        canceled = true;
        return;
      }
      if (result.length < 2) {
        [result] = result;
      }
      if (err) {
        var safeResults = {};
        Object.keys(results).forEach((rkey) => {
          safeResults[rkey] = results[rkey];
        });
        safeResults[key] = result;
        hasError = true;
        listeners = /* @__PURE__ */ Object.create(null);
        if (canceled) return;
        callback(err, safeResults);
      } else {
        results[key] = result;
        taskComplete(key);
      }
    });
    runningTasks++;
    var taskFn = wrapAsync(task[task.length - 1]);
    if (task.length > 1) {
      taskFn(results, taskCallback);
    } else {
      taskFn(taskCallback);
    }
  }
  function checkForDeadlocks() {
    var currentTask;
    var counter = 0;
    while (readyToCheck.length) {
      currentTask = readyToCheck.pop();
      counter++;
      getDependents(currentTask).forEach((dependent) => {
        if (--uncheckedDependencies[dependent] === 0) {
          readyToCheck.push(dependent);
        }
      });
    }
    if (counter !== numTasks) {
      throw new Error(
        "async.auto cannot execute tasks due to a recursive dependency"
      );
    }
  }
  function getDependents(taskName) {
    var result = [];
    Object.keys(tasks).forEach((key) => {
      const task = tasks[key];
      if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
        result.push(key);
      }
    });
    return result;
  }
  return callback[PROMISE_SYMBOL];
}
var FN_ARGS = /^(?:async\s)?(?:function)?\s*(?:\w+\s*)?\(([^)]+)\)(?:\s*{)/;
var ARROW_FN_ARGS = /^(?:async\s)?\s*(?:\(\s*)?((?:[^)=\s]\s*)*)(?:\)\s*)?=>/;
var FN_ARG_SPLIT = /,/;
var FN_ARG = /(=.+)?(\s*)$/;
function stripComments(string) {
  let stripped = "";
  let index2 = 0;
  let endBlockComment = string.indexOf("*/");
  while (index2 < string.length) {
    if (string[index2] === "/" && string[index2 + 1] === "/") {
      let endIndex = string.indexOf("\n", index2);
      index2 = endIndex === -1 ? string.length : endIndex;
    } else if (endBlockComment !== -1 && string[index2] === "/" && string[index2 + 1] === "*") {
      let endIndex = string.indexOf("*/", index2);
      if (endIndex !== -1) {
        index2 = endIndex + 2;
        endBlockComment = string.indexOf("*/", index2);
      } else {
        stripped += string[index2];
        index2++;
      }
    } else {
      stripped += string[index2];
      index2++;
    }
  }
  return stripped;
}
function parseParams(func) {
  const src2 = stripComments(func.toString());
  let match = src2.match(FN_ARGS);
  if (!match) {
    match = src2.match(ARROW_FN_ARGS);
  }
  if (!match) throw new Error("could not parse args in autoInject\nSource:\n" + src2);
  let [, args] = match;
  return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
}
function autoInject(tasks, callback) {
  var newTasks = {};
  Object.keys(tasks).forEach((key) => {
    var taskFn = tasks[key];
    var params;
    var fnIsAsync = isAsync(taskFn);
    var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
    if (Array.isArray(taskFn)) {
      params = [...taskFn];
      taskFn = params.pop();
      newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
    } else if (hasNoDeps) {
      newTasks[key] = taskFn;
    } else {
      params = parseParams(taskFn);
      if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
        throw new Error("autoInject task functions require explicit parameters.");
      }
      if (!fnIsAsync) params.pop();
      newTasks[key] = params.concat(newTask);
    }
    function newTask(results, taskCb) {
      var newArgs = params.map((name) => results[name]);
      newArgs.push(taskCb);
      wrapAsync(taskFn)(...newArgs);
    }
  });
  return auto(newTasks, callback);
}
class DLL {
  constructor() {
    this.head = this.tail = null;
    this.length = 0;
  }
  removeLink(node2) {
    if (node2.prev) node2.prev.next = node2.next;
    else this.head = node2.next;
    if (node2.next) node2.next.prev = node2.prev;
    else this.tail = node2.prev;
    node2.prev = node2.next = null;
    this.length -= 1;
    return node2;
  }
  empty() {
    while (this.head) this.shift();
    return this;
  }
  insertAfter(node2, newNode) {
    newNode.prev = node2;
    newNode.next = node2.next;
    if (node2.next) node2.next.prev = newNode;
    else this.tail = newNode;
    node2.next = newNode;
    this.length += 1;
  }
  insertBefore(node2, newNode) {
    newNode.prev = node2.prev;
    newNode.next = node2;
    if (node2.prev) node2.prev.next = newNode;
    else this.head = newNode;
    node2.prev = newNode;
    this.length += 1;
  }
  unshift(node2) {
    if (this.head) this.insertBefore(this.head, node2);
    else setInitial(this, node2);
  }
  push(node2) {
    if (this.tail) this.insertAfter(this.tail, node2);
    else setInitial(this, node2);
  }
  shift() {
    return this.head && this.removeLink(this.head);
  }
  pop() {
    return this.tail && this.removeLink(this.tail);
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    var cur = this.head;
    while (cur) {
      yield cur.data;
      cur = cur.next;
    }
  }
  remove(testFn) {
    var curr = this.head;
    while (curr) {
      var { next } = curr;
      if (testFn(curr)) {
        this.removeLink(curr);
      }
      curr = next;
    }
    return this;
  }
}
function setInitial(dll, node2) {
  dll.length = 1;
  dll.head = dll.tail = node2;
}
function queue$1(worker, concurrency, payload) {
  if (concurrency == null) {
    concurrency = 1;
  } else if (concurrency === 0) {
    throw new RangeError("Concurrency must not be zero");
  }
  var _worker = wrapAsync(worker);
  var numRunning = 0;
  var workersList = [];
  const events = {
    error: [],
    drain: [],
    saturated: [],
    unsaturated: [],
    empty: []
  };
  function on(event, handler) {
    events[event].push(handler);
  }
  function once2(event, handler) {
    const handleAndRemove = (...args) => {
      off(event, handleAndRemove);
      handler(...args);
    };
    events[event].push(handleAndRemove);
  }
  function off(event, handler) {
    if (!event) return Object.keys(events).forEach((ev) => events[ev] = []);
    if (!handler) return events[event] = [];
    events[event] = events[event].filter((ev) => ev !== handler);
  }
  function trigger(event, ...args) {
    events[event].forEach((handler) => handler(...args));
  }
  var processingScheduled = false;
  function _insert(data2, insertAtFront, rejectOnError, callback) {
    if (callback != null && typeof callback !== "function") {
      throw new Error("task callback must be a function");
    }
    q.started = true;
    var res, rej;
    function promiseCallback2(err, ...args) {
      if (err) return rejectOnError ? rej(err) : res();
      if (args.length <= 1) return res(args[0]);
      res(args);
    }
    var item = q._createTaskItem(
      data2,
      rejectOnError ? promiseCallback2 : callback || promiseCallback2
    );
    if (insertAtFront) {
      q._tasks.unshift(item);
    } else {
      q._tasks.push(item);
    }
    if (!processingScheduled) {
      processingScheduled = true;
      setImmediate$1(() => {
        processingScheduled = false;
        q.process();
      });
    }
    if (rejectOnError || !callback) {
      return new Promise((resolve, reject2) => {
        res = resolve;
        rej = reject2;
      });
    }
  }
  function _createCB(tasks) {
    return function(err, ...args) {
      numRunning -= 1;
      for (var i = 0, l = tasks.length; i < l; i++) {
        var task = tasks[i];
        var index2 = workersList.indexOf(task);
        if (index2 === 0) {
          workersList.shift();
        } else if (index2 > 0) {
          workersList.splice(index2, 1);
        }
        task.callback(err, ...args);
        if (err != null) {
          trigger("error", err, task.data);
        }
      }
      if (numRunning <= q.concurrency - q.buffer) {
        trigger("unsaturated");
      }
      if (q.idle()) {
        trigger("drain");
      }
      q.process();
    };
  }
  function _maybeDrain(data2) {
    if (data2.length === 0 && q.idle()) {
      setImmediate$1(() => trigger("drain"));
      return true;
    }
    return false;
  }
  const eventMethod = (name) => (handler) => {
    if (!handler) {
      return new Promise((resolve, reject2) => {
        once2(name, (err, data2) => {
          if (err) return reject2(err);
          resolve(data2);
        });
      });
    }
    off(name);
    on(name, handler);
  };
  var isProcessing = false;
  var q = {
    _tasks: new DLL(),
    _createTaskItem(data2, callback) {
      return {
        data: data2,
        callback
      };
    },
    *[Symbol.iterator]() {
      yield* q._tasks[Symbol.iterator]();
    },
    concurrency,
    payload,
    buffer: concurrency / 4,
    started: false,
    paused: false,
    push(data2, callback) {
      if (Array.isArray(data2)) {
        if (_maybeDrain(data2)) return;
        return data2.map((datum) => _insert(datum, false, false, callback));
      }
      return _insert(data2, false, false, callback);
    },
    pushAsync(data2, callback) {
      if (Array.isArray(data2)) {
        if (_maybeDrain(data2)) return;
        return data2.map((datum) => _insert(datum, false, true, callback));
      }
      return _insert(data2, false, true, callback);
    },
    kill() {
      off();
      q._tasks.empty();
    },
    unshift(data2, callback) {
      if (Array.isArray(data2)) {
        if (_maybeDrain(data2)) return;
        return data2.map((datum) => _insert(datum, true, false, callback));
      }
      return _insert(data2, true, false, callback);
    },
    unshiftAsync(data2, callback) {
      if (Array.isArray(data2)) {
        if (_maybeDrain(data2)) return;
        return data2.map((datum) => _insert(datum, true, true, callback));
      }
      return _insert(data2, true, true, callback);
    },
    remove(testFn) {
      q._tasks.remove(testFn);
    },
    process() {
      if (isProcessing) {
        return;
      }
      isProcessing = true;
      while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
        var tasks = [], data2 = [];
        var l = q._tasks.length;
        if (q.payload) l = Math.min(l, q.payload);
        for (var i = 0; i < l; i++) {
          var node2 = q._tasks.shift();
          tasks.push(node2);
          workersList.push(node2);
          data2.push(node2.data);
        }
        numRunning += 1;
        if (q._tasks.length === 0) {
          trigger("empty");
        }
        if (numRunning === q.concurrency) {
          trigger("saturated");
        }
        var cb = onlyOnce(_createCB(tasks));
        _worker(data2, cb);
      }
      isProcessing = false;
    },
    length() {
      return q._tasks.length;
    },
    running() {
      return numRunning;
    },
    workersList() {
      return workersList;
    },
    idle() {
      return q._tasks.length + numRunning === 0;
    },
    pause() {
      q.paused = true;
    },
    resume() {
      if (q.paused === false) {
        return;
      }
      q.paused = false;
      setImmediate$1(q.process);
    }
  };
  Object.defineProperties(q, {
    saturated: {
      writable: false,
      value: eventMethod("saturated")
    },
    unsaturated: {
      writable: false,
      value: eventMethod("unsaturated")
    },
    empty: {
      writable: false,
      value: eventMethod("empty")
    },
    drain: {
      writable: false,
      value: eventMethod("drain")
    },
    error: {
      writable: false,
      value: eventMethod("error")
    }
  });
  return q;
}
function cargo$1(worker, payload) {
  return queue$1(worker, 1, payload);
}
function cargo(worker, concurrency, payload) {
  return queue$1(worker, concurrency, payload);
}
function reduce$1(coll, memo, iteratee, callback) {
  callback = once$1(callback);
  var _iteratee = wrapAsync(iteratee);
  return eachOfSeries$1(coll, (x, i, iterCb) => {
    _iteratee(memo, x, (err, v) => {
      memo = v;
      iterCb(err);
    });
  }, (err) => callback(err, memo));
}
var reduce$1$1 = awaitify(reduce$1, 4);
function seq(...functions) {
  var _functions = functions.map(wrapAsync);
  return function(...args) {
    var that = this;
    var cb = args[args.length - 1];
    if (typeof cb == "function") {
      args.pop();
    } else {
      cb = promiseCallback();
    }
    reduce$1$1(
      _functions,
      args,
      (newargs, fn, iterCb) => {
        fn.apply(that, newargs.concat((err, ...nextargs) => {
          iterCb(err, nextargs);
        }));
      },
      (err, results) => cb(err, ...results)
    );
    return cb[PROMISE_SYMBOL];
  };
}
function compose(...args) {
  return seq(...args.reverse());
}
function mapLimit(coll, limit, iteratee, callback) {
  return _asyncMap(eachOfLimit$2(limit), coll, iteratee, callback);
}
var mapLimit$1 = awaitify(mapLimit, 4);
function concatLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, ...args) => {
      if (err) return iterCb(err);
      return iterCb(err, args);
    });
  }, (err, mapResults) => {
    var result = [];
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        result = result.concat(...mapResults[i]);
      }
    }
    return callback(err, result);
  });
}
var concatLimit$1 = awaitify(concatLimit, 4);
function concat(coll, iteratee, callback) {
  return concatLimit$1(coll, Infinity, iteratee, callback);
}
var concat$1 = awaitify(concat, 3);
function concatSeries(coll, iteratee, callback) {
  return concatLimit$1(coll, 1, iteratee, callback);
}
var concatSeries$1 = awaitify(concatSeries, 3);
function constant$1(...args) {
  return function(...ignoredArgs) {
    var callback = ignoredArgs.pop();
    return callback(null, ...args);
  };
}
function _createTester(check, getResult) {
  return (eachfn, arr, _iteratee, cb) => {
    var testPassed = false;
    var testResult;
    const iteratee = wrapAsync(_iteratee);
    eachfn(arr, (value, _2, callback) => {
      iteratee(value, (err, result) => {
        if (err || err === false) return callback(err);
        if (check(result) && !testResult) {
          testPassed = true;
          testResult = getResult(true, value);
          return callback(null, breakLoop);
        }
        callback();
      });
    }, (err) => {
      if (err) return cb(err);
      cb(null, testPassed ? testResult : getResult(false));
    });
  };
}
function detect(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
}
var detect$1 = awaitify(detect, 3);
function detectLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var detectLimit$1 = awaitify(detectLimit, 4);
function detectSeries(coll, iteratee, callback) {
  return _createTester((bool) => bool, (res, item) => item)(eachOfLimit$2(1), coll, iteratee, callback);
}
var detectSeries$1 = awaitify(detectSeries, 3);
function consoleFunc(name) {
  return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
    if (typeof console === "object") {
      if (err) {
        if (console.error) {
          console.error(err);
        }
      } else if (console[name]) {
        resultArgs.forEach((x) => console[name](x));
      }
    }
  });
}
var dir = consoleFunc("dir");
function doWhilst(iteratee, test2, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test2);
  var results;
  function next(err, ...args) {
    if (err) return callback(err);
    if (err === false) return;
    results = args;
    _test(...args, check);
  }
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return check(null, true);
}
var doWhilst$1 = awaitify(doWhilst, 3);
function doUntil(iteratee, test2, callback) {
  const _test = wrapAsync(test2);
  return doWhilst$1(iteratee, (...args) => {
    const cb = args.pop();
    _test(...args, (err, truth) => cb(err, !truth));
  }, callback);
}
function _withoutIndex(iteratee) {
  return (value, index2, callback) => iteratee(value, callback);
}
function eachLimit$2(coll, iteratee, callback) {
  return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var each$1 = awaitify(eachLimit$2, 3);
function eachLimit(coll, limit, iteratee, callback) {
  return eachOfLimit$2(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
}
var eachLimit$1 = awaitify(eachLimit, 4);
function eachSeries(coll, iteratee, callback) {
  return eachLimit$1(coll, 1, iteratee, callback);
}
var eachSeries$1 = awaitify(eachSeries, 3);
function ensureAsync(fn) {
  if (isAsync(fn)) return fn;
  return function(...args) {
    var callback = args.pop();
    var sync2 = true;
    args.push((...innerArgs) => {
      if (sync2) {
        setImmediate$1(() => callback(...innerArgs));
      } else {
        callback(...innerArgs);
      }
    });
    fn.apply(this, args);
    sync2 = false;
  };
}
function every(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
}
var every$1 = awaitify(every, 3);
function everyLimit(coll, limit, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var everyLimit$1 = awaitify(everyLimit, 4);
function everySeries(coll, iteratee, callback) {
  return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
}
var everySeries$1 = awaitify(everySeries, 3);
function filterArray(eachfn, arr, iteratee, callback) {
  var truthValues = new Array(arr.length);
  eachfn(arr, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      truthValues[index2] = !!v;
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    var results = [];
    for (var i = 0; i < arr.length; i++) {
      if (truthValues[i]) results.push(arr[i]);
    }
    callback(null, results);
  });
}
function filterGeneric(eachfn, coll, iteratee, callback) {
  var results = [];
  eachfn(coll, (x, index2, iterCb) => {
    iteratee(x, (err, v) => {
      if (err) return iterCb(err);
      if (v) {
        results.push({ index: index2, value: x });
      }
      iterCb(err);
    });
  }, (err) => {
    if (err) return callback(err);
    callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
  });
}
function _filter(eachfn, coll, iteratee, callback) {
  var filter3 = isArrayLike(coll) ? filterArray : filterGeneric;
  return filter3(eachfn, coll, wrapAsync(iteratee), callback);
}
function filter$1(coll, iteratee, callback) {
  return _filter(eachOf$1, coll, iteratee, callback);
}
var filter$1$1 = awaitify(filter$1, 3);
function filterLimit(coll, limit, iteratee, callback) {
  return _filter(eachOfLimit$2(limit), coll, iteratee, callback);
}
var filterLimit$1 = awaitify(filterLimit, 4);
function filterSeries(coll, iteratee, callback) {
  return _filter(eachOfSeries$1, coll, iteratee, callback);
}
var filterSeries$1 = awaitify(filterSeries, 3);
function forever(fn, errback) {
  var done = onlyOnce(errback);
  var task = wrapAsync(ensureAsync(fn));
  function next(err) {
    if (err) return done(err);
    if (err === false) return;
    task(next);
  }
  return next();
}
var forever$1 = awaitify(forever, 2);
function groupByLimit(coll, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(coll, limit, (val, iterCb) => {
    _iteratee(val, (err, key) => {
      if (err) return iterCb(err);
      return iterCb(err, { key, val });
    });
  }, (err, mapResults) => {
    var result = {};
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    for (var i = 0; i < mapResults.length; i++) {
      if (mapResults[i]) {
        var { key } = mapResults[i];
        var { val } = mapResults[i];
        if (hasOwnProperty2.call(result, key)) {
          result[key].push(val);
        } else {
          result[key] = [val];
        }
      }
    }
    return callback(err, result);
  });
}
var groupByLimit$1 = awaitify(groupByLimit, 4);
function groupBy(coll, iteratee, callback) {
  return groupByLimit$1(coll, Infinity, iteratee, callback);
}
function groupBySeries(coll, iteratee, callback) {
  return groupByLimit$1(coll, 1, iteratee, callback);
}
var log = consoleFunc("log");
function mapValuesLimit(obj, limit, iteratee, callback) {
  callback = once$1(callback);
  var newObj = {};
  var _iteratee = wrapAsync(iteratee);
  return eachOfLimit$2(limit)(obj, (val, key, next) => {
    _iteratee(val, key, (err, result) => {
      if (err) return next(err);
      newObj[key] = result;
      next(err);
    });
  }, (err) => callback(err, newObj));
}
var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
function mapValues(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, Infinity, iteratee, callback);
}
function mapValuesSeries(obj, iteratee, callback) {
  return mapValuesLimit$1(obj, 1, iteratee, callback);
}
function memoize(fn, hasher = (v) => v) {
  var memo = /* @__PURE__ */ Object.create(null);
  var queues = /* @__PURE__ */ Object.create(null);
  var _fn = wrapAsync(fn);
  var memoized = initialParams((args, callback) => {
    var key = hasher(...args);
    if (key in memo) {
      setImmediate$1(() => callback(null, ...memo[key]));
    } else if (key in queues) {
      queues[key].push(callback);
    } else {
      queues[key] = [callback];
      _fn(...args, (err, ...resultArgs) => {
        if (!err) {
          memo[key] = resultArgs;
        }
        var q = queues[key];
        delete queues[key];
        for (var i = 0, l = q.length; i < l; i++) {
          q[i](err, ...resultArgs);
        }
      });
    }
  });
  memoized.memo = memo;
  memoized.unmemoized = fn;
  return memoized;
}
var _defer;
if (hasNextTick) {
  _defer = process.nextTick;
} else if (hasSetImmediate) {
  _defer = setImmediate;
} else {
  _defer = fallback;
}
var nextTick = wrap(_defer);
var _parallel = awaitify((eachfn, tasks, callback) => {
  var results = isArrayLike(tasks) ? [] : {};
  eachfn(tasks, (task, key, taskCb) => {
    wrapAsync(task)((err, ...result) => {
      if (result.length < 2) {
        [result] = result;
      }
      results[key] = result;
      taskCb(err);
    });
  }, (err) => callback(err, results));
}, 3);
function parallel(tasks, callback) {
  return _parallel(eachOf$1, tasks, callback);
}
function parallelLimit(tasks, limit, callback) {
  return _parallel(eachOfLimit$2(limit), tasks, callback);
}
function queue$2(worker, concurrency) {
  var _worker = wrapAsync(worker);
  return queue$1((items, cb) => {
    _worker(items[0], cb);
  }, concurrency, 1);
}
class Heap {
  constructor() {
    this.heap = [];
    this.pushCount = Number.MIN_SAFE_INTEGER;
  }
  get length() {
    return this.heap.length;
  }
  empty() {
    this.heap = [];
    return this;
  }
  percUp(index2) {
    let p;
    while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
      let t = this.heap[index2];
      this.heap[index2] = this.heap[p];
      this.heap[p] = t;
      index2 = p;
    }
  }
  percDown(index2) {
    let l;
    while ((l = leftChi(index2)) < this.heap.length) {
      if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
        l = l + 1;
      }
      if (smaller(this.heap[index2], this.heap[l])) {
        break;
      }
      let t = this.heap[index2];
      this.heap[index2] = this.heap[l];
      this.heap[l] = t;
      index2 = l;
    }
  }
  push(node2) {
    node2.pushCount = ++this.pushCount;
    this.heap.push(node2);
    this.percUp(this.heap.length - 1);
  }
  unshift(node2) {
    return this.heap.push(node2);
  }
  shift() {
    let [top] = this.heap;
    this.heap[0] = this.heap[this.heap.length - 1];
    this.heap.pop();
    this.percDown(0);
    return top;
  }
  toArray() {
    return [...this];
  }
  *[Symbol.iterator]() {
    for (let i = 0; i < this.heap.length; i++) {
      yield this.heap[i].data;
    }
  }
  remove(testFn) {
    let j = 0;
    for (let i = 0; i < this.heap.length; i++) {
      if (!testFn(this.heap[i])) {
        this.heap[j] = this.heap[i];
        j++;
      }
    }
    this.heap.splice(j);
    for (let i = parent(this.heap.length - 1); i >= 0; i--) {
      this.percDown(i);
    }
    return this;
  }
}
function leftChi(i) {
  return (i << 1) + 1;
}
function parent(i) {
  return (i + 1 >> 1) - 1;
}
function smaller(x, y) {
  if (x.priority !== y.priority) {
    return x.priority < y.priority;
  } else {
    return x.pushCount < y.pushCount;
  }
}
function priorityQueue(worker, concurrency) {
  var q = queue$2(worker, concurrency);
  var {
    push,
    pushAsync
  } = q;
  q._tasks = new Heap();
  q._createTaskItem = ({ data: data2, priority }, callback) => {
    return {
      data: data2,
      priority,
      callback
    };
  };
  function createDataItems(tasks, priority) {
    if (!Array.isArray(tasks)) {
      return { data: tasks, priority };
    }
    return tasks.map((data2) => {
      return { data: data2, priority };
    });
  }
  q.push = function(data2, priority = 0, callback) {
    return push(createDataItems(data2, priority), callback);
  };
  q.pushAsync = function(data2, priority = 0, callback) {
    return pushAsync(createDataItems(data2, priority), callback);
  };
  delete q.unshift;
  delete q.unshiftAsync;
  return q;
}
function race$1(tasks, callback) {
  callback = once$1(callback);
  if (!Array.isArray(tasks)) return callback(new TypeError("First argument to race must be an array of functions"));
  if (!tasks.length) return callback();
  for (var i = 0, l = tasks.length; i < l; i++) {
    wrapAsync(tasks[i])(callback);
  }
}
var race$1$1 = awaitify(race$1, 2);
function reduceRight(array, memo, iteratee, callback) {
  var reversed = [...array].reverse();
  return reduce$1$1(reversed, memo, iteratee, callback);
}
function reflect(fn) {
  var _fn = wrapAsync(fn);
  return initialParams(function reflectOn(args, reflectCallback) {
    args.push((error2, ...cbArgs) => {
      let retVal = {};
      if (error2) {
        retVal.error = error2;
      }
      if (cbArgs.length > 0) {
        var value = cbArgs;
        if (cbArgs.length <= 1) {
          [value] = cbArgs;
        }
        retVal.value = value;
      }
      reflectCallback(null, retVal);
    });
    return _fn.apply(this, args);
  });
}
function reflectAll(tasks) {
  var results;
  if (Array.isArray(tasks)) {
    results = tasks.map(reflect);
  } else {
    results = {};
    Object.keys(tasks).forEach((key) => {
      results[key] = reflect.call(this, tasks[key]);
    });
  }
  return results;
}
function reject$2(eachfn, arr, _iteratee, callback) {
  const iteratee = wrapAsync(_iteratee);
  return _filter(eachfn, arr, (value, cb) => {
    iteratee(value, (err, v) => {
      cb(err, !v);
    });
  }, callback);
}
function reject(coll, iteratee, callback) {
  return reject$2(eachOf$1, coll, iteratee, callback);
}
var reject$1 = awaitify(reject, 3);
function rejectLimit(coll, limit, iteratee, callback) {
  return reject$2(eachOfLimit$2(limit), coll, iteratee, callback);
}
var rejectLimit$1 = awaitify(rejectLimit, 4);
function rejectSeries(coll, iteratee, callback) {
  return reject$2(eachOfSeries$1, coll, iteratee, callback);
}
var rejectSeries$1 = awaitify(rejectSeries, 3);
function constant(value) {
  return function() {
    return value;
  };
}
const DEFAULT_TIMES = 5;
const DEFAULT_INTERVAL = 0;
function retry(opts, task, callback) {
  var options = {
    times: DEFAULT_TIMES,
    intervalFunc: constant(DEFAULT_INTERVAL)
  };
  if (arguments.length < 3 && typeof opts === "function") {
    callback = task || promiseCallback();
    task = opts;
  } else {
    parseTimes(options, opts);
    callback = callback || promiseCallback();
  }
  if (typeof task !== "function") {
    throw new Error("Invalid arguments for async.retry");
  }
  var _task = wrapAsync(task);
  var attempt = 1;
  function retryAttempt() {
    _task((err, ...args) => {
      if (err === false) return;
      if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
        setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
      } else {
        callback(err, ...args);
      }
    });
  }
  retryAttempt();
  return callback[PROMISE_SYMBOL];
}
function parseTimes(acc, t) {
  if (typeof t === "object") {
    acc.times = +t.times || DEFAULT_TIMES;
    acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant(+t.interval || DEFAULT_INTERVAL);
    acc.errorFilter = t.errorFilter;
  } else if (typeof t === "number" || typeof t === "string") {
    acc.times = +t || DEFAULT_TIMES;
  } else {
    throw new Error("Invalid arguments for async.retry");
  }
}
function retryable(opts, task) {
  if (!task) {
    task = opts;
    opts = null;
  }
  let arity = opts && opts.arity || task.length;
  if (isAsync(task)) {
    arity += 1;
  }
  var _task = wrapAsync(task);
  return initialParams((args, callback) => {
    if (args.length < arity - 1 || callback == null) {
      args.push(callback);
      callback = promiseCallback();
    }
    function taskFn(cb) {
      _task(...args, cb);
    }
    if (opts) retry(opts, taskFn, callback);
    else retry(taskFn, callback);
    return callback[PROMISE_SYMBOL];
  });
}
function series(tasks, callback) {
  return _parallel(eachOfSeries$1, tasks, callback);
}
function some$1(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
}
var some$1$1 = awaitify(some$1, 3);
function someLimit(coll, limit, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfLimit$2(limit), coll, iteratee, callback);
}
var someLimit$1 = awaitify(someLimit, 4);
function someSeries(coll, iteratee, callback) {
  return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
}
var someSeries$1 = awaitify(someSeries, 3);
function sortBy(coll, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return map$1$1(coll, (x, iterCb) => {
    _iteratee(x, (err, criteria) => {
      if (err) return iterCb(err);
      iterCb(err, { value: x, criteria });
    });
  }, (err, results) => {
    if (err) return callback(err);
    callback(null, results.sort(comparator).map((v) => v.value));
  });
  function comparator(left, right) {
    var a = left.criteria, b = right.criteria;
    return a < b ? -1 : a > b ? 1 : 0;
  }
}
var sortBy$1 = awaitify(sortBy, 3);
function timeout(asyncFn, milliseconds, info) {
  var fn = wrapAsync(asyncFn);
  return initialParams((args, callback) => {
    var timedOut = false;
    var timer;
    function timeoutCallback() {
      var name = asyncFn.name || "anonymous";
      var error2 = new Error('Callback function "' + name + '" timed out.');
      error2.code = "ETIMEDOUT";
      if (info) {
        error2.info = info;
      }
      timedOut = true;
      callback(error2);
    }
    args.push((...cbArgs) => {
      if (!timedOut) {
        callback(...cbArgs);
        clearTimeout(timer);
      }
    });
    timer = setTimeout(timeoutCallback, milliseconds);
    fn(...args);
  });
}
function range(size) {
  var result = Array(size);
  while (size--) {
    result[size] = size;
  }
  return result;
}
function timesLimit(count, limit, iteratee, callback) {
  var _iteratee = wrapAsync(iteratee);
  return mapLimit$1(range(count), limit, _iteratee, callback);
}
function times(n, iteratee, callback) {
  return timesLimit(n, Infinity, iteratee, callback);
}
function timesSeries(n, iteratee, callback) {
  return timesLimit(n, 1, iteratee, callback);
}
function transform(coll, accumulator, iteratee, callback) {
  if (arguments.length <= 3 && typeof accumulator === "function") {
    callback = iteratee;
    iteratee = accumulator;
    accumulator = Array.isArray(coll) ? [] : {};
  }
  callback = once$1(callback || promiseCallback());
  var _iteratee = wrapAsync(iteratee);
  eachOf$1(coll, (v, k, cb) => {
    _iteratee(accumulator, v, k, cb);
  }, (err) => callback(err, accumulator));
  return callback[PROMISE_SYMBOL];
}
function tryEach(tasks, callback) {
  var error2 = null;
  var result;
  return eachSeries$1(tasks, (task, taskCb) => {
    wrapAsync(task)((err, ...args) => {
      if (err === false) return taskCb(err);
      if (args.length < 2) {
        [result] = args;
      } else {
        result = args;
      }
      error2 = err;
      taskCb(err ? null : {});
    });
  }, () => callback(error2, result));
}
var tryEach$1 = awaitify(tryEach);
function unmemoize(fn) {
  return (...args) => {
    return (fn.unmemoized || fn)(...args);
  };
}
function whilst(test2, iteratee, callback) {
  callback = onlyOnce(callback);
  var _fn = wrapAsync(iteratee);
  var _test = wrapAsync(test2);
  var results = [];
  function next(err, ...rest) {
    if (err) return callback(err);
    results = rest;
    if (err === false) return;
    _test(check);
  }
  function check(err, truth) {
    if (err) return callback(err);
    if (err === false) return;
    if (!truth) return callback(null, ...results);
    _fn(next);
  }
  return _test(check);
}
var whilst$1 = awaitify(whilst, 3);
function until(test2, iteratee, callback) {
  const _test = wrapAsync(test2);
  return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
}
function waterfall(tasks, callback) {
  callback = once$1(callback);
  if (!Array.isArray(tasks)) return callback(new Error("First argument to waterfall must be an array of functions"));
  if (!tasks.length) return callback();
  var taskIndex = 0;
  function nextTask(args) {
    var task = wrapAsync(tasks[taskIndex++]);
    task(...args, onlyOnce(next));
  }
  function next(err, ...args) {
    if (err === false) return;
    if (err || taskIndex === tasks.length) {
      return callback(err, ...args);
    }
    nextTask(args);
  }
  nextTask([]);
}
var waterfall$1 = awaitify(waterfall);
var index = {
  apply,
  applyEach,
  applyEachSeries,
  asyncify,
  auto,
  autoInject,
  cargo: cargo$1,
  cargoQueue: cargo,
  compose,
  concat: concat$1,
  concatLimit: concatLimit$1,
  concatSeries: concatSeries$1,
  constant: constant$1,
  detect: detect$1,
  detectLimit: detectLimit$1,
  detectSeries: detectSeries$1,
  dir,
  doUntil,
  doWhilst: doWhilst$1,
  each: each$1,
  eachLimit: eachLimit$1,
  eachOf: eachOf$1,
  eachOfLimit: eachOfLimit$1,
  eachOfSeries: eachOfSeries$1,
  eachSeries: eachSeries$1,
  ensureAsync,
  every: every$1,
  everyLimit: everyLimit$1,
  everySeries: everySeries$1,
  filter: filter$1$1,
  filterLimit: filterLimit$1,
  filterSeries: filterSeries$1,
  forever: forever$1,
  groupBy,
  groupByLimit: groupByLimit$1,
  groupBySeries,
  log,
  map: map$1$1,
  mapLimit: mapLimit$1,
  mapSeries: mapSeries$1,
  mapValues,
  mapValuesLimit: mapValuesLimit$1,
  mapValuesSeries,
  memoize,
  nextTick,
  parallel,
  parallelLimit,
  priorityQueue,
  queue: queue$2,
  race: race$1$1,
  reduce: reduce$1$1,
  reduceRight,
  reflect,
  reflectAll,
  reject: reject$1,
  rejectLimit: rejectLimit$1,
  rejectSeries: rejectSeries$1,
  retry,
  retryable,
  seq,
  series,
  setImmediate: setImmediate$1,
  some: some$1$1,
  someLimit: someLimit$1,
  someSeries: someSeries$1,
  sortBy: sortBy$1,
  timeout,
  times,
  timesLimit,
  timesSeries,
  transform,
  tryEach: tryEach$1,
  unmemoize,
  until,
  waterfall: waterfall$1,
  whilst: whilst$1,
  // aliases
  all: every$1,
  allLimit: everyLimit$1,
  allSeries: everySeries$1,
  any: some$1$1,
  anyLimit: someLimit$1,
  anySeries: someSeries$1,
  find: detect$1,
  findLimit: detectLimit$1,
  findSeries: detectSeries$1,
  flatMap: concat$1,
  flatMapLimit: concatLimit$1,
  flatMapSeries: concatSeries$1,
  forEach: each$1,
  forEachSeries: eachSeries$1,
  forEachLimit: eachLimit$1,
  forEachOf: eachOf$1,
  forEachOfSeries: eachOfSeries$1,
  forEachOfLimit: eachOfLimit$1,
  inject: reduce$1$1,
  foldl: reduce$1$1,
  foldr: reduceRight,
  select: filter$1$1,
  selectLimit: filterLimit$1,
  selectSeries: filterSeries$1,
  wrapSync: asyncify,
  during: whilst$1,
  doDuring: doWhilst$1
};
const async$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  all: every$1,
  allLimit: everyLimit$1,
  allSeries: everySeries$1,
  any: some$1$1,
  anyLimit: someLimit$1,
  anySeries: someSeries$1,
  apply,
  applyEach,
  applyEachSeries,
  asyncify,
  auto,
  autoInject,
  cargo: cargo$1,
  cargoQueue: cargo,
  compose,
  concat: concat$1,
  concatLimit: concatLimit$1,
  concatSeries: concatSeries$1,
  constant: constant$1,
  default: index,
  detect: detect$1,
  detectLimit: detectLimit$1,
  detectSeries: detectSeries$1,
  dir,
  doDuring: doWhilst$1,
  doUntil,
  doWhilst: doWhilst$1,
  during: whilst$1,
  each: each$1,
  eachLimit: eachLimit$1,
  eachOf: eachOf$1,
  eachOfLimit: eachOfLimit$1,
  eachOfSeries: eachOfSeries$1,
  eachSeries: eachSeries$1,
  ensureAsync,
  every: every$1,
  everyLimit: everyLimit$1,
  everySeries: everySeries$1,
  filter: filter$1$1,
  filterLimit: filterLimit$1,
  filterSeries: filterSeries$1,
  find: detect$1,
  findLimit: detectLimit$1,
  findSeries: detectSeries$1,
  flatMap: concat$1,
  flatMapLimit: concatLimit$1,
  flatMapSeries: concatSeries$1,
  foldl: reduce$1$1,
  foldr: reduceRight,
  forEach: each$1,
  forEachLimit: eachLimit$1,
  forEachOf: eachOf$1,
  forEachOfLimit: eachOfLimit$1,
  forEachOfSeries: eachOfSeries$1,
  forEachSeries: eachSeries$1,
  forever: forever$1,
  groupBy,
  groupByLimit: groupByLimit$1,
  groupBySeries,
  inject: reduce$1$1,
  log,
  map: map$1$1,
  mapLimit: mapLimit$1,
  mapSeries: mapSeries$1,
  mapValues,
  mapValuesLimit: mapValuesLimit$1,
  mapValuesSeries,
  memoize,
  nextTick,
  parallel,
  parallelLimit,
  priorityQueue,
  queue: queue$2,
  race: race$1$1,
  reduce: reduce$1$1,
  reduceRight,
  reflect,
  reflectAll,
  reject: reject$1,
  rejectLimit: rejectLimit$1,
  rejectSeries: rejectSeries$1,
  retry,
  retryable,
  select: filter$1$1,
  selectLimit: filterLimit$1,
  selectSeries: filterSeries$1,
  seq,
  series,
  setImmediate: setImmediate$1,
  some: some$1$1,
  someLimit: someLimit$1,
  someSeries: someSeries$1,
  sortBy: sortBy$1,
  timeout,
  times,
  timesLimit,
  timesSeries,
  transform,
  tryEach: tryEach$1,
  unmemoize,
  until,
  waterfall: waterfall$1,
  whilst: whilst$1,
  wrapSync: asyncify
}, Symbol.toStringTag, { value: "Module" }));
const require$$2 = /* @__PURE__ */ getAugmentedNamespace(async$1);
var archiverUtils$1 = { exports: {} };
var polyfills;
var hasRequiredPolyfills;
function requirePolyfills() {
  if (hasRequiredPolyfills) return polyfills;
  hasRequiredPolyfills = 1;
  var constants2 = require$$0$9;
  var origCwd = process.cwd;
  var cwd = null;
  var platform2 = process.env.GRACEFUL_FS_PLATFORM || process.platform;
  process.cwd = function() {
    if (!cwd)
      cwd = origCwd.call(process);
    return cwd;
  };
  try {
    process.cwd();
  } catch (er) {
  }
  if (typeof process.chdir === "function") {
    var chdir = process.chdir;
    process.chdir = function(d) {
      cwd = null;
      chdir.call(process, d);
    };
    if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
  }
  polyfills = patch;
  function patch(fs2) {
    if (constants2.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
      patchLchmod(fs2);
    }
    if (!fs2.lutimes) {
      patchLutimes(fs2);
    }
    fs2.chown = chownFix(fs2.chown);
    fs2.fchown = chownFix(fs2.fchown);
    fs2.lchown = chownFix(fs2.lchown);
    fs2.chmod = chmodFix(fs2.chmod);
    fs2.fchmod = chmodFix(fs2.fchmod);
    fs2.lchmod = chmodFix(fs2.lchmod);
    fs2.chownSync = chownFixSync(fs2.chownSync);
    fs2.fchownSync = chownFixSync(fs2.fchownSync);
    fs2.lchownSync = chownFixSync(fs2.lchownSync);
    fs2.chmodSync = chmodFixSync(fs2.chmodSync);
    fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
    fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
    fs2.stat = statFix(fs2.stat);
    fs2.fstat = statFix(fs2.fstat);
    fs2.lstat = statFix(fs2.lstat);
    fs2.statSync = statFixSync(fs2.statSync);
    fs2.fstatSync = statFixSync(fs2.fstatSync);
    fs2.lstatSync = statFixSync(fs2.lstatSync);
    if (fs2.chmod && !fs2.lchmod) {
      fs2.lchmod = function(path2, mode, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchmodSync = function() {
      };
    }
    if (fs2.chown && !fs2.lchown) {
      fs2.lchown = function(path2, uid, gid, cb) {
        if (cb) process.nextTick(cb);
      };
      fs2.lchownSync = function() {
      };
    }
    if (platform2 === "win32") {
      fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
        function rename(from, to, cb) {
          var start = Date.now();
          var backoff = 0;
          fs$rename(from, to, function CB(er) {
            if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
              setTimeout(function() {
                fs2.stat(to, function(stater, st) {
                  if (stater && stater.code === "ENOENT")
                    fs$rename(from, to, CB);
                  else
                    cb(er);
                });
              }, backoff);
              if (backoff < 100)
                backoff += 10;
              return;
            }
            if (cb) cb(er);
          });
        }
        if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
        return rename;
      }(fs2.rename);
    }
    fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
      function read(fd, buffer, offset, length, position, callback_) {
        var callback;
        if (callback_ && typeof callback_ === "function") {
          var eagCounter = 0;
          callback = function(er, _2, __) {
            if (er && er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
            }
            callback_.apply(this, arguments);
          };
        }
        return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
      return read;
    }(fs2.read);
    fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
      return function(fd, buffer, offset, length, position) {
        var eagCounter = 0;
        while (true) {
          try {
            return fs$readSync.call(fs2, fd, buffer, offset, length, position);
          } catch (er) {
            if (er.code === "EAGAIN" && eagCounter < 10) {
              eagCounter++;
              continue;
            }
            throw er;
          }
        }
      };
    }(fs2.readSync);
    function patchLchmod(fs22) {
      fs22.lchmod = function(path2, mode, callback) {
        fs22.open(
          path2,
          constants2.O_WRONLY | constants2.O_SYMLINK,
          mode,
          function(err, fd) {
            if (err) {
              if (callback) callback(err);
              return;
            }
            fs22.fchmod(fd, mode, function(err2) {
              fs22.close(fd, function(err22) {
                if (callback) callback(err2 || err22);
              });
            });
          }
        );
      };
      fs22.lchmodSync = function(path2, mode) {
        var fd = fs22.openSync(path2, constants2.O_WRONLY | constants2.O_SYMLINK, mode);
        var threw = true;
        var ret;
        try {
          ret = fs22.fchmodSync(fd, mode);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    }
    function patchLutimes(fs22) {
      if (constants2.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
        fs22.lutimes = function(path2, at, mt, cb) {
          fs22.open(path2, constants2.O_SYMLINK, function(er, fd) {
            if (er) {
              if (cb) cb(er);
              return;
            }
            fs22.futimes(fd, at, mt, function(er2) {
              fs22.close(fd, function(er22) {
                if (cb) cb(er2 || er22);
              });
            });
          });
        };
        fs22.lutimesSync = function(path2, at, mt) {
          var fd = fs22.openSync(path2, constants2.O_SYMLINK);
          var ret;
          var threw = true;
          try {
            ret = fs22.futimesSync(fd, at, mt);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs22.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs22.closeSync(fd);
            }
          }
          return ret;
        };
      } else if (fs22.futimes) {
        fs22.lutimes = function(_a, _b, _c, cb) {
          if (cb) process.nextTick(cb);
        };
        fs22.lutimesSync = function() {
        };
      }
    }
    function chmodFix(orig) {
      if (!orig) return orig;
      return function(target, mode, cb) {
        return orig.call(fs2, target, mode, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chmodFixSync(orig) {
      if (!orig) return orig;
      return function(target, mode) {
        try {
          return orig.call(fs2, target, mode);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function chownFix(orig) {
      if (!orig) return orig;
      return function(target, uid, gid, cb) {
        return orig.call(fs2, target, uid, gid, function(er) {
          if (chownErOk(er)) er = null;
          if (cb) cb.apply(this, arguments);
        });
      };
    }
    function chownFixSync(orig) {
      if (!orig) return orig;
      return function(target, uid, gid) {
        try {
          return orig.call(fs2, target, uid, gid);
        } catch (er) {
          if (!chownErOk(er)) throw er;
        }
      };
    }
    function statFix(orig) {
      if (!orig) return orig;
      return function(target, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        function callback(er, stats) {
          if (stats) {
            if (stats.uid < 0) stats.uid += 4294967296;
            if (stats.gid < 0) stats.gid += 4294967296;
          }
          if (cb) cb.apply(this, arguments);
        }
        return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
      };
    }
    function statFixSync(orig) {
      if (!orig) return orig;
      return function(target, options) {
        var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        return stats;
      };
    }
    function chownErOk(er) {
      if (!er)
        return true;
      if (er.code === "ENOSYS")
        return true;
      var nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (er.code === "EINVAL" || er.code === "EPERM")
          return true;
      }
      return false;
    }
  }
  return polyfills;
}
var legacyStreams;
var hasRequiredLegacyStreams;
function requireLegacyStreams() {
  if (hasRequiredLegacyStreams) return legacyStreams;
  hasRequiredLegacyStreams = 1;
  var Stream = require$$0$1.Stream;
  legacyStreams = legacy;
  function legacy(fs2) {
    return {
      ReadStream,
      WriteStream
    };
    function ReadStream(path2, options) {
      if (!(this instanceof ReadStream)) return new ReadStream(path2, options);
      Stream.call(this);
      var self2 = this;
      this.path = path2;
      this.fd = null;
      this.readable = true;
      this.paused = false;
      this.flags = "r";
      this.mode = 438;
      this.bufferSize = 64 * 1024;
      options = options || {};
      var keys = Object.keys(options);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options[key];
      }
      if (this.encoding) this.setEncoding(this.encoding);
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.end === void 0) {
          this.end = Infinity;
        } else if ("number" !== typeof this.end) {
          throw TypeError("end must be a Number");
        }
        if (this.start > this.end) {
          throw new Error("start must be <= end");
        }
        this.pos = this.start;
      }
      if (this.fd !== null) {
        process.nextTick(function() {
          self2._read();
        });
        return;
      }
      fs2.open(this.path, this.flags, this.mode, function(err, fd) {
        if (err) {
          self2.emit("error", err);
          self2.readable = false;
          return;
        }
        self2.fd = fd;
        self2.emit("open", fd);
        self2._read();
      });
    }
    function WriteStream(path2, options) {
      if (!(this instanceof WriteStream)) return new WriteStream(path2, options);
      Stream.call(this);
      this.path = path2;
      this.fd = null;
      this.writable = true;
      this.flags = "w";
      this.encoding = "binary";
      this.mode = 438;
      this.bytesWritten = 0;
      options = options || {};
      var keys = Object.keys(options);
      for (var index2 = 0, length = keys.length; index2 < length; index2++) {
        var key = keys[index2];
        this[key] = options[key];
      }
      if (this.start !== void 0) {
        if ("number" !== typeof this.start) {
          throw TypeError("start must be a Number");
        }
        if (this.start < 0) {
          throw new Error("start must be >= zero");
        }
        this.pos = this.start;
      }
      this.busy = false;
      this._queue = [];
      if (this.fd === null) {
        this._open = fs2.open;
        this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
        this.flush();
      }
    }
  }
  return legacyStreams;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone) return clone_1;
  hasRequiredClone = 1;
  clone_1 = clone;
  var getPrototypeOf2 = Object.getPrototypeOf || function(obj) {
    return obj.__proto__;
  };
  function clone(obj) {
    if (obj === null || typeof obj !== "object")
      return obj;
    if (obj instanceof Object)
      var copy = { __proto__: getPrototypeOf2(obj) };
    else
      var copy = /* @__PURE__ */ Object.create(null);
    Object.getOwnPropertyNames(obj).forEach(function(key) {
      Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
    });
    return copy;
  }
  return clone_1;
}
var gracefulFs;
var hasRequiredGracefulFs;
function requireGracefulFs() {
  if (hasRequiredGracefulFs) return gracefulFs;
  hasRequiredGracefulFs = 1;
  var fs2 = require$$0$4;
  var polyfills2 = requirePolyfills();
  var legacy = requireLegacyStreams();
  var clone = requireClone();
  var util2 = require$$0$2;
  var gracefulQueue;
  var previousSymbol;
  if (typeof Symbol === "function" && typeof Symbol.for === "function") {
    gracefulQueue = Symbol.for("graceful-fs.queue");
    previousSymbol = Symbol.for("graceful-fs.previous");
  } else {
    gracefulQueue = "___graceful-fs.queue";
    previousSymbol = "___graceful-fs.previous";
  }
  function noop2() {
  }
  function publishQueue(context2, queue22) {
    Object.defineProperty(context2, gracefulQueue, {
      get: function() {
        return queue22;
      }
    });
  }
  var debug = noop2;
  if (util2.debuglog)
    debug = util2.debuglog("gfs4");
  else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
    debug = function() {
      var m = util2.format.apply(util2, arguments);
      m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
      console.error(m);
    };
  if (!fs2[gracefulQueue]) {
    var queue2 = commonjsGlobal[gracefulQueue] || [];
    publishQueue(fs2, queue2);
    fs2.close = function(fs$close) {
      function close(fd, cb) {
        return fs$close.call(fs2, fd, function(err) {
          if (!err) {
            resetQueue();
          }
          if (typeof cb === "function")
            cb.apply(this, arguments);
        });
      }
      Object.defineProperty(close, previousSymbol, {
        value: fs$close
      });
      return close;
    }(fs2.close);
    fs2.closeSync = function(fs$closeSync) {
      function closeSync(fd) {
        fs$closeSync.apply(fs2, arguments);
        resetQueue();
      }
      Object.defineProperty(closeSync, previousSymbol, {
        value: fs$closeSync
      });
      return closeSync;
    }(fs2.closeSync);
    if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
      process.on("exit", function() {
        debug(fs2[gracefulQueue]);
        require$$5.equal(fs2[gracefulQueue].length, 0);
      });
    }
  }
  if (!commonjsGlobal[gracefulQueue]) {
    publishQueue(commonjsGlobal, fs2[gracefulQueue]);
  }
  gracefulFs = patch(clone(fs2));
  if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs2.__patched) {
    gracefulFs = patch(fs2);
    fs2.__patched = true;
  }
  function patch(fs22) {
    polyfills2(fs22);
    fs22.gracefulify = patch;
    fs22.createReadStream = createReadStream;
    fs22.createWriteStream = createWriteStream;
    var fs$readFile = fs22.readFile;
    fs22.readFile = readFile;
    function readFile(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$readFile(path2, options, cb);
      function go$readFile(path22, options2, cb2, startTime) {
        return fs$readFile(path22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$writeFile = fs22.writeFile;
    fs22.writeFile = writeFile;
    function writeFile(path2, data2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$writeFile(path2, data2, options, cb);
      function go$writeFile(path22, data22, options2, cb2, startTime) {
        return fs$writeFile(path22, data22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$writeFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$appendFile = fs22.appendFile;
    if (fs$appendFile)
      fs22.appendFile = appendFile;
    function appendFile(path2, data2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      return go$appendFile(path2, data2, options, cb);
      function go$appendFile(path22, data22, options2, cb2, startTime) {
        return fs$appendFile(path22, data22, options2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$appendFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$copyFile = fs22.copyFile;
    if (fs$copyFile)
      fs22.copyFile = copyFile;
    function copyFile(src2, dest, flags, cb) {
      if (typeof flags === "function") {
        cb = flags;
        flags = 0;
      }
      return go$copyFile(src2, dest, flags, cb);
      function go$copyFile(src22, dest2, flags2, cb2, startTime) {
        return fs$copyFile(src22, dest2, flags2, function(err) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    var fs$readdir = fs22.readdir;
    fs22.readdir = readdir;
    var noReaddirOptionVersions = /^v[0-5]\./;
    function readdir(path2, options, cb) {
      if (typeof options === "function")
        cb = options, options = null;
      var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
        return fs$readdir(path22, fs$readdirCallback(
          path22,
          options2,
          cb2,
          startTime
        ));
      } : function go$readdir2(path22, options2, cb2, startTime) {
        return fs$readdir(path22, options2, fs$readdirCallback(
          path22,
          options2,
          cb2,
          startTime
        ));
      };
      return go$readdir(path2, options, cb);
      function fs$readdirCallback(path22, options2, cb2, startTime) {
        return function(err, files) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([
              go$readdir,
              [path22, options2, cb2],
              err,
              startTime || Date.now(),
              Date.now()
            ]);
          else {
            if (files && files.sort)
              files.sort();
            if (typeof cb2 === "function")
              cb2.call(this, err, files);
          }
        };
      }
    }
    if (process.version.substr(0, 4) === "v0.8") {
      var legStreams = legacy(fs22);
      ReadStream = legStreams.ReadStream;
      WriteStream = legStreams.WriteStream;
    }
    var fs$ReadStream = fs22.ReadStream;
    if (fs$ReadStream) {
      ReadStream.prototype = Object.create(fs$ReadStream.prototype);
      ReadStream.prototype.open = ReadStream$open;
    }
    var fs$WriteStream = fs22.WriteStream;
    if (fs$WriteStream) {
      WriteStream.prototype = Object.create(fs$WriteStream.prototype);
      WriteStream.prototype.open = WriteStream$open;
    }
    Object.defineProperty(fs22, "ReadStream", {
      get: function() {
        return ReadStream;
      },
      set: function(val) {
        ReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    Object.defineProperty(fs22, "WriteStream", {
      get: function() {
        return WriteStream;
      },
      set: function(val) {
        WriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileReadStream = ReadStream;
    Object.defineProperty(fs22, "FileReadStream", {
      get: function() {
        return FileReadStream;
      },
      set: function(val) {
        FileReadStream = val;
      },
      enumerable: true,
      configurable: true
    });
    var FileWriteStream = WriteStream;
    Object.defineProperty(fs22, "FileWriteStream", {
      get: function() {
        return FileWriteStream;
      },
      set: function(val) {
        FileWriteStream = val;
      },
      enumerable: true,
      configurable: true
    });
    function ReadStream(path2, options) {
      if (this instanceof ReadStream)
        return fs$ReadStream.apply(this, arguments), this;
      else
        return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
    }
    function ReadStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          if (that.autoClose)
            that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
          that.read();
        }
      });
    }
    function WriteStream(path2, options) {
      if (this instanceof WriteStream)
        return fs$WriteStream.apply(this, arguments), this;
      else
        return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
    }
    function WriteStream$open() {
      var that = this;
      open(that.path, that.flags, that.mode, function(err, fd) {
        if (err) {
          that.destroy();
          that.emit("error", err);
        } else {
          that.fd = fd;
          that.emit("open", fd);
        }
      });
    }
    function createReadStream(path2, options) {
      return new fs22.ReadStream(path2, options);
    }
    function createWriteStream(path2, options) {
      return new fs22.WriteStream(path2, options);
    }
    var fs$open = fs22.open;
    fs22.open = open;
    function open(path2, flags, mode, cb) {
      if (typeof mode === "function")
        cb = mode, mode = null;
      return go$open(path2, flags, mode, cb);
      function go$open(path22, flags2, mode2, cb2, startTime) {
        return fs$open(path22, flags2, mode2, function(err, fd) {
          if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
            enqueue([go$open, [path22, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
          else {
            if (typeof cb2 === "function")
              cb2.apply(this, arguments);
          }
        });
      }
    }
    return fs22;
  }
  function enqueue(elem) {
    debug("ENQUEUE", elem[0].name, elem[1]);
    fs2[gracefulQueue].push(elem);
    retry2();
  }
  var retryTimer;
  function resetQueue() {
    var now = Date.now();
    for (var i = 0; i < fs2[gracefulQueue].length; ++i) {
      if (fs2[gracefulQueue][i].length > 2) {
        fs2[gracefulQueue][i][3] = now;
        fs2[gracefulQueue][i][4] = now;
      }
    }
    retry2();
  }
  function retry2() {
    clearTimeout(retryTimer);
    retryTimer = void 0;
    if (fs2[gracefulQueue].length === 0)
      return;
    var elem = fs2[gracefulQueue].shift();
    var fn = elem[0];
    var args = elem[1];
    var err = elem[2];
    var startTime = elem[3];
    var lastTime = elem[4];
    if (startTime === void 0) {
      debug("RETRY", fn.name, args);
      fn.apply(null, args);
    } else if (Date.now() - startTime >= 6e4) {
      debug("TIMEOUT", fn.name, args);
      var cb = args.pop();
      if (typeof cb === "function")
        cb.call(null, err);
    } else {
      var sinceAttempt = Date.now() - lastTime;
      var sinceStart = Math.max(lastTime - startTime, 1);
      var desiredDelay = Math.min(sinceStart * 1.2, 100);
      if (sinceAttempt >= desiredDelay) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args.concat([startTime]));
      } else {
        fs2[gracefulQueue].push(elem);
      }
    }
    if (retryTimer === void 0) {
      retryTimer = setTimeout(retry2, 0);
    }
  }
  return gracefulFs;
}
var readable$3 = { exports: {} };
var stream$3;
var hasRequiredStream$3;
function requireStream$3() {
  if (hasRequiredStream$3) return stream$3;
  hasRequiredStream$3 = 1;
  stream$3 = require$$0$1;
  return stream$3;
}
var safeBuffer$3 = { exports: {} };
var hasRequiredSafeBuffer$3;
function requireSafeBuffer$3() {
  if (hasRequiredSafeBuffer$3) return safeBuffer$3.exports;
  hasRequiredSafeBuffer$3 = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$3, safeBuffer$3.exports);
  return safeBuffer$3.exports;
}
var util$6 = {};
var hasRequiredUtil$6;
function requireUtil$6() {
  if (hasRequiredUtil$6) return util$6;
  hasRequiredUtil$6 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$6.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$6.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$6.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$6.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$6.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$6.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$6.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$6.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$6.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$6.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util$6.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$6.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$6.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$6.isPrimitive = isPrimitive;
  util$6.isBuffer = require$$0$7.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$6;
}
var BufferList$3 = { exports: {} };
var hasRequiredBufferList$4;
function requireBufferList$4() {
  if (hasRequiredBufferList$4) return BufferList$3.exports;
  hasRequiredBufferList$4 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$3().Buffer;
    var util2 = require$$0$2;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$3);
  return BufferList$3.exports;
}
var destroy_1$3;
var hasRequiredDestroy$3;
function requireDestroy$3() {
  if (hasRequiredDestroy$3) return destroy_1$3;
  hasRequiredDestroy$3 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$3 = {
    destroy,
    undestroy
  };
  return destroy_1$3;
}
var _stream_writable$3;
var hasRequired_stream_writable$3;
function require_stream_writable$3() {
  if (hasRequired_stream_writable$3) return _stream_writable$3;
  hasRequired_stream_writable$3 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$3 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$6());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream$3();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$3();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$3();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$3();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$3;
}
var _stream_duplex$3;
var hasRequired_stream_duplex$3;
function require_stream_duplex$3() {
  if (hasRequired_stream_duplex$3) return _stream_duplex$3;
  hasRequired_stream_duplex$3 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$3 = Duplex;
  var util2 = Object.create(requireUtil$6());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$3();
  var Writable = require_stream_writable$3();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$3;
}
var string_decoder$3 = {};
var hasRequiredString_decoder$3;
function requireString_decoder$3() {
  if (hasRequiredString_decoder$3) return string_decoder$3;
  hasRequiredString_decoder$3 = 1;
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$3.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$3;
}
var _stream_readable$3;
var hasRequired_stream_readable$3;
function require_stream_readable$3() {
  if (hasRequired_stream_readable$3) return _stream_readable$3;
  hasRequired_stream_readable$3 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$3 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream$3();
  var Buffer2 = requireSafeBuffer$3().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$6());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$2;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList$4();
  var destroyImpl = requireDestroy$3();
  var StringDecoder;
  util2.inherits(Readable2, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$3();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder$3().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$3();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder$3().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$3;
}
var _stream_transform$3;
var hasRequired_stream_transform$3;
function require_stream_transform$3() {
  if (hasRequired_stream_transform$3) return _stream_transform$3;
  hasRequired_stream_transform$3 = 1;
  _stream_transform$3 = Transform;
  var Duplex = require_stream_duplex$3();
  var util2 = Object.create(requireUtil$6());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$3;
}
var _stream_passthrough$3;
var hasRequired_stream_passthrough$3;
function require_stream_passthrough$3() {
  if (hasRequired_stream_passthrough$3) return _stream_passthrough$3;
  hasRequired_stream_passthrough$3 = 1;
  _stream_passthrough$3 = PassThrough;
  var Transform = require_stream_transform$3();
  var util2 = Object.create(requireUtil$6());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$3;
}
var hasRequiredReadable$3;
function requireReadable$3() {
  if (hasRequiredReadable$3) return readable$3.exports;
  hasRequiredReadable$3 = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable$3();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$3();
      exports.Duplex = require_stream_duplex$3();
      exports.Transform = require_stream_transform$3();
      exports.PassThrough = require_stream_passthrough$3();
    }
  })(readable$3, readable$3.exports);
  return readable$3.exports;
}
var passthrough;
var hasRequiredPassthrough;
function requirePassthrough() {
  if (hasRequiredPassthrough) return passthrough;
  hasRequiredPassthrough = 1;
  passthrough = requireReadable$3().PassThrough;
  return passthrough;
}
var lazystream;
var hasRequiredLazystream;
function requireLazystream() {
  if (hasRequiredLazystream) return lazystream;
  hasRequiredLazystream = 1;
  var util2 = require$$0$2;
  var PassThrough = requirePassthrough();
  lazystream = {
    Readable: Readable2,
    Writable
  };
  util2.inherits(Readable2, PassThrough);
  util2.inherits(Writable, PassThrough);
  function beforeFirstCall(instance, method2, callback) {
    instance[method2] = function() {
      delete instance[method2];
      callback.apply(this, arguments);
      return this[method2].apply(this, arguments);
    };
  }
  function Readable2(fn, options) {
    if (!(this instanceof Readable2))
      return new Readable2(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_read", function() {
      var source = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      source.on("error", emit);
      source.pipe(this);
    });
    this.emit("readable");
  }
  function Writable(fn, options) {
    if (!(this instanceof Writable))
      return new Writable(fn, options);
    PassThrough.call(this, options);
    beforeFirstCall(this, "_write", function() {
      var destination = fn.call(this, options);
      var emit = this.emit.bind(this, "error");
      destination.on("error", emit);
      this.pipe(destination);
    });
    this.emit("writable");
  }
  return lazystream;
}
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
var normalizePath;
var hasRequiredNormalizePath;
function requireNormalizePath() {
  if (hasRequiredNormalizePath) return normalizePath;
  hasRequiredNormalizePath = 1;
  normalizePath = function(path2, stripTrailing) {
    if (typeof path2 !== "string") {
      throw new TypeError("expected path to be a string");
    }
    if (path2 === "\\" || path2 === "/") return "/";
    var len = path2.length;
    if (len <= 1) return path2;
    var prefix = "";
    if (len > 4 && path2[3] === "\\") {
      var ch = path2[2];
      if ((ch === "?" || ch === ".") && path2.slice(0, 2) === "\\\\") {
        path2 = path2.slice(2);
        prefix = "//";
      }
    }
    var segs = path2.split(/[/\\]+/);
    if (stripTrailing !== false && segs[segs.length - 1] === "") {
      segs.pop();
    }
    return prefix + segs.join("/");
  };
  return normalizePath;
}
var lodash_defaults;
var hasRequiredLodash_defaults;
function requireLodash_defaults() {
  if (hasRequiredLodash_defaults) return lodash_defaults;
  hasRequiredLodash_defaults = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  function arrayLikeKeys(value, inherited) {
    var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if (!(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignInDefaults(objValue, srcValue, key, object2) {
    if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object2, key)) {
      return srcValue;
    }
    return objValue;
  }
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty2.call(object2, key) && eq(objValue, value)) || value === void 0 && !(key in object2)) {
      object2[key] = value;
    }
  }
  function baseKeysIn(object2) {
    if (!isObject2(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = array;
      return apply2(func, this, otherArgs);
    };
  }
  function copyObject(source, props2, object2, customizer) {
    object2 || (object2 = {});
    var index2 = -1, length = props2.length;
    while (++index2 < length) {
      var key = props2[index2];
      var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
      assignValue(object2, key, newValue === void 0 ? source[key] : newValue);
    }
    return object2;
  }
  function createAssigner(assigner) {
    return baseRest(function(object2, sources) {
      var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object2 = Object(object2);
      while (++index2 < length) {
        var source = sources[index2];
        if (source) {
          assigner(object2, source, index2, customizer);
        }
      }
      return object2;
    });
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index2, object2) {
    if (!isObject2(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike2(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq(object2[index2], value);
    }
    return false;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike2(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  var assignInWith = createAssigner(function(object2, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object2, customizer);
  });
  var defaults2 = baseRest(function(args) {
    args.push(void 0, assignInDefaults);
    return apply2(assignInWith, void 0, args);
  });
  function keysIn(object2) {
    return isArrayLike2(object2) ? arrayLikeKeys(object2) : baseKeysIn(object2);
  }
  lodash_defaults = defaults2;
  return lodash_defaults;
}
var readable$2 = { exports: {} };
var stream$2;
var hasRequiredStream$2;
function requireStream$2() {
  if (hasRequiredStream$2) return stream$2;
  hasRequiredStream$2 = 1;
  stream$2 = require$$0$1;
  return stream$2;
}
var safeBuffer$2 = { exports: {} };
var hasRequiredSafeBuffer$2;
function requireSafeBuffer$2() {
  if (hasRequiredSafeBuffer$2) return safeBuffer$2.exports;
  hasRequiredSafeBuffer$2 = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$2, safeBuffer$2.exports);
  return safeBuffer$2.exports;
}
var util$5 = {};
var hasRequiredUtil$5;
function requireUtil$5() {
  if (hasRequiredUtil$5) return util$5;
  hasRequiredUtil$5 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$5.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$5.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$5.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$5.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$5.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$5.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$5.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$5.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$5.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$5.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util$5.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$5.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$5.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$5.isPrimitive = isPrimitive;
  util$5.isBuffer = require$$0$7.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$5;
}
var BufferList$2 = { exports: {} };
var hasRequiredBufferList$3;
function requireBufferList$3() {
  if (hasRequiredBufferList$3) return BufferList$2.exports;
  hasRequiredBufferList$3 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$2().Buffer;
    var util2 = require$$0$2;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$2);
  return BufferList$2.exports;
}
var destroy_1$2;
var hasRequiredDestroy$2;
function requireDestroy$2() {
  if (hasRequiredDestroy$2) return destroy_1$2;
  hasRequiredDestroy$2 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$2 = {
    destroy,
    undestroy
  };
  return destroy_1$2;
}
var _stream_writable$2;
var hasRequired_stream_writable$2;
function require_stream_writable$2() {
  if (hasRequired_stream_writable$2) return _stream_writable$2;
  hasRequired_stream_writable$2 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$2 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$5());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream$2();
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$2();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$2();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$2();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$2;
}
var _stream_duplex$2;
var hasRequired_stream_duplex$2;
function require_stream_duplex$2() {
  if (hasRequired_stream_duplex$2) return _stream_duplex$2;
  hasRequired_stream_duplex$2 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$2 = Duplex;
  var util2 = Object.create(requireUtil$5());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$2();
  var Writable = require_stream_writable$2();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$2;
}
var string_decoder$2 = {};
var hasRequiredString_decoder$2;
function requireString_decoder$2() {
  if (hasRequiredString_decoder$2) return string_decoder$2;
  hasRequiredString_decoder$2 = 1;
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$2.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$2;
}
var _stream_readable$2;
var hasRequired_stream_readable$2;
function require_stream_readable$2() {
  if (hasRequired_stream_readable$2) return _stream_readable$2;
  hasRequired_stream_readable$2 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$2 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream$2();
  var Buffer2 = requireSafeBuffer$2().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$5());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$2;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList$3();
  var destroyImpl = requireDestroy$2();
  var StringDecoder;
  util2.inherits(Readable2, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$2();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder$2().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$2();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder$2().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$2;
}
var _stream_transform$2;
var hasRequired_stream_transform$2;
function require_stream_transform$2() {
  if (hasRequired_stream_transform$2) return _stream_transform$2;
  hasRequired_stream_transform$2 = 1;
  _stream_transform$2 = Transform;
  var Duplex = require_stream_duplex$2();
  var util2 = Object.create(requireUtil$5());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$2;
}
var _stream_passthrough$2;
var hasRequired_stream_passthrough$2;
function require_stream_passthrough$2() {
  if (hasRequired_stream_passthrough$2) return _stream_passthrough$2;
  hasRequired_stream_passthrough$2 = 1;
  _stream_passthrough$2 = PassThrough;
  var Transform = require_stream_transform$2();
  var util2 = Object.create(requireUtil$5());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$2;
}
var hasRequiredReadable$2;
function requireReadable$2() {
  if (hasRequiredReadable$2) return readable$2.exports;
  hasRequiredReadable$2 = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable$2();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$2();
      exports.Duplex = require_stream_duplex$2();
      exports.Transform = require_stream_transform$2();
      exports.PassThrough = require_stream_passthrough$2();
    }
  })(readable$2, readable$2.exports);
  return readable$2.exports;
}
var file$1 = { exports: {} };
var lodash_flatten;
var hasRequiredLodash_flatten;
function requireLodash_flatten() {
  if (hasRequiredLodash_flatten) return lodash_flatten;
  hasRequiredLodash_flatten = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  var objectProto = Object.prototype;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value)) {
        {
          arrayPush(result, value);
        }
      } else {
        result[result.length] = value;
      }
    }
    return result;
  }
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function flatten(array) {
    var length = array ? array.length : 0;
    return length ? baseFlatten(array) : [];
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike2(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  lodash_flatten = flatten;
  return lodash_flatten;
}
var lodash_difference;
var hasRequiredLodash_difference;
function requireLodash_difference() {
  if (hasRequiredLodash_difference) return lodash_difference;
  hasRequiredLodash_difference = 1;
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index2 = fromIndex + -1;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Symbol2 = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map"), nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseDifference(array, values, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
    if (!length) {
      return result;
    }
    if (values.length >= LARGE_ARRAY_SIZE) {
      includes = cacheHas;
      isCommon = false;
      values = new SetCache(values);
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
    return result;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value)) {
        {
          arrayPush(result, value);
        }
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = array;
      return apply2(func, this, otherArgs);
    };
  }
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var difference = baseRest(function(array, values) {
    return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject)) : [];
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike2(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  lodash_difference = difference;
  return lodash_difference;
}
var lodash_union;
var hasRequiredLodash_union;
function requireLodash_union() {
  if (hasRequiredLodash_union) return lodash_union;
  hasRequiredLodash_union = 1;
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function arrayIncludes(array, value) {
    var length = array ? array.length : 0;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  function arrayPush(array, values) {
    var index2 = -1, length = values.length, offset = array.length;
    while (++index2 < length) {
      array[offset + index2] = values[index2];
    }
    return array;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index2 = fromIndex + -1;
    while (++index2 < length) {
      if (predicate(array[index2], index2, array)) {
        return index2;
      }
    }
    return -1;
  }
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index2 = fromIndex - 1, length = array.length;
    while (++index2 < length) {
      if (array[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  function baseIsNaN(value) {
    return value !== value;
  }
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function setToArray(set) {
    var index2 = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  var Symbol2 = root.Symbol, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  var nativeMax = Math.max;
  var Map2 = getNative(root, "Map"), Set2 = getNative(root, "Set"), nativeCreate = getNative(Object, "create");
  function Hash(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data2 = this.__data__;
    if (nativeCreate) {
      var result = data2[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty2.call(data2, key) ? data2[key] : void 0;
  }
  function hashHas(key) {
    var data2 = this.__data__;
    return nativeCreate ? data2[key] !== void 0 : hasOwnProperty2.call(data2, key);
  }
  function hashSet(key, value) {
    var data2 = this.__data__;
    data2[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data2.length - 1;
    if (index2 == lastIndex) {
      data2.pop();
    } else {
      splice.call(data2, index2, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    return index2 < 0 ? void 0 : data2[index2][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data2 = this.__data__, index2 = assocIndexOf(data2, key);
    if (index2 < 0) {
      data2.push([key, value]);
    } else {
      data2[index2][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index2 = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index2 < length) {
      var entry = entries[index2];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      "hash": new Hash(),
      "map": new (Map2 || ListCache)(),
      "string": new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index2 = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index2 < length) {
      this.add(values[index2]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseFlatten(array, depth, predicate, isStrict, result) {
    var index2 = -1, length = array.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length) {
      var value = array[index2];
      if (predicate(value)) {
        {
          arrayPush(result, value);
        }
      }
    }
    return result;
  }
  function baseIsNative(value) {
    if (!isObject2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseRest(func, start) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index2 < length) {
        array[index2] = args[start + index2];
      }
      index2 = -1;
      var otherArgs = Array(start + 1);
      while (++index2 < start) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start] = array;
      return apply2(func, this, otherArgs);
    };
  }
  function baseUniq(array, iteratee, comparator) {
    var index2 = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
    if (length >= LARGE_ARRAY_SIZE) {
      var set = createSet(array);
      if (set) {
        return setToArray(set);
      }
      isCommon = false;
      includes = cacheHas;
      seen = new SetCache();
    } else {
      seen = result;
    }
    outer:
      while (++index2 < length) {
        var value = array[index2], computed = value;
        value = value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        } else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
    return new Set2(values);
  };
  function getMapData(map2, key) {
    var data2 = map2.__data__;
    return isKeyable(key) ? data2[typeof key == "string" ? "string" : "hash"] : data2.map;
  }
  function getNative(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  function isFlattenable(value) {
    return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  function isKeyable(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject));
  });
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray2 = Array.isArray;
  function isArrayLike2(value) {
    return value != null && isLength(value.length) && !isFunction2(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike2(value);
  }
  function isFunction2(value) {
    var tag = isObject2(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject2(value) {
    var type2 = typeof value;
    return !!value && (type2 == "object" || type2 == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function noop2() {
  }
  lodash_union = union;
  return lodash_union;
}
var lodash_isplainobject;
var hasRequiredLodash_isplainobject;
function requireLodash_isplainobject() {
  if (hasRequiredLodash_isplainobject) return lodash_isplainobject;
  hasRequiredLodash_isplainobject = 1;
  var objectTag = "[object Object]";
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  var funcProto = Function.prototype, objectProto = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  var objectToString = objectProto.toString;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isPlainObject2(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  lodash_isplainobject = isPlainObject2;
  return lodash_isplainobject;
}
var old = {};
var hasRequiredOld;
function requireOld() {
  if (hasRequiredOld) return old;
  hasRequiredOld = 1;
  var pathModule = require$$1;
  var isWindows = process.platform === "win32";
  var fs2 = require$$0$4;
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  pathModule.normalize;
  if (isWindows) {
    var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    var nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  if (isWindows) {
    var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    var splitRootRe = /^[\/]*/;
  }
  old.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs2.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache) cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs2.statSync(base);
          linkTarget = fs2.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache) cache[base] = resolvedLink;
        if (!isWindows) seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache) cache[original] = p;
    return p;
  };
  old.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstat(base, function(err) {
          if (err) return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache) cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs2.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err) return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs2.stat(base, function(err2) {
        if (err2) return cb(err2);
        fs2.readlink(base, function(err3, target) {
          if (!isWindows) seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err) return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache) cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
  return old;
}
var fs_realpath;
var hasRequiredFs_realpath;
function requireFs_realpath() {
  if (hasRequiredFs_realpath) return fs_realpath;
  hasRequiredFs_realpath = 1;
  fs_realpath = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require$$0$4;
  var origRealpath = fs2.realpath;
  var origRealpathSync = fs2.realpathSync;
  var version2 = process.version;
  var ok = /^v[0-5]\./.test(version2);
  var old2 = requireOld();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old2.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old2.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath;
    fs2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath;
    fs2.realpathSync = origRealpathSync;
  }
  return fs_realpath;
}
var concatMap;
var hasRequiredConcatMap;
function requireConcatMap() {
  if (hasRequiredConcatMap) return concatMap;
  hasRequiredConcatMap = 1;
  concatMap = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray2(x)) res.push.apply(res, x);
      else res.push(x);
    }
    return res;
  };
  var isArray2 = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
  return concatMap;
}
var braceExpansion;
var hasRequiredBraceExpansion;
function requireBraceExpansion() {
  if (hasRequiredBraceExpansion) return braceExpansion;
  hasRequiredBraceExpansion = 1;
  var concatMap2 = requireConcatMap();
  var balanced = requireBalancedMatch();
  braceExpansion = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre)) return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test2 = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test2 = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test2(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap2(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
  return braceExpansion;
}
var minimatch_1;
var hasRequiredMinimatch;
function requireMinimatch() {
  if (hasRequiredMinimatch) return minimatch_1;
  hasRequiredMinimatch = 1;
  minimatch_1 = minimatch;
  minimatch.Minimatch = Minimatch;
  var path2 = function() {
    try {
      return require("path");
    } catch (e) {
    }
  }() || {
    sep: "/"
  };
  minimatch.sep = path2.sep;
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = requireBraceExpansion();
  var plTypes = {
    "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
    "?": { open: "(?:", close: ")?" },
    "+": { open: "(?:", close: ")+" },
    "*": { open: "(?:", close: ")*" },
    "@": { open: "(?:", close: ")" }
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter3;
  function filter3(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    b = b || {};
    var t = {};
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || typeof def !== "object" || !Object.keys(def).length) {
      return minimatch;
    }
    var orig = minimatch;
    var m = function minimatch2(p, pattern, options) {
      return orig(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    m.Minimatch.defaults = function defaults2(options) {
      return orig.defaults(ext(def, options)).Minimatch;
    };
    m.filter = function filter4(pattern, options) {
      return orig.filter(pattern, ext(def, options));
    };
    m.defaults = function defaults2(options) {
      return orig.defaults(ext(def, options));
    };
    m.makeRe = function makeRe2(pattern, options) {
      return orig.makeRe(pattern, ext(def, options));
    };
    m.braceExpand = function braceExpand2(pattern, options) {
      return orig.braceExpand(pattern, ext(def, options));
    };
    m.match = function(list, pattern, options) {
      return orig.match(list, pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    assertValidPattern(pattern);
    if (!options) options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    assertValidPattern(pattern);
    if (!options) options = {};
    pattern = pattern.trim();
    if (!options.allowWindowsEscape && path2.sep !== "/") {
      pattern = pattern.split(path2.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.partial = !!options.partial;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug) this.debug = function debug() {
      console.error.apply(console, arguments);
    };
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate) return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset) this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    assertValidPattern(pattern);
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
      return [pattern];
    }
    return expand(pattern);
  }
  var MAX_PATTERN_LENGTH = 1024 * 64;
  var assertValidPattern = function(pattern) {
    if (typeof pattern !== "string") {
      throw new TypeError("invalid pattern");
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
      throw new TypeError("pattern is too long");
    }
  };
  Minimatch.prototype.parse = parse2;
  var SUBPARSE = {};
  function parse2(pattern, isSub) {
    assertValidPattern(pattern);
    var options = this.options;
    if (pattern === "**") {
      if (!options.noglobstar)
        return GLOBSTAR;
      else
        pattern = "*";
    }
    if (pattern === "") return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        /* istanbul ignore next */
        case "/": {
          return false;
        }
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        // the various stateChar values
        // for the "extglob" stuff.
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1) c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext) clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        // these are mostly the same in regexp and glob
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp("[" + cs + "]");
          } catch (er) {
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue;
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case "[":
      case ".":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false) return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate) re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = function match(f, partial) {
    if (typeof partial === "undefined") partial = this.partial;
    this.debug("match", f, this.pattern);
    if (this.comment) return false;
    if (this.empty) return f === "";
    if (f === "/" && partial) return true;
    var options = this.options;
    if (path2.sep !== "/") {
      f = f.split(path2.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename) break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file2 = f;
      if (options.matchBase && pattern.length === 1) {
        file2 = [filename];
      }
      var hit = this.matchOne(file2, pattern, partial);
      if (hit) {
        if (options.flipNegate) return true;
        return !this.negate;
      }
    }
    if (options.flipNegate) return false;
    return this.negate;
  };
  Minimatch.prototype.matchOne = function(file2, pattern, partial) {
    var options = this.options;
    this.debug(
      "matchOne",
      { "this": this, file: file2, pattern }
    );
    this.debug("matchOne", file2.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file2.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file2[fi];
      this.debug(pattern, p, f);
      if (p === false) return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file2[fi] === "." || file2[fi] === ".." || !options.dot && file2[fi].charAt(0) === ".") return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file2[fr];
          this.debug("\nglobstar while", file2, fr, pattern, pr, swallowee);
          if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file2, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file2, fr, pattern, pr);
          if (fr === fl) return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        hit = f === p;
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit) return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      return fi === fl - 1 && file2[fi] === "";
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
  return minimatch_1;
}
var pathIsAbsolute = { exports: {} };
var hasRequiredPathIsAbsolute;
function requirePathIsAbsolute() {
  if (hasRequiredPathIsAbsolute) return pathIsAbsolute.exports;
  hasRequiredPathIsAbsolute = 1;
  function posix(path2) {
    return path2.charAt(0) === "/";
  }
  function win32(path2) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path2);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  pathIsAbsolute.exports = process.platform === "win32" ? win32 : posix;
  pathIsAbsolute.exports.posix = posix;
  pathIsAbsolute.exports.win32 = win32;
  return pathIsAbsolute.exports;
}
var common = {};
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common;
  hasRequiredCommon = 1;
  common.setopts = setopts;
  common.ownProp = ownProp;
  common.makeAbs = makeAbs;
  common.finish = finish;
  common.mark = mark;
  common.isIgnored = isIgnored;
  common.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var fs2 = require$$0$4;
  var path2 = require$$1;
  var minimatch = requireMinimatch();
  var isAbsolute = requirePathIsAbsolute();
  var Minimatch = minimatch.Minimatch;
  function alphasort(a, b) {
    return a.localeCompare(b, "en");
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, { dot: true });
    }
    return {
      matcher: new Minimatch(pattern, { dot: true }),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && -1 === pattern.indexOf("/")) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.fs = options.fs || fs2;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
    self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
    self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path2.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path2.resolve(self2.cwd, "/");
    self2.root = path2.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    options.allowWindowsEscape = false;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all3 = nou ? [] : /* @__PURE__ */ Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all3.push(literal);
          else
            all3[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all3.push.apply(all3, m);
        else
          m.forEach(function(m2) {
            all3[m2] = true;
          });
      }
    }
    if (!nou)
      all3 = Object.keys(all3);
    if (!self2.nosort)
      all3 = all3.sort(alphasort);
    if (self2.mark) {
      for (var i = 0; i < all3.length; i++) {
        all3[i] = self2._mark(all3[i]);
      }
      if (self2.nodir) {
        all3 = all3.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all3 = all3.filter(function(m2) {
        return !isIgnored(self2, m2);
      });
    self2.found = all3;
  }
  function mark(self2, p) {
    var abs2 = makeAbs(self2, p);
    var c = self2.cache[abs2];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs2];
        self2.cache[mabs] = self2.cache[abs2];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs2 = f;
    if (f.charAt(0) === "/") {
      abs2 = path2.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs2 = f;
    } else if (self2.changedCwd) {
      abs2 = path2.resolve(self2.cwd, f);
    } else {
      abs2 = path2.resolve(f);
    }
    if (process.platform === "win32")
      abs2 = abs2.replace(/\\/g, "/");
    return abs2;
  }
  function isIgnored(self2, path3) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path3) || !!(item.gmatcher && item.gmatcher.match(path3));
    });
  }
  function childrenIgnored(self2, path3) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path3));
    });
  }
  return common;
}
var sync;
var hasRequiredSync;
function requireSync() {
  if (hasRequiredSync) return sync;
  hasRequiredSync = 1;
  sync = globSync;
  globSync.GlobSync = GlobSync;
  var rp = requireFs_realpath();
  var minimatch = requireMinimatch();
  minimatch.Minimatch;
  requireGlob().Glob;
  var path2 = require$$1;
  var assert2 = require$$5;
  var isAbsolute = requirePathIsAbsolute();
  var common2 = requireCommon();
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert2.ok(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index2) {
        var set = self2.matches[index2] = /* @__PURE__ */ Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common2.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index2, inGlobStar) {
    assert2.ok(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join("/"), index2);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs2 = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs2, remain, index2, inGlobStar);
    else
      this._processReaddir(prefix, read, abs2, remain, index2, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs2, remain, index2, inGlobStar) {
    var entries = this._readdir(abs2, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index2, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index2, e) {
    if (isIgnored(this, e))
      return;
    var abs2 = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs2;
    }
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs2];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index2][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs2) {
    if (this.follow)
      return this._readdir(abs2, false);
    var entries;
    var lstat;
    try {
      lstat = this.fs.lstatSync(abs2);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs2] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs2] = "FILE";
    else
      entries = this._readdir(abs2, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs2, inGlobStar) {
    if (inGlobStar && !ownProp(this.symlinks, abs2))
      return this._readdirInGlobStar(abs2);
    if (ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs2, this.fs.readdirSync(abs2));
    } catch (er) {
      this._readdirError(abs2, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs2, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs2 === "/")
          e = abs2 + e;
        else
          e = abs2 + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs2] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      // https://github.com/isaacs/node-glob/issues/205
      case "ENOTDIR":
        var abs2 = this._makeAbs(f);
        this.cache[abs2] = "FILE";
        if (abs2 === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          throw error2;
        }
        break;
      case "ENOENT":
      // not terribly unusual
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs2, remain, index2, inGlobStar) {
    var entries = this._readdir(abs2, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false);
    var len = entries.length;
    var isSym = this.symlinks[abs2];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index2) {
    var exists = this._stat(prefix);
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs2 = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var stat = this.statCache[abs2];
    if (!stat) {
      var lstat;
      try {
        lstat = this.fs.lstatSync(abs2);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs2] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = this.fs.statSync(abs2);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs2] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs2] = this.cache[abs2] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  return sync;
}
var wrappy_1;
var hasRequiredWrappy;
function requireWrappy() {
  if (hasRequiredWrappy) return wrappy_1;
  hasRequiredWrappy = 1;
  wrappy_1 = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb) return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
  return wrappy_1;
}
var once = { exports: {} };
var hasRequiredOnce;
function requireOnce() {
  if (hasRequiredOnce) return once.exports;
  hasRequiredOnce = 1;
  var wrappy = requireWrappy();
  once.exports = wrappy(once$12);
  once.exports.strict = wrappy(onceStrict);
  once$12.proto = once$12(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once$12(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once$12(fn) {
    var f = function() {
      if (f.called) return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
  return once.exports;
}
var inflight_1;
var hasRequiredInflight;
function requireInflight() {
  if (hasRequiredInflight) return inflight_1;
  hasRequiredInflight = 1;
  var wrappy = requireWrappy();
  var reqs = /* @__PURE__ */ Object.create(null);
  var once2 = requireOnce();
  inflight_1 = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once2(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++) array[i] = args[i];
    return array;
  }
  return inflight_1;
}
var glob_1;
var hasRequiredGlob;
function requireGlob() {
  if (hasRequiredGlob) return glob_1;
  hasRequiredGlob = 1;
  glob_1 = glob;
  var rp = requireFs_realpath();
  var minimatch = requireMinimatch();
  minimatch.Minimatch;
  var inherits2 = requireInherits();
  var EE = require$$2$1.EventEmitter;
  var path2 = require$$1;
  var assert2 = require$$5;
  var isAbsolute = requirePathIsAbsolute();
  var globSync = requireSync();
  var common2 = requireCommon();
  var setopts = common2.setopts;
  var ownProp = common2.ownProp;
  var inflight = requireInflight();
  var childrenIgnored = common2.childrenIgnored;
  var isIgnored = common2.isIgnored;
  var once2 = requireOnce();
  function glob(pattern, options, cb) {
    if (typeof options === "function") cb = options, options = {};
    if (!options) options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend2(origin2, add) {
    if (add === null || typeof add !== "object") {
      return origin2;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin2[keys[i]] = add[keys[i]];
    }
    return origin2;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend2({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits2(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once2(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync2 = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync2 = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync2) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert2(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common2.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index2, cb) {
    var matchset = this.matches[index2];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index2] = /* @__PURE__ */ Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index2] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common2.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common2.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index2, inGlobStar, cb) {
    assert2(this instanceof Glob);
    assert2(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index2, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      // if not, then this is rather simple
      case pattern.length:
        this._processSimple(pattern.join("/"), index2, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
      return typeof p === "string" ? p : "[*]";
    }).join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs2 = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs2, remain, index2, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs2, remain, index2, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs2, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs2, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs2, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs2, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index2])
        this.matches[index2] = /* @__PURE__ */ Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path2.join(this.root, e);
        }
        this._emitMatch(index2, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index2, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index2, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index2, e]);
      return;
    }
    var abs2 = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs2;
    if (this.matches[index2][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs2];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index2][e] = true;
    var st = this.statCache[abs2];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs2, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs2, false, cb);
    var lstatkey = "lstat\0" + abs2;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      self2.fs.lstat(abs2, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs2] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs2] = "FILE";
        cb();
      } else
        self2._readdir(abs2, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs2, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs2 + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs2))
      return this._readdirInGlobStar(abs2, cb);
    if (ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    self2.fs.readdir(abs2, readdirCb(this, abs2, cb));
  };
  function readdirCb(self2, abs2, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs2, er, cb);
      else
        self2._readdirEntries(abs2, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs2, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs2 === "/")
          e = abs2 + e;
        else
          e = abs2 + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs2] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      // https://github.com/isaacs/node-glob/issues/205
      case "ENOTDIR":
        var abs2 = this._makeAbs(f);
        this.cache[abs2] = "FILE";
        if (abs2 === this.cwdAbs) {
          var error2 = new Error(er.code + " invalid cwd " + this.cwd);
          error2.path = this.cwd;
          error2.code = er.code;
          this.emit("error", error2);
          this.abort();
        }
        break;
      case "ENOENT":
      // not terribly unusual
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs2, remain, index2, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs2, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs2, remain, index2, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs2, remain, index2, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index2, false, cb);
    var isSym = this.symlinks[abs2];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index2, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index2, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index2, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index2, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index2, er, exists, cb) {
    if (!this.matches[index2])
      this.matches[index2] = /* @__PURE__ */ Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path2.join(this.root, prefix);
      } else {
        prefix = path2.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index2, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs2 = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs2)) {
      var c = this.cache[abs2];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var stat = this.statCache[abs2];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type2 = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type2 === "FILE")
          return cb();
        else
          return cb(null, type2, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs2, lstatcb_);
    if (statcb)
      self2.fs.lstat(abs2, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return self2.fs.stat(abs2, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs2, null, lstat, cb);
          else
            self2._stat2(f, abs2, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs2, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs2, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs2] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs2] = stat;
    if (abs2.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs2] = this.cache[abs2] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
  return glob_1;
}
var hasRequiredFile$1;
function requireFile$1() {
  if (hasRequiredFile$1) return file$1.exports;
  hasRequiredFile$1 = 1;
  var fs2 = requireGracefulFs();
  var path2 = require$$1;
  var flatten = requireLodash_flatten();
  var difference = requireLodash_difference();
  var union = requireLodash_union();
  var isPlainObject2 = requireLodash_isplainobject();
  var glob = requireGlob();
  var file2 = file$1.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file2.exists = function() {
    var filepath = path2.join.apply(path2, arguments);
    return fs2.existsSync(filepath);
  };
  file2.expand = function(...args) {
    var options = isPlainObject2(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path2.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs2.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file2.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path2.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file2.expand(options, patterns).forEach(function(src2) {
      var destPath = src2;
      if (options.flatten) {
        destPath = path2.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src2 = path2.join(options.cwd, src2);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src2 = src2.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src2);
      } else {
        files.push({
          src: [src2],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file2.normalizeFilesArray = function(data2) {
    var files = [];
    data2.forEach(function(obj) {
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file2.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src2;
            if (!("result" in fn)) {
              src2 = obj.src;
              src2 = Array.isArray(src2) ? flatten(src2) : [src2];
              fn.result = file2.expand(expandOptions, src2);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
  return file$1.exports;
}
var hasRequiredArchiverUtils$1;
function requireArchiverUtils$1() {
  if (hasRequiredArchiverUtils$1) return archiverUtils$1.exports;
  hasRequiredArchiverUtils$1 = 1;
  var fs2 = requireGracefulFs();
  var path2 = require$$1;
  var lazystream2 = requireLazystream();
  var normalizePath2 = requireNormalizePath();
  var defaults2 = requireLodash_defaults();
  var Stream = require$$0$1.Stream;
  var PassThrough = requireReadable$2().PassThrough;
  var utils2 = archiverUtils$1.exports = {};
  utils2.file = requireFile$1();
  utils2.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = new Buffer(size);
      var offset = 0;
      collection.forEach(function(data2) {
        data2.copy(buf, offset);
        offset += data2.length;
      });
      callback(null, buf);
    });
  };
  utils2.dateify = function(dateish) {
    dateish = dateish || /* @__PURE__ */ new Date();
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = /* @__PURE__ */ new Date();
    }
    return dateish;
  };
  utils2.defaults = function(object2, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults2(...args);
  };
  utils2.isStream = function(source) {
    return source instanceof Stream;
  };
  utils2.lazyReadStream = function(filepath) {
    return new lazystream2.Readable(function() {
      return fs2.createReadStream(filepath);
    });
  };
  utils2.normalizeInputSource = function(source) {
    if (source === null) {
      return new Buffer(0);
    } else if (typeof source === "string") {
      return new Buffer(source);
    } else if (utils2.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
  utils2.sanitizePath = function(filepath) {
    return normalizePath2(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils2.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils2.unixifyPath = function(filepath) {
    return normalizePath2(filepath, false).replace(/^\w+:/, "");
  };
  utils2.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs2.readdir(dirpath, function(err, list) {
      var i = 0;
      var file2;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file2 = list[i++];
        if (!file2) {
          return callback(null, results);
        }
        filepath = path2.join(dirpath, file2);
        fs2.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path2.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils2.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
  return archiverUtils$1.exports;
}
var error = { exports: {} };
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var hasRequiredError;
function requireError() {
  if (hasRequiredError) return error.exports;
  hasRequiredError = 1;
  (function(module, exports) {
    var util2 = require$$0$2;
    const ERROR_CODES = {
      "ABORTED": "archive was aborted",
      "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
      "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
      "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
      "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
      "FINALIZING": "archive already finalizing",
      "QUEUECLOSED": "queue closed",
      "NOENDMETHOD": "no suitable finalize/end method defined by module",
      "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
      "FORMATSET": "archive format already set",
      "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
      "MODULESET": "module already set",
      "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
      "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
      "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
      "ENTRYNOTSUPPORTED": "entry not supported"
    };
    function ArchiverError(code, data2) {
      Error.captureStackTrace(this, this.constructor);
      this.message = ERROR_CODES[code] || code;
      this.code = code;
      this.data = data2;
    }
    util2.inherits(ArchiverError, Error);
    module.exports = ArchiverError;
  })(error);
  return error.exports;
}
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var core;
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core;
  hasRequiredCore = 1;
  var fs2 = require$$0$4;
  var glob = requireReaddirGlob();
  var async2 = require$$2;
  var path2 = require$$1;
  var util2 = requireArchiverUtils$1();
  var inherits2 = require$$0$2.inherits;
  var ArchiverError = requireError();
  var Transform = requireReadable$4().Transform;
  var win32 = process.platform === "win32";
  var Archiver = function(format, options) {
    if (!(this instanceof Archiver)) {
      return new Archiver(format, options);
    }
    if (typeof format !== "string") {
      options = format;
      format = "zip";
    }
    options = this.options = util2.defaults(options, {
      highWaterMark: 1024 * 1024,
      statConcurrency: 4
    });
    Transform.call(this, options);
    this._format = false;
    this._module = false;
    this._pending = 0;
    this._pointer = 0;
    this._entriesCount = 0;
    this._entriesProcessedCount = 0;
    this._fsEntriesTotalBytes = 0;
    this._fsEntriesProcessedBytes = 0;
    this._queue = async2.queue(this._onQueueTask.bind(this), 1);
    this._queue.drain(this._onQueueDrain.bind(this));
    this._statQueue = async2.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
    this._statQueue.drain(this._onQueueDrain.bind(this));
    this._state = {
      aborted: false,
      finalize: false,
      finalizing: false,
      finalized: false,
      modulePiped: false
    };
    this._streams = [];
  };
  inherits2(Archiver, Transform);
  Archiver.prototype._abort = function() {
    this._state.aborted = true;
    this._queue.kill();
    this._statQueue.kill();
    if (this._queue.idle()) {
      this._shutdown();
    }
  };
  Archiver.prototype._append = function(filepath, data2) {
    data2 = data2 || {};
    var task = {
      source: null,
      filepath
    };
    if (!data2.name) {
      data2.name = filepath;
    }
    data2.sourcePath = filepath;
    task.data = data2;
    this._entriesCount++;
    if (data2.stats && data2.stats instanceof fs2.Stats) {
      task = this._updateQueueTaskWithStats(task, data2.stats);
      if (task) {
        if (data2.stats.size) {
          this._fsEntriesTotalBytes += data2.stats.size;
        }
        this._queue.push(task);
      }
    } else {
      this._statQueue.push(task);
    }
  };
  Archiver.prototype._finalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    this._state.finalizing = true;
    this._moduleFinalize();
    this._state.finalizing = false;
    this._state.finalized = true;
  };
  Archiver.prototype._maybeFinalize = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return false;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
      return true;
    }
    return false;
  };
  Archiver.prototype._moduleAppend = function(source, data2, callback) {
    if (this._state.aborted) {
      callback();
      return;
    }
    this._module.append(source, data2, (function(err) {
      this._task = null;
      if (this._state.aborted) {
        this._shutdown();
        return;
      }
      if (err) {
        this.emit("error", err);
        setImmediate(callback);
        return;
      }
      this.emit("entry", data2);
      this._entriesProcessedCount++;
      if (data2.stats && data2.stats.size) {
        this._fsEntriesProcessedBytes += data2.stats.size;
      }
      this.emit("progress", {
        entries: {
          total: this._entriesCount,
          processed: this._entriesProcessedCount
        },
        fs: {
          totalBytes: this._fsEntriesTotalBytes,
          processedBytes: this._fsEntriesProcessedBytes
        }
      });
      setImmediate(callback);
    }).bind(this));
  };
  Archiver.prototype._moduleFinalize = function() {
    if (typeof this._module.finalize === "function") {
      this._module.finalize();
    } else if (typeof this._module.end === "function") {
      this._module.end();
    } else {
      this.emit("error", new ArchiverError("NOENDMETHOD"));
    }
  };
  Archiver.prototype._modulePipe = function() {
    this._module.on("error", this._onModuleError.bind(this));
    this._module.pipe(this);
    this._state.modulePiped = true;
  };
  Archiver.prototype._moduleSupports = function(key) {
    if (!this._module.supports || !this._module.supports[key]) {
      return false;
    }
    return this._module.supports[key];
  };
  Archiver.prototype._moduleUnpipe = function() {
    this._module.unpipe(this);
    this._state.modulePiped = false;
  };
  Archiver.prototype._normalizeEntryData = function(data2, stats) {
    data2 = util2.defaults(data2, {
      type: "file",
      name: null,
      date: null,
      mode: null,
      prefix: null,
      sourcePath: null,
      stats: false
    });
    if (stats && data2.stats === false) {
      data2.stats = stats;
    }
    var isDir = data2.type === "directory";
    if (data2.name) {
      if (typeof data2.prefix === "string" && "" !== data2.prefix) {
        data2.name = data2.prefix + "/" + data2.name;
        data2.prefix = null;
      }
      data2.name = util2.sanitizePath(data2.name);
      if (data2.type !== "symlink" && data2.name.slice(-1) === "/") {
        isDir = true;
        data2.type = "directory";
      } else if (isDir) {
        data2.name += "/";
      }
    }
    if (typeof data2.mode === "number") {
      if (win32) {
        data2.mode &= 511;
      } else {
        data2.mode &= 4095;
      }
    } else if (data2.stats && data2.mode === null) {
      if (win32) {
        data2.mode = data2.stats.mode & 511;
      } else {
        data2.mode = data2.stats.mode & 4095;
      }
      if (win32 && isDir) {
        data2.mode = 493;
      }
    } else if (data2.mode === null) {
      data2.mode = isDir ? 493 : 420;
    }
    if (data2.stats && data2.date === null) {
      data2.date = data2.stats.mtime;
    } else {
      data2.date = util2.dateify(data2.date);
    }
    return data2;
  };
  Archiver.prototype._onModuleError = function(err) {
    this.emit("error", err);
  };
  Archiver.prototype._onQueueDrain = function() {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      return;
    }
    if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
  };
  Archiver.prototype._onQueueTask = function(task, callback) {
    var fullCallback = () => {
      if (task.data.callback) {
        task.data.callback();
      }
      callback();
    };
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      fullCallback();
      return;
    }
    this._task = task;
    this._moduleAppend(task.source, task.data, fullCallback);
  };
  Archiver.prototype._onStatQueueTask = function(task, callback) {
    if (this._state.finalizing || this._state.finalized || this._state.aborted) {
      callback();
      return;
    }
    fs2.lstat(task.filepath, (function(err, stats) {
      if (this._state.aborted) {
        setImmediate(callback);
        return;
      }
      if (err) {
        this._entriesCount--;
        this.emit("warning", err);
        setImmediate(callback);
        return;
      }
      task = this._updateQueueTaskWithStats(task, stats);
      if (task) {
        if (stats.size) {
          this._fsEntriesTotalBytes += stats.size;
        }
        this._queue.push(task);
      }
      setImmediate(callback);
    }).bind(this));
  };
  Archiver.prototype._shutdown = function() {
    this._moduleUnpipe();
    this.end();
  };
  Archiver.prototype._transform = function(chunk, encoding, callback) {
    if (chunk) {
      this._pointer += chunk.length;
    }
    callback(null, chunk);
  };
  Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
    if (stats.isFile()) {
      task.data.type = "file";
      task.data.sourceType = "stream";
      task.source = util2.lazyReadStream(task.filepath);
    } else if (stats.isDirectory() && this._moduleSupports("directory")) {
      task.data.name = util2.trailingSlashIt(task.data.name);
      task.data.type = "directory";
      task.data.sourcePath = util2.trailingSlashIt(task.filepath);
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
      var linkPath = fs2.readlinkSync(task.filepath);
      var dirName = path2.dirname(task.filepath);
      task.data.type = "symlink";
      task.data.linkname = path2.relative(dirName, path2.resolve(dirName, linkPath));
      task.data.sourceType = "buffer";
      task.source = Buffer.concat([]);
    } else {
      if (stats.isDirectory()) {
        this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
      } else if (stats.isSymbolicLink()) {
        this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
      } else {
        this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
      }
      return null;
    }
    task.data = this._normalizeEntryData(task.data, stats);
    return task;
  };
  Archiver.prototype.abort = function() {
    if (this._state.aborted || this._state.finalized) {
      return this;
    }
    this._abort();
    return this;
  };
  Archiver.prototype.append = function(source, data2) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    data2 = this._normalizeEntryData(data2);
    if (typeof data2.name !== "string" || data2.name.length === 0) {
      this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
      return this;
    }
    if (data2.type === "directory" && !this._moduleSupports("directory")) {
      this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data2.name }));
      return this;
    }
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      data2.sourceType = "buffer";
    } else if (util2.isStream(source)) {
      data2.sourceType = "stream";
    } else {
      this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data2.name }));
      return this;
    }
    this._entriesCount++;
    this._queue.push({
      data: data2,
      source
    });
    return this;
  };
  Archiver.prototype.directory = function(dirpath, destpath, data2) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof dirpath !== "string" || dirpath.length === 0) {
      this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
      return this;
    }
    this._pending++;
    if (destpath === false) {
      destpath = "";
    } else if (typeof destpath !== "string") {
      destpath = dirpath;
    }
    var dataFunction = false;
    if (typeof data2 === "function") {
      dataFunction = data2;
      data2 = {};
    } else if (typeof data2 !== "object") {
      data2 = {};
    }
    var globOptions = {
      stat: true,
      dot: true
    };
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var ignoreMatch = false;
      var entryData = Object.assign({}, data2);
      entryData.name = match.relative;
      entryData.prefix = destpath;
      entryData.stats = match.stat;
      entryData.callback = globber.resume.bind(globber);
      try {
        if (dataFunction) {
          entryData = dataFunction(entryData);
          if (entryData === false) {
            ignoreMatch = true;
          } else if (typeof entryData !== "object") {
            throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
          }
        }
      } catch (e) {
        this.emit("error", e);
        return;
      }
      if (ignoreMatch) {
        globber.resume();
        return;
      }
      this._append(match.absolute, entryData);
    }
    var globber = glob(dirpath, globOptions);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.file = function(filepath, data2) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
      return this;
    }
    this._append(filepath, data2);
    return this;
  };
  Archiver.prototype.glob = function(pattern, options, data2) {
    this._pending++;
    options = util2.defaults(options, {
      stat: true,
      pattern
    });
    function onGlobEnd() {
      this._pending--;
      this._maybeFinalize();
    }
    function onGlobError(err) {
      this.emit("error", err);
    }
    function onGlobMatch(match) {
      globber.pause();
      var entryData = Object.assign({}, data2);
      entryData.callback = globber.resume.bind(globber);
      entryData.stats = match.stat;
      entryData.name = match.relative;
      this._append(match.absolute, entryData);
    }
    var globber = glob(options.cwd || ".", options);
    globber.on("error", onGlobError.bind(this));
    globber.on("match", onGlobMatch.bind(this));
    globber.on("end", onGlobEnd.bind(this));
    return this;
  };
  Archiver.prototype.finalize = function() {
    if (this._state.aborted) {
      var abortedError = new ArchiverError("ABORTED");
      this.emit("error", abortedError);
      return Promise.reject(abortedError);
    }
    if (this._state.finalize) {
      var finalizingError = new ArchiverError("FINALIZING");
      this.emit("error", finalizingError);
      return Promise.reject(finalizingError);
    }
    this._state.finalize = true;
    if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
      this._finalize();
    }
    var self2 = this;
    return new Promise(function(resolve, reject2) {
      var errored;
      self2._module.on("end", function() {
        if (!errored) {
          resolve();
        }
      });
      self2._module.on("error", function(err) {
        errored = true;
        reject2(err);
      });
    });
  };
  Archiver.prototype.setFormat = function(format) {
    if (this._format) {
      this.emit("error", new ArchiverError("FORMATSET"));
      return this;
    }
    this._format = format;
    return this;
  };
  Archiver.prototype.setModule = function(module) {
    if (this._state.aborted) {
      this.emit("error", new ArchiverError("ABORTED"));
      return this;
    }
    if (this._state.module) {
      this.emit("error", new ArchiverError("MODULESET"));
      return this;
    }
    this._module = module;
    this._modulePipe();
    return this;
  };
  Archiver.prototype.symlink = function(filepath, target, mode) {
    if (this._state.finalize || this._state.aborted) {
      this.emit("error", new ArchiverError("QUEUECLOSED"));
      return this;
    }
    if (typeof filepath !== "string" || filepath.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
      return this;
    }
    if (typeof target !== "string" || target.length === 0) {
      this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
      return this;
    }
    if (!this._moduleSupports("symlink")) {
      this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
      return this;
    }
    var data2 = {};
    data2.type = "symlink";
    data2.name = filepath.replace(/\\/g, "/");
    data2.linkname = target.replace(/\\/g, "/");
    data2.sourceType = "buffer";
    if (typeof mode === "number") {
      data2.mode = mode;
    }
    this._entriesCount++;
    this._queue.push({
      data: data2,
      source: Buffer.concat([])
    });
    return this;
  };
  Archiver.prototype.pointer = function() {
    return this._pointer;
  };
  Archiver.prototype.use = function(plugin) {
    this._streams.push(plugin);
    return this;
  };
  core = Archiver;
  return core;
}
var zipStream = { exports: {} };
var archiveEntry = { exports: {} };
var hasRequiredArchiveEntry;
function requireArchiveEntry() {
  if (hasRequiredArchiveEntry) return archiveEntry.exports;
  hasRequiredArchiveEntry = 1;
  var ArchiveEntry = archiveEntry.exports = function() {
  };
  ArchiveEntry.prototype.getName = function() {
  };
  ArchiveEntry.prototype.getSize = function() {
  };
  ArchiveEntry.prototype.getLastModifiedDate = function() {
  };
  ArchiveEntry.prototype.isDirectory = function() {
  };
  return archiveEntry.exports;
}
var zipArchiveEntry = { exports: {} };
var generalPurposeBit = { exports: {} };
var util$4 = { exports: {} };
var hasRequiredUtil$4;
function requireUtil$4() {
  if (hasRequiredUtil$4) return util$4.exports;
  hasRequiredUtil$4 = 1;
  var util2 = util$4.exports = {};
  util2.dateToDos = function(d, forceLocalTime) {
    forceLocalTime = forceLocalTime || false;
    var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
    if (year < 1980) {
      return 2162688;
    } else if (year >= 2044) {
      return 2141175677;
    }
    var val = {
      year,
      month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
      date: forceLocalTime ? d.getDate() : d.getUTCDate(),
      hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
      minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
      seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
    };
    return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
  };
  util2.dosToDate = function(dos) {
    return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
  };
  util2.fromDosTime = function(buf) {
    return util2.dosToDate(buf.readUInt32LE(0));
  };
  util2.getEightBytes = function(v) {
    var buf = Buffer.alloc(8);
    buf.writeUInt32LE(v % 4294967296, 0);
    buf.writeUInt32LE(v / 4294967296 | 0, 4);
    return buf;
  };
  util2.getShortBytes = function(v) {
    var buf = Buffer.alloc(2);
    buf.writeUInt16LE((v & 65535) >>> 0, 0);
    return buf;
  };
  util2.getShortBytesValue = function(buf, offset) {
    return buf.readUInt16LE(offset);
  };
  util2.getLongBytes = function(v) {
    var buf = Buffer.alloc(4);
    buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
    return buf;
  };
  util2.getLongBytesValue = function(buf, offset) {
    return buf.readUInt32LE(offset);
  };
  util2.toDosTime = function(d) {
    return util2.getLongBytes(util2.dateToDos(d));
  };
  return util$4.exports;
}
var hasRequiredGeneralPurposeBit;
function requireGeneralPurposeBit() {
  if (hasRequiredGeneralPurposeBit) return generalPurposeBit.exports;
  hasRequiredGeneralPurposeBit = 1;
  var zipUtil = requireUtil$4();
  var DATA_DESCRIPTOR_FLAG = 1 << 3;
  var ENCRYPTION_FLAG = 1 << 0;
  var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
  var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
  var STRONG_ENCRYPTION_FLAG = 1 << 6;
  var UFT8_NAMES_FLAG = 1 << 11;
  var GeneralPurposeBit = generalPurposeBit.exports = function() {
    if (!(this instanceof GeneralPurposeBit)) {
      return new GeneralPurposeBit();
    }
    this.descriptor = false;
    this.encryption = false;
    this.utf8 = false;
    this.numberOfShannonFanoTrees = 0;
    this.strongEncryption = false;
    this.slidingDictionarySize = 0;
    return this;
  };
  GeneralPurposeBit.prototype.encode = function() {
    return zipUtil.getShortBytes(
      (this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0)
    );
  };
  GeneralPurposeBit.prototype.parse = function(buf, offset) {
    var flag = zipUtil.getShortBytesValue(buf, offset);
    var gbp = new GeneralPurposeBit();
    gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
    gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
    gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
    gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
    gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
    gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
    return gbp;
  };
  GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
    this.numberOfShannonFanoTrees = n;
  };
  GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
    return this.numberOfShannonFanoTrees;
  };
  GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
    this.slidingDictionarySize = n;
  };
  GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
    return this.slidingDictionarySize;
  };
  GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
    this.descriptor = b;
  };
  GeneralPurposeBit.prototype.usesDataDescriptor = function() {
    return this.descriptor;
  };
  GeneralPurposeBit.prototype.useEncryption = function(b) {
    this.encryption = b;
  };
  GeneralPurposeBit.prototype.usesEncryption = function() {
    return this.encryption;
  };
  GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
    this.strongEncryption = b;
  };
  GeneralPurposeBit.prototype.usesStrongEncryption = function() {
    return this.strongEncryption;
  };
  GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
    this.utf8 = b;
  };
  GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
    return this.utf8;
  };
  return generalPurposeBit.exports;
}
var unixStat;
var hasRequiredUnixStat;
function requireUnixStat() {
  if (hasRequiredUnixStat) return unixStat;
  hasRequiredUnixStat = 1;
  unixStat = {
    /**
     * Bits used for permissions (and sticky bit)
     */
    PERM_MASK: 4095,
    // 07777
    /**
     * Bits used to indicate the filesystem object type.
     */
    FILE_TYPE_FLAG: 61440,
    // 0170000
    /**
     * Indicates symbolic links.
     */
    LINK_FLAG: 40960,
    // 0120000
    /**
     * Indicates plain files.
     */
    FILE_FLAG: 32768,
    // 0100000
    /**
     * Indicates directories.
     */
    DIR_FLAG: 16384,
    // 040000
    // ----------------------------------------------------------
    // somewhat arbitrary choices that are quite common for shared
    // installations
    // -----------------------------------------------------------
    /**
     * Default permissions for symbolic links.
     */
    DEFAULT_LINK_PERM: 511,
    // 0777
    /**
     * Default permissions for directories.
     */
    DEFAULT_DIR_PERM: 493,
    // 0755
    /**
     * Default permissions for plain files.
     */
    DEFAULT_FILE_PERM: 420
    // 0644
  };
  return unixStat;
}
var constants;
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants) return constants;
  hasRequiredConstants = 1;
  constants = {
    WORD: 4,
    DWORD: 8,
    EMPTY: Buffer.alloc(0),
    SHORT: 2,
    SHORT_MASK: 65535,
    SHORT_SHIFT: 16,
    SHORT_ZERO: Buffer.from(Array(2)),
    LONG: 4,
    LONG_ZERO: Buffer.from(Array(4)),
    MIN_VERSION_INITIAL: 10,
    MIN_VERSION_DATA_DESCRIPTOR: 20,
    MIN_VERSION_ZIP64: 45,
    VERSION_MADEBY: 45,
    METHOD_STORED: 0,
    METHOD_DEFLATED: 8,
    PLATFORM_UNIX: 3,
    PLATFORM_FAT: 0,
    SIG_LFH: 67324752,
    SIG_DD: 134695760,
    SIG_CFH: 33639248,
    SIG_EOCD: 101010256,
    SIG_ZIP64_EOCD: 101075792,
    SIG_ZIP64_EOCD_LOC: 117853008,
    ZIP64_MAGIC_SHORT: 65535,
    ZIP64_MAGIC: 4294967295,
    ZIP64_EXTRA_ID: 1,
    ZLIB_NO_COMPRESSION: 0,
    ZLIB_BEST_SPEED: 1,
    ZLIB_BEST_COMPRESSION: 9,
    ZLIB_DEFAULT_COMPRESSION: -1,
    MODE_MASK: 4095,
    DEFAULT_FILE_MODE: 33188,
    // 010644 = -rw-r--r-- = S_IFREG | S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH
    DEFAULT_DIR_MODE: 16877,
    // 040755 = drwxr-xr-x = S_IFDIR | S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH
    EXT_FILE_ATTR_DIR: 1106051088,
    // 010173200020 = drwxr-xr-x = (((S_IFDIR | 0755) << 16) | S_DOS_D)
    EXT_FILE_ATTR_FILE: 2175008800,
    // 020151000040 = -rw-r--r-- = (((S_IFREG | 0644) << 16) | S_DOS_A) >>> 0
    // Unix file types
    S_IFMT: 61440,
    // 0170000 type of file mask
    S_IFIFO: 4096,
    // 010000 named pipe (fifo)
    S_IFCHR: 8192,
    // 020000 character special
    S_IFDIR: 16384,
    // 040000 directory
    S_IFBLK: 24576,
    // 060000 block special
    S_IFREG: 32768,
    // 0100000 regular
    S_IFLNK: 40960,
    // 0120000 symbolic link
    S_IFSOCK: 49152,
    // 0140000 socket
    // DOS file type flags
    S_DOS_A: 32,
    // 040 Archive
    S_DOS_D: 16,
    // 020 Directory
    S_DOS_V: 8,
    // 010 Volume
    S_DOS_S: 4,
    // 04 System
    S_DOS_H: 2,
    // 02 Hidden
    S_DOS_R: 1
    // 01 Read Only
  };
  return constants;
}
var hasRequiredZipArchiveEntry;
function requireZipArchiveEntry() {
  if (hasRequiredZipArchiveEntry) return zipArchiveEntry.exports;
  hasRequiredZipArchiveEntry = 1;
  var inherits2 = require$$0$2.inherits;
  var normalizePath2 = requireNormalizePath();
  var ArchiveEntry = requireArchiveEntry();
  var GeneralPurposeBit = requireGeneralPurposeBit();
  var UnixStat = requireUnixStat();
  var constants2 = requireConstants();
  var zipUtil = requireUtil$4();
  var ZipArchiveEntry = zipArchiveEntry.exports = function(name) {
    if (!(this instanceof ZipArchiveEntry)) {
      return new ZipArchiveEntry(name);
    }
    ArchiveEntry.call(this);
    this.platform = constants2.PLATFORM_FAT;
    this.method = -1;
    this.name = null;
    this.size = 0;
    this.csize = 0;
    this.gpb = new GeneralPurposeBit();
    this.crc = 0;
    this.time = -1;
    this.minver = constants2.MIN_VERSION_INITIAL;
    this.mode = -1;
    this.extra = null;
    this.exattr = 0;
    this.inattr = 0;
    this.comment = null;
    if (name) {
      this.setName(name);
    }
  };
  inherits2(ZipArchiveEntry, ArchiveEntry);
  ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getComment = function() {
    return this.comment !== null ? this.comment : "";
  };
  ZipArchiveEntry.prototype.getCompressedSize = function() {
    return this.csize;
  };
  ZipArchiveEntry.prototype.getCrc = function() {
    return this.crc;
  };
  ZipArchiveEntry.prototype.getExternalAttributes = function() {
    return this.exattr;
  };
  ZipArchiveEntry.prototype.getExtra = function() {
    return this.extra !== null ? this.extra : constants2.EMPTY;
  };
  ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
    return this.gpb;
  };
  ZipArchiveEntry.prototype.getInternalAttributes = function() {
    return this.inattr;
  };
  ZipArchiveEntry.prototype.getLastModifiedDate = function() {
    return this.getTime();
  };
  ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
    return this.getExtra();
  };
  ZipArchiveEntry.prototype.getMethod = function() {
    return this.method;
  };
  ZipArchiveEntry.prototype.getName = function() {
    return this.name;
  };
  ZipArchiveEntry.prototype.getPlatform = function() {
    return this.platform;
  };
  ZipArchiveEntry.prototype.getSize = function() {
    return this.size;
  };
  ZipArchiveEntry.prototype.getTime = function() {
    return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
  };
  ZipArchiveEntry.prototype.getTimeDos = function() {
    return this.time !== -1 ? this.time : 0;
  };
  ZipArchiveEntry.prototype.getUnixMode = function() {
    return this.platform !== constants2.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants2.SHORT_SHIFT & constants2.SHORT_MASK;
  };
  ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
    return this.minver;
  };
  ZipArchiveEntry.prototype.setComment = function(comment) {
    if (Buffer.byteLength(comment) !== comment.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.comment = comment;
  };
  ZipArchiveEntry.prototype.setCompressedSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry compressed size");
    }
    this.csize = size;
  };
  ZipArchiveEntry.prototype.setCrc = function(crc) {
    if (crc < 0) {
      throw new Error("invalid entry crc32");
    }
    this.crc = crc;
  };
  ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
    this.exattr = attr >>> 0;
  };
  ZipArchiveEntry.prototype.setExtra = function(extra) {
    this.extra = extra;
  };
  ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
    if (!(gpb instanceof GeneralPurposeBit)) {
      throw new Error("invalid entry GeneralPurposeBit");
    }
    this.gpb = gpb;
  };
  ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
    this.inattr = attr;
  };
  ZipArchiveEntry.prototype.setMethod = function(method2) {
    if (method2 < 0) {
      throw new Error("invalid entry compression method");
    }
    this.method = method2;
  };
  ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
    name = normalizePath2(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    if (prependSlash) {
      name = `/${name}`;
    }
    if (Buffer.byteLength(name) !== name.length) {
      this.getGeneralPurposeBit().useUTF8ForNames(true);
    }
    this.name = name;
  };
  ZipArchiveEntry.prototype.setPlatform = function(platform2) {
    this.platform = platform2;
  };
  ZipArchiveEntry.prototype.setSize = function(size) {
    if (size < 0) {
      throw new Error("invalid entry size");
    }
    this.size = size;
  };
  ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
    if (!(time instanceof Date)) {
      throw new Error("invalid entry time");
    }
    this.time = zipUtil.dateToDos(time, forceLocalTime);
  };
  ZipArchiveEntry.prototype.setUnixMode = function(mode) {
    mode |= this.isDirectory() ? constants2.S_IFDIR : constants2.S_IFREG;
    var extattr = 0;
    extattr |= mode << constants2.SHORT_SHIFT | (this.isDirectory() ? constants2.S_DOS_D : constants2.S_DOS_A);
    this.setExternalAttributes(extattr);
    this.mode = mode & constants2.MODE_MASK;
    this.platform = constants2.PLATFORM_UNIX;
  };
  ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
    this.minver = minver;
  };
  ZipArchiveEntry.prototype.isDirectory = function() {
    return this.getName().slice(-1) === "/";
  };
  ZipArchiveEntry.prototype.isUnixSymlink = function() {
    return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
  };
  ZipArchiveEntry.prototype.isZip64 = function() {
    return this.csize > constants2.ZIP64_MAGIC || this.size > constants2.ZIP64_MAGIC;
  };
  return zipArchiveEntry.exports;
}
var archiveOutputStream = { exports: {} };
var util$3 = { exports: {} };
var hasRequiredUtil$3;
function requireUtil$3() {
  if (hasRequiredUtil$3) return util$3.exports;
  hasRequiredUtil$3 = 1;
  var Stream = require$$0$1.Stream;
  var PassThrough = requireReadable$4().PassThrough;
  var util2 = util$3.exports = {};
  util2.isStream = function(source) {
    return source instanceof Stream;
  };
  util2.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (util2.isStream(source) && !source._readableState) {
      var normalized = new PassThrough();
      source.pipe(normalized);
      return normalized;
    }
    return source;
  };
  return util$3.exports;
}
var hasRequiredArchiveOutputStream;
function requireArchiveOutputStream() {
  if (hasRequiredArchiveOutputStream) return archiveOutputStream.exports;
  hasRequiredArchiveOutputStream = 1;
  var inherits2 = require$$0$2.inherits;
  var Transform = requireReadable$4().Transform;
  var ArchiveEntry = requireArchiveEntry();
  var util2 = requireUtil$3();
  var ArchiveOutputStream = archiveOutputStream.exports = function(options) {
    if (!(this instanceof ArchiveOutputStream)) {
      return new ArchiveOutputStream(options);
    }
    Transform.call(this, options);
    this.offset = 0;
    this._archive = {
      finish: false,
      finished: false,
      processing: false
    };
  };
  inherits2(ArchiveOutputStream, Transform);
  ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
  };
  ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
    if (err) {
      this.emit("error", err);
    }
  };
  ArchiveOutputStream.prototype._finish = function(ae) {
  };
  ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
  };
  ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
    source = source || null;
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    if (!(ae instanceof ArchiveEntry)) {
      callback(new Error("not a valid instance of ArchiveEntry"));
      return;
    }
    if (this._archive.finish || this._archive.finished) {
      callback(new Error("unacceptable entry after finish"));
      return;
    }
    if (this._archive.processing) {
      callback(new Error("already processing an entry"));
      return;
    }
    this._archive.processing = true;
    this._normalizeEntry(ae);
    this._entry = ae;
    source = util2.normalizeInputSource(source);
    if (Buffer.isBuffer(source)) {
      this._appendBuffer(ae, source, callback);
    } else if (util2.isStream(source)) {
      this._appendStream(ae, source, callback);
    } else {
      this._archive.processing = false;
      callback(new Error("input source must be valid Stream or Buffer instance"));
      return;
    }
    return this;
  };
  ArchiveOutputStream.prototype.finish = function() {
    if (this._archive.processing) {
      this._archive.finish = true;
      return;
    }
    this._finish();
  };
  ArchiveOutputStream.prototype.getBytesWritten = function() {
    return this.offset;
  };
  ArchiveOutputStream.prototype.write = function(chunk, cb) {
    if (chunk) {
      this.offset += chunk.length;
    }
    return Transform.prototype.write.call(this, chunk, cb);
  };
  return archiveOutputStream.exports;
}
var zipArchiveOutputStream = { exports: {} };
var bufferCrc32;
var hasRequiredBufferCrc32;
function requireBufferCrc32() {
  if (hasRequiredBufferCrc32) return bufferCrc32;
  hasRequiredBufferCrc32 = 1;
  var Buffer2 = require$$0$7.Buffer;
  var CRC_TABLE = [
    0,
    1996959894,
    3993919788,
    2567524794,
    124634137,
    1886057615,
    3915621685,
    2657392035,
    249268274,
    2044508324,
    3772115230,
    2547177864,
    162941995,
    2125561021,
    3887607047,
    2428444049,
    498536548,
    1789927666,
    4089016648,
    2227061214,
    450548861,
    1843258603,
    4107580753,
    2211677639,
    325883990,
    1684777152,
    4251122042,
    2321926636,
    335633487,
    1661365465,
    4195302755,
    2366115317,
    997073096,
    1281953886,
    3579855332,
    2724688242,
    1006888145,
    1258607687,
    3524101629,
    2768942443,
    901097722,
    1119000684,
    3686517206,
    2898065728,
    853044451,
    1172266101,
    3705015759,
    2882616665,
    651767980,
    1373503546,
    3369554304,
    3218104598,
    565507253,
    1454621731,
    3485111705,
    3099436303,
    671266974,
    1594198024,
    3322730930,
    2970347812,
    795835527,
    1483230225,
    3244367275,
    3060149565,
    1994146192,
    31158534,
    2563907772,
    4023717930,
    1907459465,
    112637215,
    2680153253,
    3904427059,
    2013776290,
    251722036,
    2517215374,
    3775830040,
    2137656763,
    141376813,
    2439277719,
    3865271297,
    1802195444,
    476864866,
    2238001368,
    4066508878,
    1812370925,
    453092731,
    2181625025,
    4111451223,
    1706088902,
    314042704,
    2344532202,
    4240017532,
    1658658271,
    366619977,
    2362670323,
    4224994405,
    1303535960,
    984961486,
    2747007092,
    3569037538,
    1256170817,
    1037604311,
    2765210733,
    3554079995,
    1131014506,
    879679996,
    2909243462,
    3663771856,
    1141124467,
    855842277,
    2852801631,
    3708648649,
    1342533948,
    654459306,
    3188396048,
    3373015174,
    1466479909,
    544179635,
    3110523913,
    3462522015,
    1591671054,
    702138776,
    2966460450,
    3352799412,
    1504918807,
    783551873,
    3082640443,
    3233442989,
    3988292384,
    2596254646,
    62317068,
    1957810842,
    3939845945,
    2647816111,
    81470997,
    1943803523,
    3814918930,
    2489596804,
    225274430,
    2053790376,
    3826175755,
    2466906013,
    167816743,
    2097651377,
    4027552580,
    2265490386,
    503444072,
    1762050814,
    4150417245,
    2154129355,
    426522225,
    1852507879,
    4275313526,
    2312317920,
    282753626,
    1742555852,
    4189708143,
    2394877945,
    397917763,
    1622183637,
    3604390888,
    2714866558,
    953729732,
    1340076626,
    3518719985,
    2797360999,
    1068828381,
    1219638859,
    3624741850,
    2936675148,
    906185462,
    1090812512,
    3747672003,
    2825379669,
    829329135,
    1181335161,
    3412177804,
    3160834842,
    628085408,
    1382605366,
    3423369109,
    3138078467,
    570562233,
    1426400815,
    3317316542,
    2998733608,
    733239954,
    1555261956,
    3268935591,
    3050360625,
    752459403,
    1541320221,
    2607071920,
    3965973030,
    1969922972,
    40735498,
    2617837225,
    3943577151,
    1913087877,
    83908371,
    2512341634,
    3803740692,
    2075208622,
    213261112,
    2463272603,
    3855990285,
    2094854071,
    198958881,
    2262029012,
    4057260610,
    1759359992,
    534414190,
    2176718541,
    4139329115,
    1873836001,
    414664567,
    2282248934,
    4279200368,
    1711684554,
    285281116,
    2405801727,
    4167216745,
    1634467795,
    376229701,
    2685067896,
    3608007406,
    1308918612,
    956543938,
    2808555105,
    3495958263,
    1231636301,
    1047427035,
    2932959818,
    3654703836,
    1088359270,
    936918e3,
    2847714899,
    3736837829,
    1202900863,
    817233897,
    3183342108,
    3401237130,
    1404277552,
    615818150,
    3134207493,
    3453421203,
    1423857449,
    601450431,
    3009837614,
    3294710456,
    1567103746,
    711928724,
    3020668471,
    3272380065,
    1510334235,
    755167117
  ];
  if (typeof Int32Array !== "undefined") {
    CRC_TABLE = new Int32Array(CRC_TABLE);
  }
  function ensureBuffer(input) {
    if (Buffer2.isBuffer(input)) {
      return input;
    }
    var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
    if (typeof input === "number") {
      return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
    } else if (typeof input === "string") {
      return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
    } else {
      throw new Error("input must be buffer, number, or string, received " + typeof input);
    }
  }
  function bufferizeInt(num) {
    var tmp2 = ensureBuffer(4);
    tmp2.writeInt32BE(num, 0);
    return tmp2;
  }
  function _crc32(buf, previous) {
    buf = ensureBuffer(buf);
    if (Buffer2.isBuffer(previous)) {
      previous = previous.readUInt32BE(0);
    }
    var crc = ~~previous ^ -1;
    for (var n = 0; n < buf.length; n++) {
      crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
    }
    return crc ^ -1;
  }
  function crc322() {
    return bufferizeInt(_crc32.apply(null, arguments));
  }
  crc322.signed = function() {
    return _crc32.apply(null, arguments);
  };
  crc322.unsigned = function() {
    return _crc32.apply(null, arguments) >>> 0;
  };
  bufferCrc32 = crc322;
  return bufferCrc32;
}
var crc32 = {};
/*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
var hasRequiredCrc32;
function requireCrc32() {
  if (hasRequiredCrc32) return crc32;
  hasRequiredCrc32 = 1;
  (function(exports) {
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        {
          factory(exports);
        }
      } else {
        factory({});
      }
    })(function(CRC32) {
      CRC32.version = "1.2.2";
      function signed_crc_table() {
        var c = 0, table2 = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table2[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table2) : table2;
      }
      var T0 = signed_crc_table();
      function slice_by_16_tables(T) {
        var c = 0, v = 0, n = 0, table2 = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
        for (n = 0; n != 256; ++n) table2[n] = T[n];
        for (n = 0; n != 256; ++n) {
          v = T[n];
          for (c = 256 + n; c < 4096; c += 256) v = table2[c] = v >>> 8 ^ T[v & 255];
        }
        var out = [];
        for (n = 1; n != 16; ++n) out[n - 1] = typeof Int32Array !== "undefined" ? table2.subarray(n * 256, n * 256 + 256) : table2.slice(n * 256, n * 256 + 256);
        return out;
      }
      var TT = slice_by_16_tables(T0);
      var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
      var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
      var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = bstr.length; i < L; ) C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
        return ~C;
      }
      function crc32_buf(B, seed) {
        var C = seed ^ -1, L = B.length - 15, i = 0;
        for (; i < L; ) C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
        L += 15;
        while (i < L) C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
        return ~C;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c = 0, d = 0; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T0[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
          }
        }
        return ~C;
      }
      CRC32.table = T0;
      CRC32.bstr = crc32_bstr;
      CRC32.buf = crc32_buf;
      CRC32.str = crc32_str;
    });
  })(crc32);
  return crc32;
}
var crc32Stream;
var hasRequiredCrc32Stream;
function requireCrc32Stream() {
  if (hasRequiredCrc32Stream) return crc32Stream;
  hasRequiredCrc32Stream = 1;
  const { Transform } = requireReadable$4();
  const crc322 = requireCrc32();
  class CRC32Stream extends Transform {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc322.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      callback(null, chunk);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size() {
      return this.rawSize;
    }
  }
  crc32Stream = CRC32Stream;
  return crc32Stream;
}
var deflateCrc32Stream;
var hasRequiredDeflateCrc32Stream;
function requireDeflateCrc32Stream() {
  if (hasRequiredDeflateCrc32Stream) return deflateCrc32Stream;
  hasRequiredDeflateCrc32Stream = 1;
  const { DeflateRaw } = zlib;
  const crc322 = requireCrc32();
  class DeflateCRC32Stream extends DeflateRaw {
    constructor(options) {
      super(options);
      this.checksum = Buffer.allocUnsafe(4);
      this.checksum.writeInt32BE(0, 0);
      this.rawSize = 0;
      this.compressedSize = 0;
    }
    push(chunk, encoding) {
      if (chunk) {
        this.compressedSize += chunk.length;
      }
      return super.push(chunk, encoding);
    }
    _transform(chunk, encoding, callback) {
      if (chunk) {
        this.checksum = crc322.buf(chunk, this.checksum) >>> 0;
        this.rawSize += chunk.length;
      }
      super._transform(chunk, encoding, callback);
    }
    digest(encoding) {
      const checksum = Buffer.allocUnsafe(4);
      checksum.writeUInt32BE(this.checksum >>> 0, 0);
      return encoding ? checksum.toString(encoding) : checksum;
    }
    hex() {
      return this.digest("hex").toUpperCase();
    }
    size(compressed = false) {
      if (compressed) {
        return this.compressedSize;
      } else {
        return this.rawSize;
      }
    }
  }
  deflateCrc32Stream = DeflateCRC32Stream;
  return deflateCrc32Stream;
}
var lib;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib;
  hasRequiredLib = 1;
  lib = {
    CRC32Stream: requireCrc32Stream(),
    DeflateCRC32Stream: requireDeflateCrc32Stream()
  };
  return lib;
}
var hasRequiredZipArchiveOutputStream;
function requireZipArchiveOutputStream() {
  if (hasRequiredZipArchiveOutputStream) return zipArchiveOutputStream.exports;
  hasRequiredZipArchiveOutputStream = 1;
  var inherits2 = require$$0$2.inherits;
  var crc322 = requireBufferCrc32();
  var { CRC32Stream } = requireLib();
  var { DeflateCRC32Stream } = requireLib();
  var ArchiveOutputStream = requireArchiveOutputStream();
  requireZipArchiveEntry();
  requireGeneralPurposeBit();
  var constants2 = requireConstants();
  requireUtil$3();
  var zipUtil = requireUtil$4();
  var ZipArchiveOutputStream = zipArchiveOutputStream.exports = function(options) {
    if (!(this instanceof ZipArchiveOutputStream)) {
      return new ZipArchiveOutputStream(options);
    }
    options = this.options = this._defaults(options);
    ArchiveOutputStream.call(this, options);
    this._entry = null;
    this._entries = [];
    this._archive = {
      centralLength: 0,
      centralOffset: 0,
      comment: "",
      finish: false,
      finished: false,
      processing: false,
      forceZip64: options.forceZip64,
      forceLocalTime: options.forceLocalTime
    };
  };
  inherits2(ZipArchiveOutputStream, ArchiveOutputStream);
  ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
    this._entries.push(ae);
    if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
      this._writeDataDescriptor(ae);
    }
    this._archive.processing = false;
    this._entry = null;
    if (this._archive.finish && !this._archive.finished) {
      this._finish();
    }
  };
  ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
    if (source.length === 0) {
      ae.setMethod(constants2.METHOD_STORED);
    }
    var method2 = ae.getMethod();
    if (method2 === constants2.METHOD_STORED) {
      ae.setSize(source.length);
      ae.setCompressedSize(source.length);
      ae.setCrc(crc322.unsigned(source));
    }
    this._writeLocalFileHeader(ae);
    if (method2 === constants2.METHOD_STORED) {
      this.write(source);
      this._afterAppend(ae);
      callback(null, ae);
      return;
    } else if (method2 === constants2.METHOD_DEFLATED) {
      this._smartStream(ae, callback).end(source);
      return;
    } else {
      callback(new Error("compression method " + method2 + " not implemented"));
      return;
    }
  };
  ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
    ae.getGeneralPurposeBit().useDataDescriptor(true);
    ae.setVersionNeededToExtract(constants2.MIN_VERSION_DATA_DESCRIPTOR);
    this._writeLocalFileHeader(ae);
    var smart = this._smartStream(ae, callback);
    source.once("error", function(err) {
      smart.emit("error", err);
      smart.end();
    });
    source.pipe(smart);
  };
  ZipArchiveOutputStream.prototype._defaults = function(o) {
    if (typeof o !== "object") {
      o = {};
    }
    if (typeof o.zlib !== "object") {
      o.zlib = {};
    }
    if (typeof o.zlib.level !== "number") {
      o.zlib.level = constants2.ZLIB_BEST_SPEED;
    }
    o.forceZip64 = !!o.forceZip64;
    o.forceLocalTime = !!o.forceLocalTime;
    return o;
  };
  ZipArchiveOutputStream.prototype._finish = function() {
    this._archive.centralOffset = this.offset;
    this._entries.forEach((function(ae) {
      this._writeCentralFileHeader(ae);
    }).bind(this));
    this._archive.centralLength = this.offset - this._archive.centralOffset;
    if (this.isZip64()) {
      this._writeCentralDirectoryZip64();
    }
    this._writeCentralDirectoryEnd();
    this._archive.processing = false;
    this._archive.finish = true;
    this._archive.finished = true;
    this.end();
  };
  ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    if (ae.getMethod() === -1) {
      ae.setMethod(constants2.METHOD_DEFLATED);
    }
    if (ae.getMethod() === constants2.METHOD_DEFLATED) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants2.MIN_VERSION_DATA_DESCRIPTOR);
    }
    if (ae.getTime() === -1) {
      ae.setTime(/* @__PURE__ */ new Date(), this._archive.forceLocalTime);
    }
    ae._offsets = {
      file: 0,
      data: 0,
      contents: 0
    };
  };
  ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
    var deflate2 = ae.getMethod() === constants2.METHOD_DEFLATED;
    var process2 = deflate2 ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
    var error2 = null;
    function handleStuff() {
      var digest = process2.digest().readUInt32BE(0);
      ae.setCrc(digest);
      ae.setSize(process2.size());
      ae.setCompressedSize(process2.size(true));
      this._afterAppend(ae);
      callback(error2, ae);
    }
    process2.once("end", handleStuff.bind(this));
    process2.once("error", function(err) {
      error2 = err;
    });
    process2.pipe(this, { end: false });
    return process2;
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
    var records = this._entries.length;
    var size = this._archive.centralLength;
    var offset = this._archive.centralOffset;
    if (this.isZip64()) {
      records = constants2.ZIP64_MAGIC_SHORT;
      size = constants2.ZIP64_MAGIC;
      offset = constants2.ZIP64_MAGIC;
    }
    this.write(zipUtil.getLongBytes(constants2.SIG_EOCD));
    this.write(constants2.SHORT_ZERO);
    this.write(constants2.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getShortBytes(records));
    this.write(zipUtil.getLongBytes(size));
    this.write(zipUtil.getLongBytes(offset));
    var comment = this.getComment();
    var commentLength = Buffer.byteLength(comment);
    this.write(zipUtil.getShortBytes(commentLength));
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
    this.write(zipUtil.getLongBytes(constants2.SIG_ZIP64_EOCD));
    this.write(zipUtil.getEightBytes(44));
    this.write(zipUtil.getShortBytes(constants2.MIN_VERSION_ZIP64));
    this.write(zipUtil.getShortBytes(constants2.MIN_VERSION_ZIP64));
    this.write(constants2.LONG_ZERO);
    this.write(constants2.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._entries.length));
    this.write(zipUtil.getEightBytes(this._archive.centralLength));
    this.write(zipUtil.getEightBytes(this._archive.centralOffset));
    this.write(zipUtil.getLongBytes(constants2.SIG_ZIP64_EOCD_LOC));
    this.write(constants2.LONG_ZERO);
    this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
    this.write(zipUtil.getLongBytes(1));
  };
  ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method2 = ae.getMethod();
    var offsets = ae._offsets;
    var size = ae.getSize();
    var compressedSize = ae.getCompressedSize();
    if (ae.isZip64() || offsets.file > constants2.ZIP64_MAGIC) {
      size = constants2.ZIP64_MAGIC;
      compressedSize = constants2.ZIP64_MAGIC;
      ae.setVersionNeededToExtract(constants2.MIN_VERSION_ZIP64);
      var extraBuf = Buffer.concat([
        zipUtil.getShortBytes(constants2.ZIP64_EXTRA_ID),
        zipUtil.getShortBytes(24),
        zipUtil.getEightBytes(ae.getSize()),
        zipUtil.getEightBytes(ae.getCompressedSize()),
        zipUtil.getEightBytes(offsets.file)
      ], 28);
      ae.setExtra(extraBuf);
    }
    this.write(zipUtil.getLongBytes(constants2.SIG_CFH));
    this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants2.VERSION_MADEBY));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method2));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    this.write(zipUtil.getLongBytes(compressedSize));
    this.write(zipUtil.getLongBytes(size));
    var name = ae.getName();
    var comment = ae.getComment();
    var extra = ae.getCentralDirectoryExtra();
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
      comment = Buffer.from(comment);
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(zipUtil.getShortBytes(comment.length));
    this.write(constants2.SHORT_ZERO);
    this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
    this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
    if (offsets.file > constants2.ZIP64_MAGIC) {
      this.write(zipUtil.getLongBytes(constants2.ZIP64_MAGIC));
    } else {
      this.write(zipUtil.getLongBytes(offsets.file));
    }
    this.write(name);
    this.write(extra);
    this.write(comment);
  };
  ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
    this.write(zipUtil.getLongBytes(constants2.SIG_DD));
    this.write(zipUtil.getLongBytes(ae.getCrc()));
    if (ae.isZip64()) {
      this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
      this.write(zipUtil.getEightBytes(ae.getSize()));
    } else {
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
  };
  ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
    var gpb = ae.getGeneralPurposeBit();
    var method2 = ae.getMethod();
    var name = ae.getName();
    var extra = ae.getLocalFileDataExtra();
    if (ae.isZip64()) {
      gpb.useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants2.MIN_VERSION_ZIP64);
    }
    if (gpb.usesUTF8ForNames()) {
      name = Buffer.from(name);
    }
    ae._offsets.file = this.offset;
    this.write(zipUtil.getLongBytes(constants2.SIG_LFH));
    this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
    this.write(gpb.encode());
    this.write(zipUtil.getShortBytes(method2));
    this.write(zipUtil.getLongBytes(ae.getTimeDos()));
    ae._offsets.data = this.offset;
    if (gpb.usesDataDescriptor()) {
      this.write(constants2.LONG_ZERO);
      this.write(constants2.LONG_ZERO);
      this.write(constants2.LONG_ZERO);
    } else {
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
      this.write(zipUtil.getLongBytes(ae.getSize()));
    }
    this.write(zipUtil.getShortBytes(name.length));
    this.write(zipUtil.getShortBytes(extra.length));
    this.write(name);
    this.write(extra);
    ae._offsets.contents = this.offset;
  };
  ZipArchiveOutputStream.prototype.getComment = function(comment) {
    return this._archive.comment !== null ? this._archive.comment : "";
  };
  ZipArchiveOutputStream.prototype.isZip64 = function() {
    return this._archive.forceZip64 || this._entries.length > constants2.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants2.ZIP64_MAGIC || this._archive.centralOffset > constants2.ZIP64_MAGIC;
  };
  ZipArchiveOutputStream.prototype.setComment = function(comment) {
    this._archive.comment = comment;
  };
  return zipArchiveOutputStream.exports;
}
var compressCommons;
var hasRequiredCompressCommons;
function requireCompressCommons() {
  if (hasRequiredCompressCommons) return compressCommons;
  hasRequiredCompressCommons = 1;
  compressCommons = {
    ArchiveEntry: requireArchiveEntry(),
    ZipArchiveEntry: requireZipArchiveEntry(),
    ArchiveOutputStream: requireArchiveOutputStream(),
    ZipArchiveOutputStream: requireZipArchiveOutputStream()
  };
  return compressCommons;
}
var archiverUtils = { exports: {} };
var file = { exports: {} };
var hasRequiredFile;
function requireFile() {
  if (hasRequiredFile) return file.exports;
  hasRequiredFile = 1;
  var fs2 = requireGracefulFs();
  var path2 = require$$1;
  var flatten = requireLodash_flatten();
  var difference = requireLodash_difference();
  var union = requireLodash_union();
  var isPlainObject2 = requireLodash_isplainobject();
  var glob = requireGlob();
  var file$12 = file.exports = {};
  var pathSeparatorRe = /[\/\\]/g;
  var processPatterns = function(patterns, fn) {
    var result = [];
    flatten(patterns).forEach(function(pattern) {
      var exclusion = pattern.indexOf("!") === 0;
      if (exclusion) {
        pattern = pattern.slice(1);
      }
      var matches = fn(pattern);
      if (exclusion) {
        result = difference(result, matches);
      } else {
        result = union(result, matches);
      }
    });
    return result;
  };
  file$12.exists = function() {
    var filepath = path2.join.apply(path2, arguments);
    return fs2.existsSync(filepath);
  };
  file$12.expand = function(...args) {
    var options = isPlainObject2(args[0]) ? args.shift() : {};
    var patterns = Array.isArray(args[0]) ? args[0] : args;
    if (patterns.length === 0) {
      return [];
    }
    var matches = processPatterns(patterns, function(pattern) {
      return glob.sync(pattern, options);
    });
    if (options.filter) {
      matches = matches.filter(function(filepath) {
        filepath = path2.join(options.cwd || "", filepath);
        try {
          if (typeof options.filter === "function") {
            return options.filter(filepath);
          } else {
            return fs2.statSync(filepath)[options.filter]();
          }
        } catch (e) {
          return false;
        }
      });
    }
    return matches;
  };
  file$12.expandMapping = function(patterns, destBase, options) {
    options = Object.assign({
      rename: function(destBase2, destPath) {
        return path2.join(destBase2 || "", destPath);
      }
    }, options);
    var files = [];
    var fileByDest = {};
    file$12.expand(options, patterns).forEach(function(src2) {
      var destPath = src2;
      if (options.flatten) {
        destPath = path2.basename(destPath);
      }
      if (options.ext) {
        destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
      }
      var dest = options.rename(destBase, destPath, options);
      if (options.cwd) {
        src2 = path2.join(options.cwd, src2);
      }
      dest = dest.replace(pathSeparatorRe, "/");
      src2 = src2.replace(pathSeparatorRe, "/");
      if (fileByDest[dest]) {
        fileByDest[dest].src.push(src2);
      } else {
        files.push({
          src: [src2],
          dest
        });
        fileByDest[dest] = files[files.length - 1];
      }
    });
    return files;
  };
  file$12.normalizeFilesArray = function(data2) {
    var files = [];
    data2.forEach(function(obj) {
      if ("src" in obj || "dest" in obj) {
        files.push(obj);
      }
    });
    if (files.length === 0) {
      return [];
    }
    files = _(files).chain().forEach(function(obj) {
      if (!("src" in obj) || !obj.src) {
        return;
      }
      if (Array.isArray(obj.src)) {
        obj.src = flatten(obj.src);
      } else {
        obj.src = [obj.src];
      }
    }).map(function(obj) {
      var expandOptions = Object.assign({}, obj);
      delete expandOptions.src;
      delete expandOptions.dest;
      if (obj.expand) {
        return file$12.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
          var result2 = Object.assign({}, obj);
          result2.orig = Object.assign({}, obj);
          result2.src = mapObj.src;
          result2.dest = mapObj.dest;
          ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
            delete result2[prop];
          });
          return result2;
        });
      }
      var result = Object.assign({}, obj);
      result.orig = Object.assign({}, obj);
      if ("src" in result) {
        Object.defineProperty(result, "src", {
          enumerable: true,
          get: function fn() {
            var src2;
            if (!("result" in fn)) {
              src2 = obj.src;
              src2 = Array.isArray(src2) ? flatten(src2) : [src2];
              fn.result = file$12.expand(expandOptions, src2);
            }
            return fn.result;
          }
        });
      }
      if ("dest" in result) {
        result.dest = obj.dest;
      }
      return result;
    }).flatten().value();
    return files;
  };
  return file.exports;
}
var hasRequiredArchiverUtils;
function requireArchiverUtils() {
  if (hasRequiredArchiverUtils) return archiverUtils.exports;
  hasRequiredArchiverUtils = 1;
  var fs2 = requireGracefulFs();
  var path2 = require$$1;
  var lazystream2 = requireLazystream();
  var normalizePath2 = requireNormalizePath();
  var defaults2 = requireLodash_defaults();
  var Stream = require$$0$1.Stream;
  var PassThrough = requireReadable$4().PassThrough;
  var utils2 = archiverUtils.exports = {};
  utils2.file = requireFile();
  utils2.collectStream = function(source, callback) {
    var collection = [];
    var size = 0;
    source.on("error", callback);
    source.on("data", function(chunk) {
      collection.push(chunk);
      size += chunk.length;
    });
    source.on("end", function() {
      var buf = Buffer.alloc(size);
      var offset = 0;
      collection.forEach(function(data2) {
        data2.copy(buf, offset);
        offset += data2.length;
      });
      callback(null, buf);
    });
  };
  utils2.dateify = function(dateish) {
    dateish = dateish || /* @__PURE__ */ new Date();
    if (dateish instanceof Date) {
      dateish = dateish;
    } else if (typeof dateish === "string") {
      dateish = new Date(dateish);
    } else {
      dateish = /* @__PURE__ */ new Date();
    }
    return dateish;
  };
  utils2.defaults = function(object2, source, guard) {
    var args = arguments;
    args[0] = args[0] || {};
    return defaults2(...args);
  };
  utils2.isStream = function(source) {
    return source instanceof Stream;
  };
  utils2.lazyReadStream = function(filepath) {
    return new lazystream2.Readable(function() {
      return fs2.createReadStream(filepath);
    });
  };
  utils2.normalizeInputSource = function(source) {
    if (source === null) {
      return Buffer.alloc(0);
    } else if (typeof source === "string") {
      return Buffer.from(source);
    } else if (utils2.isStream(source)) {
      return source.pipe(new PassThrough());
    }
    return source;
  };
  utils2.sanitizePath = function(filepath) {
    return normalizePath2(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
  };
  utils2.trailingSlashIt = function(str) {
    return str.slice(-1) !== "/" ? str + "/" : str;
  };
  utils2.unixifyPath = function(filepath) {
    return normalizePath2(filepath, false).replace(/^\w+:/, "");
  };
  utils2.walkdir = function(dirpath, base, callback) {
    var results = [];
    if (typeof base === "function") {
      callback = base;
      base = dirpath;
    }
    fs2.readdir(dirpath, function(err, list) {
      var i = 0;
      var file2;
      var filepath;
      if (err) {
        return callback(err);
      }
      (function next() {
        file2 = list[i++];
        if (!file2) {
          return callback(null, results);
        }
        filepath = path2.join(dirpath, file2);
        fs2.stat(filepath, function(err2, stats) {
          results.push({
            path: filepath,
            relative: path2.relative(base, filepath).replace(/\\/g, "/"),
            stats
          });
          if (stats && stats.isDirectory()) {
            utils2.walkdir(filepath, base, function(err3, res) {
              res.forEach(function(dirEntry) {
                results.push(dirEntry);
              });
              next();
            });
          } else {
            next();
          }
        });
      })();
    });
  };
  return archiverUtils.exports;
}
/**
 * ZipStream
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
 * @copyright (c) 2014 Chris Talkington, contributors.
 */
var hasRequiredZipStream;
function requireZipStream() {
  if (hasRequiredZipStream) return zipStream.exports;
  hasRequiredZipStream = 1;
  var inherits2 = require$$0$2.inherits;
  var ZipArchiveOutputStream = requireCompressCommons().ZipArchiveOutputStream;
  var ZipArchiveEntry = requireCompressCommons().ZipArchiveEntry;
  var util2 = requireArchiverUtils();
  var ZipStream = zipStream.exports = function(options) {
    if (!(this instanceof ZipStream)) {
      return new ZipStream(options);
    }
    options = this.options = options || {};
    options.zlib = options.zlib || {};
    ZipArchiveOutputStream.call(this, options);
    if (typeof options.level === "number" && options.level >= 0) {
      options.zlib.level = options.level;
      delete options.level;
    }
    if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
      options.store = true;
    }
    options.namePrependSlash = options.namePrependSlash || false;
    if (options.comment && options.comment.length > 0) {
      this.setComment(options.comment);
    }
  };
  inherits2(ZipStream, ZipArchiveOutputStream);
  ZipStream.prototype._normalizeFileData = function(data2) {
    data2 = util2.defaults(data2, {
      type: "file",
      name: null,
      namePrependSlash: this.options.namePrependSlash,
      linkname: null,
      date: null,
      mode: null,
      store: this.options.store,
      comment: ""
    });
    var isDir = data2.type === "directory";
    var isSymlink = data2.type === "symlink";
    if (data2.name) {
      data2.name = util2.sanitizePath(data2.name);
      if (!isSymlink && data2.name.slice(-1) === "/") {
        isDir = true;
        data2.type = "directory";
      } else if (isDir) {
        data2.name += "/";
      }
    }
    if (isDir || isSymlink) {
      data2.store = true;
    }
    data2.date = util2.dateify(data2.date);
    return data2;
  };
  ZipStream.prototype.entry = function(source, data2, callback) {
    if (typeof callback !== "function") {
      callback = this._emitErrorCallback.bind(this);
    }
    data2 = this._normalizeFileData(data2);
    if (data2.type !== "file" && data2.type !== "directory" && data2.type !== "symlink") {
      callback(new Error(data2.type + " entries not currently supported"));
      return;
    }
    if (typeof data2.name !== "string" || data2.name.length === 0) {
      callback(new Error("entry name must be a non-empty string value"));
      return;
    }
    if (data2.type === "symlink" && typeof data2.linkname !== "string") {
      callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
      return;
    }
    var entry = new ZipArchiveEntry(data2.name);
    entry.setTime(data2.date, this.options.forceLocalTime);
    if (data2.namePrependSlash) {
      entry.setName(data2.name, true);
    }
    if (data2.store) {
      entry.setMethod(0);
    }
    if (data2.comment.length > 0) {
      entry.setComment(data2.comment);
    }
    if (data2.type === "symlink" && typeof data2.mode !== "number") {
      data2.mode = 40960;
    }
    if (typeof data2.mode === "number") {
      if (data2.type === "symlink") {
        data2.mode |= 40960;
      }
      entry.setUnixMode(data2.mode);
    }
    if (data2.type === "symlink" && typeof data2.linkname === "string") {
      source = Buffer.from(data2.linkname);
    }
    return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
  };
  ZipStream.prototype.finalize = function() {
    this.finish();
  };
  return zipStream.exports;
}
/**
 * ZIP Format Plugin
 *
 * @module plugins/zip
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var zip;
var hasRequiredZip;
function requireZip() {
  if (hasRequiredZip) return zip;
  hasRequiredZip = 1;
  var engine = requireZipStream();
  var util2 = requireArchiverUtils$1();
  var Zip = function(options) {
    if (!(this instanceof Zip)) {
      return new Zip(options);
    }
    options = this.options = util2.defaults(options, {
      comment: "",
      forceUTC: false,
      namePrependSlash: false,
      store: false
    });
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = new engine(options);
  };
  Zip.prototype.append = function(source, data2, callback) {
    this.engine.entry(source, data2, callback);
  };
  Zip.prototype.finalize = function() {
    this.engine.finalize();
  };
  Zip.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Zip.prototype.pipe = function() {
    return this.engine.pipe.apply(this.engine, arguments);
  };
  Zip.prototype.unpipe = function() {
    return this.engine.unpipe.apply(this.engine, arguments);
  };
  zip = Zip;
  return zip;
}
var tarStream = {};
var bl = { exports: {} };
var BufferList_1;
var hasRequiredBufferList$2;
function requireBufferList$2() {
  if (hasRequiredBufferList$2) return BufferList_1;
  hasRequiredBufferList$2 = 1;
  const { Buffer: Buffer2 } = require$$0$7;
  const symbol = Symbol.for("BufferList");
  function BufferList2(buf) {
    if (!(this instanceof BufferList2)) {
      return new BufferList2(buf);
    }
    BufferList2._init.call(this, buf);
  }
  BufferList2._init = function _init(buf) {
    Object.defineProperty(this, symbol, { value: true });
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList2.prototype._new = function _new(buf) {
    return new BufferList2(buf);
  };
  BufferList2.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length;
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList2.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList2.prototype.get = function get2(index2) {
    if (index2 > this.length || index2 < 0) {
      return void 0;
    }
    const offset = this._offset(index2);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList2.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
      start += this.length;
    }
    if (typeof end === "number" && end < 0) {
      end += this.length;
    }
    return this.copy(null, 0, start, end);
  };
  BufferList2.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
      srcEnd = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer2.alloc(0);
    }
    if (srcEnd <= 0) {
      return dst || Buffer2.alloc(0);
    }
    const copy2 = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy2 && dstStart || 0;
    let start = off[1];
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy2) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy2) {
      dst = Buffer2.allocUnsafe(len);
    }
    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start) {
        start = 0;
      }
    }
    if (dst.length > bufoff) return dst.slice(0, bufoff);
    return dst;
  };
  BufferList2.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
      start += this.length;
    }
    if (end < 0) {
      end += this.length;
    }
    if (start === end) {
      return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers2 = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers2.pop();
    } else {
      buffers2[buffers2.length - 1] = buffers2[buffers2.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers2[0] = buffers2[0].slice(startOffset[1]);
    }
    return this._new(buffers2);
  };
  BufferList2.prototype.toString = function toString3(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList2.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0) return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList2.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for (let i = 0; i < this._bufs.length; i++) {
      copy.append(this._bufs[i]);
    }
    return copy;
  };
  BufferList2.prototype.append = function append2(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList2.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList2.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList2.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m in methods) {
      (function(m2) {
        if (methods[m2] === null) {
          BufferList2.prototype[m2] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m2](0, byteLength);
          };
        } else {
          BufferList2.prototype[m2] = function(offset = 0) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        }
      })(m);
    }
  })();
  BufferList2.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList2 || BufferList2.isBufferList(b);
  };
  BufferList2.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
  };
  BufferList_1 = BufferList2;
  return BufferList_1;
}
var hasRequiredBl;
function requireBl() {
  if (hasRequiredBl) return bl.exports;
  hasRequiredBl = 1;
  const DuplexStream = requireReadable$4().Duplex;
  const inherits2 = requireInherits();
  const BufferList2 = requireBufferList$2();
  function BufferListStream(callback) {
    if (!(this instanceof BufferListStream)) {
      return new BufferListStream(callback);
    }
    if (typeof callback === "function") {
      this._callback = callback;
      const piper = (function piper2(err) {
        if (this._callback) {
          this._callback(err);
          this._callback = null;
        }
      }).bind(this);
      this.on("pipe", function onPipe(src2) {
        src2.on("error", piper);
      });
      this.on("unpipe", function onUnpipe(src2) {
        src2.removeListener("error", piper);
      });
      callback = null;
    }
    BufferList2._init.call(this, callback);
    DuplexStream.call(this);
  }
  inherits2(BufferListStream, DuplexStream);
  Object.assign(BufferListStream.prototype, BufferList2.prototype);
  BufferListStream.prototype._new = function _new(callback) {
    return new BufferListStream(callback);
  };
  BufferListStream.prototype._write = function _write(buf, encoding, callback) {
    this._appendBuffer(buf);
    if (typeof callback === "function") {
      callback();
    }
  };
  BufferListStream.prototype._read = function _read(size) {
    if (!this.length) {
      return this.push(null);
    }
    size = Math.min(size, this.length);
    this.push(this.slice(0, size));
    this.consume(size);
  };
  BufferListStream.prototype.end = function end(chunk) {
    DuplexStream.prototype.end.call(this, chunk);
    if (this._callback) {
      this._callback(null, this.slice());
      this._callback = null;
    }
  };
  BufferListStream.prototype._destroy = function _destroy(err, cb) {
    this._bufs.length = 0;
    this.length = 0;
    cb(err);
  };
  BufferListStream.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferListStream || b instanceof BufferList2 || BufferListStream.isBufferList(b);
  };
  BufferListStream.isBufferList = BufferList2.isBufferList;
  bl.exports = BufferListStream;
  bl.exports.BufferListStream = BufferListStream;
  bl.exports.BufferList = BufferList2;
  return bl.exports;
}
var headers = {};
var hasRequiredHeaders;
function requireHeaders() {
  if (hasRequiredHeaders) return headers;
  hasRequiredHeaders = 1;
  var alloc = Buffer.alloc;
  var ZEROS = "0000000000000000000";
  var SEVENS = "7777777777777777777";
  var ZERO_OFFSET = "0".charCodeAt(0);
  var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
  var USTAR_VER = Buffer.from("00", "binary");
  var GNU_MAGIC = Buffer.from("ustar ", "binary");
  var GNU_VER = Buffer.from(" \0", "binary");
  var MASK = parseInt("7777", 8);
  var MAGIC_OFFSET = 257;
  var VERSION_OFFSET = 263;
  var clamp = function(index2, len, defaultValue) {
    if (typeof index2 !== "number") return defaultValue;
    index2 = ~~index2;
    if (index2 >= len) return len;
    if (index2 >= 0) return index2;
    index2 += len;
    if (index2 >= 0) return index2;
    return 0;
  };
  var toType = function(flag) {
    switch (flag) {
      case 0:
        return "file";
      case 1:
        return "link";
      case 2:
        return "symlink";
      case 3:
        return "character-device";
      case 4:
        return "block-device";
      case 5:
        return "directory";
      case 6:
        return "fifo";
      case 7:
        return "contiguous-file";
      case 72:
        return "pax-header";
      case 55:
        return "pax-global-header";
      case 27:
        return "gnu-long-link-path";
      case 28:
      case 30:
        return "gnu-long-path";
    }
    return null;
  };
  var toTypeflag = function(flag) {
    switch (flag) {
      case "file":
        return 0;
      case "link":
        return 1;
      case "symlink":
        return 2;
      case "character-device":
        return 3;
      case "block-device":
        return 4;
      case "directory":
        return 5;
      case "fifo":
        return 6;
      case "contiguous-file":
        return 7;
      case "pax-header":
        return 72;
    }
    return 0;
  };
  var indexOf = function(block, num, offset, end) {
    for (; offset < end; offset++) {
      if (block[offset] === num) return offset;
    }
    return end;
  };
  var cksum = function(block) {
    var sum = 8 * 32;
    for (var i = 0; i < 148; i++) sum += block[i];
    for (var j = 156; j < 512; j++) sum += block[j];
    return sum;
  };
  var encodeOct = function(val, n) {
    val = val.toString(8);
    if (val.length > n) return SEVENS.slice(0, n) + " ";
    else return ZEROS.slice(0, n - val.length) + val + " ";
  };
  function parse256(buf) {
    var positive;
    if (buf[0] === 128) positive = true;
    else if (buf[0] === 255) positive = false;
    else return null;
    var tuple = [];
    for (var i = buf.length - 1; i > 0; i--) {
      var byte = buf[i];
      if (positive) tuple.push(byte);
      else tuple.push(255 - byte);
    }
    var sum = 0;
    var l = tuple.length;
    for (i = 0; i < l; i++) {
      sum += tuple[i] * Math.pow(256, i);
    }
    return positive ? sum : -1 * sum;
  }
  var decodeOct = function(val, offset, length) {
    val = val.slice(offset, offset + length);
    offset = 0;
    if (val[offset] & 128) {
      return parse256(val);
    } else {
      while (offset < val.length && val[offset] === 32) offset++;
      var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
      while (offset < end && val[offset] === 0) offset++;
      if (end === offset) return 0;
      return parseInt(val.slice(offset, end).toString(), 8);
    }
  };
  var decodeStr = function(val, offset, length, encoding) {
    return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
  };
  var addLength = function(str) {
    var len = Buffer.byteLength(str);
    var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
    if (len + digits >= Math.pow(10, digits)) digits++;
    return len + digits + str;
  };
  headers.decodeLongPath = function(buf, encoding) {
    return decodeStr(buf, 0, buf.length, encoding);
  };
  headers.encodePax = function(opts) {
    var result = "";
    if (opts.name) result += addLength(" path=" + opts.name + "\n");
    if (opts.linkname) result += addLength(" linkpath=" + opts.linkname + "\n");
    var pax = opts.pax;
    if (pax) {
      for (var key in pax) {
        result += addLength(" " + key + "=" + pax[key] + "\n");
      }
    }
    return Buffer.from(result);
  };
  headers.decodePax = function(buf) {
    var result = {};
    while (buf.length) {
      var i = 0;
      while (i < buf.length && buf[i] !== 32) i++;
      var len = parseInt(buf.slice(0, i).toString(), 10);
      if (!len) return result;
      var b = buf.slice(i + 1, len - 1).toString();
      var keyIndex = b.indexOf("=");
      if (keyIndex === -1) return result;
      result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
      buf = buf.slice(len);
    }
    return result;
  };
  headers.encode = function(opts) {
    var buf = alloc(512);
    var name = opts.name;
    var prefix = "";
    if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
    if (Buffer.byteLength(name) !== name.length) return null;
    while (Buffer.byteLength(name) > 100) {
      var i = name.indexOf("/");
      if (i === -1) return null;
      prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
      name = name.slice(i + 1);
    }
    if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
    if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
    buf.write(name);
    buf.write(encodeOct(opts.mode & MASK, 6), 100);
    buf.write(encodeOct(opts.uid, 6), 108);
    buf.write(encodeOct(opts.gid, 6), 116);
    buf.write(encodeOct(opts.size, 11), 124);
    buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
    buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
    if (opts.linkname) buf.write(opts.linkname, 157);
    USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
    USTAR_VER.copy(buf, VERSION_OFFSET);
    if (opts.uname) buf.write(opts.uname, 265);
    if (opts.gname) buf.write(opts.gname, 297);
    buf.write(encodeOct(opts.devmajor || 0, 6), 329);
    buf.write(encodeOct(opts.devminor || 0, 6), 337);
    if (prefix) buf.write(prefix, 345);
    buf.write(encodeOct(cksum(buf), 6), 148);
    return buf;
  };
  headers.decode = function(buf, filenameEncoding, allowUnknownFormat) {
    var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
    var name = decodeStr(buf, 0, 100, filenameEncoding);
    var mode = decodeOct(buf, 100, 8);
    var uid = decodeOct(buf, 108, 8);
    var gid = decodeOct(buf, 116, 8);
    var size = decodeOct(buf, 124, 12);
    var mtime = decodeOct(buf, 136, 12);
    var type2 = toType(typeflag);
    var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
    var uname = decodeStr(buf, 265, 32);
    var gname = decodeStr(buf, 297, 32);
    var devmajor = decodeOct(buf, 329, 8);
    var devminor = decodeOct(buf, 337, 8);
    var c = cksum(buf);
    if (c === 8 * 32) return null;
    if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
    if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
      if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
    } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) ;
    else {
      if (!allowUnknownFormat) {
        throw new Error("Invalid tar header: unknown format.");
      }
    }
    if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
    return {
      name,
      mode,
      uid,
      gid,
      size,
      mtime: new Date(1e3 * mtime),
      type: type2,
      linkname,
      uname,
      gname,
      devmajor,
      devminor
    };
  };
  return headers;
}
var extract$1;
var hasRequiredExtract$1;
function requireExtract$1() {
  if (hasRequiredExtract$1) return extract$1;
  hasRequiredExtract$1 = 1;
  var util2 = require$$0$2;
  var bl2 = requireBl();
  var headers2 = requireHeaders();
  var Writable = requireReadable$4().Writable;
  var PassThrough = requireReadable$4().PassThrough;
  var noop2 = function() {
  };
  var overflow = function(size) {
    size &= 511;
    return size && 512 - size;
  };
  var emptyStream = function(self2, offset) {
    var s = new Source(self2, offset);
    s.end();
    return s;
  };
  var mixinPax = function(header, pax) {
    if (pax.path) header.name = pax.path;
    if (pax.linkpath) header.linkname = pax.linkpath;
    if (pax.size) header.size = parseInt(pax.size, 10);
    header.pax = pax;
    return header;
  };
  var Source = function(self2, offset) {
    this._parent = self2;
    this.offset = offset;
    PassThrough.call(this, { autoDestroy: false });
  };
  util2.inherits(Source, PassThrough);
  Source.prototype.destroy = function(err) {
    this._parent.destroy(err);
  };
  var Extract = function(opts) {
    if (!(this instanceof Extract)) return new Extract(opts);
    Writable.call(this, opts);
    opts = opts || {};
    this._offset = 0;
    this._buffer = bl2();
    this._missing = 0;
    this._partial = false;
    this._onparse = noop2;
    this._header = null;
    this._stream = null;
    this._overflow = null;
    this._cb = null;
    this._locked = false;
    this._destroyed = false;
    this._pax = null;
    this._paxGlobal = null;
    this._gnuLongPath = null;
    this._gnuLongLinkPath = null;
    var self2 = this;
    var b = self2._buffer;
    var oncontinue = function() {
      self2._continue();
    };
    var onunlock = function(err) {
      self2._locked = false;
      if (err) return self2.destroy(err);
      if (!self2._stream) oncontinue();
    };
    var onstreamend = function() {
      self2._stream = null;
      var drain = overflow(self2._header.size);
      if (drain) self2._parse(drain, ondrain);
      else self2._parse(512, onheader);
      if (!self2._locked) oncontinue();
    };
    var ondrain = function() {
      self2._buffer.consume(overflow(self2._header.size));
      self2._parse(512, onheader);
      oncontinue();
    };
    var onpaxglobalheader = function() {
      var size = self2._header.size;
      self2._paxGlobal = headers2.decodePax(b.slice(0, size));
      b.consume(size);
      onstreamend();
    };
    var onpaxheader = function() {
      var size = self2._header.size;
      self2._pax = headers2.decodePax(b.slice(0, size));
      if (self2._paxGlobal) self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
      b.consume(size);
      onstreamend();
    };
    var ongnulongpath = function() {
      var size = self2._header.size;
      this._gnuLongPath = headers2.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var ongnulonglinkpath = function() {
      var size = self2._header.size;
      this._gnuLongLinkPath = headers2.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
      b.consume(size);
      onstreamend();
    };
    var onheader = function() {
      var offset = self2._offset;
      var header;
      try {
        header = self2._header = headers2.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
      } catch (err) {
        self2.emit("error", err);
      }
      b.consume(512);
      if (!header) {
        self2._parse(512, onheader);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-path") {
        self2._parse(header.size, ongnulongpath);
        oncontinue();
        return;
      }
      if (header.type === "gnu-long-link-path") {
        self2._parse(header.size, ongnulonglinkpath);
        oncontinue();
        return;
      }
      if (header.type === "pax-global-header") {
        self2._parse(header.size, onpaxglobalheader);
        oncontinue();
        return;
      }
      if (header.type === "pax-header") {
        self2._parse(header.size, onpaxheader);
        oncontinue();
        return;
      }
      if (self2._gnuLongPath) {
        header.name = self2._gnuLongPath;
        self2._gnuLongPath = null;
      }
      if (self2._gnuLongLinkPath) {
        header.linkname = self2._gnuLongLinkPath;
        self2._gnuLongLinkPath = null;
      }
      if (self2._pax) {
        self2._header = header = mixinPax(header, self2._pax);
        self2._pax = null;
      }
      self2._locked = true;
      if (!header.size || header.type === "directory") {
        self2._parse(512, onheader);
        self2.emit("entry", header, emptyStream(self2, offset), onunlock);
        return;
      }
      self2._stream = new Source(self2, offset);
      self2.emit("entry", header, self2._stream, onunlock);
      self2._parse(header.size, onstreamend);
      oncontinue();
    };
    this._onheader = onheader;
    this._parse(512, onheader);
  };
  util2.inherits(Extract, Writable);
  Extract.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream) this._stream.emit("close");
  };
  Extract.prototype._parse = function(size, onparse) {
    if (this._destroyed) return;
    this._offset += size;
    this._missing = size;
    if (onparse === this._onheader) this._partial = false;
    this._onparse = onparse;
  };
  Extract.prototype._continue = function() {
    if (this._destroyed) return;
    var cb = this._cb;
    this._cb = noop2;
    if (this._overflow) this._write(this._overflow, void 0, cb);
    else cb();
  };
  Extract.prototype._write = function(data2, enc, cb) {
    if (this._destroyed) return;
    var s = this._stream;
    var b = this._buffer;
    var missing = this._missing;
    if (data2.length) this._partial = true;
    if (data2.length < missing) {
      this._missing -= data2.length;
      this._overflow = null;
      if (s) return s.write(data2, cb);
      b.append(data2);
      return cb();
    }
    this._cb = cb;
    this._missing = 0;
    var overflow2 = null;
    if (data2.length > missing) {
      overflow2 = data2.slice(missing);
      data2 = data2.slice(0, missing);
    }
    if (s) s.end(data2);
    else b.append(data2);
    this._overflow = overflow2;
    this._onparse();
  };
  Extract.prototype._final = function(cb) {
    if (this._partial) return this.destroy(new Error("Unexpected end of data"));
    cb();
  };
  extract$1 = Extract;
  return extract$1;
}
var fsConstants;
var hasRequiredFsConstants;
function requireFsConstants() {
  if (hasRequiredFsConstants) return fsConstants;
  hasRequiredFsConstants = 1;
  fsConstants = require$$0$4.constants || require$$0$9;
  return fsConstants;
}
var endOfStream;
var hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var once2 = requireOnce();
  var noop2 = function() {
  };
  var isRequest2 = function(stream2) {
    return stream2.setHeader && typeof stream2.abort === "function";
  };
  var isChildProcess = function(stream2) {
    return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
  };
  var eos = function(stream2, opts, callback) {
    if (typeof opts === "function") return eos(stream2, null, opts);
    if (!opts) opts = {};
    callback = once2(callback || noop2);
    var ws = stream2._writableState;
    var rs = stream2._readableState;
    var readable2 = opts.readable || opts.readable !== false && stream2.readable;
    var writable = opts.writable || opts.writable !== false && stream2.writable;
    var cancelled = false;
    var onlegacyfinish = function() {
      if (!stream2.writable) onfinish();
    };
    var onfinish = function() {
      writable = false;
      if (!readable2) callback.call(stream2);
    };
    var onend = function() {
      readable2 = false;
      if (!writable) callback.call(stream2);
    };
    var onexit = function(exitCode) {
      callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
    };
    var onerror = function(err) {
      callback.call(stream2, err);
    };
    var onclose = function() {
      process.nextTick(onclosenexttick);
    };
    var onclosenexttick = function() {
      if (cancelled) return;
      if (readable2 && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream2, new Error("premature close"));
      if (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream2, new Error("premature close"));
    };
    var onrequest = function() {
      stream2.req.on("finish", onfinish);
    };
    if (isRequest2(stream2)) {
      stream2.on("complete", onfinish);
      stream2.on("abort", onclose);
      if (stream2.req) onrequest();
      else stream2.on("request", onrequest);
    } else if (writable && !ws) {
      stream2.on("end", onlegacyfinish);
      stream2.on("close", onlegacyfinish);
    }
    if (isChildProcess(stream2)) stream2.on("exit", onexit);
    stream2.on("end", onend);
    stream2.on("finish", onfinish);
    if (opts.error !== false) stream2.on("error", onerror);
    stream2.on("close", onclose);
    return function() {
      cancelled = true;
      stream2.removeListener("complete", onfinish);
      stream2.removeListener("abort", onclose);
      stream2.removeListener("request", onrequest);
      if (stream2.req) stream2.req.removeListener("finish", onfinish);
      stream2.removeListener("end", onlegacyfinish);
      stream2.removeListener("close", onlegacyfinish);
      stream2.removeListener("finish", onfinish);
      stream2.removeListener("exit", onexit);
      stream2.removeListener("end", onend);
      stream2.removeListener("error", onerror);
      stream2.removeListener("close", onclose);
    };
  };
  endOfStream = eos;
  return endOfStream;
}
var pack;
var hasRequiredPack;
function requirePack() {
  if (hasRequiredPack) return pack;
  hasRequiredPack = 1;
  var constants2 = requireFsConstants();
  var eos = requireEndOfStream();
  var inherits2 = requireInherits();
  var alloc = Buffer.alloc;
  var Readable2 = requireReadable$4().Readable;
  var Writable = requireReadable$4().Writable;
  var StringDecoder = require$$0$8.StringDecoder;
  var headers2 = requireHeaders();
  var DMODE = parseInt("755", 8);
  var FMODE = parseInt("644", 8);
  var END_OF_TAR = alloc(1024);
  var noop2 = function() {
  };
  var overflow = function(self2, size) {
    size &= 511;
    if (size) self2.push(END_OF_TAR.slice(0, 512 - size));
  };
  function modeToType(mode) {
    switch (mode & constants2.S_IFMT) {
      case constants2.S_IFBLK:
        return "block-device";
      case constants2.S_IFCHR:
        return "character-device";
      case constants2.S_IFDIR:
        return "directory";
      case constants2.S_IFIFO:
        return "fifo";
      case constants2.S_IFLNK:
        return "symlink";
    }
    return "file";
  }
  var Sink = function(to) {
    Writable.call(this);
    this.written = 0;
    this._to = to;
    this._destroyed = false;
  };
  inherits2(Sink, Writable);
  Sink.prototype._write = function(data2, enc, cb) {
    this.written += data2.length;
    if (this._to.push(data2)) return cb();
    this._to._drain = cb;
  };
  Sink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
  };
  var LinkSink = function() {
    Writable.call(this);
    this.linkname = "";
    this._decoder = new StringDecoder("utf-8");
    this._destroyed = false;
  };
  inherits2(LinkSink, Writable);
  LinkSink.prototype._write = function(data2, enc, cb) {
    this.linkname += this._decoder.write(data2);
    cb();
  };
  LinkSink.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
  };
  var Void = function() {
    Writable.call(this);
    this._destroyed = false;
  };
  inherits2(Void, Writable);
  Void.prototype._write = function(data2, enc, cb) {
    cb(new Error("No body allowed for this entry"));
  };
  Void.prototype.destroy = function() {
    if (this._destroyed) return;
    this._destroyed = true;
    this.emit("close");
  };
  var Pack = function(opts) {
    if (!(this instanceof Pack)) return new Pack(opts);
    Readable2.call(this, opts);
    this._drain = noop2;
    this._finalized = false;
    this._finalizing = false;
    this._destroyed = false;
    this._stream = null;
  };
  inherits2(Pack, Readable2);
  Pack.prototype.entry = function(header, buffer, callback) {
    if (this._stream) throw new Error("already piping an entry");
    if (this._finalized || this._destroyed) return;
    if (typeof buffer === "function") {
      callback = buffer;
      buffer = null;
    }
    if (!callback) callback = noop2;
    var self2 = this;
    if (!header.size || header.type === "symlink") header.size = 0;
    if (!header.type) header.type = modeToType(header.mode);
    if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
    if (!header.uid) header.uid = 0;
    if (!header.gid) header.gid = 0;
    if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
    if (typeof buffer === "string") buffer = Buffer.from(buffer);
    if (Buffer.isBuffer(buffer)) {
      header.size = buffer.length;
      this._encode(header);
      var ok = this.push(buffer);
      overflow(self2, header.size);
      if (ok) process.nextTick(callback);
      else this._drain = callback;
      return new Void();
    }
    if (header.type === "symlink" && !header.linkname) {
      var linkSink = new LinkSink();
      eos(linkSink, function(err) {
        if (err) {
          self2.destroy();
          return callback(err);
        }
        header.linkname = linkSink.linkname;
        self2._encode(header);
        callback();
      });
      return linkSink;
    }
    this._encode(header);
    if (header.type !== "file" && header.type !== "contiguous-file") {
      process.nextTick(callback);
      return new Void();
    }
    var sink = new Sink(this);
    this._stream = sink;
    eos(sink, function(err) {
      self2._stream = null;
      if (err) {
        self2.destroy();
        return callback(err);
      }
      if (sink.written !== header.size) {
        self2.destroy();
        return callback(new Error("size mismatch"));
      }
      overflow(self2, header.size);
      if (self2._finalizing) self2.finalize();
      callback();
    });
    return sink;
  };
  Pack.prototype.finalize = function() {
    if (this._stream) {
      this._finalizing = true;
      return;
    }
    if (this._finalized) return;
    this._finalized = true;
    this.push(END_OF_TAR);
    this.push(null);
  };
  Pack.prototype.destroy = function(err) {
    if (this._destroyed) return;
    this._destroyed = true;
    if (err) this.emit("error", err);
    this.emit("close");
    if (this._stream && this._stream.destroy) this._stream.destroy();
  };
  Pack.prototype._encode = function(header) {
    if (!header.pax) {
      var buf = headers2.encode(header);
      if (buf) {
        this.push(buf);
        return;
      }
    }
    this._encodePax(header);
  };
  Pack.prototype._encodePax = function(header) {
    var paxHeader = headers2.encodePax({
      name: header.name,
      linkname: header.linkname,
      pax: header.pax
    });
    var newHeader = {
      name: "PaxHeader",
      mode: header.mode,
      uid: header.uid,
      gid: header.gid,
      size: paxHeader.length,
      mtime: header.mtime,
      type: "pax-header",
      linkname: header.linkname && "PaxHeader",
      uname: header.uname,
      gname: header.gname,
      devmajor: header.devmajor,
      devminor: header.devminor
    };
    this.push(headers2.encode(newHeader));
    this.push(paxHeader);
    overflow(this, paxHeader.length);
    newHeader.size = header.size;
    newHeader.type = header.type;
    this.push(headers2.encode(newHeader));
  };
  Pack.prototype._read = function(n) {
    var drain = this._drain;
    this._drain = noop2;
    drain();
  };
  pack = Pack;
  return pack;
}
var hasRequiredTarStream;
function requireTarStream() {
  if (hasRequiredTarStream) return tarStream;
  hasRequiredTarStream = 1;
  tarStream.extract = requireExtract$1();
  tarStream.pack = requirePack();
  return tarStream;
}
/**
 * TAR Format Plugin
 *
 * @module plugins/tar
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var tar;
var hasRequiredTar;
function requireTar() {
  if (hasRequiredTar) return tar;
  hasRequiredTar = 1;
  var zlib$1 = zlib;
  var engine = requireTarStream();
  var util2 = requireArchiverUtils$1();
  var Tar = function(options) {
    if (!(this instanceof Tar)) {
      return new Tar(options);
    }
    options = this.options = util2.defaults(options, {
      gzip: false
    });
    if (typeof options.gzipOptions !== "object") {
      options.gzipOptions = {};
    }
    this.supports = {
      directory: true,
      symlink: true
    };
    this.engine = engine.pack(options);
    this.compressor = false;
    if (options.gzip) {
      this.compressor = zlib$1.createGzip(options.gzipOptions);
      this.compressor.on("error", this._onCompressorError.bind(this));
    }
  };
  Tar.prototype._onCompressorError = function(err) {
    this.engine.emit("error", err);
  };
  Tar.prototype.append = function(source, data2, callback) {
    var self2 = this;
    data2.mtime = data2.date;
    function append2(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      self2.engine.entry(data2, sourceBuffer, function(err2) {
        callback(err2, data2);
      });
    }
    if (data2.sourceType === "buffer") {
      append2(null, source);
    } else if (data2.sourceType === "stream" && data2.stats) {
      data2.size = data2.stats.size;
      var entry = self2.engine.entry(data2, function(err) {
        callback(err, data2);
      });
      source.pipe(entry);
    } else if (data2.sourceType === "stream") {
      util2.collectStream(source, append2);
    }
  };
  Tar.prototype.finalize = function() {
    this.engine.finalize();
  };
  Tar.prototype.on = function() {
    return this.engine.on.apply(this.engine, arguments);
  };
  Tar.prototype.pipe = function(destination, options) {
    if (this.compressor) {
      return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
    } else {
      return this.engine.pipe.apply(this.engine, arguments);
    }
  };
  Tar.prototype.unpipe = function() {
    if (this.compressor) {
      return this.compressor.unpipe.apply(this.compressor, arguments);
    } else {
      return this.engine.unpipe.apply(this.engine, arguments);
    }
  };
  tar = Tar;
  return tar;
}
/**
 * JSON Format Plugin
 *
 * @module plugins/json
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var json;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json;
  hasRequiredJson = 1;
  var inherits2 = require$$0$2.inherits;
  var Transform = requireReadable$4().Transform;
  var crc322 = requireBufferCrc32();
  var util2 = requireArchiverUtils$1();
  var Json = function(options) {
    if (!(this instanceof Json)) {
      return new Json(options);
    }
    options = this.options = util2.defaults(options, {});
    Transform.call(this, options);
    this.supports = {
      directory: true,
      symlink: true
    };
    this.files = [];
  };
  inherits2(Json, Transform);
  Json.prototype._transform = function(chunk, encoding, callback) {
    callback(null, chunk);
  };
  Json.prototype._writeStringified = function() {
    var fileString = JSON.stringify(this.files);
    this.write(fileString);
  };
  Json.prototype.append = function(source, data2, callback) {
    var self2 = this;
    data2.crc32 = 0;
    function onend(err, sourceBuffer) {
      if (err) {
        callback(err);
        return;
      }
      data2.size = sourceBuffer.length || 0;
      data2.crc32 = crc322.unsigned(sourceBuffer);
      self2.files.push(data2);
      callback(null, data2);
    }
    if (data2.sourceType === "buffer") {
      onend(null, source);
    } else if (data2.sourceType === "stream") {
      util2.collectStream(source, onend);
    }
  };
  Json.prototype.finalize = function() {
    this._writeStringified();
    this.end();
  };
  json = Json;
  return json;
}
/**
 * Archiver Vending
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
var archiver;
var hasRequiredArchiver;
function requireArchiver() {
  if (hasRequiredArchiver) return archiver;
  hasRequiredArchiver = 1;
  var Archiver = requireCore();
  var formats = {};
  var vending = function(format, options) {
    return vending.create(format, options);
  };
  vending.create = function(format, options) {
    if (formats[format]) {
      var instance = new Archiver(format, options);
      instance.setFormat(format);
      instance.setModule(new formats[format](options));
      return instance;
    } else {
      throw new Error("create(" + format + "): format not registered");
    }
  };
  vending.registerFormat = function(format, module) {
    if (formats[format]) {
      throw new Error("register(" + format + "): format already registered");
    }
    if (typeof module !== "function") {
      throw new Error("register(" + format + "): format module invalid");
    }
    if (typeof module.prototype.append !== "function" || typeof module.prototype.finalize !== "function") {
      throw new Error("register(" + format + "): format module missing methods");
    }
    formats[format] = module;
  };
  vending.isRegisteredFormat = function(format) {
    if (formats[format]) {
      return true;
    }
    return false;
  };
  vending.registerFormat("zip", requireZip());
  vending.registerFormat("tar", requireTar());
  vending.registerFormat("json", requireJson());
  archiver = vending;
  return archiver;
}
var sharedStrings;
var hasRequiredSharedStrings;
function requireSharedStrings() {
  if (hasRequiredSharedStrings) return sharedStrings;
  hasRequiredSharedStrings = 1;
  class SharedStrings {
    constructor() {
      this._values = [];
      this._totalRefs = 0;
      this._hash = /* @__PURE__ */ Object.create(null);
    }
    get count() {
      return this._values.length;
    }
    get values() {
      return this._values;
    }
    get totalRefs() {
      return this._totalRefs;
    }
    getString(index2) {
      return this._values[index2];
    }
    add(value) {
      let index2 = this._hash[value];
      if (index2 === void 0) {
        index2 = this._hash[value] = this._values.length;
        this._values.push(value);
      }
      this._totalRefs++;
      return index2;
    }
  }
  sharedStrings = SharedStrings;
  return sharedStrings;
}
var sheetRelsWriter;
var hasRequiredSheetRelsWriter;
function requireSheetRelsWriter() {
  if (hasRequiredSheetRelsWriter) return sheetRelsWriter;
  hasRequiredSheetRelsWriter = 1;
  const utils2 = requireUtils();
  const RelType = requireRelType();
  class HyperlinksProxy {
    constructor(sheetRelsWriter2) {
      this.writer = sheetRelsWriter2;
    }
    push(hyperlink) {
      this.writer.addHyperlink(hyperlink);
    }
  }
  class SheetRelsWriter {
    constructor(options) {
      this.id = options.id;
      this.count = 0;
      this._hyperlinks = [];
      this._workbook = options.workbook;
    }
    get stream() {
      if (!this._stream) {
        this._stream = this._workbook._openStream(`/xl/worksheets/_rels/sheet${this.id}.xml.rels`);
      }
      return this._stream;
    }
    get length() {
      return this._hyperlinks.length;
    }
    each(fn) {
      return this._hyperlinks.forEach(fn);
    }
    get hyperlinksProxy() {
      return this._hyperlinksProxy || (this._hyperlinksProxy = new HyperlinksProxy(this));
    }
    addHyperlink(hyperlink) {
      const relationship = {
        Target: hyperlink.target,
        Type: RelType.Hyperlink,
        TargetMode: "External"
      };
      const rId = this._writeRelationship(relationship);
      this._hyperlinks.push({
        rId,
        address: hyperlink.address
      });
    }
    addMedia(media) {
      return this._writeRelationship(media);
    }
    addRelationship(rel) {
      return this._writeRelationship(rel);
    }
    commit() {
      if (this.count) {
        this._writeClose();
        this.stream.end();
      }
    }
    // ================================================================================
    _writeOpen() {
      this.stream.write(
        `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
       <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">`
      );
    }
    _writeRelationship(relationship) {
      if (!this.count) {
        this._writeOpen();
      }
      const rId = `rId${++this.count}`;
      if (relationship.TargetMode) {
        this.stream.write(
          `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${utils2.xmlEncode(relationship.Target)}" TargetMode="${relationship.TargetMode}"/>`
        );
      } else {
        this.stream.write(
          `<Relationship Id="${rId}" Type="${relationship.Type}" Target="${relationship.Target}"/>`
        );
      }
      return rId;
    }
    _writeClose() {
      this.stream.write("</Relationships>");
    }
  }
  sheetRelsWriter = SheetRelsWriter;
  return sheetRelsWriter;
}
var sheetCommentsWriter;
var hasRequiredSheetCommentsWriter;
function requireSheetCommentsWriter() {
  if (hasRequiredSheetCommentsWriter) return sheetCommentsWriter;
  hasRequiredSheetCommentsWriter = 1;
  const XmlStream = requireXmlStream();
  const RelType = requireRelType();
  const colCache = requireColCache();
  const CommentXform = requireCommentXform();
  const VmlShapeXform = requireVmlShapeXform();
  class SheetCommentsWriter {
    constructor(worksheet2, sheetRelsWriter2, options) {
      this.id = options.id;
      this.count = 0;
      this._worksheet = worksheet2;
      this._workbook = options.workbook;
      this._sheetRelsWriter = sheetRelsWriter2;
    }
    get commentsStream() {
      if (!this._commentsStream) {
        this._commentsStream = this._workbook._openStream(`/xl/comments${this.id}.xml`);
      }
      return this._commentsStream;
    }
    get vmlStream() {
      if (!this._vmlStream) {
        this._vmlStream = this._workbook._openStream(`xl/drawings/vmlDrawing${this.id}.vml`);
      }
      return this._vmlStream;
    }
    _addRelationships() {
      const commentRel = {
        Type: RelType.Comments,
        Target: `../comments${this.id}.xml`
      };
      this._sheetRelsWriter.addRelationship(commentRel);
      const vmlDrawingRel = {
        Type: RelType.VmlDrawing,
        Target: `../drawings/vmlDrawing${this.id}.vml`
      };
      this.vmlRelId = this._sheetRelsWriter.addRelationship(vmlDrawingRel);
    }
    _addCommentRefs() {
      this._workbook.commentRefs.push({
        commentName: `comments${this.id}`,
        vmlDrawing: `vmlDrawing${this.id}`
      });
    }
    _writeOpen() {
      this.commentsStream.write(
        '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"><authors><author>Author</author></authors><commentList>'
      );
      this.vmlStream.write(
        '<?xml version="1.0" encoding="UTF-8"?><xml xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:v="urn:schemas-microsoft-com:vml" xmlns:x="urn:schemas-microsoft-com:office:excel"><o:shapelayout v:ext="edit"><o:idmap v:ext="edit" data="1" /></o:shapelayout><v:shapetype id="_x0000_t202" coordsize="21600,21600" o:spt="202" path="m,l,21600r21600,l21600,xe"><v:stroke joinstyle="miter" /><v:path gradientshapeok="t" o:connecttype="rect" /></v:shapetype>'
      );
    }
    _writeComment(comment, index2) {
      const commentXform2 = new CommentXform();
      const commentsXmlStream = new XmlStream();
      commentXform2.render(commentsXmlStream, comment);
      this.commentsStream.write(commentsXmlStream.xml);
      const vmlShapeXform2 = new VmlShapeXform();
      const vmlXmlStream = new XmlStream();
      vmlShapeXform2.render(vmlXmlStream, comment, index2);
      this.vmlStream.write(vmlXmlStream.xml);
    }
    _writeClose() {
      this.commentsStream.write("</commentList></comments>");
      this.vmlStream.write("</xml>");
    }
    addComments(comments) {
      if (comments && comments.length) {
        if (!this.startedData) {
          this._worksheet.comments = [];
          this._writeOpen();
          this._addRelationships();
          this._addCommentRefs();
          this.startedData = true;
        }
        comments.forEach((item) => {
          item.refAddress = colCache.decodeAddress(item.ref);
        });
        comments.forEach((comment) => {
          this._writeComment(comment, this.count);
          this.count += 1;
        });
      }
    }
    commit() {
      if (this.count) {
        this._writeClose();
        this.commentsStream.end();
        this.vmlStream.end();
      }
    }
  }
  sheetCommentsWriter = SheetCommentsWriter;
  return sheetCommentsWriter;
}
var worksheetWriter;
var hasRequiredWorksheetWriter;
function requireWorksheetWriter() {
  if (hasRequiredWorksheetWriter) return worksheetWriter;
  hasRequiredWorksheetWriter = 1;
  const _2 = requireUnderDash();
  const RelType = requireRelType();
  const colCache = requireColCache();
  const Encryptor = requireEncryptor();
  const Dimensions = requireRange();
  const StringBuf = requireStringBuf();
  const Row = requireRow();
  const Column = requireColumn$1();
  const SheetRelsWriter = requireSheetRelsWriter();
  const SheetCommentsWriter = requireSheetCommentsWriter();
  const DataValidations = requireDataValidations();
  const xmlBuffer = new StringBuf();
  const ListXform = requireListXform();
  const DataValidationsXform = requireDataValidationsXform();
  const SheetPropertiesXform = requireSheetPropertiesXform();
  const SheetFormatPropertiesXform = requireSheetFormatPropertiesXform();
  const ColXform = requireColXform();
  const RowXform = requireRowXform();
  const HyperlinkXform = requireHyperlinkXform();
  const SheetViewXform = requireSheetViewXform();
  const SheetProtectionXform = requireSheetProtectionXform();
  const PageMarginsXform = requirePageMarginsXform();
  const PageSetupXform = requirePageSetupXform();
  const AutoFilterXform = requireAutoFilterXform$1();
  const PictureXform = requirePictureXform();
  const ConditionalFormattingsXform = requireConditionalFormattingsXform();
  const HeaderFooterXform = requireHeaderFooterXform();
  const RowBreaksXform = requireRowBreaksXform();
  const xform = {
    dataValidations: new DataValidationsXform(),
    sheetProperties: new SheetPropertiesXform(),
    sheetFormatProperties: new SheetFormatPropertiesXform(),
    columns: new ListXform({ tag: "cols", length: false, childXform: new ColXform() }),
    row: new RowXform(),
    hyperlinks: new ListXform({ tag: "hyperlinks", length: false, childXform: new HyperlinkXform() }),
    sheetViews: new ListXform({ tag: "sheetViews", length: false, childXform: new SheetViewXform() }),
    sheetProtection: new SheetProtectionXform(),
    pageMargins: new PageMarginsXform(),
    pageSeteup: new PageSetupXform(),
    autoFilter: new AutoFilterXform(),
    picture: new PictureXform(),
    conditionalFormattings: new ConditionalFormattingsXform(),
    headerFooter: new HeaderFooterXform(),
    rowBreaks: new RowBreaksXform()
  };
  class WorksheetWriter {
    constructor(options) {
      this.id = options.id;
      this.name = options.name || `Sheet${this.id}`;
      this.state = options.state || "visible";
      this._rows = [];
      this._columns = null;
      this._keys = {};
      this._merges = [];
      this._merges.add = function() {
      };
      this._sheetRelsWriter = new SheetRelsWriter(options);
      this._sheetCommentsWriter = new SheetCommentsWriter(this, this._sheetRelsWriter, options);
      this._dimensions = new Dimensions();
      this._rowZero = 1;
      this.committed = false;
      this.dataValidations = new DataValidations();
      this._formulae = {};
      this._siFormulae = 0;
      this.conditionalFormatting = [];
      this.rowBreaks = [];
      this.properties = Object.assign(
        {},
        {
          defaultRowHeight: 15,
          dyDescent: 55,
          outlineLevelCol: 0,
          outlineLevelRow: 0
        },
        options.properties
      );
      this.headerFooter = Object.assign(
        {},
        {
          differentFirst: false,
          differentOddEven: false,
          oddHeader: null,
          oddFooter: null,
          evenHeader: null,
          evenFooter: null,
          firstHeader: null,
          firstFooter: null
        },
        options.headerFooter
      );
      this.pageSetup = Object.assign(
        {},
        {
          margins: { left: 0.7, right: 0.7, top: 0.75, bottom: 0.75, header: 0.3, footer: 0.3 },
          orientation: "portrait",
          horizontalDpi: 4294967295,
          verticalDpi: 4294967295,
          fitToPage: !!(options.pageSetup && (options.pageSetup.fitToWidth || options.pageSetup.fitToHeight) && !options.pageSetup.scale),
          pageOrder: "downThenOver",
          blackAndWhite: false,
          draft: false,
          cellComments: "None",
          errors: "displayed",
          scale: 100,
          fitToWidth: 1,
          fitToHeight: 1,
          paperSize: void 0,
          showRowColHeaders: false,
          showGridLines: false,
          horizontalCentered: false,
          verticalCentered: false,
          rowBreaks: null,
          colBreaks: null
        },
        options.pageSetup
      );
      this.useSharedStrings = options.useSharedStrings || false;
      this._workbook = options.workbook;
      this.hasComments = false;
      this._views = options.views || [];
      this.autoFilter = options.autoFilter || null;
      this._media = [];
      this.sheetProtection = null;
      this._writeOpenWorksheet();
      this.startedData = false;
    }
    get workbook() {
      return this._workbook;
    }
    get stream() {
      if (!this._stream) {
        this._stream = this._workbook._openStream(`/xl/worksheets/sheet${this.id}.xml`);
        this._stream.pause();
      }
      return this._stream;
    }
    // destroy - not a valid operation for a streaming writer
    // even though some streamers might be able to, it's a bad idea.
    destroy() {
      throw new Error("Invalid Operation: destroy");
    }
    commit() {
      if (this.committed) {
        return;
      }
      this._rows.forEach((cRow) => {
        if (cRow) {
          this._writeRow(cRow);
        }
      });
      this._rows = null;
      if (!this.startedData) {
        this._writeOpenSheetData();
      }
      this._writeCloseSheetData();
      this._writeAutoFilter();
      this._writeMergeCells();
      this._writeHyperlinks();
      this._writeConditionalFormatting();
      this._writeDataValidations();
      this._writeSheetProtection();
      this._writePageMargins();
      this._writePageSetup();
      this._writeBackground();
      this._writeHeaderFooter();
      this._writeRowBreaks();
      this._writeLegacyData();
      this._writeCloseWorksheet();
      this.stream.end();
      this._sheetCommentsWriter.commit();
      this._sheetRelsWriter.commit();
      this.committed = true;
    }
    // return the current dimensions of the writer
    get dimensions() {
      return this._dimensions;
    }
    get views() {
      return this._views;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
      return this._columns;
    }
    // set the columns from an array of column definitions.
    // Note: any headers defined will overwrite existing values.
    set columns(value) {
      this._headerRowCount = value.reduce((pv, cv) => {
        const headerCount = cv.header && 1 || cv.headers && cv.headers.length || 0;
        return Math.max(pv, headerCount);
      }, 0);
      let count = 1;
      const columns = this._columns = [];
      value.forEach((defn) => {
        const column2 = new Column(this, count++, false);
        columns.push(column2);
        column2.defn = defn;
      });
    }
    getColumnKey(key) {
      return this._keys[key];
    }
    setColumnKey(key, value) {
      this._keys[key] = value;
    }
    deleteColumnKey(key) {
      delete this._keys[key];
    }
    eachColumnKey(f) {
      _2.each(this._keys, f);
    }
    // get a single column by col number. If it doesn't exist, it and any gaps before it
    // are created.
    getColumn(c) {
      if (typeof c === "string") {
        const col = this._keys[c];
        if (col) return col;
        c = colCache.l2n(c);
      }
      if (!this._columns) {
        this._columns = [];
      }
      if (c > this._columns.length) {
        let n = this._columns.length + 1;
        while (n <= c) {
          this._columns.push(new Column(this, n++));
        }
      }
      return this._columns[c - 1];
    }
    // =========================================================================
    // Rows
    get _nextRow() {
      return this._rowZero + this._rows.length;
    }
    // iterate over every uncommitted row in the worksheet, including maybe empty rows
    eachRow(options, iteratee) {
      if (!iteratee) {
        iteratee = options;
        options = void 0;
      }
      if (options && options.includeEmpty) {
        const n = this._nextRow;
        for (let i = this._rowZero; i < n; i++) {
          iteratee(this.getRow(i), i);
        }
      } else {
        this._rows.forEach((row2) => {
          if (row2.hasValues) {
            iteratee(row2, row2.number);
          }
        });
      }
    }
    _commitRow(cRow) {
      let found = false;
      while (this._rows.length && !found) {
        const row2 = this._rows.shift();
        this._rowZero++;
        if (row2) {
          this._writeRow(row2);
          found = row2.number === cRow.number;
          this._rowZero = row2.number + 1;
        }
      }
    }
    get lastRow() {
      if (this._rows.length) {
        return this._rows[this._rows.length - 1];
      }
      return void 0;
    }
    // find a row (if exists) by row number
    findRow(rowNumber) {
      const index2 = rowNumber - this._rowZero;
      return this._rows[index2];
    }
    getRow(rowNumber) {
      const index2 = rowNumber - this._rowZero;
      if (index2 < 0) {
        throw new Error("Out of bounds: this row has been committed");
      }
      let row2 = this._rows[index2];
      if (!row2) {
        this._rows[index2] = row2 = new Row(this, rowNumber);
      }
      return row2;
    }
    addRow(value) {
      const row2 = new Row(this, this._nextRow);
      this._rows[row2.number - this._rowZero] = row2;
      row2.values = value;
      return row2;
    }
    // ================================================================================
    // Cells
    // returns the cell at [r,c] or address given by r. If not found, return undefined
    findCell(r, c) {
      const address = colCache.getAddress(r, c);
      const row2 = this.findRow(address.row);
      return row2 ? row2.findCell(address.column) : void 0;
    }
    // return the cell at [r,c] or address given by r. If not found, create a new one.
    getCell(r, c) {
      const address = colCache.getAddress(r, c);
      const row2 = this.getRow(address.row);
      return row2.getCellEx(address);
    }
    mergeCells(...cells) {
      const dimensions = new Dimensions(cells);
      this._merges.forEach((merge2) => {
        if (merge2.intersects(dimensions)) {
          throw new Error("Cannot merge already merged cells");
        }
      });
      const master = this.getCell(dimensions.top, dimensions.left);
      for (let i = dimensions.top; i <= dimensions.bottom; i++) {
        for (let j = dimensions.left; j <= dimensions.right; j++) {
          if (i > dimensions.top || j > dimensions.left) {
            this.getCell(i, j).merge(master);
          }
        }
      }
      this._merges.push(dimensions);
    }
    // ===========================================================================
    // Conditional Formatting
    addConditionalFormatting(cf) {
      this.conditionalFormatting.push(cf);
    }
    removeConditionalFormatting(filter3) {
      if (typeof filter3 === "number") {
        this.conditionalFormatting.splice(filter3, 1);
      } else if (filter3 instanceof Function) {
        this.conditionalFormatting = this.conditionalFormatting.filter(filter3);
      } else {
        this.conditionalFormatting = [];
      }
    }
    // =========================================================================
    addBackgroundImage(imageId) {
      this._background = {
        imageId
      };
    }
    getBackgroundImageId() {
      return this._background && this._background.imageId;
    }
    // =========================================================================
    // Worksheet Protection
    protect(password, options) {
      return new Promise((resolve) => {
        this.sheetProtection = {
          sheet: true
        };
        if (options && "spinCount" in options) {
          options.spinCount = Number.isFinite(options.spinCount) ? Math.round(Math.max(0, options.spinCount)) : 1e5;
        }
        if (password) {
          this.sheetProtection.algorithmName = "SHA-512";
          this.sheetProtection.saltValue = Encryptor.randomBytes(16).toString("base64");
          this.sheetProtection.spinCount = options && "spinCount" in options ? options.spinCount : 1e5;
          this.sheetProtection.hashValue = Encryptor.convertPasswordToHash(
            password,
            "SHA512",
            this.sheetProtection.saltValue,
            this.sheetProtection.spinCount
          );
        }
        if (options) {
          this.sheetProtection = Object.assign(this.sheetProtection, options);
          if (!password && "spinCount" in options) {
            delete this.sheetProtection.spinCount;
          }
        }
        resolve();
      });
    }
    unprotect() {
      this.sheetProtection = null;
    }
    // ================================================================================
    _write(text) {
      xmlBuffer.reset();
      xmlBuffer.addText(text);
      this.stream.write(xmlBuffer);
    }
    _writeSheetProperties(xmlBuf, properties, pageSetup) {
      const sheetPropertiesModel = {
        outlineProperties: properties && properties.outlineProperties,
        tabColor: properties && properties.tabColor,
        pageSetup: pageSetup && pageSetup.fitToPage ? {
          fitToPage: pageSetup.fitToPage
        } : void 0
      };
      xmlBuf.addText(xform.sheetProperties.toXml(sheetPropertiesModel));
    }
    _writeSheetFormatProperties(xmlBuf, properties) {
      const sheetFormatPropertiesModel = properties ? {
        defaultRowHeight: properties.defaultRowHeight,
        dyDescent: properties.dyDescent,
        outlineLevelCol: properties.outlineLevelCol,
        outlineLevelRow: properties.outlineLevelRow
      } : void 0;
      if (properties.defaultColWidth) {
        sheetFormatPropertiesModel.defaultColWidth = properties.defaultColWidth;
      }
      xmlBuf.addText(xform.sheetFormatProperties.toXml(sheetFormatPropertiesModel));
    }
    _writeOpenWorksheet() {
      xmlBuffer.reset();
      xmlBuffer.addText('<?xml version="1.0" encoding="UTF-8" standalone="yes"?>');
      xmlBuffer.addText(
        '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" mc:Ignorable="x14ac" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">'
      );
      this._writeSheetProperties(xmlBuffer, this.properties, this.pageSetup);
      xmlBuffer.addText(xform.sheetViews.toXml(this.views));
      this._writeSheetFormatProperties(xmlBuffer, this.properties);
      this.stream.write(xmlBuffer);
    }
    _writeColumns() {
      const cols = Column.toModel(this.columns);
      if (cols) {
        xform.columns.prepare(cols, { styles: this._workbook.styles });
        this.stream.write(xform.columns.toXml(cols));
      }
    }
    _writeOpenSheetData() {
      this._write("<sheetData>");
    }
    _writeRow(row2) {
      if (!this.startedData) {
        this._writeColumns();
        this._writeOpenSheetData();
        this.startedData = true;
      }
      if (row2.hasValues || row2.height) {
        const { model } = row2;
        const options = {
          styles: this._workbook.styles,
          sharedStrings: this.useSharedStrings ? this._workbook.sharedStrings : void 0,
          hyperlinks: this._sheetRelsWriter.hyperlinksProxy,
          merges: this._merges,
          formulae: this._formulae,
          siFormulae: this._siFormulae,
          comments: []
        };
        xform.row.prepare(model, options);
        this.stream.write(xform.row.toXml(model));
        if (options.comments.length) {
          this.hasComments = true;
          this._sheetCommentsWriter.addComments(options.comments);
        }
      }
    }
    _writeCloseSheetData() {
      this._write("</sheetData>");
    }
    _writeMergeCells() {
      if (this._merges.length) {
        xmlBuffer.reset();
        xmlBuffer.addText(`<mergeCells count="${this._merges.length}">`);
        this._merges.forEach((merge2) => {
          xmlBuffer.addText(`<mergeCell ref="${merge2}"/>`);
        });
        xmlBuffer.addText("</mergeCells>");
        this.stream.write(xmlBuffer);
      }
    }
    _writeHyperlinks() {
      this.stream.write(xform.hyperlinks.toXml(this._sheetRelsWriter._hyperlinks));
    }
    _writeConditionalFormatting() {
      const options = {
        styles: this._workbook.styles
      };
      xform.conditionalFormattings.prepare(this.conditionalFormatting, options);
      this.stream.write(xform.conditionalFormattings.toXml(this.conditionalFormatting));
    }
    _writeRowBreaks() {
      this.stream.write(xform.rowBreaks.toXml(this.rowBreaks));
    }
    _writeDataValidations() {
      this.stream.write(xform.dataValidations.toXml(this.dataValidations.model));
    }
    _writeSheetProtection() {
      this.stream.write(xform.sheetProtection.toXml(this.sheetProtection));
    }
    _writePageMargins() {
      this.stream.write(xform.pageMargins.toXml(this.pageSetup.margins));
    }
    _writePageSetup() {
      this.stream.write(xform.pageSeteup.toXml(this.pageSetup));
    }
    _writeHeaderFooter() {
      this.stream.write(xform.headerFooter.toXml(this.headerFooter));
    }
    _writeAutoFilter() {
      this.stream.write(xform.autoFilter.toXml(this.autoFilter));
    }
    _writeBackground() {
      if (this._background) {
        if (this._background.imageId !== void 0) {
          const image2 = this._workbook.getImage(this._background.imageId);
          const pictureId = this._sheetRelsWriter.addMedia({
            Target: `../media/${image2.name}`,
            Type: RelType.Image
          });
          this._background = {
            ...this._background,
            rId: pictureId
          };
        }
        this.stream.write(xform.picture.toXml({ rId: this._background.rId }));
      }
    }
    _writeLegacyData() {
      if (this.hasComments) {
        xmlBuffer.reset();
        xmlBuffer.addText(`<legacyDrawing r:id="${this._sheetCommentsWriter.vmlRelId}"/>`);
        this.stream.write(xmlBuffer);
      }
    }
    _writeDimensions() {
    }
    _writeCloseWorksheet() {
      this._write("</worksheet>");
    }
  }
  worksheetWriter = WorksheetWriter;
  return worksheetWriter;
}
var workbookWriter;
var hasRequiredWorkbookWriter;
function requireWorkbookWriter() {
  if (hasRequiredWorkbookWriter) return workbookWriter;
  hasRequiredWorkbookWriter = 1;
  const fs2 = require$$0$4;
  const Archiver = requireArchiver();
  const StreamBuf = requireStreamBuf();
  const RelType = requireRelType();
  const StylesXform = requireStylesXform();
  const SharedStrings = requireSharedStrings();
  const DefinedNames = requireDefinedNames();
  const CoreXform = requireCoreXform();
  const RelationshipsXform = requireRelationshipsXform();
  const ContentTypesXform = requireContentTypesXform();
  const AppXform = requireAppXform();
  const WorkbookXform = requireWorkbookXform();
  const SharedStringsXform = requireSharedStringsXform();
  const WorksheetWriter = requireWorksheetWriter();
  const theme1Xml = requireTheme1();
  class WorkbookWriter {
    constructor(options) {
      options = options || {};
      this.created = options.created || /* @__PURE__ */ new Date();
      this.modified = options.modified || this.created;
      this.creator = options.creator || "ExcelJS";
      this.lastModifiedBy = options.lastModifiedBy || "ExcelJS";
      this.lastPrinted = options.lastPrinted;
      this.useSharedStrings = options.useSharedStrings || false;
      this.sharedStrings = new SharedStrings();
      this.styles = options.useStyles ? new StylesXform(true) : new StylesXform.Mock(true);
      this._definedNames = new DefinedNames();
      this._worksheets = [];
      this.views = [];
      this.zipOptions = options.zip;
      this.media = [];
      this.commentRefs = [];
      this.zip = Archiver("zip", this.zipOptions);
      if (options.stream) {
        this.stream = options.stream;
      } else if (options.filename) {
        this.stream = fs2.createWriteStream(options.filename);
      } else {
        this.stream = new StreamBuf();
      }
      this.zip.pipe(this.stream);
      this.promise = Promise.all([this.addThemes(), this.addOfficeRels()]);
    }
    get definedNames() {
      return this._definedNames;
    }
    _openStream(path2) {
      const stream2 = new StreamBuf({ bufSize: 65536, batch: true });
      this.zip.append(stream2, { name: path2 });
      stream2.on("finish", () => {
        stream2.emit("zipped");
      });
      return stream2;
    }
    _commitWorksheets() {
      const commitWorksheet = function(worksheet2) {
        if (!worksheet2.committed) {
          return new Promise((resolve) => {
            worksheet2.stream.on("zipped", () => {
              resolve();
            });
            worksheet2.commit();
          });
        }
        return Promise.resolve();
      };
      const promises = this._worksheets.map(commitWorksheet);
      if (promises.length) {
        return Promise.all(promises);
      }
      return Promise.resolve();
    }
    async commit() {
      await this.promise;
      await this.addMedia();
      await this._commitWorksheets();
      await Promise.all([
        this.addContentTypes(),
        this.addApp(),
        this.addCore(),
        this.addSharedStrings(),
        this.addStyles(),
        this.addWorkbookRels()
      ]);
      await this.addWorkbook();
      return this._finalize();
    }
    get nextId() {
      let i;
      for (i = 1; i < this._worksheets.length; i++) {
        if (!this._worksheets[i]) {
          return i;
        }
      }
      return this._worksheets.length || 1;
    }
    addImage(image2) {
      const id = this.media.length;
      const medium = Object.assign({}, image2, { type: "image", name: `image${id}.${image2.extension}` });
      this.media.push(medium);
      return id;
    }
    getImage(id) {
      return this.media[id];
    }
    addWorksheet(name, options) {
      options = options || {};
      const useSharedStrings = options.useSharedStrings !== void 0 ? options.useSharedStrings : this.useSharedStrings;
      if (options.tabColor) {
        console.trace("tabColor option has moved to { properties: tabColor: {...} }");
        options.properties = Object.assign(
          {
            tabColor: options.tabColor
          },
          options.properties
        );
      }
      const id = this.nextId;
      name = name || `sheet${id}`;
      const worksheet2 = new WorksheetWriter({
        id,
        name,
        workbook: this,
        useSharedStrings,
        properties: options.properties,
        state: options.state,
        pageSetup: options.pageSetup,
        views: options.views,
        autoFilter: options.autoFilter,
        headerFooter: options.headerFooter
      });
      this._worksheets[id] = worksheet2;
      return worksheet2;
    }
    getWorksheet(id) {
      if (id === void 0) {
        return this._worksheets.find(() => true);
      }
      if (typeof id === "number") {
        return this._worksheets[id];
      }
      if (typeof id === "string") {
        return this._worksheets.find((worksheet2) => worksheet2 && worksheet2.name === id);
      }
      return void 0;
    }
    addStyles() {
      return new Promise((resolve) => {
        this.zip.append(this.styles.xml, { name: "xl/styles.xml" });
        resolve();
      });
    }
    addThemes() {
      return new Promise((resolve) => {
        this.zip.append(theme1Xml, { name: "xl/theme/theme1.xml" });
        resolve();
      });
    }
    addOfficeRels() {
      return new Promise((resolve) => {
        const xform = new RelationshipsXform();
        const xml = xform.toXml([
          { Id: "rId1", Type: RelType.OfficeDocument, Target: "xl/workbook.xml" },
          { Id: "rId2", Type: RelType.CoreProperties, Target: "docProps/core.xml" },
          { Id: "rId3", Type: RelType.ExtenderProperties, Target: "docProps/app.xml" }
        ]);
        this.zip.append(xml, { name: "/_rels/.rels" });
        resolve();
      });
    }
    addContentTypes() {
      return new Promise((resolve) => {
        const model = {
          worksheets: this._worksheets.filter(Boolean),
          sharedStrings: this.sharedStrings,
          commentRefs: this.commentRefs,
          media: this.media
        };
        const xform = new ContentTypesXform();
        const xml = xform.toXml(model);
        this.zip.append(xml, { name: "[Content_Types].xml" });
        resolve();
      });
    }
    addMedia() {
      return Promise.all(
        this.media.map((medium) => {
          if (medium.type === "image") {
            const filename = `xl/media/${medium.name}`;
            if (medium.filename) {
              return this.zip.file(medium.filename, { name: filename });
            }
            if (medium.buffer) {
              return this.zip.append(medium.buffer, { name: filename });
            }
            if (medium.base64) {
              const dataimg64 = medium.base64;
              const content = dataimg64.substring(dataimg64.indexOf(",") + 1);
              return this.zip.append(content, { name: filename, base64: true });
            }
          }
          throw new Error("Unsupported media");
        })
      );
    }
    addApp() {
      return new Promise((resolve) => {
        const model = {
          worksheets: this._worksheets.filter(Boolean)
        };
        const xform = new AppXform();
        const xml = xform.toXml(model);
        this.zip.append(xml, { name: "docProps/app.xml" });
        resolve();
      });
    }
    addCore() {
      return new Promise((resolve) => {
        const coreXform2 = new CoreXform();
        const xml = coreXform2.toXml(this);
        this.zip.append(xml, { name: "docProps/core.xml" });
        resolve();
      });
    }
    addSharedStrings() {
      if (this.sharedStrings.count) {
        return new Promise((resolve) => {
          const sharedStringsXform2 = new SharedStringsXform();
          const xml = sharedStringsXform2.toXml(this.sharedStrings);
          this.zip.append(xml, { name: "/xl/sharedStrings.xml" });
          resolve();
        });
      }
      return Promise.resolve();
    }
    addWorkbookRels() {
      let count = 1;
      const relationships = [
        { Id: `rId${count++}`, Type: RelType.Styles, Target: "styles.xml" },
        { Id: `rId${count++}`, Type: RelType.Theme, Target: "theme/theme1.xml" }
      ];
      if (this.sharedStrings.count) {
        relationships.push({
          Id: `rId${count++}`,
          Type: RelType.SharedStrings,
          Target: "sharedStrings.xml"
        });
      }
      this._worksheets.forEach((worksheet2) => {
        if (worksheet2) {
          worksheet2.rId = `rId${count++}`;
          relationships.push({
            Id: worksheet2.rId,
            Type: RelType.Worksheet,
            Target: `worksheets/sheet${worksheet2.id}.xml`
          });
        }
      });
      return new Promise((resolve) => {
        const xform = new RelationshipsXform();
        const xml = xform.toXml(relationships);
        this.zip.append(xml, { name: "/xl/_rels/workbook.xml.rels" });
        resolve();
      });
    }
    addWorkbook() {
      const { zip: zip2 } = this;
      const model = {
        worksheets: this._worksheets.filter(Boolean),
        definedNames: this._definedNames.model,
        views: this.views,
        properties: {},
        calcProperties: {}
      };
      return new Promise((resolve) => {
        const xform = new WorkbookXform();
        xform.prepare(model);
        zip2.append(xform.toXml(model), { name: "/xl/workbook.xml" });
        resolve();
      });
    }
    _finalize() {
      return new Promise((resolve, reject2) => {
        this.stream.on("error", reject2);
        this.stream.on("finish", () => {
          resolve(this);
        });
        this.zip.on("error", reject2);
        this.zip.finalize();
      });
    }
  }
  workbookWriter = WorkbookWriter;
  return workbookWriter;
}
var unzip$1 = {};
var listenercount;
var hasRequiredListenercount;
function requireListenercount() {
  if (hasRequiredListenercount) return listenercount;
  hasRequiredListenercount = 1;
  var listenerCount = require$$2$1.listenerCount;
  listenerCount = listenerCount || function(ee, event) {
    var listeners = ee && ee._events && ee._events[event];
    if (Array.isArray(listeners)) {
      return listeners.length;
    } else if (typeof listeners === "function") {
      return 1;
    } else {
      return 0;
    }
  };
  listenercount = listenerCount;
  return listenercount;
}
var bufferIndexofPolyfill = {};
var initBuffer;
var hasRequiredInitBuffer;
function requireInitBuffer() {
  if (hasRequiredInitBuffer) return initBuffer;
  hasRequiredInitBuffer = 1;
  initBuffer = function initBuffer2(val) {
    var nodeVersion = process && process.version ? process.version : "v5.0.0";
    var major = nodeVersion.split(".")[0].replace("v", "");
    return major < 6 ? new Buffer(val) : Buffer.from(val);
  };
  return initBuffer;
}
var hasRequiredBufferIndexofPolyfill;
function requireBufferIndexofPolyfill() {
  if (hasRequiredBufferIndexofPolyfill) return bufferIndexofPolyfill;
  hasRequiredBufferIndexofPolyfill = 1;
  var initBuffer2 = requireInitBuffer();
  if (!Buffer.prototype.indexOf) {
    Buffer.prototype.indexOf = function(value, offset) {
      offset = offset || 0;
      if (typeof value === "string" || value instanceof String) {
        value = initBuffer2(value);
      } else if (typeof value === "number" || value instanceof Number) {
        value = initBuffer2([value]);
      }
      var len = value.length;
      for (var i = offset; i <= this.length - len; i++) {
        var mismatch = false;
        for (var j = 0; j < len; j++) {
          if (this[i + j] != value[j]) {
            mismatch = true;
            break;
          }
        }
        if (!mismatch) {
          return i;
        }
      }
      return -1;
    };
  }
  function bufferLastIndexOf(value, offset) {
    if (typeof value === "string" || value instanceof String) {
      value = initBuffer2(value);
    } else if (typeof value === "number" || value instanceof Number) {
      value = initBuffer2([value]);
    }
    var len = value.length;
    offset = offset || this.length - len;
    for (var i = offset; i >= 0; i--) {
      var mismatch = false;
      for (var j = 0; j < len; j++) {
        if (this[i + j] != value[j]) {
          mismatch = true;
          break;
        }
      }
      if (!mismatch) {
        return i;
      }
    }
    return -1;
  }
  if (Buffer.prototype.lastIndexOf) {
    if (initBuffer2("ABC").lastIndexOf("ABC") === -1)
      Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  } else {
    Buffer.prototype.lastIndexOf = bufferLastIndexOf;
  }
  return bufferIndexofPolyfill;
}
var binary = { exports: {} };
var traverse;
var hasRequiredTraverse;
function requireTraverse() {
  if (hasRequiredTraverse) return traverse;
  hasRequiredTraverse = 1;
  traverse = Traverse;
  function Traverse(obj) {
    if (!(this instanceof Traverse)) return new Traverse(obj);
    this.value = obj;
  }
  Traverse.prototype.get = function(ps) {
    var node2 = this.value;
    for (var i = 0; i < ps.length; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node2, key)) {
        node2 = void 0;
        break;
      }
      node2 = node2[key];
    }
    return node2;
  };
  Traverse.prototype.set = function(ps, value) {
    var node2 = this.value;
    for (var i = 0; i < ps.length - 1; i++) {
      var key = ps[i];
      if (!Object.hasOwnProperty.call(node2, key)) node2[key] = {};
      node2 = node2[key];
    }
    node2[ps[i]] = value;
    return value;
  };
  Traverse.prototype.map = function(cb) {
    return walk(this.value, cb, true);
  };
  Traverse.prototype.forEach = function(cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
  };
  Traverse.prototype.reduce = function(cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function(x) {
      if (!this.isRoot || !skip) {
        acc = cb.call(this, acc, x);
      }
    });
    return acc;
  };
  Traverse.prototype.deepEqual = function(obj) {
    if (arguments.length !== 1) {
      throw new Error(
        "deepEqual requires exactly one object to compare against"
      );
    }
    var equal = true;
    var node2 = obj;
    this.forEach(function(y) {
      var notEqual = (function() {
        equal = false;
        return void 0;
      }).bind(this);
      if (!this.isRoot) {
        if (typeof node2 !== "object") return notEqual();
        node2 = node2[this.key];
      }
      var x = node2;
      this.post(function() {
        node2 = x;
      });
      var toS = function(o) {
        return Object.prototype.toString.call(o);
      };
      if (this.circular) {
        if (Traverse(obj).get(this.circular.path) !== x) notEqual();
      } else if (typeof x !== typeof y) {
        notEqual();
      } else if (x === null || y === null || x === void 0 || y === void 0) {
        if (x !== y) notEqual();
      } else if (x.__proto__ !== y.__proto__) {
        notEqual();
      } else if (x === y) ;
      else if (typeof x === "function") {
        if (x instanceof RegExp) {
          if (x.toString() != y.toString()) notEqual();
        } else if (x !== y) notEqual();
      } else if (typeof x === "object") {
        if (toS(y) === "[object Arguments]" || toS(x) === "[object Arguments]") {
          if (toS(x) !== toS(y)) {
            notEqual();
          }
        } else if (x instanceof Date || y instanceof Date) {
          if (!(x instanceof Date) || !(y instanceof Date) || x.getTime() !== y.getTime()) {
            notEqual();
          }
        } else {
          var kx = Object.keys(x);
          var ky = Object.keys(y);
          if (kx.length !== ky.length) return notEqual();
          for (var i = 0; i < kx.length; i++) {
            var k = kx[i];
            if (!Object.hasOwnProperty.call(y, k)) {
              notEqual();
            }
          }
        }
      }
    });
    return equal;
  };
  Traverse.prototype.paths = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.path);
    });
    return acc;
  };
  Traverse.prototype.nodes = function() {
    var acc = [];
    this.forEach(function(x) {
      acc.push(this.node);
    });
    return acc;
  };
  Traverse.prototype.clone = function() {
    var parents = [], nodes = [];
    return function clone(src2) {
      for (var i = 0; i < parents.length; i++) {
        if (parents[i] === src2) {
          return nodes[i];
        }
      }
      if (typeof src2 === "object" && src2 !== null) {
        var dst = copy(src2);
        parents.push(src2);
        nodes.push(dst);
        Object.keys(src2).forEach(function(key) {
          dst[key] = clone(src2[key]);
        });
        parents.pop();
        nodes.pop();
        return dst;
      } else {
        return src2;
      }
    }(this.value);
  };
  function walk(root, cb, immutable) {
    var path2 = [];
    var parents = [];
    var alive = true;
    return function walker(node_) {
      var node2 = immutable ? copy(node_) : node_;
      var modifiers = {};
      var state2 = {
        node: node2,
        node_,
        path: [].concat(path2),
        parent: parents.slice(-1)[0],
        key: path2.slice(-1)[0],
        isRoot: path2.length === 0,
        level: path2.length,
        circular: null,
        update: function(x) {
          if (!state2.isRoot) {
            state2.parent.node[state2.key] = x;
          }
          state2.node = x;
        },
        "delete": function() {
          delete state2.parent.node[state2.key];
        },
        remove: function() {
          if (Array.isArray(state2.parent.node)) {
            state2.parent.node.splice(state2.key, 1);
          } else {
            delete state2.parent.node[state2.key];
          }
        },
        before: function(f) {
          modifiers.before = f;
        },
        after: function(f) {
          modifiers.after = f;
        },
        pre: function(f) {
          modifiers.pre = f;
        },
        post: function(f) {
          modifiers.post = f;
        },
        stop: function() {
          alive = false;
        }
      };
      if (!alive) return state2;
      if (typeof node2 === "object" && node2 !== null) {
        state2.isLeaf = Object.keys(node2).length == 0;
        for (var i = 0; i < parents.length; i++) {
          if (parents[i].node_ === node_) {
            state2.circular = parents[i];
            break;
          }
        }
      } else {
        state2.isLeaf = true;
      }
      state2.notLeaf = !state2.isLeaf;
      state2.notRoot = !state2.isRoot;
      var ret = cb.call(state2, state2.node);
      if (ret !== void 0 && state2.update) state2.update(ret);
      if (modifiers.before) modifiers.before.call(state2, state2.node);
      if (typeof state2.node == "object" && state2.node !== null && !state2.circular) {
        parents.push(state2);
        var keys = Object.keys(state2.node);
        keys.forEach(function(key, i2) {
          path2.push(key);
          if (modifiers.pre) modifiers.pre.call(state2, state2.node[key], key);
          var child = walker(state2.node[key]);
          if (immutable && Object.hasOwnProperty.call(state2.node, key)) {
            state2.node[key] = child.node;
          }
          child.isLast = i2 == keys.length - 1;
          child.isFirst = i2 == 0;
          if (modifiers.post) modifiers.post.call(state2, child);
          path2.pop();
        });
        parents.pop();
      }
      if (modifiers.after) modifiers.after.call(state2, state2.node);
      return state2;
    }(root).node;
  }
  Object.keys(Traverse.prototype).forEach(function(key) {
    Traverse[key] = function(obj) {
      var args = [].slice.call(arguments, 1);
      var t = Traverse(obj);
      return t[key].apply(t, args);
    };
  });
  function copy(src2) {
    if (typeof src2 === "object" && src2 !== null) {
      var dst;
      if (Array.isArray(src2)) {
        dst = [];
      } else if (src2 instanceof Date) {
        dst = new Date(src2);
      } else if (src2 instanceof Boolean) {
        dst = new Boolean(src2);
      } else if (src2 instanceof Number) {
        dst = new Number(src2);
      } else if (src2 instanceof String) {
        dst = new String(src2);
      } else {
        dst = Object.create(Object.getPrototypeOf(src2));
      }
      Object.keys(src2).forEach(function(key) {
        dst[key] = src2[key];
      });
      return dst;
    } else return src2;
  }
  return traverse;
}
var chainsaw;
var hasRequiredChainsaw;
function requireChainsaw() {
  if (hasRequiredChainsaw) return chainsaw;
  hasRequiredChainsaw = 1;
  var Traverse = requireTraverse();
  var EventEmitter2 = require$$2$1.EventEmitter;
  chainsaw = Chainsaw;
  function Chainsaw(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== void 0) saw.handlers = r;
    saw.record();
    return saw.chain();
  }
  Chainsaw.light = function ChainsawLight(builder) {
    var saw = Chainsaw.saw(builder, {});
    var r = builder.call(saw.handlers, saw);
    if (r !== void 0) saw.handlers = r;
    return saw.chain();
  };
  Chainsaw.saw = function(builder, handlers) {
    var saw = new EventEmitter2();
    saw.handlers = handlers;
    saw.actions = [];
    saw.chain = function() {
      var ch = Traverse(saw.handlers).map(function(node2) {
        if (this.isRoot) return node2;
        var ps = this.path;
        if (typeof node2 === "function") {
          this.update(function() {
            saw.actions.push({
              path: ps,
              args: [].slice.call(arguments)
            });
            return ch;
          });
        }
      });
      process.nextTick(function() {
        saw.emit("begin");
        saw.next();
      });
      return ch;
    };
    saw.pop = function() {
      return saw.actions.shift();
    };
    saw.next = function() {
      var action = saw.pop();
      if (!action) {
        saw.emit("end");
      } else if (!action.trap) {
        var node2 = saw.handlers;
        action.path.forEach(function(key) {
          node2 = node2[key];
        });
        node2.apply(saw.handlers, action.args);
      }
    };
    saw.nest = function(cb) {
      var args = [].slice.call(arguments, 1);
      var autonext = true;
      if (typeof cb === "boolean") {
        var autonext = cb;
        cb = args.shift();
      }
      var s = Chainsaw.saw(builder, {});
      var r = builder.call(s.handlers, s);
      if (r !== void 0) s.handlers = r;
      if ("undefined" !== typeof saw.step) {
        s.record();
      }
      cb.apply(s.chain(), args);
      if (autonext !== false) s.on("end", saw.next);
    };
    saw.record = function() {
      upgradeChainsaw(saw);
    };
    ["trap", "down", "jump"].forEach(function(method2) {
      saw[method2] = function() {
        throw new Error("To use the trap, down and jump features, please call record() first to start recording actions.");
      };
    });
    return saw;
  };
  function upgradeChainsaw(saw) {
    saw.step = 0;
    saw.pop = function() {
      return saw.actions[saw.step++];
    };
    saw.trap = function(name, cb) {
      var ps = Array.isArray(name) ? name : [name];
      saw.actions.push({
        path: ps,
        step: saw.step,
        cb,
        trap: true
      });
    };
    saw.down = function(name) {
      var ps = (Array.isArray(name) ? name : [name]).join("/");
      var i = saw.actions.slice(saw.step).map(function(x) {
        if (x.trap && x.step <= saw.step) return false;
        return x.path.join("/") == ps;
      }).indexOf(true);
      if (i >= 0) saw.step += i;
      else saw.step = saw.actions.length;
      var act = saw.actions[saw.step - 1];
      if (act && act.trap) {
        saw.step = act.step;
        act.cb();
      } else saw.next();
    };
    saw.jump = function(step) {
      saw.step = step;
      saw.next();
    };
  }
  return chainsaw;
}
var buffers;
var hasRequiredBuffers;
function requireBuffers() {
  if (hasRequiredBuffers) return buffers;
  hasRequiredBuffers = 1;
  buffers = Buffers;
  function Buffers(bufs) {
    if (!(this instanceof Buffers)) return new Buffers(bufs);
    this.buffers = bufs || [];
    this.length = this.buffers.reduce(function(size, buf) {
      return size + buf.length;
    }, 0);
  }
  Buffers.prototype.push = function() {
    for (var i = 0; i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to push a non-buffer");
      }
    }
    for (var i = 0; i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.push(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.unshift = function() {
    for (var i = 0; i < arguments.length; i++) {
      if (!Buffer.isBuffer(arguments[i])) {
        throw new TypeError("Tried to unshift a non-buffer");
      }
    }
    for (var i = 0; i < arguments.length; i++) {
      var buf = arguments[i];
      this.buffers.unshift(buf);
      this.length += buf.length;
    }
    return this.length;
  };
  Buffers.prototype.copy = function(dst, dStart, start, end) {
    return this.slice(start, end).copy(dst, dStart, 0, end - start);
  };
  Buffers.prototype.splice = function(i, howMany) {
    var buffers2 = this.buffers;
    var index2 = i >= 0 ? i : this.length - i;
    var reps = [].slice.call(arguments, 2);
    if (howMany === void 0) {
      howMany = this.length - index2;
    } else if (howMany > this.length - index2) {
      howMany = this.length - index2;
    }
    for (var i = 0; i < reps.length; i++) {
      this.length += reps[i].length;
    }
    var removed = new Buffers();
    var startBytes = 0;
    for (var ii = 0; ii < buffers2.length && startBytes + buffers2[ii].length < index2; ii++) {
      startBytes += buffers2[ii].length;
    }
    if (index2 - startBytes > 0) {
      var start = index2 - startBytes;
      if (start + howMany < buffers2[ii].length) {
        removed.push(buffers2[ii].slice(start, start + howMany));
        var orig = buffers2[ii];
        var buf0 = new Buffer(start);
        for (var i = 0; i < start; i++) {
          buf0[i] = orig[i];
        }
        var buf1 = new Buffer(orig.length - start - howMany);
        for (var i = start + howMany; i < orig.length; i++) {
          buf1[i - howMany - start] = orig[i];
        }
        if (reps.length > 0) {
          var reps_ = reps.slice();
          reps_.unshift(buf0);
          reps_.push(buf1);
          buffers2.splice.apply(buffers2, [ii, 1].concat(reps_));
          ii += reps_.length;
          reps = [];
        } else {
          buffers2.splice(ii, 1, buf0, buf1);
          ii += 2;
        }
      } else {
        removed.push(buffers2[ii].slice(start));
        buffers2[ii] = buffers2[ii].slice(0, start);
        ii++;
      }
    }
    if (reps.length > 0) {
      buffers2.splice.apply(buffers2, [ii, 0].concat(reps));
      ii += reps.length;
    }
    while (removed.length < howMany) {
      var buf = buffers2[ii];
      var len = buf.length;
      var take = Math.min(len, howMany - removed.length);
      if (take === len) {
        removed.push(buf);
        buffers2.splice(ii, 1);
      } else {
        removed.push(buf.slice(0, take));
        buffers2[ii] = buffers2[ii].slice(take);
      }
    }
    this.length -= removed.length;
    return removed;
  };
  Buffers.prototype.slice = function(i, j) {
    var buffers2 = this.buffers;
    if (j === void 0) j = this.length;
    if (i === void 0) i = 0;
    if (j > this.length) j = this.length;
    var startBytes = 0;
    for (var si = 0; si < buffers2.length && startBytes + buffers2[si].length <= i; si++) {
      startBytes += buffers2[si].length;
    }
    var target = new Buffer(j - i);
    var ti = 0;
    for (var ii = si; ti < j - i && ii < buffers2.length; ii++) {
      var len = buffers2[ii].length;
      var start = ti === 0 ? i - startBytes : 0;
      var end = ti + len >= j - i ? Math.min(start + (j - i) - ti, len) : len;
      buffers2[ii].copy(target, ti, start, end);
      ti += end - start;
    }
    return target;
  };
  Buffers.prototype.pos = function(i) {
    if (i < 0 || i >= this.length) throw new Error("oob");
    var l = i, bi = 0, bu = null;
    for (; ; ) {
      bu = this.buffers[bi];
      if (l < bu.length) {
        return { buf: bi, offset: l };
      } else {
        l -= bu.length;
      }
      bi++;
    }
  };
  Buffers.prototype.get = function get2(i) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].get(pos.offset);
  };
  Buffers.prototype.set = function set(i, b) {
    var pos = this.pos(i);
    return this.buffers[pos.buf].set(pos.offset, b);
  };
  Buffers.prototype.indexOf = function(needle, offset) {
    if ("string" === typeof needle) {
      needle = new Buffer(needle);
    } else if (needle instanceof Buffer) ;
    else {
      throw new Error("Invalid type for a search string");
    }
    if (!needle.length) {
      return 0;
    }
    if (!this.length) {
      return -1;
    }
    var i = 0, j = 0, match = 0, mstart, pos = 0;
    if (offset) {
      var p = this.pos(offset);
      i = p.buf;
      j = p.offset;
      pos = offset;
    }
    for (; ; ) {
      while (j >= this.buffers[i].length) {
        j = 0;
        i++;
        if (i >= this.buffers.length) {
          return -1;
        }
      }
      var char = this.buffers[i][j];
      if (char == needle[match]) {
        if (match == 0) {
          mstart = {
            i,
            j,
            pos
          };
        }
        match++;
        if (match == needle.length) {
          return mstart.pos;
        }
      } else if (match != 0) {
        i = mstart.i;
        j = mstart.j;
        pos = mstart.pos;
        match = 0;
      }
      j++;
      pos++;
    }
  };
  Buffers.prototype.toBuffer = function() {
    return this.slice();
  };
  Buffers.prototype.toString = function(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  return buffers;
}
var vars;
var hasRequiredVars;
function requireVars() {
  if (hasRequiredVars) return vars;
  hasRequiredVars = 1;
  vars = function(store) {
    function getset(name, value) {
      var node2 = vars2.store;
      var keys = name.split(".");
      keys.slice(0, -1).forEach(function(k) {
        if (node2[k] === void 0) node2[k] = {};
        node2 = node2[k];
      });
      var key = keys[keys.length - 1];
      if (arguments.length == 1) {
        return node2[key];
      } else {
        return node2[key] = value;
      }
    }
    var vars2 = {
      get: function(name) {
        return getset(name);
      },
      set: function(name, value) {
        return getset(name, value);
      },
      store: store || {}
    };
    return vars2;
  };
  return vars;
}
var hasRequiredBinary;
function requireBinary() {
  if (hasRequiredBinary) return binary.exports;
  hasRequiredBinary = 1;
  (function(module, exports) {
    var Chainsaw = requireChainsaw();
    var EventEmitter2 = require$$2$1.EventEmitter;
    var Buffers = requireBuffers();
    var Vars = requireVars();
    var Stream = require$$0$1.Stream;
    exports = module.exports = function(bufOrEm, eventName) {
      if (Buffer.isBuffer(bufOrEm)) {
        return exports.parse(bufOrEm);
      }
      var s = exports.stream();
      if (bufOrEm && bufOrEm.pipe) {
        bufOrEm.pipe(s);
      } else if (bufOrEm) {
        bufOrEm.on(eventName || "data", function(buf) {
          s.write(buf);
        });
        bufOrEm.on("end", function() {
          s.end();
        });
      }
      return s;
    };
    exports.stream = function(input) {
      if (input) return exports.apply(null, arguments);
      var pending = null;
      function getBytes(bytes, cb, skip) {
        pending = {
          bytes,
          skip,
          cb: function(buf) {
            pending = null;
            cb(buf);
          }
        };
        dispatch();
      }
      var offset = null;
      function dispatch() {
        if (!pending) {
          if (caughtEnd) done = true;
          return;
        }
        if (typeof pending === "function") {
          pending();
        } else {
          var bytes = offset + pending.bytes;
          if (buffers2.length >= bytes) {
            var buf;
            if (offset == null) {
              buf = buffers2.splice(0, bytes);
              if (!pending.skip) {
                buf = buf.slice();
              }
            } else {
              if (!pending.skip) {
                buf = buffers2.slice(offset, bytes);
              }
              offset = bytes;
            }
            if (pending.skip) {
              pending.cb();
            } else {
              pending.cb(buf);
            }
          }
        }
      }
      function builder(saw) {
        function next() {
          if (!done) saw.next();
        }
        var self2 = words(function(bytes, cb) {
          return function(name) {
            getBytes(bytes, function(buf) {
              vars2.set(name, cb(buf));
              next();
            });
          };
        });
        self2.tap = function(cb) {
          saw.nest(cb, vars2.store);
        };
        self2.into = function(key, cb) {
          if (!vars2.get(key)) vars2.set(key, {});
          var parent2 = vars2;
          vars2 = Vars(parent2.get(key));
          saw.nest(function() {
            cb.apply(this, arguments);
            this.tap(function() {
              vars2 = parent2;
            });
          }, vars2.store);
        };
        self2.flush = function() {
          vars2.store = {};
          next();
        };
        self2.loop = function(cb) {
          var end = false;
          saw.nest(false, function loop() {
            this.vars = vars2.store;
            cb.call(this, function() {
              end = true;
              next();
            }, vars2.store);
            this.tap((function() {
              if (end) saw.next();
              else loop.call(this);
            }).bind(this));
          }, vars2.store);
        };
        self2.buffer = function(name, bytes) {
          if (typeof bytes === "string") {
            bytes = vars2.get(bytes);
          }
          getBytes(bytes, function(buf) {
            vars2.set(name, buf);
            next();
          });
        };
        self2.skip = function(bytes) {
          if (typeof bytes === "string") {
            bytes = vars2.get(bytes);
          }
          getBytes(bytes, function() {
            next();
          });
        };
        self2.scan = function find(name, search) {
          if (typeof search === "string") {
            search = new Buffer(search);
          } else if (!Buffer.isBuffer(search)) {
            throw new Error("search must be a Buffer or a string");
          }
          var taken = 0;
          pending = function() {
            var pos = buffers2.indexOf(search, offset + taken);
            var i = pos - offset - taken;
            if (pos !== -1) {
              pending = null;
              if (offset != null) {
                vars2.set(
                  name,
                  buffers2.slice(offset, offset + taken + i)
                );
                offset += taken + i + search.length;
              } else {
                vars2.set(
                  name,
                  buffers2.slice(0, taken + i)
                );
                buffers2.splice(0, taken + i + search.length);
              }
              next();
              dispatch();
            } else {
              i = Math.max(buffers2.length - search.length - offset - taken, 0);
            }
            taken += i;
          };
          dispatch();
        };
        self2.peek = function(cb) {
          offset = 0;
          saw.nest(function() {
            cb.call(this, vars2.store);
            this.tap(function() {
              offset = null;
            });
          });
        };
        return self2;
      }
      var stream2 = Chainsaw.light(builder);
      stream2.writable = true;
      var buffers2 = Buffers();
      stream2.write = function(buf) {
        buffers2.push(buf);
        dispatch();
      };
      var vars2 = Vars();
      var done = false, caughtEnd = false;
      stream2.end = function() {
        caughtEnd = true;
      };
      stream2.pipe = Stream.prototype.pipe;
      Object.getOwnPropertyNames(EventEmitter2.prototype).forEach(function(name) {
        stream2[name] = EventEmitter2.prototype[name];
      });
      return stream2;
    };
    exports.parse = function parse2(buffer) {
      var self2 = words(function(bytes, cb) {
        return function(name) {
          if (offset + bytes <= buffer.length) {
            var buf = buffer.slice(offset, offset + bytes);
            offset += bytes;
            vars2.set(name, cb(buf));
          } else {
            vars2.set(name, null);
          }
          return self2;
        };
      });
      var offset = 0;
      var vars2 = Vars();
      self2.vars = vars2.store;
      self2.tap = function(cb) {
        cb.call(self2, vars2.store);
        return self2;
      };
      self2.into = function(key, cb) {
        if (!vars2.get(key)) {
          vars2.set(key, {});
        }
        var parent2 = vars2;
        vars2 = Vars(parent2.get(key));
        cb.call(self2, vars2.store);
        vars2 = parent2;
        return self2;
      };
      self2.loop = function(cb) {
        var end = false;
        var ender = function() {
          end = true;
        };
        while (end === false) {
          cb.call(self2, ender, vars2.store);
        }
        return self2;
      };
      self2.buffer = function(name, size) {
        if (typeof size === "string") {
          size = vars2.get(size);
        }
        var buf = buffer.slice(offset, Math.min(buffer.length, offset + size));
        offset += size;
        vars2.set(name, buf);
        return self2;
      };
      self2.skip = function(bytes) {
        if (typeof bytes === "string") {
          bytes = vars2.get(bytes);
        }
        offset += bytes;
        return self2;
      };
      self2.scan = function(name, search) {
        if (typeof search === "string") {
          search = new Buffer(search);
        } else if (!Buffer.isBuffer(search)) {
          throw new Error("search must be a Buffer or a string");
        }
        vars2.set(name, null);
        for (var i = 0; i + offset <= buffer.length - search.length + 1; i++) {
          for (var j = 0; j < search.length && buffer[offset + i + j] === search[j]; j++) ;
          if (j === search.length) break;
        }
        vars2.set(name, buffer.slice(offset, offset + i));
        offset += i + search.length;
        return self2;
      };
      self2.peek = function(cb) {
        var was = offset;
        cb.call(self2, vars2.store);
        offset = was;
        return self2;
      };
      self2.flush = function() {
        vars2.store = {};
        return self2;
      };
      self2.eof = function() {
        return offset >= buffer.length;
      };
      return self2;
    };
    function decodeLEu(bytes) {
      var acc = 0;
      for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, i) * bytes[i];
      }
      return acc;
    }
    function decodeBEu(bytes) {
      var acc = 0;
      for (var i = 0; i < bytes.length; i++) {
        acc += Math.pow(256, bytes.length - i - 1) * bytes[i];
      }
      return acc;
    }
    function decodeBEs(bytes) {
      var val = decodeBEu(bytes);
      if ((bytes[0] & 128) == 128) {
        val -= Math.pow(256, bytes.length);
      }
      return val;
    }
    function decodeLEs(bytes) {
      var val = decodeLEu(bytes);
      if ((bytes[bytes.length - 1] & 128) == 128) {
        val -= Math.pow(256, bytes.length);
      }
      return val;
    }
    function words(decode) {
      var self2 = {};
      [1, 2, 4, 8].forEach(function(bytes) {
        var bits = bytes * 8;
        self2["word" + bits + "le"] = self2["word" + bits + "lu"] = decode(bytes, decodeLEu);
        self2["word" + bits + "ls"] = decode(bytes, decodeLEs);
        self2["word" + bits + "be"] = self2["word" + bits + "bu"] = decode(bytes, decodeBEu);
        self2["word" + bits + "bs"] = decode(bytes, decodeBEs);
      });
      self2.word8 = self2.word8u = self2.word8be;
      self2.word8s = self2.word8bs;
      return self2;
    }
  })(binary, binary.exports);
  return binary.exports;
}
var promise = { exports: {} };
var es5 = { exports: {} };
var hasRequiredEs5;
function requireEs5() {
  if (hasRequiredEs5) return es5.exports;
  hasRequiredEs5 = 1;
  var isES5 = /* @__PURE__ */ function() {
    return this === void 0;
  }();
  if (isES5) {
    es5.exports = {
      freeze: Object.freeze,
      defineProperty: Object.defineProperty,
      getDescriptor: Object.getOwnPropertyDescriptor,
      keys: Object.keys,
      names: Object.getOwnPropertyNames,
      getPrototypeOf: Object.getPrototypeOf,
      isArray: Array.isArray,
      isES5,
      propertyIsWritable: function(obj, prop) {
        var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
        return !!(!descriptor || descriptor.writable || descriptor.set);
      }
    };
  } else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;
    var ObjectKeys = function(o) {
      var ret = [];
      for (var key in o) {
        if (has.call(o, key)) {
          ret.push(key);
        }
      }
      return ret;
    };
    var ObjectGetDescriptor = function(o, key) {
      return { value: o[key] };
    };
    var ObjectDefineProperty = function(o, key, desc) {
      o[key] = desc.value;
      return o;
    };
    var ObjectFreeze = function(obj) {
      return obj;
    };
    var ObjectGetPrototypeOf = function(obj) {
      try {
        return Object(obj).constructor.prototype;
      } catch (e) {
        return proto;
      }
    };
    var ArrayIsArray = function(obj) {
      try {
        return str.call(obj) === "[object Array]";
      } catch (e) {
        return false;
      }
    };
    es5.exports = {
      isArray: ArrayIsArray,
      keys: ObjectKeys,
      names: ObjectKeys,
      defineProperty: ObjectDefineProperty,
      getDescriptor: ObjectGetDescriptor,
      freeze: ObjectFreeze,
      getPrototypeOf: ObjectGetPrototypeOf,
      isES5,
      propertyIsWritable: function() {
        return true;
      }
    };
  }
  return es5.exports;
}
var util$2;
var hasRequiredUtil$2;
function requireUtil$2() {
  if (hasRequiredUtil$2) return util$2;
  hasRequiredUtil$2 = 1;
  var es52 = requireEs5();
  var canEvaluate = typeof navigator == "undefined";
  var errorObj = { e: {} };
  var tryCatchTarget;
  var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof commonjsGlobal !== "undefined" ? commonjsGlobal : util$2 !== void 0 ? util$2 : null;
  function tryCatcher() {
    try {
      var target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      errorObj.e = e;
      return errorObj;
    }
  }
  function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  }
  var inherits2 = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;
    function T() {
      this.constructor = Child;
      this.constructor$ = Parent;
      for (var propertyName in Parent.prototype) {
        if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
          this[propertyName + "$"] = Parent.prototype[propertyName];
        }
      }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
  };
  function isPrimitive(val) {
    return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
  }
  function isObject2(value) {
    return typeof value === "function" || typeof value === "object" && value !== null;
  }
  function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;
    return new Error(safeToString(maybeError));
  }
  function withAppended(target, appendee) {
    var len = target.length;
    var ret2 = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
      ret2[i] = target[i];
    }
    ret2[i] = appendee;
    return ret2;
  }
  function getDataPropertyOrDefault(obj2, key, defaultValue) {
    if (es52.isES5) {
      var desc = Object.getOwnPropertyDescriptor(obj2, key);
      if (desc != null) {
        return desc.get == null && desc.set == null ? desc.value : defaultValue;
      }
    } else {
      return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
    }
  }
  function notEnumerableProp(obj2, name, value) {
    if (isPrimitive(obj2)) return obj2;
    var descriptor = {
      value,
      configurable: true,
      enumerable: false,
      writable: true
    };
    es52.defineProperty(obj2, name, descriptor);
    return obj2;
  }
  function thrower(r) {
    throw r;
  }
  var inheritedDataKeys = function() {
    var excludedPrototypes = [
      Array.prototype,
      Object.prototype,
      Function.prototype
    ];
    var isExcludedProto = function(val) {
      for (var i = 0; i < excludedPrototypes.length; ++i) {
        if (excludedPrototypes[i] === val) {
          return true;
        }
      }
      return false;
    };
    if (es52.isES5) {
      var getKeys = Object.getOwnPropertyNames;
      return function(obj2) {
        var ret2 = [];
        var visitedKeys = /* @__PURE__ */ Object.create(null);
        while (obj2 != null && !isExcludedProto(obj2)) {
          var keys;
          try {
            keys = getKeys(obj2);
          } catch (e) {
            return ret2;
          }
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (visitedKeys[key]) continue;
            visitedKeys[key] = true;
            var desc = Object.getOwnPropertyDescriptor(obj2, key);
            if (desc != null && desc.get == null && desc.set == null) {
              ret2.push(key);
            }
          }
          obj2 = es52.getPrototypeOf(obj2);
        }
        return ret2;
      };
    } else {
      var hasProp = {}.hasOwnProperty;
      return function(obj2) {
        if (isExcludedProto(obj2)) return [];
        var ret2 = [];
        enumeration: for (var key in obj2) {
          if (hasProp.call(obj2, key)) {
            ret2.push(key);
          } else {
            for (var i = 0; i < excludedPrototypes.length; ++i) {
              if (hasProp.call(excludedPrototypes[i], key)) {
                continue enumeration;
              }
            }
            ret2.push(key);
          }
        }
        return ret2;
      };
    }
  }();
  var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
  function isClass(fn) {
    try {
      if (typeof fn === "function") {
        var keys = es52.names(fn.prototype);
        var hasMethods = es52.isES5 && keys.length > 1;
        var hasMethodsOtherThanConstructor = keys.length > 0 && !(keys.length === 1 && keys[0] === "constructor");
        var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es52.names(fn).length > 0;
        if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
          return true;
        }
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function toFastProperties(obj) {
    return obj;
  }
  var rident = /^[a-z$_][a-z$_0-9]*$/i;
  function isIdentifier(str) {
    return rident.test(str);
  }
  function filledRange(count, prefix, suffix) {
    var ret2 = new Array(count);
    for (var i = 0; i < count; ++i) {
      ret2[i] = prefix + i + suffix;
    }
    return ret2;
  }
  function safeToString(obj2) {
    try {
      return obj2 + "";
    } catch (e) {
      return "[no string representation]";
    }
  }
  function isError(obj2) {
    return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
  }
  function markAsOriginatingFromRejection(e) {
    try {
      notEnumerableProp(e, "isOperational", true);
    } catch (ignore) {
    }
  }
  function originatesFromRejection(e) {
    if (e == null) return false;
    return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
  }
  function canAttachTrace(obj2) {
    return isError(obj2) && es52.propertyIsWritable(obj2, "stack");
  }
  var ensureErrorObject = function() {
    if (!("stack" in new Error())) {
      return function(value) {
        if (canAttachTrace(value)) return value;
        try {
          throw new Error(safeToString(value));
        } catch (err) {
          return err;
        }
      };
    } else {
      return function(value) {
        if (canAttachTrace(value)) return value;
        return new Error(safeToString(value));
      };
    }
  }();
  function classString(obj2) {
    return {}.toString.call(obj2);
  }
  function copyDescriptors(from, to, filter3) {
    var keys = es52.names(from);
    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];
      if (filter3(key)) {
        try {
          es52.defineProperty(to, key, es52.getDescriptor(from, key));
        } catch (ignore) {
        }
      }
    }
  }
  var asArray = function(v) {
    if (es52.isArray(v)) {
      return v;
    }
    return null;
  };
  if (typeof Symbol !== "undefined" && Symbol.iterator) {
    var ArrayFrom = typeof Array.from === "function" ? function(v) {
      return Array.from(v);
    } : function(v) {
      var ret2 = [];
      var it = v[Symbol.iterator]();
      var itResult;
      while (!(itResult = it.next()).done) {
        ret2.push(itResult.value);
      }
      return ret2;
    };
    asArray = function(v) {
      if (es52.isArray(v)) {
        return v;
      } else if (v != null && typeof v[Symbol.iterator] === "function") {
        return ArrayFrom(v);
      }
      return null;
    };
  }
  var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
  var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
  function env(key) {
    return hasEnvVariables ? process.env[key] : void 0;
  }
  function getNativePromise() {
    if (typeof Promise === "function") {
      try {
        var promise2 = new Promise(function() {
        });
        if ({}.toString.call(promise2) === "[object Promise]") {
          return Promise;
        }
      } catch (e) {
      }
    }
  }
  function domainBind(self2, cb) {
    return self2.bind(cb);
  }
  var ret = {
    isClass,
    isIdentifier,
    inheritedDataKeys,
    getDataPropertyOrDefault,
    thrower,
    isArray: es52.isArray,
    asArray,
    notEnumerableProp,
    isPrimitive,
    isObject: isObject2,
    isError,
    canEvaluate,
    errorObj,
    tryCatch,
    inherits: inherits2,
    withAppended,
    maybeWrapAsError,
    toFastProperties,
    filledRange,
    toString: safeToString,
    canAttachTrace,
    ensureErrorObject,
    originatesFromRejection,
    markAsOriginatingFromRejection,
    classString,
    copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
    isNode,
    hasEnvVariables,
    env,
    global: globalObject,
    getNativePromise,
    domainBind
  };
  ret.isRecentNode = ret.isNode && function() {
    var version2 = process.versions.node.split(".").map(Number);
    return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
  }();
  if (ret.isNode) ret.toFastProperties(process);
  try {
    throw new Error();
  } catch (e) {
    ret.lastLineError = e;
  }
  util$2 = ret;
  return util$2;
}
var async = { exports: {} };
var schedule_1;
var hasRequiredSchedule;
function requireSchedule() {
  if (hasRequiredSchedule) return schedule_1;
  hasRequiredSchedule = 1;
  var util2 = requireUtil$2();
  var schedule;
  var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
  };
  var NativePromise = util2.getNativePromise();
  if (util2.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = commonjsGlobal.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util2.isRecentNode ? function(fn) {
      GlobalSetImmediate.call(commonjsGlobal, fn);
    } : function(fn) {
      ProcessNextTick.call(process, fn);
    };
  } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
    var nativePromise = NativePromise.resolve();
    schedule = function(fn) {
      nativePromise.then(fn);
    };
  } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
    schedule = function() {
      var div = document.createElement("div");
      var opts = { attributes: true };
      var toggleScheduled = false;
      var div2 = document.createElement("div");
      var o2 = new MutationObserver(function() {
        div.classList.toggle("foo");
        toggleScheduled = false;
      });
      o2.observe(div2, opts);
      var scheduleToggle = function() {
        if (toggleScheduled) return;
        toggleScheduled = true;
        div2.classList.toggle("foo");
      };
      return function schedule2(fn) {
        var o = new MutationObserver(function() {
          o.disconnect();
          fn();
        });
        o.observe(div, opts);
        scheduleToggle();
      };
    }();
  } else if (typeof setImmediate !== "undefined") {
    schedule = function(fn) {
      setImmediate(fn);
    };
  } else if (typeof setTimeout !== "undefined") {
    schedule = function(fn) {
      setTimeout(fn, 0);
    };
  } else {
    schedule = noAsyncScheduler;
  }
  schedule_1 = schedule;
  return schedule_1;
}
var queue;
var hasRequiredQueue;
function requireQueue() {
  if (hasRequiredQueue) return queue;
  hasRequiredQueue = 1;
  function arrayMove(src2, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
      dst[j + dstIndex] = src2[j + srcIndex];
      src2[j + srcIndex] = void 0;
    }
  }
  function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
  }
  Queue.prototype._willBeOverCapacity = function(size) {
    return this._capacity < size;
  };
  Queue.prototype._pushOne = function(arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = this._front + length & this._capacity - 1;
    this[i] = arg;
    this._length = length + 1;
  };
  Queue.prototype.push = function(fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
      this._pushOne(fn);
      this._pushOne(receiver);
      this._pushOne(arg);
      return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[j + 0 & wrapMask] = fn;
    this[j + 1 & wrapMask] = receiver;
    this[j + 2 & wrapMask] = arg;
    this._length = length;
  };
  Queue.prototype.shift = function() {
    var front = this._front, ret = this[front];
    this[front] = void 0;
    this._front = front + 1 & this._capacity - 1;
    this._length--;
    return ret;
  };
  Queue.prototype.length = function() {
    return this._length;
  };
  Queue.prototype._checkCapacity = function(size) {
    if (this._capacity < size) {
      this._resizeTo(this._capacity << 1);
    }
  };
  Queue.prototype._resizeTo = function(capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = front + length & oldCapacity - 1;
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
  };
  queue = Queue;
  return queue;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async.exports;
  hasRequiredAsync = 1;
  var firstLineError;
  try {
    throw new Error();
  } catch (e) {
    firstLineError = e;
  }
  var schedule = requireSchedule();
  var Queue = requireQueue();
  var util2 = requireUtil$2();
  function Async() {
    this._customScheduler = false;
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._haveDrainedQueues = false;
    this._trampolineEnabled = true;
    var self2 = this;
    this.drainQueues = function() {
      self2._drainQueues();
    };
    this._schedule = schedule;
  }
  Async.prototype.setScheduler = function(fn) {
    var prev = this._schedule;
    this._schedule = fn;
    this._customScheduler = true;
    return prev;
  };
  Async.prototype.hasCustomScheduler = function() {
    return this._customScheduler;
  };
  Async.prototype.enableTrampoline = function() {
    this._trampolineEnabled = true;
  };
  Async.prototype.disableTrampolineIfNecessary = function() {
    if (util2.hasDevTools) {
      this._trampolineEnabled = false;
    }
  };
  Async.prototype.haveItemsQueued = function() {
    return this._isTickUsed || this._haveDrainedQueues;
  };
  Async.prototype.fatalError = function(e, isNode) {
    if (isNode) {
      process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
      process.exit(2);
    } else {
      this.throwLater(e);
    }
  };
  Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
      arg = fn;
      fn = function() {
        throw arg;
      };
    }
    if (typeof setTimeout !== "undefined") {
      setTimeout(function() {
        fn(arg);
      }, 0);
    } else try {
      this._schedule(function() {
        fn(arg);
      });
    } catch (e) {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    }
  };
  function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
  }
  function AsyncSettlePromises(promise2) {
    this._normalQueue._pushOne(promise2);
    this._queueTick();
  }
  if (!util2.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
  } else {
    Async.prototype.invokeLater = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvokeLater.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          setTimeout(function() {
            fn.call(receiver, arg);
          }, 100);
        });
      }
    };
    Async.prototype.invoke = function(fn, receiver, arg) {
      if (this._trampolineEnabled) {
        AsyncInvoke.call(this, fn, receiver, arg);
      } else {
        this._schedule(function() {
          fn.call(receiver, arg);
        });
      }
    };
    Async.prototype.settlePromises = function(promise2) {
      if (this._trampolineEnabled) {
        AsyncSettlePromises.call(this, promise2);
      } else {
        this._schedule(function() {
          promise2._settlePromises();
        });
      }
    };
  }
  Async.prototype._drainQueue = function(queue2) {
    while (queue2.length() > 0) {
      var fn = queue2.shift();
      if (typeof fn !== "function") {
        fn._settlePromises();
        continue;
      }
      var receiver = queue2.shift();
      var arg = queue2.shift();
      fn.call(receiver, arg);
    }
  };
  Async.prototype._drainQueues = function() {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._haveDrainedQueues = true;
    this._drainQueue(this._lateQueue);
  };
  Async.prototype._queueTick = function() {
    if (!this._isTickUsed) {
      this._isTickUsed = true;
      this._schedule(this.drainQueues);
    }
  };
  Async.prototype._reset = function() {
    this._isTickUsed = false;
  };
  async.exports = Async;
  async.exports.firstLineError = firstLineError;
  return async.exports;
}
var errors;
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  var es52 = requireEs5();
  var Objectfreeze = es52.freeze;
  var util2 = requireUtil$2();
  var inherits2 = util2.inherits;
  var notEnumerableProp = util2.notEnumerableProp;
  function subError(nameProperty, defaultMessage) {
    function SubError(message) {
      if (!(this instanceof SubError)) return new SubError(message);
      notEnumerableProp(
        this,
        "message",
        typeof message === "string" ? message : defaultMessage
      );
      notEnumerableProp(this, "name", nameProperty);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        Error.call(this);
      }
    }
    inherits2(SubError, Error);
    return SubError;
  }
  var _TypeError, _RangeError;
  var Warning = subError("Warning", "warning");
  var CancellationError = subError("CancellationError", "cancellation error");
  var TimeoutError = subError("TimeoutError", "timeout error");
  var AggregateError2 = subError("AggregateError", "aggregate error");
  try {
    _TypeError = TypeError;
    _RangeError = RangeError;
  } catch (e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
  }
  var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
  for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
      AggregateError2.prototype[methods[i]] = Array.prototype[methods[i]];
    }
  }
  es52.defineProperty(AggregateError2.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
  });
  AggregateError2.prototype["isOperational"] = true;
  var level = 0;
  AggregateError2.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i2 = 0; i2 < this.length; ++i2) {
      var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
      var lines = str.split("\n");
      for (var j = 0; j < lines.length; ++j) {
        lines[j] = indent + lines[j];
      }
      str = lines.join("\n");
      ret += str + "\n";
    }
    level--;
    return ret;
  };
  function OperationalError(message) {
    if (!(this instanceof OperationalError))
      return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;
    if (message instanceof Error) {
      notEnumerableProp(this, "message", message.message);
      notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  inherits2(OperationalError, Error);
  var errorTypes = Error["__BluebirdErrorTypes__"];
  if (!errorTypes) {
    errorTypes = Objectfreeze({
      CancellationError,
      TimeoutError,
      OperationalError,
      RejectionError: OperationalError,
      AggregateError: AggregateError2
    });
    es52.defineProperty(Error, "__BluebirdErrorTypes__", {
      value: errorTypes,
      writable: false,
      enumerable: false,
      configurable: false
    });
  }
  errors = {
    Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning
  };
  return errors;
}
var thenables;
var hasRequiredThenables;
function requireThenables() {
  if (hasRequiredThenables) return thenables;
  hasRequiredThenables = 1;
  thenables = function(Promise2, INTERNAL) {
    var util2 = requireUtil$2();
    var errorObj = util2.errorObj;
    var isObject2 = util2.isObject;
    function tryConvertToPromise(obj, context2) {
      if (isObject2(obj)) {
        if (obj instanceof Promise2) return obj;
        var then = getThen(obj);
        if (then === errorObj) {
          if (context2) context2._pushContext();
          var ret = Promise2.reject(then.e);
          if (context2) context2._popContext();
          return ret;
        } else if (typeof then === "function") {
          if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise2(INTERNAL);
            obj._then(
              ret._fulfill,
              ret._reject,
              void 0,
              ret,
              null
            );
            return ret;
          }
          return doThenable(obj, then, context2);
        }
      }
      return obj;
    }
    function doGetThen(obj) {
      return obj.then;
    }
    function getThen(obj) {
      try {
        return doGetThen(obj);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    var hasProp = {}.hasOwnProperty;
    function isAnyBluebirdPromise(obj) {
      try {
        return hasProp.call(obj, "_promise0");
      } catch (e) {
        return false;
      }
    }
    function doThenable(x, then, context2) {
      var promise2 = new Promise2(INTERNAL);
      var ret = promise2;
      if (context2) context2._pushContext();
      promise2._captureStackTrace();
      if (context2) context2._popContext();
      var synchronous = true;
      var result = util2.tryCatch(then).call(x, resolve, reject2);
      synchronous = false;
      if (promise2 && result === errorObj) {
        promise2._rejectCallback(result.e, true, true);
        promise2 = null;
      }
      function resolve(value) {
        if (!promise2) return;
        promise2._resolveCallback(value);
        promise2 = null;
      }
      function reject2(reason) {
        if (!promise2) return;
        promise2._rejectCallback(reason, synchronous, true);
        promise2 = null;
      }
      return ret;
    }
    return tryConvertToPromise;
  };
  return thenables;
}
var promise_array;
var hasRequiredPromise_array;
function requirePromise_array() {
  if (hasRequiredPromise_array) return promise_array;
  hasRequiredPromise_array = 1;
  promise_array = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, Proxyable) {
    var util2 = requireUtil$2();
    util2.isArray;
    function toResolutionValue(val) {
      switch (val) {
        case -2:
          return [];
        case -3:
          return {};
      }
    }
    function PromiseArray(values) {
      var promise2 = this._promise = new Promise2(INTERNAL);
      if (values instanceof Promise2) {
        promise2._propagateFrom(values, 3);
      }
      promise2._setOnCancel(this);
      this._values = values;
      this._length = 0;
      this._totalResolved = 0;
      this._init(void 0, -2);
    }
    util2.inherits(PromiseArray, Proxyable);
    PromiseArray.prototype.length = function() {
      return this._length;
    };
    PromiseArray.prototype.promise = function() {
      return this._promise;
    };
    PromiseArray.prototype._init = function init(_2, resolveValueIfEmpty) {
      var values = tryConvertToPromise(this._values, this._promise);
      if (values instanceof Promise2) {
        values = values._target();
        var bitField = values._bitField;
        this._values = values;
        if ((bitField & 50397184) === 0) {
          this._promise._setAsyncGuaranteed();
          return values._then(
            init,
            this._reject,
            void 0,
            this,
            resolveValueIfEmpty
          );
        } else if ((bitField & 33554432) !== 0) {
          values = values._value();
        } else if ((bitField & 16777216) !== 0) {
          return this._reject(values._reason());
        } else {
          return this._cancel();
        }
      }
      values = util2.asArray(values);
      if (values === null) {
        var err = apiRejection(
          "expecting an array or an iterable object but got " + util2.classString(values)
        ).reason();
        this._promise._rejectCallback(err, false);
        return;
      }
      if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
          this._resolveEmptyArray();
        } else {
          this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
      }
      this._iterate(values);
    };
    PromiseArray.prototype._iterate = function(values) {
      var len = this.getActualLength(values.length);
      this._length = len;
      this._values = this.shouldCopyValues() ? new Array(len) : this._values;
      var result = this._promise;
      var isResolved = false;
      var bitField = null;
      for (var i = 0; i < len; ++i) {
        var maybePromise = tryConvertToPromise(values[i], result);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          bitField = maybePromise._bitField;
        } else {
          bitField = null;
        }
        if (isResolved) {
          if (bitField !== null) {
            maybePromise.suppressUnhandledRejections();
          }
        } else if (bitField !== null) {
          if ((bitField & 50397184) === 0) {
            maybePromise._proxy(this, i);
            this._values[i] = maybePromise;
          } else if ((bitField & 33554432) !== 0) {
            isResolved = this._promiseFulfilled(maybePromise._value(), i);
          } else if ((bitField & 16777216) !== 0) {
            isResolved = this._promiseRejected(maybePromise._reason(), i);
          } else {
            isResolved = this._promiseCancelled(i);
          }
        } else {
          isResolved = this._promiseFulfilled(maybePromise, i);
        }
      }
      if (!isResolved) result._setAsyncGuaranteed();
    };
    PromiseArray.prototype._isResolved = function() {
      return this._values === null;
    };
    PromiseArray.prototype._resolve = function(value) {
      this._values = null;
      this._promise._fulfill(value);
    };
    PromiseArray.prototype._cancel = function() {
      if (this._isResolved() || !this._promise._isCancellable()) return;
      this._values = null;
      this._promise._cancel();
    };
    PromiseArray.prototype._reject = function(reason) {
      this._values = null;
      this._promise._rejectCallback(reason, false);
    };
    PromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    PromiseArray.prototype._promiseCancelled = function() {
      this._cancel();
      return true;
    };
    PromiseArray.prototype._promiseRejected = function(reason) {
      this._totalResolved++;
      this._reject(reason);
      return true;
    };
    PromiseArray.prototype._resultCancelled = function() {
      if (this._isResolved()) return;
      var values = this._values;
      this._cancel();
      if (values instanceof Promise2) {
        values.cancel();
      } else {
        for (var i = 0; i < values.length; ++i) {
          if (values[i] instanceof Promise2) {
            values[i].cancel();
          }
        }
      }
    };
    PromiseArray.prototype.shouldCopyValues = function() {
      return true;
    };
    PromiseArray.prototype.getActualLength = function(len) {
      return len;
    };
    return PromiseArray;
  };
  return promise_array;
}
var context;
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  context = function(Promise2) {
    var longStackTraces = false;
    var contextStack = [];
    Promise2.prototype._promiseCreated = function() {
    };
    Promise2.prototype._pushContext = function() {
    };
    Promise2.prototype._popContext = function() {
      return null;
    };
    Promise2._peekContext = Promise2.prototype._peekContext = function() {
    };
    function Context() {
      this._trace = new Context.CapturedTrace(peekContext());
    }
    Context.prototype._pushContext = function() {
      if (this._trace !== void 0) {
        this._trace._promiseCreated = null;
        contextStack.push(this._trace);
      }
    };
    Context.prototype._popContext = function() {
      if (this._trace !== void 0) {
        var trace = contextStack.pop();
        var ret = trace._promiseCreated;
        trace._promiseCreated = null;
        return ret;
      }
      return null;
    };
    function createContext() {
      if (longStackTraces) return new Context();
    }
    function peekContext() {
      var lastIndex = contextStack.length - 1;
      if (lastIndex >= 0) {
        return contextStack[lastIndex];
      }
      return void 0;
    }
    Context.CapturedTrace = null;
    Context.create = createContext;
    Context.deactivateLongStackTraces = function() {
    };
    Context.activateLongStackTraces = function() {
      var Promise_pushContext = Promise2.prototype._pushContext;
      var Promise_popContext = Promise2.prototype._popContext;
      var Promise_PeekContext = Promise2._peekContext;
      var Promise_peekContext = Promise2.prototype._peekContext;
      var Promise_promiseCreated = Promise2.prototype._promiseCreated;
      Context.deactivateLongStackTraces = function() {
        Promise2.prototype._pushContext = Promise_pushContext;
        Promise2.prototype._popContext = Promise_popContext;
        Promise2._peekContext = Promise_PeekContext;
        Promise2.prototype._peekContext = Promise_peekContext;
        Promise2.prototype._promiseCreated = Promise_promiseCreated;
        longStackTraces = false;
      };
      longStackTraces = true;
      Promise2.prototype._pushContext = Context.prototype._pushContext;
      Promise2.prototype._popContext = Context.prototype._popContext;
      Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
      Promise2.prototype._promiseCreated = function() {
        var ctx = this._peekContext();
        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
      };
    };
    return Context;
  };
  return context;
}
var debuggability;
var hasRequiredDebuggability;
function requireDebuggability() {
  if (hasRequiredDebuggability) return debuggability;
  hasRequiredDebuggability = 1;
  debuggability = function(Promise2, Context) {
    var getDomain = Promise2._getDomain;
    var async2 = Promise2._async;
    var Warning = requireErrors().Warning;
    var util2 = requireUtil$2();
    var canAttachTrace = util2.canAttachTrace;
    var unhandledRejectionHandled;
    var possiblyUnhandledRejection;
    var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
    var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
    var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
    var stackFramePattern = null;
    var formatStack = null;
    var indentStackFrames = false;
    var printWarning;
    var debugging = !!(util2.env("BLUEBIRD_DEBUG") != 0 && (util2.env("BLUEBIRD_DEBUG") || util2.env("NODE_ENV") === "development"));
    var warnings = !!(util2.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util2.env("BLUEBIRD_WARNINGS")));
    var longStackTraces = !!(util2.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util2.env("BLUEBIRD_LONG_STACK_TRACES")));
    var wForgottenReturn = util2.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util2.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
    Promise2.prototype.suppressUnhandledRejections = function() {
      var target = this._target();
      target._bitField = target._bitField & -1048577 | 524288;
    };
    Promise2.prototype._ensurePossibleRejectionHandled = function() {
      if ((this._bitField & 524288) !== 0) return;
      this._setRejectionIsUnhandled();
      async2.invokeLater(this._notifyUnhandledRejection, this, void 0);
    };
    Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
      fireRejectionEvent(
        "rejectionHandled",
        unhandledRejectionHandled,
        void 0,
        this
      );
    };
    Promise2.prototype._setReturnedNonUndefined = function() {
      this._bitField = this._bitField | 268435456;
    };
    Promise2.prototype._returnedNonUndefined = function() {
      return (this._bitField & 268435456) !== 0;
    };
    Promise2.prototype._notifyUnhandledRejection = function() {
      if (this._isRejectionUnhandled()) {
        var reason = this._settledValue();
        this._setUnhandledRejectionIsNotified();
        fireRejectionEvent(
          "unhandledRejection",
          possiblyUnhandledRejection,
          reason,
          this
        );
      }
    };
    Promise2.prototype._setUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField | 262144;
    };
    Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
      this._bitField = this._bitField & -262145;
    };
    Promise2.prototype._isUnhandledRejectionNotified = function() {
      return (this._bitField & 262144) > 0;
    };
    Promise2.prototype._setRejectionIsUnhandled = function() {
      this._bitField = this._bitField | 1048576;
    };
    Promise2.prototype._unsetRejectionIsUnhandled = function() {
      this._bitField = this._bitField & -1048577;
      if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
      }
    };
    Promise2.prototype._isRejectionUnhandled = function() {
      return (this._bitField & 1048576) > 0;
    };
    Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise2) {
      return warn(message, shouldUseOwnTrace, promise2 || this);
    };
    Promise2.onPossiblyUnhandledRejection = function(fn) {
      var domain = getDomain();
      possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    Promise2.onUnhandledRejectionHandled = function(fn) {
      var domain = getDomain();
      unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util2.domainBind(domain, fn) : void 0;
    };
    var disableLongStackTraces = function() {
    };
    Promise2.longStackTraces = function() {
      if (async2.haveItemsQueued() && !config.longStackTraces) {
        throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
      }
      if (!config.longStackTraces && longStackTracesIsSupported()) {
        var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
        var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
        config.longStackTraces = true;
        disableLongStackTraces = function() {
          if (async2.haveItemsQueued() && !config.longStackTraces) {
            throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
          }
          Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
          Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
          Context.deactivateLongStackTraces();
          async2.enableTrampoline();
          config.longStackTraces = false;
        };
        Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
        Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
        Context.activateLongStackTraces();
        async2.disableTrampolineIfNecessary();
      }
    };
    Promise2.hasLongStackTraces = function() {
      return config.longStackTraces && longStackTracesIsSupported();
    };
    var fireDomEvent = function() {
      try {
        if (typeof CustomEvent === "function") {
          var event = new CustomEvent("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new CustomEvent(name.toLowerCase(), {
              detail: event2,
              cancelable: true
            });
            return !util2.global.dispatchEvent(domEvent);
          };
        } else if (typeof Event === "function") {
          var event = new Event("CustomEvent");
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = new Event(name.toLowerCase(), {
              cancelable: true
            });
            domEvent.detail = event2;
            return !util2.global.dispatchEvent(domEvent);
          };
        } else {
          var event = document.createEvent("CustomEvent");
          event.initCustomEvent("testingtheevent", false, true, {});
          util2.global.dispatchEvent(event);
          return function(name, event2) {
            var domEvent = document.createEvent("CustomEvent");
            domEvent.initCustomEvent(
              name.toLowerCase(),
              false,
              true,
              event2
            );
            return !util2.global.dispatchEvent(domEvent);
          };
        }
      } catch (e) {
      }
      return function() {
        return false;
      };
    }();
    var fireGlobalEvent = function() {
      if (util2.isNode) {
        return function() {
          return process.emit.apply(process, arguments);
        };
      } else {
        if (!util2.global) {
          return function() {
            return false;
          };
        }
        return function(name) {
          var methodName = "on" + name.toLowerCase();
          var method2 = util2.global[methodName];
          if (!method2) return false;
          method2.apply(util2.global, [].slice.call(arguments, 1));
          return true;
        };
      }
    }();
    function generatePromiseLifecycleEventObject(name, promise2) {
      return { promise: promise2 };
    }
    var eventToObjectGenerator = {
      promiseCreated: generatePromiseLifecycleEventObject,
      promiseFulfilled: generatePromiseLifecycleEventObject,
      promiseRejected: generatePromiseLifecycleEventObject,
      promiseResolved: generatePromiseLifecycleEventObject,
      promiseCancelled: generatePromiseLifecycleEventObject,
      promiseChained: function(name, promise2, child) {
        return { promise: promise2, child };
      },
      warning: function(name, warning) {
        return { warning };
      },
      unhandledRejection: function(name, reason, promise2) {
        return { reason, promise: promise2 };
      },
      rejectionHandled: generatePromiseLifecycleEventObject
    };
    var activeFireEvent = function(name) {
      var globalEventFired = false;
      try {
        globalEventFired = fireGlobalEvent.apply(null, arguments);
      } catch (e) {
        async2.throwLater(e);
        globalEventFired = true;
      }
      var domEventFired = false;
      try {
        domEventFired = fireDomEvent(
          name,
          eventToObjectGenerator[name].apply(null, arguments)
        );
      } catch (e) {
        async2.throwLater(e);
        domEventFired = true;
      }
      return domEventFired || globalEventFired;
    };
    Promise2.config = function(opts) {
      opts = Object(opts);
      if ("longStackTraces" in opts) {
        if (opts.longStackTraces) {
          Promise2.longStackTraces();
        } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
          disableLongStackTraces();
        }
      }
      if ("warnings" in opts) {
        var warningsOption = opts.warnings;
        config.warnings = !!warningsOption;
        wForgottenReturn = config.warnings;
        if (util2.isObject(warningsOption)) {
          if ("wForgottenReturn" in warningsOption) {
            wForgottenReturn = !!warningsOption.wForgottenReturn;
          }
        }
      }
      if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
        if (async2.haveItemsQueued()) {
          throw new Error(
            "cannot enable cancellation after promises are in use"
          );
        }
        Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
        Promise2.prototype._propagateFrom = cancellationPropagateFrom;
        Promise2.prototype._onCancel = cancellationOnCancel;
        Promise2.prototype._setOnCancel = cancellationSetOnCancel;
        Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
        Promise2.prototype._execute = cancellationExecute;
        propagateFromFunction = cancellationPropagateFrom;
        config.cancellation = true;
      }
      if ("monitoring" in opts) {
        if (opts.monitoring && !config.monitoring) {
          config.monitoring = true;
          Promise2.prototype._fireEvent = activeFireEvent;
        } else if (!opts.monitoring && config.monitoring) {
          config.monitoring = false;
          Promise2.prototype._fireEvent = defaultFireEvent;
        }
      }
      return Promise2;
    };
    function defaultFireEvent() {
      return false;
    }
    Promise2.prototype._fireEvent = defaultFireEvent;
    Promise2.prototype._execute = function(executor, resolve, reject2) {
      try {
        executor(resolve, reject2);
      } catch (e) {
        return e;
      }
    };
    Promise2.prototype._onCancel = function() {
    };
    Promise2.prototype._setOnCancel = function(handler) {
    };
    Promise2.prototype._attachCancellationCallback = function(onCancel) {
    };
    Promise2.prototype._captureStackTrace = function() {
    };
    Promise2.prototype._attachExtraTrace = function() {
    };
    Promise2.prototype._clearCancellationData = function() {
    };
    Promise2.prototype._propagateFrom = function(parent2, flags) {
    };
    function cancellationExecute(executor, resolve, reject2) {
      var promise2 = this;
      try {
        executor(resolve, reject2, function(onCancel) {
          if (typeof onCancel !== "function") {
            throw new TypeError("onCancel must be a function, got: " + util2.toString(onCancel));
          }
          promise2._attachCancellationCallback(onCancel);
        });
      } catch (e) {
        return e;
      }
    }
    function cancellationAttachCancellationCallback(onCancel) {
      if (!this._isCancellable()) return this;
      var previousOnCancel = this._onCancel();
      if (previousOnCancel !== void 0) {
        if (util2.isArray(previousOnCancel)) {
          previousOnCancel.push(onCancel);
        } else {
          this._setOnCancel([previousOnCancel, onCancel]);
        }
      } else {
        this._setOnCancel(onCancel);
      }
    }
    function cancellationOnCancel() {
      return this._onCancelField;
    }
    function cancellationSetOnCancel(onCancel) {
      this._onCancelField = onCancel;
    }
    function cancellationClearCancellationData() {
      this._cancellationParent = void 0;
      this._onCancelField = void 0;
    }
    function cancellationPropagateFrom(parent2, flags) {
      if ((flags & 1) !== 0) {
        this._cancellationParent = parent2;
        var branchesRemainingToCancel = parent2._branchesRemainingToCancel;
        if (branchesRemainingToCancel === void 0) {
          branchesRemainingToCancel = 0;
        }
        parent2._branchesRemainingToCancel = branchesRemainingToCancel + 1;
      }
      if ((flags & 2) !== 0 && parent2._isBound()) {
        this._setBoundTo(parent2._boundTo);
      }
    }
    function bindingPropagateFrom(parent2, flags) {
      if ((flags & 2) !== 0 && parent2._isBound()) {
        this._setBoundTo(parent2._boundTo);
      }
    }
    var propagateFromFunction = bindingPropagateFrom;
    function boundValueFunction() {
      var ret = this._boundTo;
      if (ret !== void 0) {
        if (ret instanceof Promise2) {
          if (ret.isFulfilled()) {
            return ret.value();
          } else {
            return void 0;
          }
        }
      }
      return ret;
    }
    function longStackTracesCaptureStackTrace() {
      this._trace = new CapturedTrace(this._peekContext());
    }
    function longStackTracesAttachExtraTrace(error2, ignoreSelf) {
      if (canAttachTrace(error2)) {
        var trace = this._trace;
        if (trace !== void 0) {
          if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== void 0) {
          trace.attachExtraTrace(error2);
        } else if (!error2.__stackCleaned__) {
          var parsed = parseStackAndMessage(error2);
          util2.notEnumerableProp(
            error2,
            "stack",
            parsed.message + "\n" + parsed.stack.join("\n")
          );
          util2.notEnumerableProp(error2, "__stackCleaned__", true);
        }
      }
    }
    function checkForgottenReturns(returnValue, promiseCreated, name, promise2, parent2) {
      if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
        if (parent2 !== void 0 && parent2._returnedNonUndefined()) return;
        if ((promise2._bitField & 65535) === 0) return;
        if (name) name = name + " ";
        var handlerLine = "";
        var creatorLine = "";
        if (promiseCreated._trace) {
          var traceLines = promiseCreated._trace.stack.split("\n");
          var stack = cleanStack(traceLines);
          for (var i = stack.length - 1; i >= 0; --i) {
            var line = stack[i];
            if (!nodeFramePattern.test(line)) {
              var lineMatches = line.match(parseLinePattern);
              if (lineMatches) {
                handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
              }
              break;
            }
          }
          if (stack.length > 0) {
            var firstUserLine = stack[0];
            for (var i = 0; i < traceLines.length; ++i) {
              if (traceLines[i] === firstUserLine) {
                if (i > 0) {
                  creatorLine = "\n" + traceLines[i - 1];
                }
                break;
              }
            }
          }
        }
        var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
        promise2._warn(msg, true, promiseCreated);
      }
    }
    function deprecated(name, replacement) {
      var message = name + " is deprecated and will be removed in a future version.";
      if (replacement) message += " Use " + replacement + " instead.";
      return warn(message);
    }
    function warn(message, shouldUseOwnTrace, promise2) {
      if (!config.warnings) return;
      var warning = new Warning(message);
      var ctx;
      if (shouldUseOwnTrace) {
        promise2._attachExtraTrace(warning);
      } else if (config.longStackTraces && (ctx = Promise2._peekContext())) {
        ctx.attachExtraTrace(warning);
      } else {
        var parsed = parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
      }
      if (!activeFireEvent("warning", warning)) {
        formatAndLogError(warning, "", true);
      }
    }
    function reconstructStack(message, stacks) {
      for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
      }
      if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
      }
      return message + "\n" + stacks.join("\n");
    }
    function removeDuplicateOrEmptyJumps(stacks) {
      for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
          stacks.splice(i, 1);
          i--;
        }
      }
    }
    function removeCommonRoots(stacks) {
      var current = stacks[0];
      for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;
        for (var j = prev.length - 1; j >= 0; --j) {
          if (prev[j] === currentLastLine) {
            commonRootMeetPoint = j;
            break;
          }
        }
        for (var j = commonRootMeetPoint; j >= 0; --j) {
          var line = prev[j];
          if (current[currentLastIndex] === line) {
            current.pop();
            currentLastIndex--;
          } else {
            break;
          }
        }
        current = prev;
      }
    }
    function cleanStack(stack) {
      var ret = [];
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
          if (indentStackFrames && line.charAt(0) !== " ") {
            line = "    " + line;
          }
          ret.push(line);
        }
      }
      return ret;
    }
    function stackFramesAsArray(error2) {
      var stack = error2.stack.replace(/\s+$/g, "").split("\n");
      for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
          break;
        }
      }
      if (i > 0 && error2.name != "SyntaxError") {
        stack = stack.slice(i);
      }
      return stack;
    }
    function parseStackAndMessage(error2) {
      var stack = error2.stack;
      var message = error2.toString();
      stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error2) : ["    (No stack trace)"];
      return {
        message,
        stack: error2.name == "SyntaxError" ? stack : cleanStack(stack)
      };
    }
    function formatAndLogError(error2, title, isSoft) {
      if (typeof console !== "undefined") {
        var message;
        if (util2.isObject(error2)) {
          var stack = error2.stack;
          message = title + formatStack(stack, error2);
        } else {
          message = title + String(error2);
        }
        if (typeof printWarning === "function") {
          printWarning(message, isSoft);
        } else if (typeof console.log === "function" || typeof console.log === "object") {
          console.log(message);
        }
      }
    }
    function fireRejectionEvent(name, localHandler, reason, promise2) {
      var localEventFired = false;
      try {
        if (typeof localHandler === "function") {
          localEventFired = true;
          if (name === "rejectionHandled") {
            localHandler(promise2);
          } else {
            localHandler(reason, promise2);
          }
        }
      } catch (e) {
        async2.throwLater(e);
      }
      if (name === "unhandledRejection") {
        if (!activeFireEvent(name, reason, promise2) && !localEventFired) {
          formatAndLogError(reason, "Unhandled rejection ");
        }
      } else {
        activeFireEvent(name, promise2);
      }
    }
    function formatNonError(obj) {
      var str;
      if (typeof obj === "function") {
        str = "[function " + (obj.name || "anonymous") + "]";
      } else {
        str = obj && typeof obj.toString === "function" ? obj.toString() : util2.toString(obj);
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
          try {
            var newStr = JSON.stringify(obj);
            str = newStr;
          } catch (e) {
          }
        }
        if (str.length === 0) {
          str = "(empty array)";
        }
      }
      return "(<" + snip(str) + ">, no stack trace)";
    }
    function snip(str) {
      var maxChars = 41;
      if (str.length < maxChars) {
        return str;
      }
      return str.substr(0, maxChars - 3) + "...";
    }
    function longStackTracesIsSupported() {
      return typeof captureStackTrace === "function";
    }
    var shouldIgnore = function() {
      return false;
    };
    var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
    function parseLineInfo(line) {
      var matches = line.match(parseLineInfoRegex);
      if (matches) {
        return {
          fileName: matches[1],
          line: parseInt(matches[2], 10)
        };
      }
    }
    function setBounds(firstLineError, lastLineError) {
      if (!longStackTracesIsSupported()) return;
      var firstStackLines = firstLineError.stack.split("\n");
      var lastStackLines = lastLineError.stack.split("\n");
      var firstIndex = -1;
      var lastIndex = -1;
      var firstFileName;
      var lastFileName;
      for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
          firstFileName = result.fileName;
          firstIndex = result.line;
          break;
        }
      }
      for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
          lastFileName = result.fileName;
          lastIndex = result.line;
          break;
        }
      }
      if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
      }
      shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
          if (info.fileName === firstFileName && (firstIndex <= info.line && info.line <= lastIndex)) {
            return true;
          }
        }
        return false;
      };
    }
    function CapturedTrace(parent2) {
      this._parent = parent2;
      this._promisesCreated = 0;
      var length = this._length = 1 + (parent2 === void 0 ? 0 : parent2._length);
      captureStackTrace(this, CapturedTrace);
      if (length > 32) this.uncycle();
    }
    util2.inherits(CapturedTrace, Error);
    Context.CapturedTrace = CapturedTrace;
    CapturedTrace.prototype.uncycle = function() {
      var length = this._length;
      if (length < 2) return;
      var nodes = [];
      var stackToIndex = {};
      for (var i = 0, node2 = this; node2 !== void 0; ++i) {
        nodes.push(node2);
        node2 = node2._parent;
      }
      length = this._length = i;
      for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === void 0) {
          stackToIndex[stack] = i;
        }
      }
      for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index2 = stackToIndex[currentStack];
        if (index2 !== void 0 && index2 !== i) {
          if (index2 > 0) {
            nodes[index2 - 1]._parent = void 0;
            nodes[index2 - 1]._length = 1;
          }
          nodes[i]._parent = void 0;
          nodes[i]._length = 1;
          var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
          if (index2 < length - 1) {
            cycleEdgeNode._parent = nodes[index2 + 1];
            cycleEdgeNode._parent.uncycle();
            cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
          } else {
            cycleEdgeNode._parent = void 0;
            cycleEdgeNode._length = 1;
          }
          var currentChildLength = cycleEdgeNode._length + 1;
          for (var j = i - 2; j >= 0; --j) {
            nodes[j]._length = currentChildLength;
            currentChildLength++;
          }
          return;
        }
      }
    };
    CapturedTrace.prototype.attachExtraTrace = function(error2) {
      if (error2.__stackCleaned__) return;
      this.uncycle();
      var parsed = parseStackAndMessage(error2);
      var message = parsed.message;
      var stacks = [parsed.stack];
      var trace = this;
      while (trace !== void 0) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
      }
      removeCommonRoots(stacks);
      removeDuplicateOrEmptyJumps(stacks);
      util2.notEnumerableProp(error2, "stack", reconstructStack(message, stacks));
      util2.notEnumerableProp(error2, "__stackCleaned__", true);
    };
    var captureStackTrace = function stackDetection() {
      var v8stackFramePattern = /^\s*at\s*/;
      var v8stackFormatter = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if (error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit += 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace2 = Error.captureStackTrace;
        shouldIgnore = function(line) {
          return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
          Error.stackTraceLimit += 6;
          captureStackTrace2(receiver, ignoreUntil);
          Error.stackTraceLimit -= 6;
        };
      }
      var err = new Error();
      if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace3(o) {
          o.stack = new Error().stack;
        };
      }
      var hasStackAfterThrow;
      try {
        throw new Error();
      } catch (e) {
        hasStackAfterThrow = "stack" in e;
      }
      if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace3(o) {
          Error.stackTraceLimit += 6;
          try {
            throw new Error();
          } catch (e) {
            o.stack = e.stack;
          }
          Error.stackTraceLimit -= 6;
        };
      }
      formatStack = function(stack, error2) {
        if (typeof stack === "string") return stack;
        if ((typeof error2 === "object" || typeof error2 === "function") && error2.name !== void 0 && error2.message !== void 0) {
          return error2.toString();
        }
        return formatNonError(error2);
      };
      return null;
    }();
    if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
      printWarning = function(message) {
        console.warn(message);
      };
      if (util2.isNode && process.stderr.isTTY) {
        printWarning = function(message, isSoft) {
          var color = isSoft ? "\x1B[33m" : "\x1B[31m";
          console.warn(color + message + "\x1B[0m\n");
        };
      } else if (!util2.isNode && typeof new Error().stack === "string") {
        printWarning = function(message, isSoft) {
          console.warn(
            "%c" + message,
            isSoft ? "color: darkorange" : "color: red"
          );
        };
      }
    }
    var config = {
      warnings,
      longStackTraces: false,
      cancellation: false,
      monitoring: false
    };
    if (longStackTraces) Promise2.longStackTraces();
    return {
      longStackTraces: function() {
        return config.longStackTraces;
      },
      warnings: function() {
        return config.warnings;
      },
      cancellation: function() {
        return config.cancellation;
      },
      monitoring: function() {
        return config.monitoring;
      },
      propagateFromFunction: function() {
        return propagateFromFunction;
      },
      boundValueFunction: function() {
        return boundValueFunction;
      },
      checkForgottenReturns,
      setBounds,
      warn,
      deprecated,
      CapturedTrace,
      fireDomEvent,
      fireGlobalEvent
    };
  };
  return debuggability;
}
var _finally;
var hasRequired_finally;
function require_finally() {
  if (hasRequired_finally) return _finally;
  hasRequired_finally = 1;
  _finally = function(Promise2, tryConvertToPromise) {
    var util2 = requireUtil$2();
    var CancellationError = Promise2.CancellationError;
    var errorObj = util2.errorObj;
    function PassThroughHandlerContext(promise2, type2, handler) {
      this.promise = promise2;
      this.type = type2;
      this.handler = handler;
      this.called = false;
      this.cancelPromise = null;
    }
    PassThroughHandlerContext.prototype.isFinallyHandler = function() {
      return this.type === 0;
    };
    function FinallyHandlerCancelReaction(finallyHandler2) {
      this.finallyHandler = finallyHandler2;
    }
    FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
      checkCancel(this.finallyHandler);
    };
    function checkCancel(ctx, reason) {
      if (ctx.cancelPromise != null) {
        if (arguments.length > 1) {
          ctx.cancelPromise._reject(reason);
        } else {
          ctx.cancelPromise._cancel();
        }
        ctx.cancelPromise = null;
        return true;
      }
      return false;
    }
    function succeed() {
      return finallyHandler.call(this, this.promise._target()._settledValue());
    }
    function fail(reason) {
      if (checkCancel(this, reason)) return;
      errorObj.e = reason;
      return errorObj;
    }
    function finallyHandler(reasonOrValue) {
      var promise2 = this.promise;
      var handler = this.handler;
      if (!this.called) {
        this.called = true;
        var ret = this.isFinallyHandler() ? handler.call(promise2._boundValue()) : handler.call(promise2._boundValue(), reasonOrValue);
        if (ret !== void 0) {
          promise2._setReturnedNonUndefined();
          var maybePromise = tryConvertToPromise(ret, promise2);
          if (maybePromise instanceof Promise2) {
            if (this.cancelPromise != null) {
              if (maybePromise._isCancelled()) {
                var reason = new CancellationError("late cancellation observer");
                promise2._attachExtraTrace(reason);
                errorObj.e = reason;
                return errorObj;
              } else if (maybePromise.isPending()) {
                maybePromise._attachCancellationCallback(
                  new FinallyHandlerCancelReaction(this)
                );
              }
            }
            return maybePromise._then(
              succeed,
              fail,
              void 0,
              this,
              void 0
            );
          }
        }
      }
      if (promise2.isRejected()) {
        checkCancel(this);
        errorObj.e = reasonOrValue;
        return errorObj;
      } else {
        checkCancel(this);
        return reasonOrValue;
      }
    }
    Promise2.prototype._passThrough = function(handler, type2, success, fail2) {
      if (typeof handler !== "function") return this.then();
      return this._then(
        success,
        fail2,
        void 0,
        new PassThroughHandlerContext(this, type2, handler),
        void 0
      );
    };
    Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler) {
      return this._passThrough(
        handler,
        0,
        finallyHandler,
        finallyHandler
      );
    };
    Promise2.prototype.tap = function(handler) {
      return this._passThrough(handler, 1, finallyHandler);
    };
    return PassThroughHandlerContext;
  };
  return _finally;
}
var catch_filter;
var hasRequiredCatch_filter;
function requireCatch_filter() {
  if (hasRequiredCatch_filter) return catch_filter;
  hasRequiredCatch_filter = 1;
  catch_filter = function(NEXT_FILTER) {
    var util2 = requireUtil$2();
    var getKeys = requireEs5().keys;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function catchFilter(instances, cb, promise2) {
      return function(e) {
        var boundTo = promise2._boundValue();
        predicateLoop: for (var i = 0; i < instances.length; ++i) {
          var item = instances[i];
          if (item === Error || item != null && item.prototype instanceof Error) {
            if (e instanceof item) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (typeof item === "function") {
            var matchesPredicate = tryCatch(item).call(boundTo, e);
            if (matchesPredicate === errorObj) {
              return matchesPredicate;
            } else if (matchesPredicate) {
              return tryCatch(cb).call(boundTo, e);
            }
          } else if (util2.isObject(e)) {
            var keys = getKeys(item);
            for (var j = 0; j < keys.length; ++j) {
              var key = keys[j];
              if (item[key] != e[key]) {
                continue predicateLoop;
              }
            }
            return tryCatch(cb).call(boundTo, e);
          }
        }
        return NEXT_FILTER;
      };
    }
    return catchFilter;
  };
  return catch_filter;
}
var nodeback;
var hasRequiredNodeback;
function requireNodeback() {
  if (hasRequiredNodeback) return nodeback;
  hasRequiredNodeback = 1;
  var util2 = requireUtil$2();
  var maybeWrapAsError = util2.maybeWrapAsError;
  var errors2 = requireErrors();
  var OperationalError = errors2.OperationalError;
  var es52 = requireEs5();
  function isUntypedError(obj) {
    return obj instanceof Error && es52.getPrototypeOf(obj) === Error.prototype;
  }
  var rErrorKey = /^(?:name|message|stack|cause)$/;
  function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
      ret = new OperationalError(obj);
      ret.name = obj.name;
      ret.message = obj.message;
      ret.stack = obj.stack;
      var keys = es52.keys(obj);
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (!rErrorKey.test(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    util2.markAsOriginatingFromRejection(obj);
    return obj;
  }
  function nodebackForPromise(promise2, multiArgs) {
    return function(err, value) {
      if (promise2 === null) return;
      if (err) {
        var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
        promise2._attachExtraTrace(wrapped);
        promise2._reject(wrapped);
      } else if (!multiArgs) {
        promise2._fulfill(value);
      } else {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        promise2._fulfill(args);
      }
      promise2 = null;
    };
  }
  nodeback = nodebackForPromise;
  return nodeback;
}
var method;
var hasRequiredMethod;
function requireMethod() {
  if (hasRequiredMethod) return method;
  hasRequiredMethod = 1;
  method = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection, debug) {
    var util2 = requireUtil$2();
    var tryCatch = util2.tryCatch;
    Promise2.method = function(fn) {
      if (typeof fn !== "function") {
        throw new Promise2.TypeError("expecting a function but got " + util2.classString(fn));
      }
      return function() {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        var promiseCreated = ret._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.method",
          ret
        );
        ret._resolveFromSyncValue(value);
        return ret;
      };
    };
    Promise2.attempt = Promise2["try"] = function(fn) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var ret = new Promise2(INTERNAL);
      ret._captureStackTrace();
      ret._pushContext();
      var value;
      if (arguments.length > 1) {
        debug.deprecated("calling Promise.try with more than 1 argument");
        var arg = arguments[1];
        var ctx = arguments[2];
        value = util2.isArray(arg) ? tryCatch(fn).apply(ctx, arg) : tryCatch(fn).call(ctx, arg);
      } else {
        value = tryCatch(fn)();
      }
      var promiseCreated = ret._popContext();
      debug.checkForgottenReturns(
        value,
        promiseCreated,
        "Promise.try",
        ret
      );
      ret._resolveFromSyncValue(value);
      return ret;
    };
    Promise2.prototype._resolveFromSyncValue = function(value) {
      if (value === util2.errorObj) {
        this._rejectCallback(value.e, false);
      } else {
        this._resolveCallback(value, true);
      }
    };
  };
  return method;
}
var bind;
var hasRequiredBind;
function requireBind() {
  if (hasRequiredBind) return bind;
  hasRequiredBind = 1;
  bind = function(Promise2, INTERNAL, tryConvertToPromise, debug) {
    var calledBind = false;
    var rejectThis = function(_2, e) {
      this._reject(e);
    };
    var targetRejected = function(e, context2) {
      context2.promiseRejectionQueued = true;
      context2.bindingPromise._then(rejectThis, rejectThis, null, this, e);
    };
    var bindingResolved = function(thisArg, context2) {
      if ((this._bitField & 50397184) === 0) {
        this._resolveCallback(context2.target);
      }
    };
    var bindingRejected = function(e, context2) {
      if (!context2.promiseRejectionQueued) this._reject(e);
    };
    Promise2.prototype.bind = function(thisArg) {
      if (!calledBind) {
        calledBind = true;
        Promise2.prototype._propagateFrom = debug.propagateFromFunction();
        Promise2.prototype._boundValue = debug.boundValueFunction();
      }
      var maybePromise = tryConvertToPromise(thisArg);
      var ret = new Promise2(INTERNAL);
      ret._propagateFrom(this, 1);
      var target = this._target();
      ret._setBoundTo(maybePromise);
      if (maybePromise instanceof Promise2) {
        var context2 = {
          promiseRejectionQueued: false,
          promise: ret,
          target,
          bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, void 0, ret, context2);
        maybePromise._then(
          bindingResolved,
          bindingRejected,
          void 0,
          ret,
          context2
        );
        ret._setOnCancel(maybePromise);
      } else {
        ret._resolveCallback(target);
      }
      return ret;
    };
    Promise2.prototype._setBoundTo = function(obj) {
      if (obj !== void 0) {
        this._bitField = this._bitField | 2097152;
        this._boundTo = obj;
      } else {
        this._bitField = this._bitField & -2097153;
      }
    };
    Promise2.prototype._isBound = function() {
      return (this._bitField & 2097152) === 2097152;
    };
    Promise2.bind = function(thisArg, value) {
      return Promise2.resolve(value).bind(thisArg);
    };
  };
  return bind;
}
var cancel;
var hasRequiredCancel;
function requireCancel() {
  if (hasRequiredCancel) return cancel;
  hasRequiredCancel = 1;
  cancel = function(Promise2, PromiseArray, apiRejection, debug) {
    var util2 = requireUtil$2();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
      if (!debug.cancellation()) return this._warn("cancellation is disabled");
      var promise2 = this;
      var child = promise2;
      while (promise2._isCancellable()) {
        if (!promise2._cancelBy(child)) {
          if (child._isFollowing()) {
            child._followee().cancel();
          } else {
            child._cancelBranched();
          }
          break;
        }
        var parent2 = promise2._cancellationParent;
        if (parent2 == null || !parent2._isCancellable()) {
          if (promise2._isFollowing()) {
            promise2._followee().cancel();
          } else {
            promise2._cancelBranched();
          }
          break;
        } else {
          if (promise2._isFollowing()) promise2._followee().cancel();
          promise2._setWillBeCancelled();
          child = promise2;
          promise2 = parent2;
        }
      }
    };
    Promise2.prototype._branchHasCancelled = function() {
      this._branchesRemainingToCancel--;
    };
    Promise2.prototype._enoughBranchesHaveCancelled = function() {
      return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
    };
    Promise2.prototype._cancelBy = function(canceller) {
      if (canceller === this) {
        this._branchesRemainingToCancel = 0;
        this._invokeOnCancel();
        return true;
      } else {
        this._branchHasCancelled();
        if (this._enoughBranchesHaveCancelled()) {
          this._invokeOnCancel();
          return true;
        }
      }
      return false;
    };
    Promise2.prototype._cancelBranched = function() {
      if (this._enoughBranchesHaveCancelled()) {
        this._cancel();
      }
    };
    Promise2.prototype._cancel = function() {
      if (!this._isCancellable()) return;
      this._setCancelled();
      async2.invoke(this._cancelPromises, this, void 0);
    };
    Promise2.prototype._cancelPromises = function() {
      if (this._length() > 0) this._settlePromises();
    };
    Promise2.prototype._unsetOnCancel = function() {
      this._onCancelField = void 0;
    };
    Promise2.prototype._isCancellable = function() {
      return this.isPending() && !this._isCancelled();
    };
    Promise2.prototype.isCancellable = function() {
      return this.isPending() && !this.isCancelled();
    };
    Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
      if (util2.isArray(onCancelCallback)) {
        for (var i = 0; i < onCancelCallback.length; ++i) {
          this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
        }
      } else if (onCancelCallback !== void 0) {
        if (typeof onCancelCallback === "function") {
          if (!internalOnly) {
            var e = tryCatch(onCancelCallback).call(this._boundValue());
            if (e === errorObj) {
              this._attachExtraTrace(e.e);
              async2.throwLater(e.e);
            }
          }
        } else {
          onCancelCallback._resultCancelled(this);
        }
      }
    };
    Promise2.prototype._invokeOnCancel = function() {
      var onCancelCallback = this._onCancel();
      this._unsetOnCancel();
      async2.invoke(this._doInvokeOnCancel, this, onCancelCallback);
    };
    Promise2.prototype._invokeInternalOnCancel = function() {
      if (this._isCancellable()) {
        this._doInvokeOnCancel(this._onCancel(), true);
        this._unsetOnCancel();
      }
    };
    Promise2.prototype._resultCancelled = function() {
      this.cancel();
    };
  };
  return cancel;
}
var direct_resolve;
var hasRequiredDirect_resolve;
function requireDirect_resolve() {
  if (hasRequiredDirect_resolve) return direct_resolve;
  hasRequiredDirect_resolve = 1;
  direct_resolve = function(Promise2) {
    function returner() {
      return this.value;
    }
    function thrower() {
      throw this.reason;
    }
    Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
      if (value instanceof Promise2) value.suppressUnhandledRejections();
      return this._then(
        returner,
        void 0,
        void 0,
        { value },
        void 0
      );
    };
    Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
      return this._then(
        thrower,
        void 0,
        void 0,
        { reason },
        void 0
      );
    };
    Promise2.prototype.catchThrow = function(reason) {
      if (arguments.length <= 1) {
        return this._then(
          void 0,
          thrower,
          void 0,
          { reason },
          void 0
        );
      } else {
        var _reason = arguments[1];
        var handler = function() {
          throw _reason;
        };
        return this.caught(reason, handler);
      }
    };
    Promise2.prototype.catchReturn = function(value) {
      if (arguments.length <= 1) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          void 0,
          returner,
          void 0,
          { value },
          void 0
        );
      } else {
        var _value = arguments[1];
        if (_value instanceof Promise2) _value.suppressUnhandledRejections();
        var handler = function() {
          return _value;
        };
        return this.caught(value, handler);
      }
    };
  };
  return direct_resolve;
}
var synchronous_inspection;
var hasRequiredSynchronous_inspection;
function requireSynchronous_inspection() {
  if (hasRequiredSynchronous_inspection) return synchronous_inspection;
  hasRequiredSynchronous_inspection = 1;
  synchronous_inspection = function(Promise2) {
    function PromiseInspection(promise2) {
      if (promise2 !== void 0) {
        promise2 = promise2._target();
        this._bitField = promise2._bitField;
        this._settledValueField = promise2._isFateSealed() ? promise2._settledValue() : void 0;
      } else {
        this._bitField = 0;
        this._settledValueField = void 0;
      }
    }
    PromiseInspection.prototype._settledValue = function() {
      return this._settledValueField;
    };
    var value = PromiseInspection.prototype.value = function() {
      if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
      if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
      }
      return this._settledValue();
    };
    var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
      return (this._bitField & 33554432) !== 0;
    };
    var isRejected = PromiseInspection.prototype.isRejected = function() {
      return (this._bitField & 16777216) !== 0;
    };
    var isPending = PromiseInspection.prototype.isPending = function() {
      return (this._bitField & 50397184) === 0;
    };
    var isResolved = PromiseInspection.prototype.isResolved = function() {
      return (this._bitField & 50331648) !== 0;
    };
    PromiseInspection.prototype.isCancelled = function() {
      return (this._bitField & 8454144) !== 0;
    };
    Promise2.prototype.__isCancelled = function() {
      return (this._bitField & 65536) === 65536;
    };
    Promise2.prototype._isCancelled = function() {
      return this._target().__isCancelled();
    };
    Promise2.prototype.isCancelled = function() {
      return (this._target()._bitField & 8454144) !== 0;
    };
    Promise2.prototype.isPending = function() {
      return isPending.call(this._target());
    };
    Promise2.prototype.isRejected = function() {
      return isRejected.call(this._target());
    };
    Promise2.prototype.isFulfilled = function() {
      return isFulfilled.call(this._target());
    };
    Promise2.prototype.isResolved = function() {
      return isResolved.call(this._target());
    };
    Promise2.prototype.value = function() {
      return value.call(this._target());
    };
    Promise2.prototype.reason = function() {
      var target = this._target();
      target._unsetRejectionIsUnhandled();
      return reason.call(target);
    };
    Promise2.prototype._value = function() {
      return this._settledValue();
    };
    Promise2.prototype._reason = function() {
      this._unsetRejectionIsUnhandled();
      return this._settledValue();
    };
    Promise2.PromiseInspection = PromiseInspection;
  };
  return synchronous_inspection;
}
var join;
var hasRequiredJoin;
function requireJoin() {
  if (hasRequiredJoin) return join;
  hasRequiredJoin = 1;
  join = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL, async2, getDomain) {
    var util2 = requireUtil$2();
    var canEvaluate = util2.canEvaluate;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var reject2;
    {
      if (canEvaluate) {
        var thenCallback = function(i2) {
          return new Function("value", "holder", "                             \n	            'use strict';                                                    \n	            holder.pIndex = value;                                           \n	            holder.checkFulfillment(this);                                   \n	            ".replace(/Index/g, i2));
        };
        var promiseSetter = function(i2) {
          return new Function("promise", "holder", "                           \n	            'use strict';                                                    \n	            holder.pIndex = promise;                                         \n	            ".replace(/Index/g, i2));
        };
        var generateHolderClass = function(total) {
          var props2 = new Array(total);
          for (var i2 = 0; i2 < props2.length; ++i2) {
            props2[i2] = "this.p" + (i2 + 1);
          }
          var assignment = props2.join(" = ") + " = null;";
          var cancellationCode = "var promise;\n" + props2.map(function(prop) {
            return "                                                         \n	                promise = " + prop + ";                                      \n	                if (promise instanceof Promise) {                            \n	                    promise.cancel();                                        \n	                }                                                            \n	            ";
          }).join("\n");
          var passedArguments = props2.join(", ");
          var name = "Holder$" + total;
          var code = "return function(tryCatch, errorObj, Promise, async) {    \n	            'use strict';                                                    \n	            function [TheName](fn) {                                         \n	                [TheProperties]                                              \n	                this.fn = fn;                                                \n	                this.asyncNeeded = true;                                     \n	                this.now = 0;                                                \n	            }                                                                \n	                                                                             \n	            [TheName].prototype._callFunction = function(promise) {          \n	                promise._pushContext();                                      \n	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n	                promise._popContext();                                       \n	                if (ret === errorObj) {                                      \n	                    promise._rejectCallback(ret.e, false);                   \n	                } else {                                                     \n	                    promise._resolveCallback(ret);                           \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype.checkFulfillment = function(promise) {       \n	                var now = ++this.now;                                        \n	                if (now === [TheTotal]) {                                    \n	                    if (this.asyncNeeded) {                                  \n	                        async.invoke(this._callFunction, this, promise);     \n	                    } else {                                                 \n	                        this._callFunction(promise);                         \n	                    }                                                        \n	                                                                             \n	                }                                                            \n	            };                                                               \n	                                                                             \n	            [TheName].prototype._resultCancelled = function() {              \n	                [CancellationCode]                                           \n	            };                                                               \n	                                                                             \n	            return [TheName];                                                \n	        }(tryCatch, errorObj, Promise, async);                               \n	        ";
          code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
          return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch, errorObj, Promise2, async2);
        };
        var holderClasses = [];
        var thenCallbacks = [];
        var promiseSetters = [];
        for (var i = 0; i < 8; ++i) {
          holderClasses.push(generateHolderClass(i + 1));
          thenCallbacks.push(thenCallback(i + 1));
          promiseSetters.push(promiseSetter(i + 1));
        }
        reject2 = function(reason) {
          this._reject(reason);
        };
      }
    }
    Promise2.join = function() {
      var last = arguments.length - 1;
      var fn;
      if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        {
          if (last <= 8 && canEvaluate) {
            var ret = new Promise2(INTERNAL);
            ret._captureStackTrace();
            var HolderClass = holderClasses[last - 1];
            var holder = new HolderClass(fn);
            var callbacks = thenCallbacks;
            for (var i2 = 0; i2 < last; ++i2) {
              var maybePromise = tryConvertToPromise(arguments[i2], ret);
              if (maybePromise instanceof Promise2) {
                maybePromise = maybePromise._target();
                var bitField = maybePromise._bitField;
                if ((bitField & 50397184) === 0) {
                  maybePromise._then(
                    callbacks[i2],
                    reject2,
                    void 0,
                    ret,
                    holder
                  );
                  promiseSetters[i2](maybePromise, holder);
                  holder.asyncNeeded = false;
                } else if ((bitField & 33554432) !== 0) {
                  callbacks[i2].call(
                    ret,
                    maybePromise._value(),
                    holder
                  );
                } else if ((bitField & 16777216) !== 0) {
                  ret._reject(maybePromise._reason());
                } else {
                  ret._cancel();
                }
              } else {
                callbacks[i2].call(ret, maybePromise, holder);
              }
            }
            if (!ret._isFateSealed()) {
              if (holder.asyncNeeded) {
                var domain = getDomain();
                if (domain !== null) {
                  holder.fn = util2.domainBind(domain, holder.fn);
                }
              }
              ret._setAsyncGuaranteed();
              ret._setOnCancel(holder);
            }
            return ret;
          }
        }
      }
      var $_len = arguments.length;
      var args = new Array($_len);
      for (var $_i = 0; $_i < $_len; ++$_i) {
        args[$_i] = arguments[$_i];
      }
      if (fn) args.pop();
      var ret = new PromiseArray(args).promise();
      return fn !== void 0 ? ret.spread(fn) : ret;
    };
  };
  return join;
}
var map;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap) return map;
  hasRequiredMap = 1;
  map = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil$2();
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    var async2 = Promise2._async;
    function MappingPromiseArray(promises, fn, limit, _filter2) {
      this.constructor$(promises);
      this._promise._captureStackTrace();
      var domain = getDomain();
      this._callback = domain === null ? fn : util2.domainBind(domain, fn);
      this._preservedValues = _filter2 === INTERNAL ? new Array(this.length()) : null;
      this._limit = limit;
      this._inFlight = 0;
      this._queue = [];
      async2.invoke(this._asyncInit, this, void 0);
    }
    util2.inherits(MappingPromiseArray, PromiseArray);
    MappingPromiseArray.prototype._asyncInit = function() {
      this._init$(void 0, -2);
    };
    MappingPromiseArray.prototype._init = function() {
    };
    MappingPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var values = this._values;
      var length = this.length();
      var preservedValues = this._preservedValues;
      var limit = this._limit;
      if (index2 < 0) {
        index2 = index2 * -1 - 1;
        values[index2] = value;
        if (limit >= 1) {
          this._inFlight--;
          this._drainQueue();
          if (this._isResolved()) return true;
        }
      } else {
        if (limit >= 1 && this._inFlight >= limit) {
          values[index2] = value;
          this._queue.push(index2);
          return false;
        }
        if (preservedValues !== null) preservedValues[index2] = value;
        var promise2 = this._promise;
        var callback = this._callback;
        var receiver = promise2._boundValue();
        promise2._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index2, length);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          preservedValues !== null ? "Promise.filter" : "Promise.map",
          promise2
        );
        if (ret === errorObj) {
          this._reject(ret.e);
          return true;
        }
        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise2) {
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          if ((bitField & 50397184) === 0) {
            if (limit >= 1) this._inFlight++;
            values[index2] = maybePromise;
            maybePromise._proxy(this, (index2 + 1) * -1);
            return false;
          } else if ((bitField & 33554432) !== 0) {
            ret = maybePromise._value();
          } else if ((bitField & 16777216) !== 0) {
            this._reject(maybePromise._reason());
            return true;
          } else {
            this._cancel();
            return true;
          }
        }
        values[index2] = ret;
      }
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= length) {
        if (preservedValues !== null) {
          this._filter(values, preservedValues);
        } else {
          this._resolve(values);
        }
        return true;
      }
      return false;
    };
    MappingPromiseArray.prototype._drainQueue = function() {
      var queue2 = this._queue;
      var limit = this._limit;
      var values = this._values;
      while (queue2.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index2 = queue2.pop();
        this._promiseFulfilled(values[index2], index2);
      }
    };
    MappingPromiseArray.prototype._filter = function(booleans, values) {
      var len = values.length;
      var ret = new Array(len);
      var j = 0;
      for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
      }
      ret.length = j;
      this._resolve(ret);
    };
    MappingPromiseArray.prototype.preservedValues = function() {
      return this._preservedValues;
    };
    function map2(promises, fn, options, _filter2) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var limit = 0;
      if (options !== void 0) {
        if (typeof options === "object" && options !== null) {
          if (typeof options.concurrency !== "number") {
            return Promise2.reject(
              new TypeError("'concurrency' must be a number but it is " + util2.classString(options.concurrency))
            );
          }
          limit = options.concurrency;
        } else {
          return Promise2.reject(new TypeError(
            "options argument must be an object but it is " + util2.classString(options)
          ));
        }
      }
      limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
      return new MappingPromiseArray(promises, fn, limit, _filter2).promise();
    }
    Promise2.prototype.map = function(fn, options) {
      return map2(this, fn, options, null);
    };
    Promise2.map = function(promises, fn, options, _filter2) {
      return map2(promises, fn, options, _filter2);
    };
  };
  return map;
}
var call_get;
var hasRequiredCall_get;
function requireCall_get() {
  if (hasRequiredCall_get) return call_get;
  hasRequiredCall_get = 1;
  var cr = Object.create;
  if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
  }
  call_get = function(Promise2) {
    var util2 = requireUtil$2();
    var canEvaluate = util2.canEvaluate;
    var isIdentifier = util2.isIdentifier;
    var getMethodCaller;
    var getGetter;
    {
      var makeMethodCaller = function(methodName) {
        return new Function("ensureMethod", "                                    \n	        return function(obj) {                                               \n	            'use strict'                                                     \n	            var len = this.length;                                           \n	            ensureMethod(obj, 'methodName');                                 \n	            switch(len) {                                                    \n	                case 1: return obj.methodName(this[0]);                      \n	                case 2: return obj.methodName(this[0], this[1]);             \n	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n	                case 0: return obj.methodName();                             \n	                default:                                                     \n	                    return obj.methodName.apply(obj, this);                  \n	            }                                                                \n	        };                                                                   \n	        ".replace(/methodName/g, methodName))(ensureMethod);
      };
      var makeGetter = function(propertyName) {
        return new Function("obj", "                                             \n	        'use strict';                                                        \n	        return obj.propertyName;                                             \n	        ".replace("propertyName", propertyName));
      };
      var getCompiled = function(name, compiler, cache) {
        var ret = cache[name];
        if (typeof ret !== "function") {
          if (!isIdentifier(name)) {
            return null;
          }
          ret = compiler(name);
          cache[name] = ret;
          cache[" size"]++;
          if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
          }
        }
        return ret;
      };
      getMethodCaller = function(name) {
        return getCompiled(name, makeMethodCaller, callerCache);
      };
      getGetter = function(name) {
        return getCompiled(name, makeGetter, getterCache);
      };
    }
    function ensureMethod(obj, methodName) {
      var fn;
      if (obj != null) fn = obj[methodName];
      if (typeof fn !== "function") {
        var message = "Object " + util2.classString(obj) + " has no method '" + util2.toString(methodName) + "'";
        throw new Promise2.TypeError(message);
      }
      return fn;
    }
    function caller(obj) {
      var methodName = this.pop();
      var fn = ensureMethod(obj, methodName);
      return fn.apply(obj, this);
    }
    Promise2.prototype.call = function(methodName) {
      var $_len = arguments.length;
      var args = new Array(Math.max($_len - 1, 0));
      for (var $_i = 1; $_i < $_len; ++$_i) {
        args[$_i - 1] = arguments[$_i];
      }
      {
        if (canEvaluate) {
          var maybeCaller = getMethodCaller(methodName);
          if (maybeCaller !== null) {
            return this._then(
              maybeCaller,
              void 0,
              void 0,
              args,
              void 0
            );
          }
        }
      }
      args.push(methodName);
      return this._then(caller, void 0, void 0, args, void 0);
    };
    function namedGetter(obj) {
      return obj[this];
    }
    function indexedGetter(obj) {
      var index2 = +this;
      if (index2 < 0) index2 = Math.max(0, index2 + obj.length);
      return obj[index2];
    }
    Promise2.prototype.get = function(propertyName) {
      var isIndex = typeof propertyName === "number";
      var getter;
      if (!isIndex) {
        if (canEvaluate) {
          var maybeGetter = getGetter(propertyName);
          getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
          getter = namedGetter;
        }
      } else {
        getter = indexedGetter;
      }
      return this._then(getter, void 0, void 0, propertyName, void 0);
    };
  };
  return call_get;
}
var using;
var hasRequiredUsing;
function requireUsing() {
  if (hasRequiredUsing) return using;
  hasRequiredUsing = 1;
  using = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug) {
    var util2 = requireUtil$2();
    var TypeError2 = requireErrors().TypeError;
    var inherits2 = requireUtil$2().inherits;
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var NULL = {};
    function thrower(e) {
      setTimeout(function() {
        throw e;
      }, 0);
    }
    function castPreservingDisposable(thenable) {
      var maybePromise = tryConvertToPromise(thenable);
      if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
        maybePromise._setDisposable(thenable._getDisposer());
      }
      return maybePromise;
    }
    function dispose(resources, inspection) {
      var i = 0;
      var len = resources.length;
      var ret = new Promise2(INTERNAL);
      function iterator2() {
        if (i >= len) return ret._fulfill();
        var maybePromise = castPreservingDisposable(resources[i++]);
        if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
          try {
            maybePromise = tryConvertToPromise(
              maybePromise._getDisposer().tryDispose(inspection),
              resources.promise
            );
          } catch (e) {
            return thrower(e);
          }
          if (maybePromise instanceof Promise2) {
            return maybePromise._then(
              iterator2,
              thrower,
              null,
              null,
              null
            );
          }
        }
        iterator2();
      }
      iterator2();
      return ret;
    }
    function Disposer(data2, promise2, context2) {
      this._data = data2;
      this._promise = promise2;
      this._context = context2;
    }
    Disposer.prototype.data = function() {
      return this._data;
    };
    Disposer.prototype.promise = function() {
      return this._promise;
    };
    Disposer.prototype.resource = function() {
      if (this.promise().isFulfilled()) {
        return this.promise().value();
      }
      return NULL;
    };
    Disposer.prototype.tryDispose = function(inspection) {
      var resource = this.resource();
      var context2 = this._context;
      if (context2 !== void 0) context2._pushContext();
      var ret = resource !== NULL ? this.doDispose(resource, inspection) : null;
      if (context2 !== void 0) context2._popContext();
      this._promise._unsetDisposable();
      this._data = null;
      return ret;
    };
    Disposer.isDisposer = function(d) {
      return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
    };
    function FunctionDisposer(fn, promise2, context2) {
      this.constructor$(fn, promise2, context2);
    }
    inherits2(FunctionDisposer, Disposer);
    FunctionDisposer.prototype.doDispose = function(resource, inspection) {
      var fn = this.data();
      return fn.call(resource, resource, inspection);
    };
    function maybeUnwrapDisposer(value) {
      if (Disposer.isDisposer(value)) {
        this.resources[this.index]._setDisposable(value);
        return value.promise();
      }
      return value;
    }
    function ResourceList(length) {
      this.length = length;
      this.promise = null;
      this[length - 1] = null;
    }
    ResourceList.prototype._resultCancelled = function() {
      var len = this.length;
      for (var i = 0; i < len; ++i) {
        var item = this[i];
        if (item instanceof Promise2) {
          item.cancel();
        }
      }
    };
    Promise2.using = function() {
      var len = arguments.length;
      if (len < 2) return apiRejection(
        "you must pass at least 2 arguments to Promise.using"
      );
      var fn = arguments[len - 1];
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var input;
      var spreadArgs = true;
      if (len === 2 && Array.isArray(arguments[0])) {
        input = arguments[0];
        len = input.length;
        spreadArgs = false;
      } else {
        input = arguments;
        len--;
      }
      var resources = new ResourceList(len);
      for (var i = 0; i < len; ++i) {
        var resource = input[i];
        if (Disposer.isDisposer(resource)) {
          var disposer = resource;
          resource = resource.promise();
          resource._setDisposable(disposer);
        } else {
          var maybePromise = tryConvertToPromise(resource);
          if (maybePromise instanceof Promise2) {
            resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
              resources,
              index: i
            }, void 0);
          }
        }
        resources[i] = resource;
      }
      var reflectedResources = new Array(resources.length);
      for (var i = 0; i < reflectedResources.length; ++i) {
        reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
      }
      var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
        for (var i2 = 0; i2 < inspections.length; ++i2) {
          var inspection = inspections[i2];
          if (inspection.isRejected()) {
            errorObj.e = inspection.error();
            return errorObj;
          } else if (!inspection.isFulfilled()) {
            resultPromise.cancel();
            return;
          }
          inspections[i2] = inspection.value();
        }
        promise2._pushContext();
        fn = tryCatch(fn);
        var ret = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
        var promiseCreated = promise2._popContext();
        debug.checkForgottenReturns(
          ret,
          promiseCreated,
          "Promise.using",
          promise2
        );
        return ret;
      });
      var promise2 = resultPromise.lastly(function() {
        var inspection = new Promise2.PromiseInspection(resultPromise);
        return dispose(resources, inspection);
      });
      resources.promise = promise2;
      promise2._setOnCancel(resources);
      return promise2;
    };
    Promise2.prototype._setDisposable = function(disposer) {
      this._bitField = this._bitField | 131072;
      this._disposer = disposer;
    };
    Promise2.prototype._isDisposable = function() {
      return (this._bitField & 131072) > 0;
    };
    Promise2.prototype._getDisposer = function() {
      return this._disposer;
    };
    Promise2.prototype._unsetDisposable = function() {
      this._bitField = this._bitField & -131073;
      this._disposer = void 0;
    };
    Promise2.prototype.disposer = function(fn) {
      if (typeof fn === "function") {
        return new FunctionDisposer(fn, this, createContext());
      }
      throw new TypeError2();
    };
  };
  return using;
}
var timers;
var hasRequiredTimers;
function requireTimers() {
  if (hasRequiredTimers) return timers;
  hasRequiredTimers = 1;
  timers = function(Promise2, INTERNAL, debug) {
    var util2 = requireUtil$2();
    var TimeoutError = Promise2.TimeoutError;
    function HandleWrapper(handle) {
      this.handle = handle;
    }
    HandleWrapper.prototype._resultCancelled = function() {
      clearTimeout(this.handle);
    };
    var afterValue = function(value) {
      return delay(+this).thenReturn(value);
    };
    var delay = Promise2.delay = function(ms2, value) {
      var ret;
      var handle;
      if (value !== void 0) {
        ret = Promise2.resolve(value)._then(afterValue, null, null, ms2, void 0);
        if (debug.cancellation() && value instanceof Promise2) {
          ret._setOnCancel(value);
        }
      } else {
        ret = new Promise2(INTERNAL);
        handle = setTimeout(function() {
          ret._fulfill();
        }, +ms2);
        if (debug.cancellation()) {
          ret._setOnCancel(new HandleWrapper(handle));
        }
        ret._captureStackTrace();
      }
      ret._setAsyncGuaranteed();
      return ret;
    };
    Promise2.prototype.delay = function(ms2) {
      return delay(ms2, this);
    };
    var afterTimeout = function(promise2, message, parent2) {
      var err;
      if (typeof message !== "string") {
        if (message instanceof Error) {
          err = message;
        } else {
          err = new TimeoutError("operation timed out");
        }
      } else {
        err = new TimeoutError(message);
      }
      util2.markAsOriginatingFromRejection(err);
      promise2._attachExtraTrace(err);
      promise2._reject(err);
      if (parent2 != null) {
        parent2.cancel();
      }
    };
    function successClear(value) {
      clearTimeout(this.handle);
      return value;
    }
    function failureClear(reason) {
      clearTimeout(this.handle);
      throw reason;
    }
    Promise2.prototype.timeout = function(ms2, message) {
      ms2 = +ms2;
      var ret, parent2;
      var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
        if (ret.isPending()) {
          afterTimeout(ret, message, parent2);
        }
      }, ms2));
      if (debug.cancellation()) {
        parent2 = this.then();
        ret = parent2._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
        ret._setOnCancel(handleWrapper);
      } else {
        ret = this._then(
          successClear,
          failureClear,
          void 0,
          handleWrapper,
          void 0
        );
      }
      return ret;
    };
  };
  return timers;
}
var generators;
var hasRequiredGenerators;
function requireGenerators() {
  if (hasRequiredGenerators) return generators;
  hasRequiredGenerators = 1;
  generators = function(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug) {
    var errors2 = requireErrors();
    var TypeError2 = errors2.TypeError;
    var util2 = requireUtil$2();
    var errorObj = util2.errorObj;
    var tryCatch = util2.tryCatch;
    var yieldHandlers = [];
    function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
      for (var i = 0; i < yieldHandlers2.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers2[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
          traceParent._pushContext();
          var ret = Promise2.reject(errorObj.e);
          traceParent._popContext();
          return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise2) return maybePromise;
      }
      return null;
    }
    function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
      if (debug.cancellation()) {
        var internal = new Promise2(INTERNAL);
        var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL);
        this._promise = internal.lastly(function() {
          return _finallyPromise;
        });
        internal._captureStackTrace();
        internal._setOnCancel(this);
      } else {
        var promise2 = this._promise = new Promise2(INTERNAL);
        promise2._captureStackTrace();
      }
      this._stack = stack;
      this._generatorFunction = generatorFunction;
      this._receiver = receiver;
      this._generator = void 0;
      this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
      this._yieldedPromise = null;
      this._cancellationPhase = false;
    }
    util2.inherits(PromiseSpawn, Proxyable);
    PromiseSpawn.prototype._isResolved = function() {
      return this._promise === null;
    };
    PromiseSpawn.prototype._cleanup = function() {
      this._promise = this._generator = null;
      if (debug.cancellation() && this._finallyPromise !== null) {
        this._finallyPromise._fulfill();
        this._finallyPromise = null;
      }
    };
    PromiseSpawn.prototype._promiseCancelled = function() {
      if (this._isResolved()) return;
      var implementsReturn = typeof this._generator["return"] !== "undefined";
      var result;
      if (!implementsReturn) {
        var reason = new Promise2.CancellationError(
          "generator .return() sentinel"
        );
        Promise2.coroutine.returnSentinel = reason;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        result = tryCatch(this._generator["throw"]).call(
          this._generator,
          reason
        );
        this._promise._popContext();
      } else {
        this._promise._pushContext();
        result = tryCatch(this._generator["return"]).call(
          this._generator,
          void 0
        );
        this._promise._popContext();
      }
      this._cancellationPhase = true;
      this._yieldedPromise = null;
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseFulfilled = function(value) {
      this._yieldedPromise = null;
      this._promise._pushContext();
      var result = tryCatch(this._generator.next).call(this._generator, value);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._promiseRejected = function(reason) {
      this._yieldedPromise = null;
      this._promise._attachExtraTrace(reason);
      this._promise._pushContext();
      var result = tryCatch(this._generator["throw"]).call(this._generator, reason);
      this._promise._popContext();
      this._continue(result);
    };
    PromiseSpawn.prototype._resultCancelled = function() {
      if (this._yieldedPromise instanceof Promise2) {
        var promise2 = this._yieldedPromise;
        this._yieldedPromise = null;
        promise2.cancel();
      }
    };
    PromiseSpawn.prototype.promise = function() {
      return this._promise;
    };
    PromiseSpawn.prototype._run = function() {
      this._generator = this._generatorFunction.call(this._receiver);
      this._receiver = this._generatorFunction = void 0;
      this._promiseFulfilled(void 0);
    };
    PromiseSpawn.prototype._continue = function(result) {
      var promise2 = this._promise;
      if (result === errorObj) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._rejectCallback(result.e, false);
        }
      }
      var value = result.value;
      if (result.done === true) {
        this._cleanup();
        if (this._cancellationPhase) {
          return promise2.cancel();
        } else {
          return promise2._resolveCallback(value);
        }
      } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise2)) {
          maybePromise = promiseFromYieldHandler(
            maybePromise,
            this._yieldHandlers,
            this._promise
          );
          if (maybePromise === null) {
            this._promiseRejected(
              new TypeError2(
                "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
              )
            );
            return;
          }
        }
        maybePromise = maybePromise._target();
        var bitField = maybePromise._bitField;
        if ((bitField & 50397184) === 0) {
          this._yieldedPromise = maybePromise;
          maybePromise._proxy(this, null);
        } else if ((bitField & 33554432) !== 0) {
          Promise2._async.invoke(
            this._promiseFulfilled,
            this,
            maybePromise._value()
          );
        } else if ((bitField & 16777216) !== 0) {
          Promise2._async.invoke(
            this._promiseRejected,
            this,
            maybePromise._reason()
          );
        } else {
          this._promiseCancelled();
        }
      }
    };
    Promise2.coroutine = function(generatorFunction, options) {
      if (typeof generatorFunction !== "function") {
        throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var yieldHandler = Object(options).yieldHandler;
      var PromiseSpawn$ = PromiseSpawn;
      var stack = new Error().stack;
      return function() {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(
          void 0,
          void 0,
          yieldHandler,
          stack
        );
        var ret = spawn.promise();
        spawn._generator = generator;
        spawn._promiseFulfilled(void 0);
        return ret;
      };
    };
    Promise2.coroutine.addYieldHandler = function(fn) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      yieldHandlers.push(fn);
    };
    Promise2.spawn = function(generatorFunction) {
      debug.deprecated("Promise.spawn()", "Promise.coroutine()");
      if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      var spawn = new PromiseSpawn(generatorFunction, this);
      var ret = spawn.promise();
      spawn._run(Promise2.spawn);
      return ret;
    };
  };
  return generators;
}
var nodeify;
var hasRequiredNodeify;
function requireNodeify() {
  if (hasRequiredNodeify) return nodeify;
  hasRequiredNodeify = 1;
  nodeify = function(Promise2) {
    var util2 = requireUtil$2();
    var async2 = Promise2._async;
    var tryCatch = util2.tryCatch;
    var errorObj = util2.errorObj;
    function spreadAdapter(val, nodeback2) {
      var promise2 = this;
      if (!util2.isArray(val)) return successAdapter.call(promise2, val, nodeback2);
      var ret = tryCatch(nodeback2).apply(promise2._boundValue(), [null].concat(val));
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function successAdapter(val, nodeback2) {
      var promise2 = this;
      var receiver = promise2._boundValue();
      var ret = val === void 0 ? tryCatch(nodeback2).call(receiver, null) : tryCatch(nodeback2).call(receiver, null, val);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    function errorAdapter(reason, nodeback2) {
      var promise2 = this;
      if (!reason) {
        var newReason = new Error(reason + "");
        newReason.cause = reason;
        reason = newReason;
      }
      var ret = tryCatch(nodeback2).call(promise2._boundValue(), reason);
      if (ret === errorObj) {
        async2.throwLater(ret.e);
      }
    }
    Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback2, options) {
      if (typeof nodeback2 == "function") {
        var adapter = successAdapter;
        if (options !== void 0 && Object(options).spread) {
          adapter = spreadAdapter;
        }
        this._then(
          adapter,
          errorAdapter,
          void 0,
          this,
          nodeback2
        );
      }
      return this;
    };
  };
  return nodeify;
}
var promisify;
var hasRequiredPromisify;
function requirePromisify() {
  if (hasRequiredPromisify) return promisify;
  hasRequiredPromisify = 1;
  promisify = function(Promise2, INTERNAL) {
    var THIS = {};
    var util2 = requireUtil$2();
    var nodebackForPromise = requireNodeback();
    var withAppended = util2.withAppended;
    var maybeWrapAsError = util2.maybeWrapAsError;
    var canEvaluate = util2.canEvaluate;
    var TypeError2 = requireErrors().TypeError;
    var defaultSuffix = "Async";
    var defaultPromisified = { __isPromisified__: true };
    var noCopyProps = [
      "arity",
      "length",
      "name",
      "arguments",
      "caller",
      "callee",
      "prototype",
      "__isPromisified__"
    ];
    var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
    var defaultFilter = function(name) {
      return util2.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
    };
    function propsFilter(key) {
      return !noCopyPropsPattern.test(key);
    }
    function isPromisified(fn) {
      try {
        return fn.__isPromisified__ === true;
      } catch (e) {
        return false;
      }
    }
    function hasPromisified(obj, key, suffix) {
      var val = util2.getDataPropertyOrDefault(
        obj,
        key + suffix,
        defaultPromisified
      );
      return val ? isPromisified(val) : false;
    }
    function checkValid(ret, suffix, suffixRegexp) {
      for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
          var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
          for (var j = 0; j < ret.length; j += 2) {
            if (ret[j] === keyWithoutAsyncSuffix) {
              throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
            }
          }
        }
      }
    }
    function promisifiableMethods(obj, suffix, suffixRegexp, filter3) {
      var keys = util2.inheritedDataKeys(obj);
      var ret = [];
      for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter3 === defaultFilter ? true : defaultFilter(key);
        if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj, key, suffix) && filter3(key, value, obj, passesDefaultFilter)) {
          ret.push(key, value);
        }
      }
      checkValid(ret, suffix, suffixRegexp);
      return ret;
    }
    var escapeIdentRegex = function(str) {
      return str.replace(/([$])/, "\\$");
    };
    var makeNodePromisifiedEval;
    {
      var switchCaseArgumentOrder = function(likelyArgumentCount) {
        var ret = [likelyArgumentCount];
        var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
        for (var i = likelyArgumentCount - 1; i >= min2; --i) {
          ret.push(i);
        }
        for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
          ret.push(i);
        }
        return ret;
      };
      var argumentSequence = function(argumentCount) {
        return util2.filledRange(argumentCount, "_arg", "");
      };
      var parameterDeclaration = function(parameterCount2) {
        return util2.filledRange(
          Math.max(parameterCount2, 3),
          "_arg",
          ""
        );
      };
      var parameterCount = function(fn) {
        if (typeof fn.length === "number") {
          return Math.max(Math.min(fn.length, 1023 + 1), 0);
        }
        return 0;
      };
      makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _2, multiArgs) {
        var newParameterCount = Math.max(0, parameterCount(fn) - 1);
        var argumentOrder = switchCaseArgumentOrder(newParameterCount);
        var shouldProxyThis = typeof callback === "string" || receiver === THIS;
        function generateCallForArgumentCount(count) {
          var args = argumentSequence(count).join(", ");
          var comma = count > 0 ? ", " : "";
          var ret;
          if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
          } else {
            ret = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
          }
          return ret.replace("{{args}}", args).replace(", ", comma);
        }
        function generateArgumentSwitchCase() {
          var ret = "";
          for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
          }
          ret += "                                                             \n	        default:                                                             \n	            var args = new Array(len + 1);                                   \n	            var i = 0;                                                       \n	            for (var i = 0; i < len; ++i) {                                  \n	               args[i] = arguments[i];                                       \n	            }                                                                \n	            args[i] = nodeback;                                              \n	            [CodeForCall]                                                    \n	            break;                                                           \n	        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
          return ret;
        }
        var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
        var body = "'use strict';                                                \n	        var ret = function (Parameters) {                                    \n	            'use strict';                                                    \n	            var len = arguments.length;                                      \n	            var promise = new Promise(INTERNAL);                             \n	            promise._captureStackTrace();                                    \n	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n	            var ret;                                                         \n	            var callback = tryCatch([GetFunctionCode]);                      \n	            switch(len) {                                                    \n	                [CodeForSwitchCase]                                          \n	            }                                                                \n	            if (ret === errorObj) {                                          \n	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n	            }                                                                \n	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n	            return promise;                                                  \n	        };                                                                   \n	        notEnumerableProp(ret, '__isPromisified__', true);                   \n	        return ret;                                                          \n	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
        body = body.replace("Parameters", parameterDeclaration(newParameterCount));
        return new Function(
          "Promise",
          "fn",
          "receiver",
          "withAppended",
          "maybeWrapAsError",
          "nodebackForPromise",
          "tryCatch",
          "errorObj",
          "notEnumerableProp",
          "INTERNAL",
          body
        )(
          Promise2,
          fn,
          receiver,
          withAppended,
          maybeWrapAsError,
          nodebackForPromise,
          util2.tryCatch,
          util2.errorObj,
          util2.notEnumerableProp,
          INTERNAL
        );
      };
    }
    function makeNodePromisifiedClosure(callback, receiver, _2, fn, __, multiArgs) {
      var defaultThis = /* @__PURE__ */ function() {
        return this;
      }();
      var method2 = callback;
      if (typeof method2 === "string") {
        callback = fn;
      }
      function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise2 = new Promise2(INTERNAL);
        promise2._captureStackTrace();
        var cb = typeof method2 === "string" && this !== defaultThis ? this[method2] : callback;
        var fn2 = nodebackForPromise(promise2, multiArgs);
        try {
          cb.apply(_receiver, withAppended(arguments, fn2));
        } catch (e) {
          promise2._rejectCallback(maybeWrapAsError(e), true, true);
        }
        if (!promise2._isFateSealed()) promise2._setAsyncGuaranteed();
        return promise2;
      }
      util2.notEnumerableProp(promisified, "__isPromisified__", true);
      return promisified;
    }
    var makeNodePromisified = canEvaluate ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
    function promisifyAll(obj, suffix, filter3, promisifier, multiArgs) {
      var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
      var methods = promisifiableMethods(obj, suffix, suffixRegexp, filter3);
      for (var i = 0, len = methods.length; i < len; i += 2) {
        var key = methods[i];
        var fn = methods[i + 1];
        var promisifiedKey = key + suffix;
        if (promisifier === makeNodePromisified) {
          obj[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
        } else {
          var promisified = promisifier(fn, function() {
            return makeNodePromisified(
              key,
              THIS,
              key,
              fn,
              suffix,
              multiArgs
            );
          });
          util2.notEnumerableProp(promisified, "__isPromisified__", true);
          obj[promisifiedKey] = promisified;
        }
      }
      util2.toFastProperties(obj);
      return obj;
    }
    function promisify2(callback, receiver, multiArgs) {
      return makeNodePromisified(
        callback,
        receiver,
        void 0,
        callback,
        null,
        multiArgs
      );
    }
    Promise2.promisify = function(fn, options) {
      if (typeof fn !== "function") {
        throw new TypeError2("expecting a function but got " + util2.classString(fn));
      }
      if (isPromisified(fn)) {
        return fn;
      }
      options = Object(options);
      var receiver = options.context === void 0 ? THIS : options.context;
      var multiArgs = !!options.multiArgs;
      var ret = promisify2(fn, receiver, multiArgs);
      util2.copyDescriptors(fn, ret, propsFilter);
      return ret;
    };
    Promise2.promisifyAll = function(target, options) {
      if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
      }
      options = Object(options);
      var multiArgs = !!options.multiArgs;
      var suffix = options.suffix;
      if (typeof suffix !== "string") suffix = defaultSuffix;
      var filter3 = options.filter;
      if (typeof filter3 !== "function") filter3 = defaultFilter;
      var promisifier = options.promisifier;
      if (typeof promisifier !== "function") promisifier = makeNodePromisified;
      if (!util2.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
      }
      var keys = util2.inheritedDataKeys(target);
      for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" && util2.isClass(value)) {
          promisifyAll(
            value.prototype,
            suffix,
            filter3,
            promisifier,
            multiArgs
          );
          promisifyAll(value, suffix, filter3, promisifier, multiArgs);
        }
      }
      return promisifyAll(target, suffix, filter3, promisifier, multiArgs);
    };
  };
  return promisify;
}
var props;
var hasRequiredProps;
function requireProps() {
  if (hasRequiredProps) return props;
  hasRequiredProps = 1;
  props = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil$2();
    var isObject2 = util2.isObject;
    var es52 = requireEs5();
    var Es6Map;
    if (typeof Map === "function") Es6Map = Map;
    var mapToEntries = /* @__PURE__ */ function() {
      var index2 = 0;
      var size = 0;
      function extractEntry(value, key) {
        this[index2] = value;
        this[index2 + size] = key;
        index2++;
      }
      return function mapToEntries2(map2) {
        size = map2.size;
        index2 = 0;
        var ret = new Array(map2.size * 2);
        map2.forEach(extractEntry, ret);
        return ret;
      };
    }();
    var entriesToMap = function(entries) {
      var ret = new Es6Map();
      var length = entries.length / 2 | 0;
      for (var i = 0; i < length; ++i) {
        var key = entries[length + i];
        var value = entries[i];
        ret.set(key, value);
      }
      return ret;
    };
    function PropertiesPromiseArray(obj) {
      var isMap = false;
      var entries;
      if (Es6Map !== void 0 && obj instanceof Es6Map) {
        entries = mapToEntries(obj);
        isMap = true;
      } else {
        var keys = es52.keys(obj);
        var len = keys.length;
        entries = new Array(len * 2);
        for (var i = 0; i < len; ++i) {
          var key = keys[i];
          entries[i] = obj[key];
          entries[i + len] = key;
        }
      }
      this.constructor$(entries);
      this._isMap = isMap;
      this._init$(void 0, -3);
    }
    util2.inherits(PropertiesPromiseArray, PromiseArray);
    PropertiesPromiseArray.prototype._init = function() {
    };
    PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      this._values[index2] = value;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        var val;
        if (this._isMap) {
          val = entriesToMap(this._values);
        } else {
          val = {};
          var keyOffset = this.length();
          for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
          }
        }
        this._resolve(val);
        return true;
      }
      return false;
    };
    PropertiesPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    PropertiesPromiseArray.prototype.getActualLength = function(len) {
      return len >> 1;
    };
    function props2(promises) {
      var ret;
      var castValue = tryConvertToPromise(promises);
      if (!isObject2(castValue)) {
        return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
      } else if (castValue instanceof Promise2) {
        ret = castValue._then(
          Promise2.props,
          void 0,
          void 0,
          void 0,
          void 0
        );
      } else {
        ret = new PropertiesPromiseArray(castValue).promise();
      }
      if (castValue instanceof Promise2) {
        ret._propagateFrom(castValue, 2);
      }
      return ret;
    }
    Promise2.prototype.props = function() {
      return props2(this);
    };
    Promise2.props = function(promises) {
      return props2(promises);
    };
  };
  return props;
}
var race;
var hasRequiredRace;
function requireRace() {
  if (hasRequiredRace) return race;
  hasRequiredRace = 1;
  race = function(Promise2, INTERNAL, tryConvertToPromise, apiRejection) {
    var util2 = requireUtil$2();
    var raceLater = function(promise2) {
      return promise2.then(function(array) {
        return race2(array, promise2);
      });
    };
    function race2(promises, parent2) {
      var maybePromise = tryConvertToPromise(promises);
      if (maybePromise instanceof Promise2) {
        return raceLater(maybePromise);
      } else {
        promises = util2.asArray(promises);
        if (promises === null)
          return apiRejection("expecting an array or an iterable object but got " + util2.classString(promises));
      }
      var ret = new Promise2(INTERNAL);
      if (parent2 !== void 0) {
        ret._propagateFrom(parent2, 3);
      }
      var fulfill = ret._fulfill;
      var reject2 = ret._reject;
      for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];
        if (val === void 0 && !(i in promises)) {
          continue;
        }
        Promise2.cast(val)._then(fulfill, reject2, void 0, ret, null);
      }
      return ret;
    }
    Promise2.race = function(promises) {
      return race2(promises, void 0);
    };
    Promise2.prototype.race = function() {
      return race2(this, void 0);
    };
  };
  return race;
}
var reduce;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce) return reduce;
  hasRequiredReduce = 1;
  reduce = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug) {
    var getDomain = Promise2._getDomain;
    var util2 = requireUtil$2();
    var tryCatch = util2.tryCatch;
    function ReductionPromiseArray(promises, fn, initialValue, _each) {
      this.constructor$(promises);
      var domain = getDomain();
      this._fn = domain === null ? fn : util2.domainBind(domain, fn);
      if (initialValue !== void 0) {
        initialValue = Promise2.resolve(initialValue);
        initialValue._attachCancellationCallback(this);
      }
      this._initialValue = initialValue;
      this._currentCancellable = null;
      if (_each === INTERNAL) {
        this._eachValues = Array(this._length);
      } else if (_each === 0) {
        this._eachValues = null;
      } else {
        this._eachValues = void 0;
      }
      this._promise._captureStackTrace();
      this._init$(void 0, -5);
    }
    util2.inherits(ReductionPromiseArray, PromiseArray);
    ReductionPromiseArray.prototype._gotAccum = function(accum) {
      if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL) {
        this._eachValues.push(accum);
      }
    };
    ReductionPromiseArray.prototype._eachComplete = function(value) {
      if (this._eachValues !== null) {
        this._eachValues.push(value);
      }
      return this._eachValues;
    };
    ReductionPromiseArray.prototype._init = function() {
    };
    ReductionPromiseArray.prototype._resolveEmptyArray = function() {
      this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
    };
    ReductionPromiseArray.prototype.shouldCopyValues = function() {
      return false;
    };
    ReductionPromiseArray.prototype._resolve = function(value) {
      this._promise._resolveCallback(value);
      this._values = null;
    };
    ReductionPromiseArray.prototype._resultCancelled = function(sender) {
      if (sender === this._initialValue) return this._cancel();
      if (this._isResolved()) return;
      this._resultCancelled$();
      if (this._currentCancellable instanceof Promise2) {
        this._currentCancellable.cancel();
      }
      if (this._initialValue instanceof Promise2) {
        this._initialValue.cancel();
      }
    };
    ReductionPromiseArray.prototype._iterate = function(values) {
      this._values = values;
      var value;
      var i;
      var length = values.length;
      if (this._initialValue !== void 0) {
        value = this._initialValue;
        i = 0;
      } else {
        value = Promise2.resolve(values[0]);
        i = 1;
      }
      this._currentCancellable = value;
      if (!value.isRejected()) {
        for (; i < length; ++i) {
          var ctx = {
            accum: null,
            value: values[i],
            index: i,
            length,
            array: this
          };
          value = value._then(gotAccum, void 0, void 0, ctx, void 0);
        }
      }
      if (this._eachValues !== void 0) {
        value = value._then(this._eachComplete, void 0, void 0, this, void 0);
      }
      value._then(completed, completed, void 0, value, this);
    };
    Promise2.prototype.reduce = function(fn, initialValue) {
      return reduce2(this, fn, initialValue, null);
    };
    Promise2.reduce = function(promises, fn, initialValue, _each) {
      return reduce2(promises, fn, initialValue, _each);
    };
    function completed(valueOrReason, array) {
      if (this.isFulfilled()) {
        array._resolve(valueOrReason);
      } else {
        array._reject(valueOrReason);
      }
    }
    function reduce2(promises, fn, initialValue, _each) {
      if (typeof fn !== "function") {
        return apiRejection("expecting a function but got " + util2.classString(fn));
      }
      var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
      return array.promise();
    }
    function gotAccum(accum) {
      this.accum = accum;
      this.array._gotAccum(accum);
      var value = tryConvertToPromise(this.value, this.array._promise);
      if (value instanceof Promise2) {
        this.array._currentCancellable = value;
        return value._then(gotValue, void 0, void 0, this, void 0);
      } else {
        return gotValue.call(this, value);
      }
    }
    function gotValue(value) {
      var array = this.array;
      var promise2 = array._promise;
      var fn = tryCatch(array._fn);
      promise2._pushContext();
      var ret;
      if (array._eachValues !== void 0) {
        ret = fn.call(promise2._boundValue(), value, this.index, this.length);
      } else {
        ret = fn.call(
          promise2._boundValue(),
          this.accum,
          value,
          this.index,
          this.length
        );
      }
      if (ret instanceof Promise2) {
        array._currentCancellable = ret;
      }
      var promiseCreated = promise2._popContext();
      debug.checkForgottenReturns(
        ret,
        promiseCreated,
        array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
        promise2
      );
      return ret;
    }
  };
  return reduce;
}
var settle;
var hasRequiredSettle;
function requireSettle() {
  if (hasRequiredSettle) return settle;
  hasRequiredSettle = 1;
  settle = function(Promise2, PromiseArray, debug) {
    var PromiseInspection = Promise2.PromiseInspection;
    var util2 = requireUtil$2();
    function SettledPromiseArray(values) {
      this.constructor$(values);
    }
    util2.inherits(SettledPromiseArray, PromiseArray);
    SettledPromiseArray.prototype._promiseResolved = function(index2, inspection) {
      this._values[index2] = inspection;
      var totalResolved = ++this._totalResolved;
      if (totalResolved >= this._length) {
        this._resolve(this._values);
        return true;
      }
      return false;
    };
    SettledPromiseArray.prototype._promiseFulfilled = function(value, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 33554432;
      ret._settledValueField = value;
      return this._promiseResolved(index2, ret);
    };
    SettledPromiseArray.prototype._promiseRejected = function(reason, index2) {
      var ret = new PromiseInspection();
      ret._bitField = 16777216;
      ret._settledValueField = reason;
      return this._promiseResolved(index2, ret);
    };
    Promise2.settle = function(promises) {
      debug.deprecated(".settle()", ".reflect()");
      return new SettledPromiseArray(promises).promise();
    };
    Promise2.prototype.settle = function() {
      return Promise2.settle(this);
    };
  };
  return settle;
}
var some;
var hasRequiredSome;
function requireSome() {
  if (hasRequiredSome) return some;
  hasRequiredSome = 1;
  some = function(Promise2, PromiseArray, apiRejection) {
    var util2 = requireUtil$2();
    var RangeError2 = requireErrors().RangeError;
    var AggregateError2 = requireErrors().AggregateError;
    var isArray2 = util2.isArray;
    var CANCELLATION = {};
    function SomePromiseArray(values) {
      this.constructor$(values);
      this._howMany = 0;
      this._unwrap = false;
      this._initialized = false;
    }
    util2.inherits(SomePromiseArray, PromiseArray);
    SomePromiseArray.prototype._init = function() {
      if (!this._initialized) {
        return;
      }
      if (this._howMany === 0) {
        this._resolve([]);
        return;
      }
      this._init$(void 0, -5);
      var isArrayResolved = isArray2(this._values);
      if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
      }
    };
    SomePromiseArray.prototype.init = function() {
      this._initialized = true;
      this._init();
    };
    SomePromiseArray.prototype.setUnwrap = function() {
      this._unwrap = true;
    };
    SomePromiseArray.prototype.howMany = function() {
      return this._howMany;
    };
    SomePromiseArray.prototype.setHowMany = function(count) {
      this._howMany = count;
    };
    SomePromiseArray.prototype._promiseFulfilled = function(value) {
      this._addFulfilled(value);
      if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
          this._resolve(this._values[0]);
        } else {
          this._resolve(this._values);
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._promiseRejected = function(reason) {
      this._addRejected(reason);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._promiseCancelled = function() {
      if (this._values instanceof Promise2 || this._values == null) {
        return this._cancel();
      }
      this._addRejected(CANCELLATION);
      return this._checkOutcome();
    };
    SomePromiseArray.prototype._checkOutcome = function() {
      if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError2();
        for (var i = this.length(); i < this._values.length; ++i) {
          if (this._values[i] !== CANCELLATION) {
            e.push(this._values[i]);
          }
        }
        if (e.length > 0) {
          this._reject(e);
        } else {
          this._cancel();
        }
        return true;
      }
      return false;
    };
    SomePromiseArray.prototype._fulfilled = function() {
      return this._totalResolved;
    };
    SomePromiseArray.prototype._rejected = function() {
      return this._values.length - this.length();
    };
    SomePromiseArray.prototype._addRejected = function(reason) {
      this._values.push(reason);
    };
    SomePromiseArray.prototype._addFulfilled = function(value) {
      this._values[this._totalResolved++] = value;
    };
    SomePromiseArray.prototype._canPossiblyFulfill = function() {
      return this.length() - this._rejected();
    };
    SomePromiseArray.prototype._getRangeError = function(count) {
      var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
      return new RangeError2(message);
    };
    SomePromiseArray.prototype._resolveEmptyArray = function() {
      this._reject(this._getRangeError(0));
    };
    function some2(promises, howMany) {
      if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
      }
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(howMany);
      ret.init();
      return promise2;
    }
    Promise2.some = function(promises, howMany) {
      return some2(promises, howMany);
    };
    Promise2.prototype.some = function(howMany) {
      return some2(this, howMany);
    };
    Promise2._SomePromiseArray = SomePromiseArray;
  };
  return some;
}
var filter2;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter) return filter2;
  hasRequiredFilter = 1;
  filter2 = function(Promise2, INTERNAL) {
    var PromiseMap = Promise2.map;
    Promise2.prototype.filter = function(fn, options) {
      return PromiseMap(this, fn, options, INTERNAL);
    };
    Promise2.filter = function(promises, fn, options) {
      return PromiseMap(promises, fn, options, INTERNAL);
    };
  };
  return filter2;
}
var each;
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach) return each;
  hasRequiredEach = 1;
  each = function(Promise2, INTERNAL) {
    var PromiseReduce = Promise2.reduce;
    var PromiseAll = Promise2.all;
    function promiseAllThis() {
      return PromiseAll(this);
    }
    function PromiseMapSeries(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
    }
    Promise2.prototype.each = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
    };
    Promise2.prototype.mapSeries = function(fn) {
      return PromiseReduce(this, fn, INTERNAL, INTERNAL);
    };
    Promise2.each = function(promises, fn) {
      return PromiseReduce(promises, fn, INTERNAL, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
    };
    Promise2.mapSeries = PromiseMapSeries;
  };
  return each;
}
var any;
var hasRequiredAny;
function requireAny() {
  if (hasRequiredAny) return any;
  hasRequiredAny = 1;
  any = function(Promise2) {
    var SomePromiseArray = Promise2._SomePromiseArray;
    function any2(promises) {
      var ret = new SomePromiseArray(promises);
      var promise2 = ret.promise();
      ret.setHowMany(1);
      ret.setUnwrap();
      ret.init();
      return promise2;
    }
    Promise2.any = function(promises) {
      return any2(promises);
    };
    Promise2.prototype.any = function() {
      return any2(this);
    };
  };
  return any;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise.exports;
  hasRequiredPromise = 1;
  (function(module) {
    module.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util2 = requireUtil$2();
      var getDomain;
      if (util2.isNode) {
        getDomain = function() {
          var ret = process.domain;
          if (ret === void 0) ret = null;
          return ret;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util2.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = requireEs5();
      var Async = requireAsync();
      var async2 = new Async();
      es52.defineProperty(Promise2, "_async", { value: async2 });
      var errors2 = requireErrors();
      var TypeError2 = Promise2.TypeError = errors2.TypeError;
      Promise2.RangeError = errors2.RangeError;
      var CancellationError = Promise2.CancellationError = errors2.CancellationError;
      Promise2.TimeoutError = errors2.TimeoutError;
      Promise2.OperationalError = errors2.OperationalError;
      Promise2.RejectionError = errors2.OperationalError;
      Promise2.AggregateError = errors2.AggregateError;
      var INTERNAL = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = requireThenables()(Promise2, INTERNAL);
      var PromiseArray = requirePromise_array()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = requireContext()(Promise2);
      var createContext = Context.create;
      var debug = requireDebuggability()(Promise2, Context);
      debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = requireCatch_filter()(NEXT_FILTER);
      var nodebackForPromise = requireNodeback();
      var errorObj = util2.errorObj;
      var tryCatch = util2.tryCatch;
      function check(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL) {
          check(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util2.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util2.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util2.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util2.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise2 = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise2._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util2.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret.fulfillmentValue = this.value();
          ret.isFulfilled = true;
        } else if (this.isRejected()) {
          ret.rejectionReason = this.reason();
          ret.isRejected = true;
        }
        return ret;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util2.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
        if (result === errorObj) {
          ret._rejectCallback(result.e, true);
        }
        if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
        return ret;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj) {
        var ret = tryConvertToPromise(obj);
        if (!(ret instanceof Promise2)) {
          ret = new Promise2(INTERNAL);
          ret._captureStackTrace();
          ret._setFulfilled();
          ret._rejectionHandler0 = obj;
        }
        return ret;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret = new Promise2(INTERNAL);
        ret._captureStackTrace();
        ret._rejectCallback(reason, true);
        return ret;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util2.classString(fn));
        }
        return async2.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _2, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise2 = haveInternalData ? internalData : new Promise2(INTERNAL);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise2._propagateFrom(this, 3);
          promise2._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise2);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler = didReject;
          }
          async2.invoke(settler, target, {
            handler: domain === null ? handler : typeof handler === "function" && util2.domainBind(domain, handler),
            promise: promise2,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise2, receiver, domain);
        }
        return promise2;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & -65537;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async2.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index2) {
        var ret = index2 === 0 ? this._receiver0 : this[index2 * 4 - 4 + 3];
        if (ret === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret;
      };
      Promise2.prototype._promiseAt = function(index2) {
        return this[index2 * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index2) {
        return this[index2 * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject2 = follower._rejectionHandler0;
        var promise2 = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise2, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index2) {
        var fulfill = follower._fulfillmentHandlerAt(index2);
        var reject2 = follower._rejectionHandlerAt(index2);
        var promise2 = follower._promiseAt(index2);
        var receiver = follower._receiverAt(index2);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise2, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject2, promise2, receiver, domain) {
        var index2 = this._length();
        if (index2 >= 65535 - 4) {
          index2 = 0;
          this._setLength(0);
        }
        if (index2 === 0) {
          this._promise0 = promise2;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this._rejectionHandler0 = domain === null ? reject2 : util2.domainBind(domain, reject2);
          }
        } else {
          var base = index2 * 4 - 4;
          this[base + 2] = promise2;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util2.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this[base + 1] = domain === null ? reject2 : util2.domainBind(domain, reject2);
          }
        }
        this._setLength(index2 + 1);
        return index2;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
        if (shouldBind) this._propagateFrom(maybePromise, 2);
        var promise2 = maybePromise._target();
        if (promise2 === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise2._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0) promise2._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise2._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise2);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise2._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise2._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise2._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util2.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util2.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise2 = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise2._resolveCallback(value);
        }, function(reason) {
          promise2._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise2._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler, receiver, value, promise2) {
        var bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        promise2._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj;
            x.e = new TypeError2("cannot .spread() a non-array: " + util2.classString(value));
          } else {
            x = tryCatch(handler).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch(handler).call(receiver, value);
        }
        var promiseCreated = promise2._popContext();
        bitField = promise2._bitField;
        if ((bitField & 65536) !== 0) return;
        if (x === NEXT_FILTER) {
          promise2._reject(value);
        } else if (x === errorObj) {
          promise2._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise2, this);
          promise2._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret = this;
        while (ret._isFollowing()) ret = ret._followee();
        return ret;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise2) {
        this._rejectionHandler0 = promise2;
      };
      Promise2.prototype._settlePromise = function(promise2, handler, receiver, value) {
        var isPromise = promise2 instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise) promise2._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise2;
            if (tryCatch(handler).call(receiver, value) === errorObj) {
              promise2._reject(errorObj.e);
            }
          } else if (handler === reflectHandler) {
            promise2._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise2);
          } else if (isPromise || promise2 instanceof PromiseArray) {
            promise2._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler === "function") {
          if (!isPromise) {
            handler.call(receiver, value, promise2);
          } else {
            if (asyncGuaranteed) promise2._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise2);
            } else {
              receiver._promiseRejected(value, promise2);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed) promise2._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise2._fulfill(value);
          } else {
            promise2._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler = ctx.handler;
        var promise2 = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler === "function") {
          if (!(promise2 instanceof Promise2)) {
            handler.call(receiver, value, promise2);
          } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise2);
          }
        } else if (promise2 instanceof Promise2) {
          promise2._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler, value, bitField) {
        var promise2 = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise2, handler, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index2) {
        var base = index2 * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async2.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async2.fatalError(reason, util2.isNode);
        }
        if ((bitField & 65535) > 0) {
          async2.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler = this._fulfillmentHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler = this._rejectionHandlerAt(i);
          var promise2 = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise2, handler, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise2 = new Promise2(INTERNAL);
        return {
          promise: promise2,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util2.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      requireMethod()(
        Promise2,
        INTERNAL,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      requireBind()(Promise2, INTERNAL, tryConvertToPromise, debug);
      requireCancel()(Promise2, PromiseArray, apiRejection, debug);
      requireDirect_resolve()(Promise2);
      requireSynchronous_inspection()(Promise2);
      requireJoin()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL,
        async2,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      requireMap()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      requireCall_get()(Promise2);
      requireUsing()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
      requireTimers()(Promise2, INTERNAL, debug);
      requireGenerators()(Promise2, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
      requireNodeify()(Promise2);
      requirePromisify()(Promise2, INTERNAL);
      requireProps()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      requireRace()(Promise2, INTERNAL, tryConvertToPromise, apiRejection);
      requireReduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
      requireSettle()(Promise2, PromiseArray, debug);
      requireSome()(Promise2, PromiseArray, apiRejection);
      requireFilter()(Promise2, INTERNAL);
      requireEach()(Promise2, INTERNAL);
      requireAny()(Promise2);
      util2.toFastProperties(Promise2);
      util2.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL));
      debug.setBounds(Async.firstLineError, util2.lastLineError);
      return Promise2;
    };
  })(promise);
  return promise.exports;
}
var bluebird_1;
var hasRequiredBluebird;
function requireBluebird() {
  if (hasRequiredBluebird) return bluebird_1;
  hasRequiredBluebird = 1;
  var old2;
  if (typeof Promise !== "undefined") old2 = Promise;
  function noConflict() {
    try {
      if (Promise === bluebird) Promise = old2;
    } catch (e) {
    }
    return bluebird;
  }
  var bluebird = requirePromise()();
  bluebird.noConflict = noConflict;
  bluebird_1 = bluebird;
  return bluebird_1;
}
var Buffer_1;
var hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return Buffer_1;
  hasRequiredBuffer = 1;
  var Buffer2 = require$$0$7.Buffer;
  if (Buffer2.from === void 0) {
    Buffer2.from = function(a, b, c) {
      return new Buffer2(a, b, c);
    };
    Buffer2.alloc = Buffer2.from;
  }
  Buffer_1 = Buffer2;
  return Buffer_1;
}
var readable$1 = { exports: {} };
var stream$1;
var hasRequiredStream$1;
function requireStream$1() {
  if (hasRequiredStream$1) return stream$1;
  hasRequiredStream$1 = 1;
  stream$1 = require$$0$1;
  return stream$1;
}
var safeBuffer$1 = { exports: {} };
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
  hasRequiredSafeBuffer$1 = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer$1, safeBuffer$1.exports);
  return safeBuffer$1.exports;
}
var util$1 = {};
var hasRequiredUtil$1;
function requireUtil$1() {
  if (hasRequiredUtil$1) return util$1;
  hasRequiredUtil$1 = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util$1.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util$1.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util$1.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util$1.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util$1.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util$1.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util$1.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util$1.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util$1.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util$1.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util$1.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util$1.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util$1.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util$1.isPrimitive = isPrimitive;
  util$1.isBuffer = require$$0$7.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util$1;
}
var BufferList$1 = { exports: {} };
var hasRequiredBufferList$1;
function requireBufferList$1() {
  if (hasRequiredBufferList$1) return BufferList$1.exports;
  hasRequiredBufferList$1 = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer$1().Buffer;
    var util2 = require$$0$2;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList$1);
  return BufferList$1.exports;
}
var destroy_1$1;
var hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1) return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1$1 = {
    destroy,
    undestroy
  };
  return destroy_1$1;
}
var _stream_writable$1;
var hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable$1 = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream$1();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy$1();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable$1;
}
var _stream_duplex$1;
var hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex$1 = Duplex;
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable$1();
  var Writable = require_stream_writable$1();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex$1;
}
var string_decoder$1 = {};
var hasRequiredString_decoder$1;
function requireString_decoder$1() {
  if (hasRequiredString_decoder$1) return string_decoder$1;
  hasRequiredString_decoder$1 = 1;
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder$1.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder$1;
}
var _stream_readable$1;
var hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable$1 = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream$1();
  var Buffer2 = requireSafeBuffer$1().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$2;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList$1();
  var destroyImpl = requireDestroy$1();
  var StringDecoder;
  util2.inherits(Readable2, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex$1();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder$1().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex$1();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder$1().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1;
var hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1) return _stream_transform$1;
  hasRequired_stream_transform$1 = 1;
  _stream_transform$1 = Transform;
  var Duplex = require_stream_duplex$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1;
  _stream_passthrough$1 = PassThrough;
  var Transform = require_stream_transform$1();
  var util2 = Object.create(requireUtil$1());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough$1;
}
var hasRequiredReadable$1;
function requireReadable$1() {
  if (hasRequiredReadable$1) return readable$1.exports;
  hasRequiredReadable$1 = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable$1();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable$1();
      exports.Duplex = require_stream_duplex$1();
      exports.Transform = require_stream_transform$1();
      exports.PassThrough = require_stream_passthrough$1();
    }
  })(readable$1, readable$1.exports);
  return readable$1.exports;
}
var PullStream_1;
var hasRequiredPullStream;
function requirePullStream() {
  if (hasRequiredPullStream) return PullStream_1;
  hasRequiredPullStream = 1;
  var Stream = require$$0$1;
  var Promise2 = requireBluebird();
  var util2 = require$$0$2;
  var Buffer2 = requireBuffer();
  var strFunction = "function";
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  function PullStream() {
    if (!(this instanceof PullStream))
      return new PullStream();
    Stream.Duplex.call(this, { decodeStrings: false, objectMode: true });
    this.buffer = Buffer2.from("");
    var self2 = this;
    self2.on("finish", function() {
      self2.finished = true;
      self2.emit("chunk", false);
    });
  }
  util2.inherits(PullStream, Stream.Duplex);
  PullStream.prototype._write = function(chunk, e, cb) {
    this.buffer = Buffer2.concat([this.buffer, chunk]);
    this.cb = cb;
    this.emit("chunk");
  };
  PullStream.prototype.stream = function(eof, includeEof) {
    var p = Stream.PassThrough();
    var done, self2 = this;
    function cb() {
      if (typeof self2.cb === strFunction) {
        var callback = self2.cb;
        self2.cb = void 0;
        return callback();
      }
    }
    function pull() {
      var packet;
      if (self2.buffer && self2.buffer.length) {
        if (typeof eof === "number") {
          packet = self2.buffer.slice(0, eof);
          self2.buffer = self2.buffer.slice(eof);
          eof -= packet.length;
          done = !eof;
        } else {
          var match = self2.buffer.indexOf(eof);
          if (match !== -1) {
            self2.match = match;
            if (includeEof) match = match + eof.length;
            packet = self2.buffer.slice(0, match);
            self2.buffer = self2.buffer.slice(match);
            done = true;
          } else {
            var len = self2.buffer.length - eof.length;
            if (len <= 0) {
              cb();
            } else {
              packet = self2.buffer.slice(0, len);
              self2.buffer = self2.buffer.slice(len);
            }
          }
        }
        if (packet) p.write(packet, function() {
          if (self2.buffer.length === 0 || eof.length && self2.buffer.length <= eof.length) cb();
        });
      }
      if (!done) {
        if (self2.finished) {
          self2.removeListener("chunk", pull);
          self2.emit("error", new Error("FILE_ENDED"));
          return;
        }
      } else {
        self2.removeListener("chunk", pull);
        p.end();
      }
    }
    self2.on("chunk", pull);
    pull();
    return p;
  };
  PullStream.prototype.pull = function(eof, includeEof) {
    if (eof === 0) return Promise2.resolve("");
    if (!isNaN(eof) && this.buffer.length > eof) {
      var data2 = this.buffer.slice(0, eof);
      this.buffer = this.buffer.slice(eof);
      return Promise2.resolve(data2);
    }
    var buffer = Buffer2.from(""), self2 = this;
    var concatStream = Stream.Transform();
    concatStream._transform = function(d, e, cb) {
      buffer = Buffer2.concat([buffer, d]);
      cb();
    };
    var rejectHandler;
    var pullStreamRejectHandler;
    return new Promise2(function(resolve, reject2) {
      rejectHandler = reject2;
      pullStreamRejectHandler = function(e) {
        self2.__emittedError = e;
        reject2(e);
      };
      if (self2.finished)
        return reject2(new Error("FILE_ENDED"));
      self2.once("error", pullStreamRejectHandler);
      self2.stream(eof, includeEof).on("error", reject2).pipe(concatStream).on("finish", function() {
        resolve(buffer);
      }).on("error", reject2);
    }).finally(function() {
      self2.removeListener("error", rejectHandler);
      self2.removeListener("error", pullStreamRejectHandler);
    });
  };
  PullStream.prototype._read = function() {
  };
  PullStream_1 = PullStream;
  return PullStream_1;
}
var NoopStream_1;
var hasRequiredNoopStream;
function requireNoopStream() {
  if (hasRequiredNoopStream) return NoopStream_1;
  hasRequiredNoopStream = 1;
  var Stream = require$$0$1;
  var util2 = require$$0$2;
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  function NoopStream() {
    if (!(this instanceof NoopStream)) {
      return new NoopStream();
    }
    Stream.Transform.call(this);
  }
  util2.inherits(NoopStream, Stream.Transform);
  NoopStream.prototype._transform = function(d, e, cb) {
    cb();
  };
  NoopStream_1 = NoopStream;
  return NoopStream_1;
}
var BufferStream;
var hasRequiredBufferStream;
function requireBufferStream() {
  if (hasRequiredBufferStream) return BufferStream;
  hasRequiredBufferStream = 1;
  var Promise2 = requireBluebird();
  var Stream = require$$0$1;
  var Buffer2 = requireBuffer();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  BufferStream = function(entry) {
    return new Promise2(function(resolve, reject2) {
      var chunks = [];
      var bufferStream = Stream.Transform().on("finish", function() {
        resolve(Buffer2.concat(chunks));
      }).on("error", reject2);
      bufferStream._transform = function(d, e, cb) {
        chunks.push(d);
        cb();
      };
      entry.on("error", reject2).pipe(bufferStream);
    });
  };
  return BufferStream;
}
var parseExtraField;
var hasRequiredParseExtraField;
function requireParseExtraField() {
  if (hasRequiredParseExtraField) return parseExtraField;
  hasRequiredParseExtraField = 1;
  var binary2 = requireBinary();
  parseExtraField = function(extraField, vars2) {
    var extra;
    while (!extra && extraField && extraField.length) {
      var candidateExtra = binary2.parse(extraField).word16lu("signature").word16lu("partsize").word64lu("uncompressedSize").word64lu("compressedSize").word64lu("offset").word64lu("disknum").vars;
      if (candidateExtra.signature === 1) {
        extra = candidateExtra;
      } else {
        extraField = extraField.slice(candidateExtra.partsize + 4);
      }
    }
    extra = extra || {};
    if (vars2.compressedSize === 4294967295)
      vars2.compressedSize = extra.compressedSize;
    if (vars2.uncompressedSize === 4294967295)
      vars2.uncompressedSize = extra.uncompressedSize;
    if (vars2.offsetToLocalFileHeader === 4294967295)
      vars2.offsetToLocalFileHeader = extra.offset;
    return extra;
  };
  return parseExtraField;
}
var parseDateTime;
var hasRequiredParseDateTime;
function requireParseDateTime() {
  if (hasRequiredParseDateTime) return parseDateTime;
  hasRequiredParseDateTime = 1;
  parseDateTime = function parseDateTime2(date, time) {
    const day = date & 31;
    const month = date >> 5 & 15;
    const year = (date >> 9 & 127) + 1980;
    const seconds = time ? (time & 31) * 2 : 0;
    const minutes = time ? time >> 5 & 63 : 0;
    const hours = time ? time >> 11 : 0;
    return new Date(Date.UTC(year, month - 1, day, hours, minutes, seconds));
  };
  return parseDateTime;
}
var parse;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse;
  hasRequiredParse = 1;
  var util2 = require$$0$2;
  var zlib$1 = zlib;
  var Stream = require$$0$1;
  var binary2 = requireBinary();
  var Promise2 = requireBluebird();
  var PullStream = requirePullStream();
  var NoopStream = requireNoopStream();
  var BufferStream2 = requireBufferStream();
  var parseExtraField2 = requireParseExtraField();
  var Buffer2 = requireBuffer();
  var parseDateTime2 = requireParseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  var endDirectorySignature = Buffer2.alloc(4);
  endDirectorySignature.writeUInt32LE(101010256, 0);
  function Parse(opts) {
    if (!(this instanceof Parse)) {
      return new Parse(opts);
    }
    var self2 = this;
    self2._opts = opts || { verbose: false };
    PullStream.call(self2, self2._opts);
    self2.on("finish", function() {
      self2.emit("end");
      self2.emit("close");
    });
    self2._readRecord().catch(function(e) {
      if (!self2.__emittedError || self2.__emittedError !== e)
        self2.emit("error", e);
    });
  }
  util2.inherits(Parse, PullStream);
  Parse.prototype._readRecord = function() {
    var self2 = this;
    return self2.pull(4).then(function(data2) {
      if (data2.length === 0)
        return;
      var signature2 = data2.readUInt32LE(0);
      if (signature2 === 875721283) {
        return self2._readCrxHeader();
      }
      if (signature2 === 67324752) {
        return self2._readFile();
      } else if (signature2 === 33639248) {
        self2.reachedCD = true;
        return self2._readCentralDirectoryFileHeader();
      } else if (signature2 === 101010256) {
        return self2._readEndOfCentralDirectoryRecord();
      } else if (self2.reachedCD) {
        var includeEof = true;
        return self2.pull(endDirectorySignature, includeEof).then(function() {
          return self2._readEndOfCentralDirectoryRecord();
        });
      } else
        self2.emit("error", new Error("invalid signature: 0x" + signature2.toString(16)));
    });
  };
  Parse.prototype._readCrxHeader = function() {
    var self2 = this;
    return self2.pull(12).then(function(data2) {
      self2.crxHeader = binary2.parse(data2).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
      return self2.pull(self2.crxHeader.pubKeyLength + self2.crxHeader.signatureLength);
    }).then(function(data2) {
      self2.crxHeader.publicKey = data2.slice(0, self2.crxHeader.pubKeyLength);
      self2.crxHeader.signature = data2.slice(self2.crxHeader.pubKeyLength);
      self2.emit("crx-header", self2.crxHeader);
      return self2._readRecord();
    });
  };
  Parse.prototype._readFile = function() {
    var self2 = this;
    return self2.pull(26).then(function(data2) {
      var vars2 = binary2.parse(data2).word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars2.lastModifiedDateTime = parseDateTime2(vars2.lastModifiedDate, vars2.lastModifiedTime);
      if (self2.crxHeader) vars2.crxHeader = self2.crxHeader;
      return self2.pull(vars2.fileNameLength).then(function(fileNameBuffer) {
        var fileName = fileNameBuffer.toString("utf8");
        var entry = Stream.PassThrough();
        var __autodraining = false;
        entry.autodrain = function() {
          __autodraining = true;
          var draining = entry.pipe(NoopStream());
          draining.promise = function() {
            return new Promise2(function(resolve, reject2) {
              draining.on("finish", resolve);
              draining.on("error", reject2);
            });
          };
          return draining;
        };
        entry.buffer = function() {
          return BufferStream2(entry);
        };
        entry.path = fileName;
        entry.props = {};
        entry.props.path = fileName;
        entry.props.pathBuffer = fileNameBuffer;
        entry.props.flags = {
          "isUnicode": (vars2.flags & 2048) != 0
        };
        entry.type = vars2.uncompressedSize === 0 && /[\/\\]$/.test(fileName) ? "Directory" : "File";
        if (self2._opts.verbose) {
          if (entry.type === "Directory") {
            console.log("   creating:", fileName);
          } else if (entry.type === "File") {
            if (vars2.compressionMethod === 0) {
              console.log(" extracting:", fileName);
            } else {
              console.log("  inflating:", fileName);
            }
          }
        }
        return self2.pull(vars2.extraFieldLength).then(function(extraField) {
          var extra = parseExtraField2(extraField, vars2);
          entry.vars = vars2;
          entry.extra = extra;
          if (self2._opts.forceStream) {
            self2.push(entry);
          } else {
            self2.emit("entry", entry);
            if (self2._readableState.pipesCount || self2._readableState.pipes && self2._readableState.pipes.length)
              self2.push(entry);
          }
          if (self2._opts.verbose)
            console.log({
              filename: fileName,
              vars: vars2,
              extra
            });
          var fileSizeKnown = !(vars2.flags & 8) || vars2.compressedSize > 0, eof;
          entry.__autodraining = __autodraining;
          var inflater = vars2.compressionMethod && !__autodraining ? zlib$1.createInflateRaw() : Stream.PassThrough();
          if (fileSizeKnown) {
            entry.size = vars2.uncompressedSize;
            eof = vars2.compressedSize;
          } else {
            eof = Buffer2.alloc(4);
            eof.writeUInt32LE(134695760, 0);
          }
          return new Promise2(function(resolve, reject2) {
            self2.stream(eof).pipe(inflater).on("error", function(err) {
              self2.emit("error", err);
            }).pipe(entry).on("finish", function() {
              return fileSizeKnown ? self2._readRecord().then(resolve).catch(reject2) : self2._processDataDescriptor(entry).then(resolve).catch(reject2);
            });
          });
        });
      });
    });
  };
  Parse.prototype._processDataDescriptor = function(entry) {
    var self2 = this;
    return self2.pull(16).then(function(data2) {
      var vars2 = binary2.parse(data2).word32lu("dataDescriptorSignature").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").vars;
      entry.size = vars2.uncompressedSize;
      return self2._readRecord();
    });
  };
  Parse.prototype._readCentralDirectoryFileHeader = function() {
    var self2 = this;
    return self2.pull(42).then(function(data2) {
      var vars2 = binary2.parse(data2).word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
      return self2.pull(vars2.fileNameLength).then(function(fileName) {
        vars2.fileName = fileName.toString("utf8");
        return self2.pull(vars2.extraFieldLength);
      }).then(function(extraField) {
        return self2.pull(vars2.fileCommentLength);
      }).then(function(fileComment) {
        return self2._readRecord();
      });
    });
  };
  Parse.prototype._readEndOfCentralDirectoryRecord = function() {
    var self2 = this;
    return self2.pull(18).then(function(data2) {
      var vars2 = binary2.parse(data2).word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      return self2.pull(vars2.commentLength).then(function(comment) {
        comment = comment.toString("utf8");
        self2.end();
        self2.push(null);
      });
    });
  };
  Parse.prototype.promise = function() {
    var self2 = this;
    return new Promise2(function(resolve, reject2) {
      self2.on("finish", resolve);
      self2.on("error", reject2);
    });
  };
  parse = Parse;
  return parse;
}
var duplexer2 = { exports: {} };
var readable = { exports: {} };
var stream;
var hasRequiredStream;
function requireStream() {
  if (hasRequiredStream) return stream;
  hasRequiredStream = 1;
  stream = require$$0$1;
  return stream;
}
var safeBuffer = { exports: {} };
var hasRequiredSafeBuffer;
function requireSafeBuffer() {
  if (hasRequiredSafeBuffer) return safeBuffer.exports;
  hasRequiredSafeBuffer = 1;
  (function(module, exports) {
    var buffer = require$$0$7;
    var Buffer2 = buffer.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  })(safeBuffer, safeBuffer.exports);
  return safeBuffer.exports;
}
var util = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util;
  hasRequiredUtil = 1;
  function isArray2(arg) {
    if (Array.isArray) {
      return Array.isArray(arg);
    }
    return objectToString(arg) === "[object Array]";
  }
  util.isArray = isArray2;
  function isBoolean2(arg) {
    return typeof arg === "boolean";
  }
  util.isBoolean = isBoolean2;
  function isNull(arg) {
    return arg === null;
  }
  util.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  util.isNullOrUndefined = isNullOrUndefined;
  function isNumber2(arg) {
    return typeof arg === "number";
  }
  util.isNumber = isNumber2;
  function isString2(arg) {
    return typeof arg === "string";
  }
  util.isString = isString2;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  util.isSymbol = isSymbol;
  function isUndefined2(arg) {
    return arg === void 0;
  }
  util.isUndefined = isUndefined2;
  function isRegExp2(re) {
    return objectToString(re) === "[object RegExp]";
  }
  util.isRegExp = isRegExp2;
  function isObject2(arg) {
    return typeof arg === "object" && arg !== null;
  }
  util.isObject = isObject2;
  function isDate2(d) {
    return objectToString(d) === "[object Date]";
  }
  util.isDate = isDate2;
  function isError(e) {
    return objectToString(e) === "[object Error]" || e instanceof Error;
  }
  util.isError = isError;
  function isFunction2(arg) {
    return typeof arg === "function";
  }
  util.isFunction = isFunction2;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
    typeof arg === "undefined";
  }
  util.isPrimitive = isPrimitive;
  util.isBuffer = require$$0$7.Buffer.isBuffer;
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  return util;
}
var BufferList = { exports: {} };
var hasRequiredBufferList;
function requireBufferList() {
  if (hasRequiredBufferList) return BufferList.exports;
  hasRequiredBufferList = 1;
  (function(module) {
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = requireSafeBuffer().Buffer;
    var util2 = require$$0$2;
    function copyBuffer(src2, target, offset) {
      src2.copy(target, offset);
    }
    module.exports = function() {
      function BufferList2() {
        _classCallCheck(this, BufferList2);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList2.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList2.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList2.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList2.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList2.prototype.join = function join2(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList2.prototype.concat = function concat2(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList2;
    }();
    if (util2 && util2.inspect && util2.inspect.custom) {
      module.exports.prototype[util2.inspect.custom] = function() {
        var obj = util2.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  })(BufferList);
  return BufferList.exports;
}
var destroy_1;
var hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1;
  hasRequiredDestroy = 1;
  var pna = requireProcessNextickArgs();
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          pna.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          pna.nextTick(emitErrorNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          pna.nextTick(emitErrorNT, _this, err2);
        }
      } else if (cb) {
        cb(err2);
      }
    });
    return this;
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  destroy_1 = {
    destroy,
    undestroy
  };
  return destroy_1;
}
var _stream_writable;
var hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var pna = requireProcessNextickArgs();
  _stream_writable = Writable;
  function CorkedRequest(state2) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state2);
    };
  }
  var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
  var Duplex;
  Writable.WritableState = WritableState;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var internalUtil = {
    deprecate: requireNode()
  };
  var Stream = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = requireDestroy();
  util2.inherits(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
    var hwm = options.highWaterMark;
    var writableHwm = options.writableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream2, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_2) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function(object2) {
        if (realHasInstance.call(this, object2)) return true;
        if (this !== Writable) return false;
        return object2 && object2._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function(object2) {
      return object2 instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
      return new Writable(options);
    }
    this._writableState = new WritableState(options, this);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function") this._write = options.write;
      if (typeof options.writev === "function") this._writev = options.writev;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
      if (typeof options.final === "function") this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function writeAfterEnd(stream2, cb) {
    var er = new Error("write after end");
    stream2.emit("error", er);
    pna.nextTick(cb, er);
  }
  function validChunk(stream2, state2, chunk, cb) {
    var valid = true;
    var er = false;
    if (chunk === null) {
      er = new TypeError("May not write null values to stream");
    } else if (typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    if (er) {
      stream2.emit("error", er);
      pna.nextTick(cb, er);
      valid = false;
    }
    return valid;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    var ret = false;
    var isBuf = !state2.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf) encoding = "buffer";
    else if (!encoding) encoding = state2.defaultEncoding;
    if (typeof cb !== "function") cb = nop;
    if (state2.ended) writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state2, chunk, cb)) {
      state2.pendingcb++;
      ret = writeOrBuffer(this, state2, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    var state2 = this._writableState;
    state2.corked++;
  };
  Writable.prototype.uncork = function() {
    var state2 = this._writableState;
    if (state2.corked) {
      state2.corked--;
      if (!state2.writing && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) clearBuffer(this, state2);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string") encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  function decodeChunk(state2, chunk, encoding) {
    if (!state2.objectMode && state2.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream2, state2, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state2, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state2.objectMode ? 1 : chunk.length;
    state2.length += len;
    var ret = state2.length < state2.highWaterMark;
    if (!ret) state2.needDrain = true;
    if (state2.writing || state2.corked) {
      var last = state2.lastBufferedRequest;
      state2.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state2.lastBufferedRequest;
      } else {
        state2.bufferedRequest = state2.lastBufferedRequest;
      }
      state2.bufferedRequestCount += 1;
    } else {
      doWrite(stream2, state2, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream2, state2, writev, len, chunk, encoding, cb) {
    state2.writelen = len;
    state2.writecb = cb;
    state2.writing = true;
    state2.sync = true;
    if (writev) stream2._writev(chunk, state2.onwrite);
    else stream2._write(chunk, encoding, state2.onwrite);
    state2.sync = false;
  }
  function onwriteError(stream2, state2, sync2, er, cb) {
    --state2.pendingcb;
    if (sync2) {
      pna.nextTick(cb, er);
      pna.nextTick(finishMaybe, stream2, state2);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
    } else {
      cb(er);
      stream2._writableState.errorEmitted = true;
      stream2.emit("error", er);
      finishMaybe(stream2, state2);
    }
  }
  function onwriteStateUpdate(state2) {
    state2.writing = false;
    state2.writecb = null;
    state2.length -= state2.writelen;
    state2.writelen = 0;
  }
  function onwrite(stream2, er) {
    var state2 = stream2._writableState;
    var sync2 = state2.sync;
    var cb = state2.writecb;
    onwriteStateUpdate(state2);
    if (er) onwriteError(stream2, state2, sync2, er, cb);
    else {
      var finished = needFinish(state2);
      if (!finished && !state2.corked && !state2.bufferProcessing && state2.bufferedRequest) {
        clearBuffer(stream2, state2);
      }
      if (sync2) {
        asyncWrite(afterWrite, stream2, state2, finished, cb);
      } else {
        afterWrite(stream2, state2, finished, cb);
      }
    }
  }
  function afterWrite(stream2, state2, finished, cb) {
    if (!finished) onwriteDrain(stream2, state2);
    state2.pendingcb--;
    cb();
    finishMaybe(stream2, state2);
  }
  function onwriteDrain(stream2, state2) {
    if (state2.length === 0 && state2.needDrain) {
      state2.needDrain = false;
      stream2.emit("drain");
    }
  }
  function clearBuffer(stream2, state2) {
    state2.bufferProcessing = true;
    var entry = state2.bufferedRequest;
    if (stream2._writev && entry && entry.next) {
      var l = state2.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state2.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf) allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream2, state2, true, state2.length, buffer, "", holder.finish);
      state2.pendingcb++;
      state2.lastBufferedRequest = null;
      if (holder.next) {
        state2.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state2.corkedRequestsFree = new CorkedRequest(state2);
      }
      state2.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state2.objectMode ? 1 : chunk.length;
        doWrite(stream2, state2, false, len, chunk, encoding, cb);
        entry = entry.next;
        state2.bufferedRequestCount--;
        if (state2.writing) {
          break;
        }
      }
      if (entry === null) state2.lastBufferedRequest = null;
    }
    state2.bufferedRequest = entry;
    state2.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new Error("_write() is not implemented"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state2 = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
    if (state2.corked) {
      state2.corked = 1;
      this.uncork();
    }
    if (!state2.ending) endWritable(this, state2, cb);
  };
  function needFinish(state2) {
    return state2.ending && state2.length === 0 && state2.bufferedRequest === null && !state2.finished && !state2.writing;
  }
  function callFinal(stream2, state2) {
    stream2._final(function(err) {
      state2.pendingcb--;
      if (err) {
        stream2.emit("error", err);
      }
      state2.prefinished = true;
      stream2.emit("prefinish");
      finishMaybe(stream2, state2);
    });
  }
  function prefinish(stream2, state2) {
    if (!state2.prefinished && !state2.finalCalled) {
      if (typeof stream2._final === "function") {
        state2.pendingcb++;
        state2.finalCalled = true;
        pna.nextTick(callFinal, stream2, state2);
      } else {
        state2.prefinished = true;
        stream2.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream2, state2) {
    var need = needFinish(state2);
    if (need) {
      prefinish(stream2, state2);
      if (state2.pendingcb === 0) {
        state2.finished = true;
        stream2.emit("finish");
      }
    }
    return need;
  }
  function endWritable(stream2, state2, cb) {
    state2.ending = true;
    finishMaybe(stream2, state2);
    if (cb) {
      if (state2.finished) pna.nextTick(cb);
      else stream2.once("finish", cb);
    }
    state2.ended = true;
    stream2.writable = false;
  }
  function onCorkedFinish(corkReq, state2, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state2.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state2.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    get: function() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    this.end();
    cb(err);
  };
  return _stream_writable;
}
var _stream_duplex;
var hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var pna = requireProcessNextickArgs();
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  _stream_duplex = Duplex;
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var Readable2 = require_stream_readable();
  var Writable = require_stream_writable();
  util2.inherits(Duplex, Readable2);
  {
    var keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      var method2 = keys[v];
      if (!Duplex.prototype[method2]) Duplex.prototype[method2] = Writable.prototype[method2];
    }
  }
  function Duplex(options) {
    if (!(this instanceof Duplex)) return new Duplex(options);
    Readable2.call(this, options);
    Writable.call(this, options);
    if (options && options.readable === false) this.readable = false;
    if (options && options.writable === false) this.writable = false;
    this.allowHalfOpen = true;
    if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
    this.once("end", onend);
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function onend() {
    if (this.allowHalfOpen || this._writableState.ended) return;
    pna.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
  Duplex.prototype._destroy = function(err, cb) {
    this.push(null);
    this.end();
    pna.nextTick(cb, err);
  };
  return _stream_duplex;
}
var string_decoder = {};
var hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder) return string_decoder;
  hasRequiredString_decoder = 1;
  var Buffer2 = requireSafeBuffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc) return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried) return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  string_decoder.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0) return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127) return 0;
    else if (byte >> 5 === 6) return 2;
    else if (byte >> 4 === 14) return 3;
    else if (byte >> 3 === 30) return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2) nb = 0;
        else self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf);
    if (r !== void 0) return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + "";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
  return string_decoder;
}
var _stream_readable;
var hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var pna = requireProcessNextickArgs();
  _stream_readable = Readable2;
  var isArray2 = requireIsarray();
  var Duplex;
  Readable2.ReadableState = ReadableState;
  require$$2$1.EventEmitter;
  var EElistenerCount = function(emitter, type2) {
    return emitter.listeners(type2).length;
  };
  var Stream = requireStream();
  var Buffer2 = requireSafeBuffer().Buffer;
  var OurUint8Array = (typeof commonjsGlobal !== "undefined" ? commonjsGlobal : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  var debugUtil = require$$0$2;
  var debug = void 0;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function() {
    };
  }
  var BufferList2 = requireBufferList();
  var destroyImpl = requireDestroy();
  var StringDecoder;
  util2.inherits(Readable2, Stream);
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
    else if (isArray2(emitter._events[event])) emitter._events[event].unshift(fn);
    else emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream2) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    var isDuplex = stream2 instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
    var hwm = options.highWaterMark;
    var readableHwm = options.readableHighWaterMark;
    var defaultHwm = this.objectMode ? 16 : 16 * 1024;
    if (hwm || hwm === 0) this.highWaterMark = hwm;
    else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
    else this.highWaterMark = defaultHwm;
    this.highWaterMark = Math.floor(this.highWaterMark);
    this.buffer = new BufferList2();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable2(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable2)) return new Readable2(options);
    this._readableState = new ReadableState(options, this);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function") this._read = options.read;
      if (typeof options.destroy === "function") this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable2.prototype, "destroyed", {
    get: function() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable2.prototype.destroy = destroyImpl.destroy;
  Readable2.prototype._undestroy = destroyImpl.undestroy;
  Readable2.prototype._destroy = function(err, cb) {
    this.push(null);
    cb(err);
  };
  Readable2.prototype.push = function(chunk, encoding) {
    var state2 = this._readableState;
    var skipChunkCheck;
    if (!state2.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state2.defaultEncoding;
        if (encoding !== state2.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable2.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
    var state2 = stream2._readableState;
    if (chunk === null) {
      state2.reading = false;
      onEofChunk(stream2, state2);
    } else {
      var er;
      if (!skipChunkCheck) er = chunkInvalid(state2, chunk);
      if (er) {
        stream2.emit("error", er);
      } else if (state2.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state2.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state2.endEmitted) stream2.emit("error", new Error("stream.unshift() after end event"));
          else addChunk(stream2, state2, chunk, true);
        } else if (state2.ended) {
          stream2.emit("error", new Error("stream.push() after EOF"));
        } else {
          state2.reading = false;
          if (state2.decoder && !encoding) {
            chunk = state2.decoder.write(chunk);
            if (state2.objectMode || chunk.length !== 0) addChunk(stream2, state2, chunk, false);
            else maybeReadMore(stream2, state2);
          } else {
            addChunk(stream2, state2, chunk, false);
          }
        }
      } else if (!addToFront) {
        state2.reading = false;
      }
    }
    return needMoreData(state2);
  }
  function addChunk(stream2, state2, chunk, addToFront) {
    if (state2.flowing && state2.length === 0 && !state2.sync) {
      stream2.emit("data", chunk);
      stream2.read(0);
    } else {
      state2.length += state2.objectMode ? 1 : chunk.length;
      if (addToFront) state2.buffer.unshift(chunk);
      else state2.buffer.push(chunk);
      if (state2.needReadable) emitReadable(stream2);
    }
    maybeReadMore(stream2, state2);
  }
  function chunkInvalid(state2, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state2.objectMode) {
      er = new TypeError("Invalid non-string/buffer chunk");
    }
    return er;
  }
  function needMoreData(state2) {
    return !state2.ended && (state2.needReadable || state2.length < state2.highWaterMark || state2.length === 0);
  }
  Readable2.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable2.prototype.setEncoding = function(enc) {
    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
    this._readableState.decoder = new StringDecoder(enc);
    this._readableState.encoding = enc;
    return this;
  };
  var MAX_HWM = 8388608;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state2) {
    if (n <= 0 || state2.length === 0 && state2.ended) return 0;
    if (state2.objectMode) return 1;
    if (n !== n) {
      if (state2.flowing && state2.length) return state2.buffer.head.data.length;
      else return state2.length;
    }
    if (n > state2.highWaterMark) state2.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state2.length) return n;
    if (!state2.ended) {
      state2.needReadable = true;
      return 0;
    }
    return state2.length;
  }
  Readable2.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state2 = this._readableState;
    var nOrig = n;
    if (n !== 0) state2.emittedReadable = false;
    if (n === 0 && state2.needReadable && (state2.length >= state2.highWaterMark || state2.ended)) {
      debug("read: emitReadable", state2.length, state2.ended);
      if (state2.length === 0 && state2.ended) endReadable(this);
      else emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state2);
    if (n === 0 && state2.ended) {
      if (state2.length === 0) endReadable(this);
      return null;
    }
    var doRead = state2.needReadable;
    debug("need readable", doRead);
    if (state2.length === 0 || state2.length - n < state2.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state2.ended || state2.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state2.reading = true;
      state2.sync = true;
      if (state2.length === 0) state2.needReadable = true;
      this._read(state2.highWaterMark);
      state2.sync = false;
      if (!state2.reading) n = howMuchToRead(nOrig, state2);
    }
    var ret;
    if (n > 0) ret = fromList(n, state2);
    else ret = null;
    if (ret === null) {
      state2.needReadable = true;
      n = 0;
    } else {
      state2.length -= n;
    }
    if (state2.length === 0) {
      if (!state2.ended) state2.needReadable = true;
      if (nOrig !== n && state2.ended) endReadable(this);
    }
    if (ret !== null) this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream2, state2) {
    if (state2.ended) return;
    if (state2.decoder) {
      var chunk = state2.decoder.end();
      if (chunk && chunk.length) {
        state2.buffer.push(chunk);
        state2.length += state2.objectMode ? 1 : chunk.length;
      }
    }
    state2.ended = true;
    emitReadable(stream2);
  }
  function emitReadable(stream2) {
    var state2 = stream2._readableState;
    state2.needReadable = false;
    if (!state2.emittedReadable) {
      debug("emitReadable", state2.flowing);
      state2.emittedReadable = true;
      if (state2.sync) pna.nextTick(emitReadable_, stream2);
      else emitReadable_(stream2);
    }
  }
  function emitReadable_(stream2) {
    debug("emit readable");
    stream2.emit("readable");
    flow(stream2);
  }
  function maybeReadMore(stream2, state2) {
    if (!state2.readingMore) {
      state2.readingMore = true;
      pna.nextTick(maybeReadMore_, stream2, state2);
    }
  }
  function maybeReadMore_(stream2, state2) {
    var len = state2.length;
    while (!state2.reading && !state2.flowing && !state2.ended && state2.length < state2.highWaterMark) {
      debug("maybeReadMore read 0");
      stream2.read(0);
      if (len === state2.length)
        break;
      else len = state2.length;
    }
    state2.readingMore = false;
  }
  Readable2.prototype._read = function(n) {
    this.emit("error", new Error("_read() is not implemented"));
  };
  Readable2.prototype.pipe = function(dest, pipeOpts) {
    var src2 = this;
    var state2 = this._readableState;
    switch (state2.pipesCount) {
      case 0:
        state2.pipes = dest;
        break;
      case 1:
        state2.pipes = [state2.pipes, dest];
        break;
      default:
        state2.pipes.push(dest);
        break;
    }
    state2.pipesCount += 1;
    debug("pipe count=%d opts=%j", state2.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state2.endEmitted) pna.nextTick(endFn);
    else src2.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable2, unpipeInfo) {
      debug("onunpipe");
      if (readable2 === src2) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src2);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src2.removeListener("end", onend);
      src2.removeListener("end", unpipe);
      src2.removeListener("data", ondata);
      cleanedUp = true;
      if (state2.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
    }
    var increasedAwaitDrain = false;
    src2.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      increasedAwaitDrain = false;
      var ret = dest.write(chunk);
      if (false === ret && !increasedAwaitDrain) {
        if ((state2.pipesCount === 1 && state2.pipes === dest || state2.pipesCount > 1 && indexOf(state2.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state2.awaitDrain);
          state2.awaitDrain++;
          increasedAwaitDrain = true;
        }
        src2.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src2.unpipe(dest);
    }
    dest.emit("pipe", src2);
    if (!state2.flowing) {
      debug("pipe resume");
      src2.resume();
    }
    return dest;
  };
  function pipeOnDrain(src2) {
    return function() {
      var state2 = src2._readableState;
      debug("pipeOnDrain", state2.awaitDrain);
      if (state2.awaitDrain) state2.awaitDrain--;
      if (state2.awaitDrain === 0 && EElistenerCount(src2, "data")) {
        state2.flowing = true;
        flow(src2);
      }
    };
  }
  Readable2.prototype.unpipe = function(dest) {
    var state2 = this._readableState;
    var unpipeInfo = { hasUnpiped: false };
    if (state2.pipesCount === 0) return this;
    if (state2.pipesCount === 1) {
      if (dest && dest !== state2.pipes) return this;
      if (!dest) dest = state2.pipes;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      if (dest) dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state2.pipes;
      var len = state2.pipesCount;
      state2.pipes = null;
      state2.pipesCount = 0;
      state2.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, { hasUnpiped: false });
      }
      return this;
    }
    var index2 = indexOf(state2.pipes, dest);
    if (index2 === -1) return this;
    state2.pipes.splice(index2, 1);
    state2.pipesCount -= 1;
    if (state2.pipesCount === 1) state2.pipes = state2.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable2.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    if (ev === "data") {
      if (this._readableState.flowing !== false) this.resume();
    } else if (ev === "readable") {
      var state2 = this._readableState;
      if (!state2.endEmitted && !state2.readableListening) {
        state2.readableListening = state2.needReadable = true;
        state2.emittedReadable = false;
        if (!state2.reading) {
          pna.nextTick(nReadingNextTick, this);
        } else if (state2.length) {
          emitReadable(this);
        }
      }
    }
    return res;
  };
  Readable2.prototype.addListener = Readable2.prototype.on;
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable2.prototype.resume = function() {
    var state2 = this._readableState;
    if (!state2.flowing) {
      debug("resume");
      state2.flowing = true;
      resume(this, state2);
    }
    return this;
  };
  function resume(stream2, state2) {
    if (!state2.resumeScheduled) {
      state2.resumeScheduled = true;
      pna.nextTick(resume_, stream2, state2);
    }
  }
  function resume_(stream2, state2) {
    if (!state2.reading) {
      debug("resume read 0");
      stream2.read(0);
    }
    state2.resumeScheduled = false;
    state2.awaitDrain = 0;
    stream2.emit("resume");
    flow(stream2);
    if (state2.flowing && !state2.reading) stream2.read(0);
  }
  Readable2.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (false !== this._readableState.flowing) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    return this;
  };
  function flow(stream2) {
    var state2 = stream2._readableState;
    debug("flow", state2.flowing);
    while (state2.flowing && stream2.read() !== null) {
    }
  }
  Readable2.prototype.wrap = function(stream2) {
    var _this = this;
    var state2 = this._readableState;
    var paused = false;
    stream2.on("end", function() {
      debug("wrapped end");
      if (state2.decoder && !state2.ended) {
        var chunk = state2.decoder.end();
        if (chunk && chunk.length) _this.push(chunk);
      }
      _this.push(null);
    });
    stream2.on("data", function(chunk) {
      debug("wrapped data");
      if (state2.decoder) chunk = state2.decoder.write(chunk);
      if (state2.objectMode && (chunk === null || chunk === void 0)) return;
      else if (!state2.objectMode && (!chunk || !chunk.length)) return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream2.pause();
      }
    });
    for (var i in stream2) {
      if (this[i] === void 0 && typeof stream2[i] === "function") {
        this[i] = /* @__PURE__ */ function(method2) {
          return function() {
            return stream2[method2].apply(stream2, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream2.resume();
      }
    };
    return this;
  };
  Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: false,
    get: function() {
      return this._readableState.highWaterMark;
    }
  });
  Readable2._fromList = fromList;
  function fromList(n, state2) {
    if (state2.length === 0) return null;
    var ret;
    if (state2.objectMode) ret = state2.buffer.shift();
    else if (!n || n >= state2.length) {
      if (state2.decoder) ret = state2.buffer.join("");
      else if (state2.buffer.length === 1) ret = state2.buffer.head.data;
      else ret = state2.buffer.concat(state2.length);
      state2.buffer.clear();
    } else {
      ret = fromListPartial(n, state2.buffer, state2.decoder);
    }
    return ret;
  }
  function fromListPartial(n, list, hasStrings) {
    var ret;
    if (n < list.head.data.length) {
      ret = list.head.data.slice(0, n);
      list.head.data = list.head.data.slice(n);
    } else if (n === list.head.data.length) {
      ret = list.shift();
    } else {
      ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
    }
    return ret;
  }
  function copyFromBufferString(n, list) {
    var p = list.head;
    var c = 1;
    var ret = p.data;
    n -= ret.length;
    while (p = p.next) {
      var str = p.data;
      var nb = n > str.length ? str.length : n;
      if (nb === str.length) ret += str;
      else ret += str.slice(0, n);
      n -= nb;
      if (n === 0) {
        if (nb === str.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = str.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function copyFromBuffer(n, list) {
    var ret = Buffer2.allocUnsafe(n);
    var p = list.head;
    var c = 1;
    p.data.copy(ret);
    n -= p.data.length;
    while (p = p.next) {
      var buf = p.data;
      var nb = n > buf.length ? buf.length : n;
      buf.copy(ret, ret.length - n, 0, nb);
      n -= nb;
      if (n === 0) {
        if (nb === buf.length) {
          ++c;
          if (p.next) list.head = p.next;
          else list.head = list.tail = null;
        } else {
          list.head = p;
          p.data = buf.slice(nb);
        }
        break;
      }
      ++c;
    }
    list.length -= c;
    return ret;
  }
  function endReadable(stream2) {
    var state2 = stream2._readableState;
    if (state2.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    if (!state2.endEmitted) {
      state2.ended = true;
      pna.nextTick(endReadableNT, state2, stream2);
    }
  }
  function endReadableNT(state2, stream2) {
    if (!state2.endEmitted && state2.length === 0) {
      state2.endEmitted = true;
      stream2.readable = false;
      stream2.emit("end");
    }
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) return i;
    }
    return -1;
  }
  return _stream_readable;
}
var _stream_transform;
var hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform;
  hasRequired_stream_transform = 1;
  _stream_transform = Transform;
  var Duplex = require_stream_duplex();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(Transform, Duplex);
  function afterTransform(er, data2) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (!cb) {
      return this.emit("error", new Error("write callback called multiple times"));
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data2 != null)
      this.push(data2);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform)) return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function") this._transform = options.transform;
      if (typeof options.flush === "function") this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function") {
      this._flush(function(er, data2) {
        done(_this, er, data2);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    throw new Error("_transform() is not implemented");
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    var _this2 = this;
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
      _this2.emit("close");
    });
  };
  function done(stream2, er, data2) {
    if (er) return stream2.emit("error", er);
    if (data2 != null)
      stream2.push(data2);
    if (stream2._writableState.length) throw new Error("Calling transform done when ws.length != 0");
    if (stream2._transformState.transforming) throw new Error("Calling transform done when still transforming");
    return stream2.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough;
var hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough;
  hasRequired_stream_passthrough = 1;
  _stream_passthrough = PassThrough;
  var Transform = require_stream_transform();
  var util2 = Object.create(requireUtil());
  util2.inherits = requireInherits();
  util2.inherits(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough)) return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
  return _stream_passthrough;
}
var hasRequiredReadable;
function requireReadable() {
  if (hasRequiredReadable) return readable.exports;
  hasRequiredReadable = 1;
  (function(module, exports) {
    var Stream = require$$0$1;
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module.exports = Stream;
      exports = module.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  })(readable, readable.exports);
  return readable.exports;
}
var hasRequiredDuplexer2;
function requireDuplexer2() {
  if (hasRequiredDuplexer2) return duplexer2.exports;
  hasRequiredDuplexer2 = 1;
  var stream2 = requireReadable();
  function DuplexWrapper(options, writable, readable2) {
    if (typeof readable2 === "undefined") {
      readable2 = writable;
      writable = options;
      options = null;
    }
    stream2.Duplex.call(this, options);
    if (typeof readable2.read !== "function") {
      readable2 = new stream2.Readable(options).wrap(readable2);
    }
    this._writable = writable;
    this._readable = readable2;
    this._waiting = false;
    var self2 = this;
    writable.once("finish", function() {
      self2.end();
    });
    this.once("finish", function() {
      writable.end();
    });
    readable2.on("readable", function() {
      if (self2._waiting) {
        self2._waiting = false;
        self2._read();
      }
    });
    readable2.once("end", function() {
      self2.push(null);
    });
    if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
      writable.on("error", function(err) {
        self2.emit("error", err);
      });
      readable2.on("error", function(err) {
        self2.emit("error", err);
      });
    }
  }
  DuplexWrapper.prototype = Object.create(stream2.Duplex.prototype, { constructor: { value: DuplexWrapper } });
  DuplexWrapper.prototype._write = function _write(input, encoding, done) {
    this._writable.write(input, encoding, done);
  };
  DuplexWrapper.prototype._read = function _read() {
    var buf;
    var reads = 0;
    while ((buf = this._readable.read()) !== null) {
      this.push(buf);
      reads++;
    }
    if (reads === 0) {
      this._waiting = true;
    }
  };
  duplexer2.exports = function duplex2(options, writable, readable2) {
    return new DuplexWrapper(options, writable, readable2);
  };
  duplexer2.exports.DuplexWrapper = DuplexWrapper;
  return duplexer2.exports;
}
var parseOne_1;
var hasRequiredParseOne;
function requireParseOne() {
  if (hasRequiredParseOne) return parseOne_1;
  hasRequiredParseOne = 1;
  var Stream = require$$0$1;
  var Parse = requireParse();
  var duplexer22 = requireDuplexer2();
  var BufferStream2 = requireBufferStream();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  function parseOne(match, opts) {
    var inStream = Stream.PassThrough({ objectMode: true });
    var outStream = Stream.PassThrough();
    var transform2 = Stream.Transform({ objectMode: true });
    var re = match instanceof RegExp ? match : match && new RegExp(match);
    var found;
    transform2._transform = function(entry, e, cb) {
      if (found || re && !re.exec(entry.path)) {
        entry.autodrain();
        return cb();
      } else {
        found = true;
        out.emit("entry", entry);
        entry.on("error", function(e2) {
          outStream.emit("error", e2);
        });
        entry.pipe(outStream).on("error", function(err) {
          cb(err);
        }).on("finish", function(d) {
          cb(null, d);
        });
      }
    };
    inStream.pipe(Parse(opts)).on("error", function(err) {
      outStream.emit("error", err);
    }).pipe(transform2).on("error", Object).on("finish", function() {
      if (!found)
        outStream.emit("error", new Error("PATTERN_NOT_FOUND"));
      else
        outStream.end();
    });
    var out = duplexer22(inStream, outStream);
    out.buffer = function() {
      return BufferStream2(outStream);
    };
    return out;
  }
  parseOne_1 = parseOne;
  return parseOne_1;
}
var fstream = {};
var abstract;
var hasRequiredAbstract;
function requireAbstract() {
  if (hasRequiredAbstract) return abstract;
  hasRequiredAbstract = 1;
  abstract = Abstract;
  var Stream = require$$0$1.Stream;
  var inherits2 = requireInherits();
  function Abstract() {
    Stream.call(this);
  }
  inherits2(Abstract, Stream);
  Abstract.prototype.on = function(ev, fn) {
    if (ev === "ready" && this.ready) {
      process.nextTick(fn.bind(this));
    } else {
      Stream.prototype.on.call(this, ev, fn);
    }
    return this;
  };
  Abstract.prototype.abort = function() {
    this._aborted = true;
    this.emit("abort");
  };
  Abstract.prototype.destroy = function() {
  };
  Abstract.prototype.warn = function(msg, code) {
    var self2 = this;
    var er = decorate(msg, code, self2);
    if (!self2.listeners("warn")) {
      console.error(
        "%s %s\npath = %s\nsyscall = %s\nfstream_type = %s\nfstream_path = %s\nfstream_unc_path = %s\nfstream_class = %s\nfstream_stack =\n%s\n",
        code || "UNKNOWN",
        er.stack,
        er.path,
        er.syscall,
        er.fstream_type,
        er.fstream_path,
        er.fstream_unc_path,
        er.fstream_class,
        er.fstream_stack.join("\n")
      );
    } else {
      self2.emit("warn", er);
    }
  };
  Abstract.prototype.info = function(msg, code) {
    this.emit("info", msg, code);
  };
  Abstract.prototype.error = function(msg, code, th) {
    var er = decorate(msg, code, this);
    if (th) throw er;
    else this.emit("error", er);
  };
  function decorate(er, code, self2) {
    if (!(er instanceof Error)) er = new Error(er);
    er.code = er.code || code;
    er.path = er.path || self2.path;
    er.fstream_type = er.fstream_type || self2.type;
    er.fstream_path = er.fstream_path || self2.path;
    if (self2._path !== self2.path) {
      er.fstream_unc_path = er.fstream_unc_path || self2._path;
    }
    if (self2.linkpath) {
      er.fstream_linkpath = er.fstream_linkpath || self2.linkpath;
    }
    er.fstream_class = er.fstream_class || self2.constructor.name;
    er.fstream_stack = er.fstream_stack || new Error().stack.split(/\n/).slice(3).map(function(s) {
      return s.replace(/^ {4}at /, "");
    });
    return er;
  }
  return abstract;
}
var getType_1;
var hasRequiredGetType;
function requireGetType() {
  if (hasRequiredGetType) return getType_1;
  hasRequiredGetType = 1;
  getType_1 = getType;
  function getType(st) {
    var types2 = [
      "Directory",
      "File",
      "SymbolicLink",
      "Link",
      // special for hardlinks from tarballs
      "BlockDevice",
      "CharacterDevice",
      "FIFO",
      "Socket"
    ];
    var type2;
    if (st.type && types2.indexOf(st.type) !== -1) {
      st[st.type] = true;
      return st.type;
    }
    for (var i = 0, l = types2.length; i < l; i++) {
      type2 = types2[i];
      var is = st[type2] || st["is" + type2];
      if (typeof is === "function") is = is.call(st);
      if (is) {
        st[type2] = true;
        st.type = type2;
        return type2;
      }
    }
    return null;
  }
  return getType_1;
}
var linkReader;
var hasRequiredLinkReader;
function requireLinkReader() {
  if (hasRequiredLinkReader) return linkReader;
  hasRequiredLinkReader = 1;
  linkReader = LinkReader;
  var fs2 = requireGracefulFs();
  var inherits2 = requireInherits();
  var Reader = requireReader();
  inherits2(LinkReader, Reader);
  function LinkReader(props2) {
    var self2 = this;
    if (!(self2 instanceof LinkReader)) {
      throw new Error("LinkReader must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "SymbolicLink" && props2.SymbolicLink)) {
      throw new Error("Non-link type " + props2.type);
    }
    Reader.call(self2, props2);
  }
  LinkReader.prototype._stat = function(currentStat) {
    var self2 = this;
    fs2.readlink(self2._path, function(er, linkpath) {
      if (er) return self2.error(er);
      self2.linkpath = self2.props.linkpath = linkpath;
      self2.emit("linkpath", linkpath);
      Reader.prototype._stat.call(self2, currentStat);
    });
  };
  LinkReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused) return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
  return linkReader;
}
var dirReader;
var hasRequiredDirReader;
function requireDirReader() {
  if (hasRequiredDirReader) return dirReader;
  hasRequiredDirReader = 1;
  dirReader = DirReader;
  var fs2 = requireGracefulFs();
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var Reader = requireReader();
  var assert2 = require$$5.ok;
  inherits2(DirReader, Reader);
  function DirReader(props2) {
    var self2 = this;
    if (!(self2 instanceof DirReader)) {
      throw new Error("DirReader must be called as constructor.");
    }
    if (props2.type !== "Directory" || !props2.Directory) {
      throw new Error("Non-directory type " + props2.type);
    }
    self2.entries = null;
    self2._index = -1;
    self2._paused = false;
    self2._length = -1;
    if (props2.sort) {
      this.sort = props2.sort;
    }
    Reader.call(this, props2);
  }
  DirReader.prototype._getEntries = function() {
    var self2 = this;
    if (self2._gotEntries) return;
    self2._gotEntries = true;
    fs2.readdir(self2._path, function(er, entries) {
      if (er) return self2.error(er);
      self2.entries = entries;
      self2.emit("entries", entries);
      if (self2._paused) self2.once("resume", processEntries);
      else processEntries();
      function processEntries() {
        self2._length = self2.entries.length;
        if (typeof self2.sort === "function") {
          self2.entries = self2.entries.sort(self2.sort.bind(self2));
        }
        self2._read();
      }
    });
  };
  DirReader.prototype._read = function() {
    var self2 = this;
    if (!self2.entries) return self2._getEntries();
    if (self2._paused || self2._currentEntry || self2._aborted) {
      return;
    }
    self2._index++;
    if (self2._index >= self2.entries.length) {
      if (!self2._ended) {
        self2._ended = true;
        self2.emit("end");
        self2.emit("close");
      }
      return;
    }
    var p = path2.resolve(self2._path, self2.entries[self2._index]);
    assert2(p !== self2._path);
    assert2(self2.entries[self2._index]);
    self2._currentEntry = p;
    fs2[self2.props.follow ? "stat" : "lstat"](p, function(er, stat) {
      if (er) return self2.error(er);
      var who = self2._proxy || self2;
      stat.path = p;
      stat.basename = path2.basename(p);
      stat.dirname = path2.dirname(p);
      var childProps = self2.getChildProps.call(who, stat);
      childProps.path = p;
      childProps.basename = path2.basename(p);
      childProps.dirname = path2.dirname(p);
      var entry = Reader(childProps, stat);
      self2._currentEntry = entry;
      entry.on("pause", function(who2) {
        if (!self2._paused && !entry._disowned) {
          self2.pause(who2);
        }
      });
      entry.on("resume", function(who2) {
        if (self2._paused && !entry._disowned) {
          self2.resume(who2);
        }
      });
      entry.on("stat", function(props2) {
        self2.emit("_entryStat", entry, props2);
        if (entry._aborted) return;
        if (entry._paused) {
          entry.once("resume", function() {
            self2.emit("entryStat", entry, props2);
          });
        } else self2.emit("entryStat", entry, props2);
      });
      entry.on("ready", function EMITCHILD() {
        if (self2._paused) {
          entry.pause(self2);
          return self2.once("resume", EMITCHILD);
        }
        if (entry.type === "Socket") {
          self2.emit("socket", entry);
        } else {
          self2.emitEntry(entry);
        }
      });
      var ended = false;
      entry.on("close", onend);
      entry.on("disown", onend);
      function onend() {
        if (ended) return;
        ended = true;
        self2.emit("childEnd", entry);
        self2.emit("entryEnd", entry);
        self2._currentEntry = null;
        if (!self2._paused) {
          self2._read();
        }
      }
      entry.on("error", function(er2) {
        if (entry._swallowErrors) {
          self2.warn(er2);
          entry.emit("end");
          entry.emit("close");
        } else {
          self2.emit("error", er2);
        }
      });
      [
        "child",
        "childEnd",
        "warn"
      ].forEach(function(ev) {
        entry.on(ev, self2.emit.bind(self2, ev));
      });
    });
  };
  DirReader.prototype.disown = function(entry) {
    entry.emit("beforeDisown");
    entry._disowned = true;
    entry.parent = entry.root = null;
    if (entry === this._currentEntry) {
      this._currentEntry = null;
    }
    entry.emit("disown");
  };
  DirReader.prototype.getChildProps = function() {
    return {
      depth: this.depth + 1,
      root: this.root || this,
      parent: this,
      follow: this.follow,
      filter: this.filter,
      sort: this.props.sort,
      hardlinks: this.props.hardlinks
    };
  };
  DirReader.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused) return;
    who = who || self2;
    self2._paused = true;
    if (self2._currentEntry && self2._currentEntry.pause) {
      self2._currentEntry.pause(who);
    }
    self2.emit("pause", who);
  };
  DirReader.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused) return;
    who = who || self2;
    self2._paused = false;
    self2.emit("resume", who);
    if (self2._paused) {
      return;
    }
    if (self2._currentEntry) {
      if (self2._currentEntry.resume) self2._currentEntry.resume(who);
    } else self2._read();
  };
  DirReader.prototype.emitEntry = function(entry) {
    this.emit("entry", entry);
    this.emit("child", entry);
  };
  return dirReader;
}
var fileReader;
var hasRequiredFileReader;
function requireFileReader() {
  if (hasRequiredFileReader) return fileReader;
  hasRequiredFileReader = 1;
  fileReader = FileReader2;
  var fs2 = requireGracefulFs();
  var inherits2 = requireInherits();
  var Reader = requireReader();
  var EOF = { EOF: true };
  var CLOSE = { CLOSE: true };
  inherits2(FileReader2, Reader);
  function FileReader2(props2) {
    var self2 = this;
    if (!(self2 instanceof FileReader2)) {
      throw new Error("FileReader must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "File" && props2.File)) {
      throw new Error("Non-file type " + props2.type);
    }
    self2._buffer = [];
    self2._bytesEmitted = 0;
    Reader.call(self2, props2);
  }
  FileReader2.prototype._getStream = function() {
    var self2 = this;
    var stream2 = self2._stream = fs2.createReadStream(self2._path, self2.props);
    if (self2.props.blksize) {
      stream2.bufferSize = self2.props.blksize;
    }
    stream2.on("open", self2.emit.bind(self2, "open"));
    stream2.on("data", function(c) {
      self2._bytesEmitted += c.length;
      if (!c.length) {
        return;
      } else if (self2._paused || self2._buffer.length) {
        self2._buffer.push(c);
        self2._read();
      } else self2.emit("data", c);
    });
    stream2.on("end", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(EOF);
        self2._read();
      } else {
        self2.emit("end");
      }
      if (self2._bytesEmitted !== self2.props.size) {
        self2.error("Didn't get expected byte count\nexpect: " + self2.props.size + "\nactual: " + self2._bytesEmitted);
      }
    });
    stream2.on("close", function() {
      if (self2._paused || self2._buffer.length) {
        self2._buffer.push(CLOSE);
        self2._read();
      } else {
        self2.emit("close");
      }
    });
    stream2.on("error", function(e) {
      self2.emit("error", e);
    });
    self2._read();
  };
  FileReader2.prototype._read = function() {
    var self2 = this;
    if (self2._paused) {
      return;
    }
    if (!self2._stream) {
      return self2._getStream();
    }
    if (self2._buffer.length) {
      var buf = self2._buffer;
      for (var i = 0, l = buf.length; i < l; i++) {
        var c = buf[i];
        if (c === EOF) {
          self2.emit("end");
        } else if (c === CLOSE) {
          self2.emit("close");
        } else {
          self2.emit("data", c);
        }
        if (self2._paused) {
          self2._buffer = buf.slice(i);
          return;
        }
      }
      self2._buffer.length = 0;
    }
  };
  FileReader2.prototype.pause = function(who) {
    var self2 = this;
    if (self2._paused) return;
    who = who || self2;
    self2._paused = true;
    if (self2._stream) self2._stream.pause();
    self2.emit("pause", who);
  };
  FileReader2.prototype.resume = function(who) {
    var self2 = this;
    if (!self2._paused) return;
    who = who || self2;
    self2.emit("resume", who);
    self2._paused = false;
    if (self2._stream) self2._stream.resume();
    self2._read();
  };
  return fileReader;
}
var socketReader;
var hasRequiredSocketReader;
function requireSocketReader() {
  if (hasRequiredSocketReader) return socketReader;
  hasRequiredSocketReader = 1;
  socketReader = SocketReader;
  var inherits2 = requireInherits();
  var Reader = requireReader();
  inherits2(SocketReader, Reader);
  function SocketReader(props2) {
    var self2 = this;
    if (!(self2 instanceof SocketReader)) {
      throw new Error("SocketReader must be called as constructor.");
    }
    if (!(props2.type === "Socket" && props2.Socket)) {
      throw new Error("Non-socket type " + props2.type);
    }
    Reader.call(self2, props2);
  }
  SocketReader.prototype._read = function() {
    var self2 = this;
    if (self2._paused) return;
    if (!self2._ended) {
      self2.emit("end");
      self2.emit("close");
      self2._ended = true;
    }
  };
  return socketReader;
}
var proxyReader;
var hasRequiredProxyReader;
function requireProxyReader() {
  if (hasRequiredProxyReader) return proxyReader;
  hasRequiredProxyReader = 1;
  proxyReader = ProxyReader;
  var Reader = requireReader();
  var getType = requireGetType();
  var inherits2 = requireInherits();
  var fs2 = requireGracefulFs();
  inherits2(ProxyReader, Reader);
  function ProxyReader(props2) {
    var self2 = this;
    if (!(self2 instanceof ProxyReader)) {
      throw new Error("ProxyReader must be called as constructor.");
    }
    self2.props = props2;
    self2._buffer = [];
    self2.ready = false;
    Reader.call(self2, props2);
  }
  ProxyReader.prototype._stat = function() {
    var self2 = this;
    var props2 = self2.props;
    var stat = props2.follow ? "stat" : "lstat";
    fs2[stat](props2.path, function(er, current) {
      var type2;
      if (er || !current) {
        type2 = "File";
      } else {
        type2 = getType(current);
      }
      props2[type2] = true;
      props2.type = self2.type = type2;
      self2._old = current;
      self2._addProxy(Reader(props2, current));
    });
  };
  ProxyReader.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxyTarget) {
      return self2.error("proxy already set");
    }
    self2._proxyTarget = proxy;
    proxy._proxy = self2;
    [
      "error",
      "data",
      "end",
      "close",
      "linkpath",
      "entry",
      "entryEnd",
      "child",
      "childEnd",
      "warn",
      "stat"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    proxy.on("ready", function() {
      self2.ready = true;
      self2.emit("ready");
    });
    var calls = self2._buffer;
    self2._buffer.length = 0;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
  };
  ProxyReader.prototype.pause = function() {
    return this._proxyTarget ? this._proxyTarget.pause() : false;
  };
  ProxyReader.prototype.resume = function() {
    return this._proxyTarget ? this._proxyTarget.resume() : false;
  };
  return proxyReader;
}
var reader;
var hasRequiredReader;
function requireReader() {
  if (hasRequiredReader) return reader;
  hasRequiredReader = 1;
  reader = Reader;
  var fs2 = requireGracefulFs();
  var Stream = require$$0$1.Stream;
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var getType = requireGetType();
  var hardLinks = Reader.hardLinks = {};
  var Abstract = requireAbstract();
  inherits2(Reader, Abstract);
  var LinkReader = requireLinkReader();
  function Reader(props2, currentStat) {
    var self2 = this;
    if (!(self2 instanceof Reader)) return new Reader(props2, currentStat);
    if (typeof props2 === "string") {
      props2 = { path: props2 };
    }
    var type2;
    var ClassType;
    if (props2.type && typeof props2.type === "function") {
      type2 = props2.type;
      ClassType = type2;
    } else {
      type2 = getType(props2);
      ClassType = Reader;
    }
    if (currentStat && !type2) {
      type2 = getType(currentStat);
      props2[type2] = true;
      props2.type = type2;
    }
    switch (type2) {
      case "Directory":
        ClassType = requireDirReader();
        break;
      case "Link":
      // XXX hard links are just files.
      // However, it would be good to keep track of files' dev+inode
      // and nlink values, and create a HardLinkReader that emits
      // a linkpath value of the original copy, so that the tar
      // writer can preserve them.
      // ClassType = HardLinkReader
      // break
      case "File":
        ClassType = requireFileReader();
        break;
      case "SymbolicLink":
        ClassType = LinkReader;
        break;
      case "Socket":
        ClassType = requireSocketReader();
        break;
      case null:
        ClassType = requireProxyReader();
        break;
    }
    if (!(self2 instanceof ClassType)) {
      return new ClassType(props2);
    }
    Abstract.call(self2);
    if (!props2.path) {
      self2.error("Must provide a path", null, true);
    }
    self2.readable = true;
    self2.writable = false;
    self2.type = type2;
    self2.props = props2;
    self2.depth = props2.depth = props2.depth || 0;
    self2.parent = props2.parent || null;
    self2.root = props2.root || props2.parent && props2.parent.root || self2;
    self2._path = self2.path = path2.resolve(props2.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = props2.basename = path2.basename(self2.path);
    self2.dirname = props2.dirname = path2.dirname(self2.path);
    props2.parent = props2.root = null;
    self2.size = props2.size;
    self2.filter = typeof props2.filter === "function" ? props2.filter : null;
    if (props2.sort === "alpha") props2.sort = alphasort;
    self2._stat(currentStat);
  }
  function alphasort(a, b) {
    return a === b ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : a.toLowerCase() < b.toLowerCase() ? -1 : a > b ? 1 : -1;
  }
  Reader.prototype._stat = function(currentStat) {
    var self2 = this;
    var props2 = self2.props;
    var stat = props2.follow ? "stat" : "lstat";
    if (currentStat) process.nextTick(statCb.bind(null, null, currentStat));
    else fs2[stat](self2._path, statCb);
    function statCb(er, props_) {
      if (er) return self2.error(er);
      Object.keys(props_).forEach(function(k2) {
        props2[k2] = props_[k2];
      });
      if (void 0 !== self2.size && props2.size !== self2.size) {
        return self2.error("incorrect size");
      }
      self2.size = props2.size;
      var type2 = getType(props2);
      var handleHardlinks = props2.hardlinks !== false;
      if (handleHardlinks && type2 !== "Directory" && props2.nlink && props2.nlink > 1) {
        var k = props2.dev + ":" + props2.ino;
        if (hardLinks[k] === self2._path || !hardLinks[k]) {
          hardLinks[k] = self2._path;
        } else {
          type2 = self2.type = self2.props.type = "Link";
          self2.Link = self2.props.Link = true;
          self2.linkpath = self2.props.linkpath = hardLinks[k];
          self2._stat = self2._read = LinkReader.prototype._read;
        }
      }
      if (self2.type && self2.type !== type2) {
        self2.error("Unexpected type: " + type2);
      }
      if (self2.filter) {
        var who = self2._proxy || self2;
        if (!self2.filter.call(who, who, props2)) {
          if (!self2._disowned) {
            self2.abort();
            self2.emit("end");
            self2.emit("close");
          }
          return;
        }
      }
      var events = ["_stat", "stat", "ready"];
      var e = 0;
      (function go() {
        if (self2._aborted) {
          self2.emit("end");
          self2.emit("close");
          return;
        }
        if (self2._paused && self2.type !== "Directory") {
          self2.once("resume", go);
          return;
        }
        var ev = events[e++];
        if (!ev) {
          return self2._read();
        }
        self2.emit(ev, props2);
        go();
      })();
    }
  };
  Reader.prototype.pipe = function(dest) {
    var self2 = this;
    if (typeof dest.add === "function") {
      self2.on("entry", function(entry) {
        var ret = dest.add(entry);
        if (ret === false) {
          self2.pause();
        }
      });
    }
    return Stream.prototype.pipe.apply(this, arguments);
  };
  Reader.prototype.pause = function(who) {
    this._paused = true;
    who = who || this;
    this.emit("pause", who);
    if (this._stream) this._stream.pause(who);
  };
  Reader.prototype.resume = function(who) {
    this._paused = false;
    who = who || this;
    this.emit("resume", who);
    if (this._stream) this._stream.resume(who);
    this._read();
  };
  Reader.prototype._read = function() {
    this.error("Cannot read unknown type: " + this.type);
  };
  return reader;
}
var rimraf_1;
var hasRequiredRimraf;
function requireRimraf() {
  if (hasRequiredRimraf) return rimraf_1;
  hasRequiredRimraf = 1;
  rimraf_1 = rimraf;
  rimraf.sync = rimrafSync;
  var assert2 = require$$5;
  var path2 = require$$1;
  var fs2 = require$$0$4;
  var glob = void 0;
  try {
    glob = requireGlob();
  } catch (_err) {
  }
  var _0666 = parseInt("666", 8);
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout2 = 0;
  var isWindows = process.platform === "win32";
  function defaults2(options) {
    var methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach(function(m) {
      options[m] = options[m] || fs2[m];
      m = m + "Sync";
      options[m] = options[m] || fs2[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  }
  function rimraf(p, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert2(p, "rimraf: missing path");
    assert2.equal(typeof p, "string", "rimraf: path should be a string");
    assert2.equal(typeof cb, "function", "rimraf: callback function required");
    assert2(options, "rimraf: invalid options argument provided");
    assert2.equal(typeof options, "object", "rimraf: options should be object");
    defaults2(options);
    var busyTries = 0;
    var errState = null;
    var n = 0;
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, function(er, stat) {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
    function next(er) {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    }
    function afterGlob(er, results) {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach(function(p2) {
        rimraf_(p2, options, function CB(er2) {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              var time = busyTries * 100;
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, time);
            }
            if (er2.code === "EMFILE" && timeout2 < options.emfileWait) {
              return setTimeout(function() {
                rimraf_(p2, options, CB);
              }, timeout2++);
            }
            if (er2.code === "ENOENT") er2 = null;
          }
          timeout2 = 0;
          next(er2);
        });
      });
    }
  }
  function rimraf_(p, options, cb) {
    assert2(p);
    assert2(options);
    assert2(typeof cb === "function");
    options.lstat(p, function(er, st) {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, function(er2) {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  }
  function fixWinEPERM(p, options, er, cb) {
    assert2(p);
    assert2(options);
    assert2(typeof cb === "function");
    if (er)
      assert2(er instanceof Error);
    options.chmod(p, _0666, function(er2) {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, function(er3, stats) {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  }
  function fixWinEPERMSync(p, options, er) {
    assert2(p);
    assert2(options);
    if (er)
      assert2(er instanceof Error);
    try {
      options.chmodSync(p, _0666);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    try {
      var stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  }
  function rmdir(p, options, originalEr, cb) {
    assert2(p);
    assert2(options);
    if (originalEr)
      assert2(originalEr instanceof Error);
    assert2(typeof cb === "function");
    options.rmdir(p, function(er) {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  }
  function rmkids(p, options, cb) {
    assert2(p);
    assert2(options);
    assert2(typeof cb === "function");
    options.readdir(p, function(er, files) {
      if (er)
        return cb(er);
      var n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      var errState;
      files.forEach(function(f) {
        rimraf(path2.join(p, f), options, function(er2) {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  }
  function rimrafSync(p, options) {
    options = options || {};
    defaults2(options);
    assert2(p, "rimraf: missing path");
    assert2.equal(typeof p, "string", "rimraf: path should be a string");
    assert2(options, "rimraf: missing options");
    assert2.equal(typeof options, "object", "rimraf: options should be object");
    var results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (var i = 0; i < results.length; i++) {
      var p = results[i];
      try {
        var st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p, options, null);
        else
          options.unlinkSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p, options, er);
      }
    }
  }
  function rmdirSync(p, options, originalEr) {
    assert2(p);
    assert2(options);
    if (originalEr)
      assert2(originalEr instanceof Error);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  }
  function rmkidsSync(p, options) {
    assert2(p);
    assert2(options);
    options.readdirSync(p).forEach(function(f) {
      rimrafSync(path2.join(p, f), options);
    });
    var retries = isWindows ? 100 : 1;
    var i = 0;
    do {
      var threw = true;
      try {
        var ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  }
  return rimraf_1;
}
var mkdirp;
var hasRequiredMkdirp;
function requireMkdirp() {
  if (hasRequiredMkdirp) return mkdirp;
  hasRequiredMkdirp = 1;
  var path2 = require$$1;
  var fs2 = require$$0$4;
  var _0777 = parseInt("0777", 8);
  mkdirp = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
  function mkdirP(p, opts, f, made) {
    if (typeof opts === "function") {
      f = opts;
      opts = {};
    } else if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made) made = null;
    var cb = f || /* istanbul ignore next */
    function() {
    };
    p = path2.resolve(p);
    xfs.mkdir(p, mode, function(er) {
      if (!er) {
        made = made || p;
        return cb(null, made);
      }
      switch (er.code) {
        case "ENOENT":
          if (path2.dirname(p) === p) return cb(er);
          mkdirP(path2.dirname(p), opts, function(er2, made2) {
            if (er2) cb(er2, made2);
            else mkdirP(p, opts, cb, made2);
          });
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          xfs.stat(p, function(er2, stat) {
            if (er2 || !stat.isDirectory()) cb(er, made);
            else cb(null, made);
          });
          break;
      }
    });
  }
  mkdirP.sync = function sync2(p, opts, made) {
    if (!opts || typeof opts !== "object") {
      opts = { mode: opts };
    }
    var mode = opts.mode;
    var xfs = opts.fs || fs2;
    if (mode === void 0) {
      mode = _0777;
    }
    if (!made) made = null;
    p = path2.resolve(p);
    try {
      xfs.mkdirSync(p, mode);
      made = made || p;
    } catch (err0) {
      switch (err0.code) {
        case "ENOENT":
          made = sync2(path2.dirname(p), opts, made);
          sync2(p, opts, made);
          break;
        // In the case of any other error, just see if there's a dir
        // there already.  If so, then hooray!  If not, then something
        // is borked.
        default:
          var stat;
          try {
            stat = xfs.statSync(p);
          } catch (err1) {
            throw err0;
          }
          if (!stat.isDirectory()) throw err0;
          break;
      }
    }
    return made;
  };
  return mkdirp;
}
var collect_1;
var hasRequiredCollect;
function requireCollect() {
  if (hasRequiredCollect) return collect_1;
  hasRequiredCollect = 1;
  collect_1 = collect;
  function collect(stream2) {
    if (stream2._collected) return;
    if (stream2._paused) return stream2.on("resume", collect.bind(null, stream2));
    stream2._collected = true;
    stream2.pause();
    stream2.on("data", save);
    stream2.on("end", save);
    var buf = [];
    function save(b) {
      if (typeof b === "string") b = new Buffer(b);
      if (Buffer.isBuffer(b) && !b.length) return;
      buf.push(b);
    }
    stream2.on("entry", saveEntry);
    var entryBuffer = [];
    function saveEntry(e) {
      collect(e);
      entryBuffer.push(e);
    }
    stream2.on("proxy", proxyPause);
    function proxyPause(p) {
      p.pause();
    }
    stream2.pipe = /* @__PURE__ */ function(orig) {
      return function(dest) {
        var e = 0;
        (function unblockEntry() {
          var entry = entryBuffer[e++];
          if (!entry) return resume();
          entry.on("end", unblockEntry);
          if (dest) dest.add(entry);
          else stream2.emit("entry", entry);
        })();
        function resume() {
          stream2.removeListener("entry", saveEntry);
          stream2.removeListener("data", save);
          stream2.removeListener("end", save);
          stream2.pipe = orig;
          if (dest) stream2.pipe(dest);
          buf.forEach(function(b) {
            if (b) stream2.emit("data", b);
            else stream2.emit("end");
          });
          stream2.resume();
        }
        return dest;
      };
    }(stream2.pipe);
  }
  return collect_1;
}
var dirWriter;
var hasRequiredDirWriter;
function requireDirWriter() {
  if (hasRequiredDirWriter) return dirWriter;
  hasRequiredDirWriter = 1;
  dirWriter = DirWriter;
  var Writer = requireWriter();
  var inherits2 = requireInherits();
  var mkdir = requireMkdirp();
  var path2 = require$$1;
  var collect = requireCollect();
  inherits2(DirWriter, Writer);
  function DirWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof DirWriter)) {
      self2.error("DirWriter must be called as constructor.", null, true);
    }
    if (props2.type !== "Directory" || !props2.Directory) {
      self2.error("Non-directory type " + props2.type + " " + JSON.stringify(props2), null, true);
    }
    Writer.call(this, props2);
  }
  DirWriter.prototype._create = function() {
    var self2 = this;
    mkdir(self2._path, Writer.dirmode, function(er) {
      if (er) return self2.error(er);
      self2.ready = true;
      self2.emit("ready");
      self2._process();
    });
  };
  DirWriter.prototype.write = function() {
    return true;
  };
  DirWriter.prototype.end = function() {
    this._ended = true;
    this._process();
  };
  DirWriter.prototype.add = function(entry) {
    var self2 = this;
    collect(entry);
    if (!self2.ready || self2._currentEntry) {
      self2._buffer.push(entry);
      return false;
    }
    if (self2._ended) {
      return self2.error("add after end");
    }
    self2._buffer.push(entry);
    self2._process();
    return this._buffer.length === 0;
  };
  DirWriter.prototype._process = function() {
    var self2 = this;
    if (self2._processing) return;
    var entry = self2._buffer.shift();
    if (!entry) {
      self2.emit("drain");
      if (self2._ended) self2._finish();
      return;
    }
    self2._processing = true;
    self2.emit("entry", entry);
    var p = entry;
    var pp;
    do {
      pp = p._path || p.path;
      if (pp === self2.root._path || pp === self2._path || pp && pp.indexOf(self2._path) === 0) {
        self2._processing = false;
        if (entry._collected) entry.pipe();
        return self2._process();
      }
      p = p.parent;
    } while (p);
    var props2 = {
      parent: self2,
      root: self2.root || self2,
      type: entry.type,
      depth: self2.depth + 1
    };
    pp = entry._path || entry.path || entry.props.path;
    if (entry.parent) {
      pp = pp.substr(entry.parent._path.length + 1);
    }
    props2.path = path2.join(self2.path, path2.join("/", pp));
    props2.filter = self2.filter;
    Object.keys(entry.props).forEach(function(k) {
      if (!props2.hasOwnProperty(k)) {
        props2[k] = entry.props[k];
      }
    });
    var child = self2._currentChild = new Writer(props2);
    child.on("ready", function() {
      entry.pipe(child);
      entry.resume();
    });
    child.on("error", function(er) {
      if (child._swallowErrors) {
        self2.warn(er);
        child.emit("end");
        child.emit("close");
      } else {
        self2.emit("error", er);
      }
    });
    child.on("close", onend);
    var ended = false;
    function onend() {
      if (ended) return;
      ended = true;
      self2._currentChild = null;
      self2._processing = false;
      self2._process();
    }
  };
  return dirWriter;
}
var linkWriter;
var hasRequiredLinkWriter;
function requireLinkWriter() {
  if (hasRequiredLinkWriter) return linkWriter;
  hasRequiredLinkWriter = 1;
  linkWriter = LinkWriter;
  var fs2 = requireGracefulFs();
  var Writer = requireWriter();
  var inherits2 = requireInherits();
  var path2 = require$$1;
  var rimraf = requireRimraf();
  inherits2(LinkWriter, Writer);
  function LinkWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof LinkWriter)) {
      throw new Error("LinkWriter must be called as constructor.");
    }
    if (!(props2.type === "Link" && props2.Link || props2.type === "SymbolicLink" && props2.SymbolicLink)) {
      throw new Error("Non-link type " + props2.type);
    }
    if (props2.linkpath === "") props2.linkpath = ".";
    if (!props2.linkpath) {
      self2.error("Need linkpath property to create " + props2.type);
    }
    Writer.call(this, props2);
  }
  LinkWriter.prototype._create = function() {
    var self2 = this;
    var hard = self2.type === "Link" || process.platform === "win32";
    var link = hard ? "link" : "symlink";
    var lp = hard ? path2.resolve(self2.dirname, self2.linkpath) : self2.linkpath;
    if (hard) return clobber(self2, lp, link);
    fs2.readlink(self2._path, function(er, p) {
      if (p && p === lp) return finish(self2);
      clobber(self2, lp, link);
    });
  };
  function clobber(self2, lp, link) {
    rimraf(self2._path, function(er) {
      if (er) return self2.error(er);
      create(self2, lp, link);
    });
  }
  function create(self2, lp, link) {
    fs2[link](lp, self2._path, function(er) {
      if (er) {
        if ((er.code === "ENOENT" || er.code === "EACCES" || er.code === "EPERM") && process.platform === "win32") {
          self2.ready = true;
          self2.emit("ready");
          self2.emit("end");
          self2.emit("close");
          self2.end = self2._finish = function() {
          };
        } else return self2.error(er);
      }
      finish(self2);
    });
  }
  function finish(self2) {
    self2.ready = true;
    self2.emit("ready");
    if (self2._ended && !self2._finished) self2._finish();
  }
  LinkWriter.prototype.end = function() {
    this._ended = true;
    if (this.ready) {
      this._finished = true;
      this._finish();
    }
  };
  return linkWriter;
}
var fileWriter;
var hasRequiredFileWriter;
function requireFileWriter() {
  if (hasRequiredFileWriter) return fileWriter;
  hasRequiredFileWriter = 1;
  fileWriter = FileWriter;
  var fs2 = requireGracefulFs();
  var Writer = requireWriter();
  var inherits2 = requireInherits();
  var EOF = {};
  inherits2(FileWriter, Writer);
  function FileWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof FileWriter)) {
      throw new Error("FileWriter must be called as constructor.");
    }
    if (props2.type !== "File" || !props2.File) {
      throw new Error("Non-file type " + props2.type);
    }
    self2._buffer = [];
    self2._bytesWritten = 0;
    Writer.call(this, props2);
  }
  FileWriter.prototype._create = function() {
    var self2 = this;
    if (self2._stream) return;
    var so = {};
    if (self2.props.flags) so.flags = self2.props.flags;
    so.mode = Writer.filemode;
    if (self2._old && self2._old.blksize) so.bufferSize = self2._old.blksize;
    self2._stream = fs2.createWriteStream(self2._path, so);
    self2._stream.on("open", function() {
      self2.ready = true;
      self2._buffer.forEach(function(c) {
        if (c === EOF) self2._stream.end();
        else self2._stream.write(c);
      });
      self2.emit("ready");
      self2.emit("drain");
    });
    self2._stream.on("error", function(er) {
      self2.emit("error", er);
    });
    self2._stream.on("drain", function() {
      self2.emit("drain");
    });
    self2._stream.on("close", function() {
      self2._finish();
    });
  };
  FileWriter.prototype.write = function(c) {
    var self2 = this;
    self2._bytesWritten += c.length;
    if (!self2.ready) {
      if (!Buffer.isBuffer(c) && typeof c !== "string") {
        throw new Error("invalid write data");
      }
      self2._buffer.push(c);
      return false;
    }
    var ret = self2._stream.write(c);
    if (ret === false && self2._stream._queue) {
      return self2._stream._queue.length <= 2;
    } else {
      return ret;
    }
  };
  FileWriter.prototype.end = function(c) {
    var self2 = this;
    if (c) self2.write(c);
    if (!self2.ready) {
      self2._buffer.push(EOF);
      return false;
    }
    return self2._stream.end();
  };
  FileWriter.prototype._finish = function() {
    var self2 = this;
    if (typeof self2.size === "number" && self2._bytesWritten !== self2.size) {
      self2.error(
        "Did not get expected byte count.\nexpect: " + self2.size + "\nactual: " + self2._bytesWritten
      );
    }
    Writer.prototype._finish.call(self2);
  };
  return fileWriter;
}
var proxyWriter;
var hasRequiredProxyWriter;
function requireProxyWriter() {
  if (hasRequiredProxyWriter) return proxyWriter;
  hasRequiredProxyWriter = 1;
  proxyWriter = ProxyWriter;
  var Writer = requireWriter();
  var getType = requireGetType();
  var inherits2 = requireInherits();
  var collect = requireCollect();
  var fs2 = require$$0$4;
  inherits2(ProxyWriter, Writer);
  function ProxyWriter(props2) {
    var self2 = this;
    if (!(self2 instanceof ProxyWriter)) {
      throw new Error("ProxyWriter must be called as constructor.");
    }
    self2.props = props2;
    self2._needDrain = false;
    Writer.call(self2, props2);
  }
  ProxyWriter.prototype._stat = function() {
    var self2 = this;
    var props2 = self2.props;
    var stat = props2.follow ? "stat" : "lstat";
    fs2[stat](props2.path, function(er, current) {
      var type2;
      if (er || !current) {
        type2 = "File";
      } else {
        type2 = getType(current);
      }
      props2[type2] = true;
      props2.type = self2.type = type2;
      self2._old = current;
      self2._addProxy(Writer(props2, current));
    });
  };
  ProxyWriter.prototype._addProxy = function(proxy) {
    var self2 = this;
    if (self2._proxy) {
      return self2.error("proxy already set");
    }
    self2._proxy = proxy;
    [
      "ready",
      "error",
      "close",
      "pipe",
      "drain",
      "warn"
    ].forEach(function(ev) {
      proxy.on(ev, self2.emit.bind(self2, ev));
    });
    self2.emit("proxy", proxy);
    var calls = self2._buffer;
    calls.forEach(function(c) {
      proxy[c[0]].apply(proxy, c[1]);
    });
    self2._buffer.length = 0;
    if (self2._needsDrain) self2.emit("drain");
  };
  ProxyWriter.prototype.add = function(entry) {
    collect(entry);
    if (!this._proxy) {
      this._buffer.push(["add", [entry]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.add(entry);
  };
  ProxyWriter.prototype.write = function(c) {
    if (!this._proxy) {
      this._buffer.push(["write", [c]]);
      this._needDrain = true;
      return false;
    }
    return this._proxy.write(c);
  };
  ProxyWriter.prototype.end = function(c) {
    if (!this._proxy) {
      this._buffer.push(["end", [c]]);
      return false;
    }
    return this._proxy.end(c);
  };
  return proxyWriter;
}
var writer;
var hasRequiredWriter;
function requireWriter() {
  if (hasRequiredWriter) return writer;
  hasRequiredWriter = 1;
  writer = Writer;
  var fs2 = requireGracefulFs();
  var inherits2 = requireInherits();
  var rimraf = requireRimraf();
  var mkdir = requireMkdirp();
  var path2 = require$$1;
  var umask = process.platform === "win32" ? 0 : process.umask();
  var getType = requireGetType();
  var Abstract = requireAbstract();
  inherits2(Writer, Abstract);
  Writer.dirmode = parseInt("0777", 8) & ~umask;
  Writer.filemode = parseInt("0666", 8) & ~umask;
  var DirWriter = requireDirWriter();
  var LinkWriter = requireLinkWriter();
  var FileWriter = requireFileWriter();
  var ProxyWriter = requireProxyWriter();
  function Writer(props2, current) {
    var self2 = this;
    if (typeof props2 === "string") {
      props2 = { path: props2 };
    }
    var type2 = getType(props2);
    var ClassType = Writer;
    switch (type2) {
      case "Directory":
        ClassType = DirWriter;
        break;
      case "File":
        ClassType = FileWriter;
        break;
      case "Link":
      case "SymbolicLink":
        ClassType = LinkWriter;
        break;
      case null:
      default:
        ClassType = ProxyWriter;
        break;
    }
    if (!(self2 instanceof ClassType)) return new ClassType(props2);
    Abstract.call(self2);
    if (!props2.path) self2.error("Must provide a path", null, true);
    self2.type = props2.type;
    self2.props = props2;
    self2.depth = props2.depth || 0;
    self2.clobber = props2.clobber === false ? props2.clobber : true;
    self2.parent = props2.parent || null;
    self2.root = props2.root || props2.parent && props2.parent.root || self2;
    self2._path = self2.path = path2.resolve(props2.path);
    if (process.platform === "win32") {
      self2.path = self2._path = self2.path.replace(/\?/g, "_");
      if (self2._path.length >= 260) {
        self2._swallowErrors = true;
        self2._path = "\\\\?\\" + self2.path.replace(/\//g, "\\");
      }
    }
    self2.basename = path2.basename(props2.path);
    self2.dirname = path2.dirname(props2.path);
    self2.linkpath = props2.linkpath || null;
    props2.parent = props2.root = null;
    self2.size = props2.size;
    if (typeof props2.mode === "string") {
      props2.mode = parseInt(props2.mode, 8);
    }
    self2.readable = false;
    self2.writable = true;
    self2._buffer = [];
    self2.ready = false;
    self2.filter = typeof props2.filter === "function" ? props2.filter : null;
    self2._stat(current);
  }
  Writer.prototype._create = function() {
    var self2 = this;
    fs2[self2.props.follow ? "stat" : "lstat"](self2._path, function(er) {
      if (er) {
        return self2.warn("Cannot create " + self2._path + "\nUnsupported type: " + self2.type, "ENOTSUP");
      }
      self2._finish();
    });
  };
  Writer.prototype._stat = function(current) {
    var self2 = this;
    var props2 = self2.props;
    var stat = props2.follow ? "stat" : "lstat";
    var who = self2._proxy || self2;
    if (current) statCb(null, current);
    else fs2[stat](self2._path, statCb);
    function statCb(er, current2) {
      if (self2.filter && !self2.filter.call(who, who, current2)) {
        self2._aborted = true;
        self2.emit("end");
        self2.emit("close");
        return;
      }
      if (er || !current2) {
        return create(self2);
      }
      self2._old = current2;
      var currentType = getType(current2);
      if (currentType !== self2.type || self2.type === "File" && current2.nlink > 1) {
        return rimraf(self2._path, function(er2) {
          if (er2) return self2.error(er2);
          self2._old = null;
          create(self2);
        });
      }
      create(self2);
    }
  };
  function create(self2) {
    mkdir(path2.dirname(self2._path), Writer.dirmode, function(er, made) {
      if (er) return self2.error(er);
      self2._madeDir = made;
      return self2._create();
    });
  }
  function endChmod(self2, want, current, path3, cb) {
    var wantMode = want.mode;
    var chmod = want.follow || self2.type !== "SymbolicLink" ? "chmod" : "lchmod";
    if (!fs2[chmod]) return cb();
    if (typeof wantMode !== "number") return cb();
    var curMode = current.mode & parseInt("0777", 8);
    wantMode = wantMode & parseInt("0777", 8);
    if (wantMode === curMode) return cb();
    fs2[chmod](path3, wantMode, cb);
  }
  function endChown(self2, want, current, path3, cb) {
    if (process.platform === "win32") return cb();
    if (!process.getuid || process.getuid() !== 0) return cb();
    if (typeof want.uid !== "number" && typeof want.gid !== "number") return cb();
    if (current.uid === want.uid && current.gid === want.gid) return cb();
    var chown = self2.props.follow || self2.type !== "SymbolicLink" ? "chown" : "lchown";
    if (!fs2[chown]) return cb();
    if (typeof want.uid !== "number") want.uid = current.uid;
    if (typeof want.gid !== "number") want.gid = current.gid;
    fs2[chown](path3, want.uid, want.gid, cb);
  }
  function endUtimes(self2, want, current, path3, cb) {
    if (!fs2.utimes || process.platform === "win32") return cb();
    var utimes = want.follow || self2.type !== "SymbolicLink" ? "utimes" : "lutimes";
    if (utimes === "lutimes" && !fs2[utimes]) {
      utimes = "utimes";
    }
    if (!fs2[utimes]) return cb();
    var curA = current.atime;
    var curM = current.mtime;
    var meA = want.atime;
    var meM = want.mtime;
    if (meA === void 0) meA = curA;
    if (meM === void 0) meM = curM;
    if (!isDate2(meA)) meA = new Date(meA);
    if (!isDate2(meM)) meA = new Date(meM);
    if (meA.getTime() === curA.getTime() && meM.getTime() === curM.getTime()) return cb();
    fs2[utimes](path3, meA, meM, cb);
  }
  Writer.prototype._finish = function() {
    var self2 = this;
    if (self2._finishing) return;
    self2._finishing = true;
    var todo = 0;
    var errState = null;
    var done = false;
    if (self2._old) {
      self2._old.atime = /* @__PURE__ */ new Date(0);
      self2._old.mtime = /* @__PURE__ */ new Date(0);
      setProps(self2._old);
    } else {
      var stat = self2.props.follow ? "stat" : "lstat";
      fs2[stat](self2._path, function(er, current) {
        if (er) {
          if (er.code === "ENOENT" && (self2.type === "Link" || self2.type === "SymbolicLink") && process.platform === "win32") {
            self2.ready = true;
            self2.emit("ready");
            self2.emit("end");
            self2.emit("close");
            self2.end = self2._finish = function() {
            };
            return;
          } else return self2.error(er);
        }
        setProps(self2._old = current);
      });
    }
    return;
    function setProps(current) {
      todo += 3;
      endChmod(self2, self2.props, current, self2._path, next("chmod"));
      endChown(self2, self2.props, current, self2._path, next("chown"));
      endUtimes(self2, self2.props, current, self2._path, next("utimes"));
    }
    function next(what) {
      return function(er) {
        if (errState) return;
        if (er) {
          er.fstream_finish_call = what;
          return self2.error(errState = er);
        }
        if (--todo > 0) return;
        if (done) return;
        done = true;
        if (!self2._madeDir) return end();
        else endMadeDir(self2, self2._path, end);
        function end(er2) {
          if (er2) {
            er2.fstream_finish_call = "setupMadeDir";
            return self2.error(er2);
          }
          self2.emit("end");
          self2.emit("close");
        }
      };
    }
  };
  function endMadeDir(self2, p, cb) {
    var made = self2._madeDir;
    var d = path2.dirname(p);
    endMadeDir_(self2, d, function(er) {
      if (er) return cb(er);
      if (d === made) {
        return cb();
      }
      endMadeDir(self2, d, cb);
    });
  }
  function endMadeDir_(self2, p, cb) {
    var dirProps = {};
    Object.keys(self2.props).forEach(function(k) {
      dirProps[k] = self2.props[k];
      if (k === "mode" && self2.type !== "Directory") {
        dirProps[k] = dirProps[k] | parseInt("0111", 8);
      }
    });
    var todo = 3;
    var errState = null;
    fs2.stat(p, function(er, current) {
      if (er) return cb(errState = er);
      endChmod(self2, dirProps, current, p, next);
      endChown(self2, dirProps, current, p, next);
      endUtimes(self2, dirProps, current, p, next);
    });
    function next(er) {
      if (errState) return;
      if (er) return cb(errState = er);
      if (--todo === 0) return cb();
    }
  }
  Writer.prototype.pipe = function() {
    this.error("Can't pipe from writable stream");
  };
  Writer.prototype.add = function() {
    this.error("Can't add to non-Directory type");
  };
  Writer.prototype.write = function() {
    return true;
  };
  function objectToString(d) {
    return Object.prototype.toString.call(d);
  }
  function isDate2(d) {
    return typeof d === "object" && objectToString(d) === "[object Date]";
  }
  return writer;
}
var hasRequiredFstream;
function requireFstream() {
  if (hasRequiredFstream) return fstream;
  hasRequiredFstream = 1;
  (function(exports) {
    exports.Abstract = requireAbstract();
    exports.Reader = requireReader();
    exports.Writer = requireWriter();
    exports.File = {
      Reader: requireFileReader(),
      Writer: requireFileWriter()
    };
    exports.Dir = {
      Reader: requireDirReader(),
      Writer: requireDirWriter()
    };
    exports.Link = {
      Reader: requireLinkReader(),
      Writer: requireLinkWriter()
    };
    exports.Proxy = {
      Reader: requireProxyReader(),
      Writer: requireProxyWriter()
    };
    exports.Reader.Dir = exports.DirReader = exports.Dir.Reader;
    exports.Reader.File = exports.FileReader = exports.File.Reader;
    exports.Reader.Link = exports.LinkReader = exports.Link.Reader;
    exports.Reader.Proxy = exports.ProxyReader = exports.Proxy.Reader;
    exports.Writer.Dir = exports.DirWriter = exports.Dir.Writer;
    exports.Writer.File = exports.FileWriter = exports.File.Writer;
    exports.Writer.Link = exports.LinkWriter = exports.Link.Writer;
    exports.Writer.Proxy = exports.ProxyWriter = exports.Proxy.Writer;
    exports.collect = requireCollect();
  })(fstream);
  return fstream;
}
var extract;
var hasRequiredExtract;
function requireExtract() {
  if (hasRequiredExtract) return extract;
  hasRequiredExtract = 1;
  extract = Extract;
  var Parse = requireParse();
  var Writer = requireFstream().Writer;
  var path2 = require$$1;
  var stream2 = require$$0$1;
  var duplexer22 = requireDuplexer2();
  var Promise2 = requireBluebird();
  function Extract(opts) {
    opts.path = path2.resolve(path2.normalize(opts.path));
    var parser2 = new Parse(opts);
    var outStream = new stream2.Writable({ objectMode: true });
    outStream._write = function(entry, encoding, cb) {
      if (entry.type == "Directory") return cb();
      var extractPath = path2.join(opts.path, entry.path);
      if (extractPath.indexOf(opts.path) != 0) {
        return cb();
      }
      const writer2 = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
      entry.pipe(writer2).on("error", cb).on("close", cb);
    };
    var extract2 = duplexer22(parser2, outStream);
    parser2.once("crx-header", function(crxHeader) {
      extract2.crxHeader = crxHeader;
    });
    parser2.pipe(outStream).on("finish", function() {
      extract2.emit("close");
    });
    extract2.promise = function() {
      return new Promise2(function(resolve, reject2) {
        extract2.on("close", resolve);
        extract2.on("error", reject2);
      });
    };
    return extract2;
  }
  return extract;
}
var BigInteger = { exports: {} };
var hasRequiredBigInteger;
function requireBigInteger() {
  if (hasRequiredBigInteger) return BigInteger.exports;
  hasRequiredBigInteger = 1;
  (function(module) {
    var bigInt = function(undefined$1) {
      var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      var supportsNativeBigInt = typeof BigInt === "function";
      function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
      }
      function BigInteger2(value, sign2) {
        this.value = value;
        this.sign = sign2;
        this.isSmall = false;
      }
      BigInteger2.prototype = Object.create(Integer.prototype);
      function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
      }
      SmallInteger.prototype = Object.create(Integer.prototype);
      function NativeBigInt(value) {
        this.value = value;
      }
      NativeBigInt.prototype = Object.create(Integer.prototype);
      function isPrecise(n) {
        return -9007199254740992 < n && n < MAX_INT;
      }
      function smallToArray(n) {
        if (n < 1e7)
          return [n];
        if (n < 1e14)
          return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
      }
      function arrayToSmall(arr) {
        trim2(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
          switch (length) {
            case 0:
              return 0;
            case 1:
              return arr[0];
            case 2:
              return arr[0] + arr[1] * BASE;
            default:
              return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
          }
        }
        return arr;
      }
      function trim2(v) {
        var i2 = v.length;
        while (v[--i2] === 0) ;
        v.length = i2 + 1;
      }
      function createArray(length) {
        var x = new Array(length);
        var i2 = -1;
        while (++i2 < length) {
          x[i2] = 0;
        }
        return x;
      }
      function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
      }
      function add(a, b) {
        var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
        for (i2 = 0; i2 < l_b; i2++) {
          sum = a[i2] + b[i2] + carry;
          carry = sum >= base ? 1 : 0;
          r[i2] = sum - carry * base;
        }
        while (i2 < l_a) {
          sum = a[i2] + carry;
          carry = sum === base ? 1 : 0;
          r[i2++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
      }
      function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
      }
      function addSmall(a, carry) {
        var l = a.length, r = new Array(l), base = BASE, sum, i2;
        for (i2 = 0; i2 < l; i2++) {
          sum = a[i2] - base + carry;
          carry = Math.floor(sum / base);
          r[i2] = sum - carry * base;
          carry += 1;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      BigInteger2.prototype.add = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
          return new BigInteger2(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger2(addAny(a, b), this.sign);
      };
      BigInteger2.prototype.plus = BigInteger2.prototype.add;
      SmallInteger.prototype.add = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          if (isPrecise(a + b)) return new SmallInteger(a + b);
          b = smallToArray(Math.abs(b));
        }
        return new BigInteger2(addSmall(b, Math.abs(a)), a < 0);
      };
      SmallInteger.prototype.plus = SmallInteger.prototype.add;
      NativeBigInt.prototype.add = function(v) {
        return new NativeBigInt(this.value + parseValue(v).value);
      };
      NativeBigInt.prototype.plus = NativeBigInt.prototype.add;
      function subtract(a, b) {
        var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
        for (i2 = 0; i2 < b_l; i2++) {
          difference = a[i2] - borrow - b[i2];
          if (difference < 0) {
            difference += base;
            borrow = 1;
          } else borrow = 0;
          r[i2] = difference;
        }
        for (i2 = b_l; i2 < a_l; i2++) {
          difference = a[i2] - borrow;
          if (difference < 0) difference += base;
          else {
            r[i2++] = difference;
            break;
          }
          r[i2] = difference;
        }
        for (; i2 < a_l; i2++) {
          r[i2] = a[i2];
        }
        trim2(r);
        return r;
      }
      function subtractAny(a, b, sign2) {
        var value;
        if (compareAbs(a, b) >= 0) {
          value = subtract(a, b);
        } else {
          value = subtract(b, a);
          sign2 = !sign2;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
          if (sign2) value = -value;
          return new SmallInteger(value);
        }
        return new BigInteger2(value, sign2);
      }
      function subtractSmall(a, b, sign2) {
        var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference;
        for (i2 = 0; i2 < l; i2++) {
          difference = a[i2] + carry;
          carry = Math.floor(difference / base);
          difference %= base;
          r[i2] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
          if (sign2) r = -r;
          return new SmallInteger(r);
        }
        return new BigInteger2(r, sign2);
      }
      BigInteger2.prototype.subtract = function(v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
          return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
          return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
      };
      BigInteger2.prototype.minus = BigInteger2.prototype.subtract;
      SmallInteger.prototype.subtract = function(v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
          return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
          return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
      };
      SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
      NativeBigInt.prototype.subtract = function(v) {
        return new NativeBigInt(this.value - parseValue(v).value);
      };
      NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;
      BigInteger2.prototype.negate = function() {
        return new BigInteger2(this.value, !this.sign);
      };
      SmallInteger.prototype.negate = function() {
        var sign2 = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign2;
        return small;
      };
      NativeBigInt.prototype.negate = function() {
        return new NativeBigInt(-this.value);
      };
      BigInteger2.prototype.abs = function() {
        return new BigInteger2(this.value, false);
      };
      SmallInteger.prototype.abs = function() {
        return new SmallInteger(Math.abs(this.value));
      };
      NativeBigInt.prototype.abs = function() {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
      };
      function multiplyLong(a, b) {
        var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
        for (i2 = 0; i2 < a_l; ++i2) {
          a_i = a[i2];
          for (var j = 0; j < b_l; ++j) {
            b_j = b[j];
            product = a_i * b_j + r[i2 + j];
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
            r[i2 + j + 1] += carry;
          }
        }
        trim2(r);
        return r;
      }
      function multiplySmall(a, b) {
        var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i2;
        for (i2 = 0; i2 < l; i2++) {
          product = a[i2] * b + carry;
          carry = Math.floor(product / base);
          r[i2] = product - carry * base;
        }
        while (carry > 0) {
          r[i2++] = carry % base;
          carry = Math.floor(carry / base);
        }
        return r;
      }
      function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
      }
      function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);
        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);
        var b = x.slice(n), a = x.slice(0, n), d = y.slice(n), c = y.slice(0, n);
        var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim2(product);
        return product;
      }
      function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
      }
      BigInteger2.prototype.multiply = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, sign2 = this.sign !== n.sign, abs2;
        if (n.isSmall) {
          if (b === 0) return Integer[0];
          if (b === 1) return this;
          if (b === -1) return this.negate();
          abs2 = Math.abs(b);
          if (abs2 < BASE) {
            return new BigInteger2(multiplySmall(a, abs2), sign2);
          }
          b = smallToArray(abs2);
        }
        if (useKaratsuba(a.length, b.length))
          return new BigInteger2(multiplyKaratsuba(a, b), sign2);
        return new BigInteger2(multiplyLong(a, b), sign2);
      };
      BigInteger2.prototype.times = BigInteger2.prototype.multiply;
      function multiplySmallAndArray(a, b, sign2) {
        if (a < BASE) {
          return new BigInteger2(multiplySmall(b, a), sign2);
        }
        return new BigInteger2(multiplyLong(b, smallToArray(a)), sign2);
      }
      SmallInteger.prototype._multiplyBySmall = function(a) {
        if (isPrecise(a.value * this.value)) {
          return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
      };
      BigInteger2.prototype._multiplyBySmall = function(a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
      };
      SmallInteger.prototype.multiply = function(v) {
        return parseValue(v)._multiplyBySmall(this);
      };
      SmallInteger.prototype.times = SmallInteger.prototype.multiply;
      NativeBigInt.prototype.multiply = function(v) {
        return new NativeBigInt(this.value * parseValue(v).value);
      };
      NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;
      function square(a) {
        var l = a.length, r = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
        for (i2 = 0; i2 < l; i2++) {
          a_i = a[i2];
          carry = 0 - a_i * a_i;
          for (var j = i2; j < l; j++) {
            a_j = a[j];
            product = 2 * (a_i * a_j) + r[i2 + j] + carry;
            carry = Math.floor(product / base);
            r[i2 + j] = product - carry * base;
          }
          r[i2 + l] = carry;
        }
        trim2(r);
        return r;
      }
      BigInteger2.prototype.square = function() {
        return new BigInteger2(square(this.value), false);
      };
      SmallInteger.prototype.square = function() {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger2(square(smallToArray(Math.abs(this.value))), false);
      };
      NativeBigInt.prototype.square = function(v) {
        return new NativeBigInt(this.value * this.value);
      };
      function divMod1(a, b) {
        var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
          quotientDigit = base - 1;
          if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
            quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
          }
          carry = 0;
          borrow = 0;
          l = divisor.length;
          for (i2 = 0; i2 < l; i2++) {
            carry += quotientDigit * divisor[i2];
            q = Math.floor(carry / base);
            borrow += remainder[shift + i2] - (carry - q * base);
            carry = q;
            if (borrow < 0) {
              remainder[shift + i2] = borrow + base;
              borrow = -1;
            } else {
              remainder[shift + i2] = borrow;
              borrow = 0;
            }
          }
          while (borrow !== 0) {
            quotientDigit -= 1;
            carry = 0;
            for (i2 = 0; i2 < l; i2++) {
              carry += remainder[shift + i2] - base + divisor[i2];
              if (carry < 0) {
                remainder[shift + i2] = carry + base;
                carry = 0;
              } else {
                remainder[shift + i2] = carry;
                carry = 1;
              }
            }
            borrow += carry;
          }
          result[shift] = quotientDigit;
        }
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
      }
      function divMod2(a, b) {
        var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check;
        while (a_l) {
          part.unshift(a[--a_l]);
          trim2(part);
          if (compareAbs(part, b) < 0) {
            result.push(0);
            continue;
          }
          xlen = part.length;
          highx = part[xlen - 1] * base + part[xlen - 2];
          highy = b[b_l - 1] * base + b[b_l - 2];
          if (xlen > b_l) {
            highx = (highx + 1) * base;
          }
          guess = Math.ceil(highx / highy);
          do {
            check = multiplySmall(b, guess);
            if (compareAbs(check, part) <= 0) break;
            guess--;
          } while (guess);
          result.push(guess);
          part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
      }
      function divModSmall(value, lambda) {
        var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
        remainder = 0;
        for (i2 = length - 1; i2 >= 0; --i2) {
          divisor = remainder * base + value[i2];
          q = truncate(divisor / lambda);
          remainder = divisor - q * lambda;
          quotient[i2] = q | 0;
        }
        return [quotient, remainder | 0];
      }
      function divModAny(self2, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
          return [new NativeBigInt(self2.value / n.value), new NativeBigInt(self2.value % n.value)];
        }
        var a = self2.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self2.isSmall) {
          if (n.isSmall) {
            return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
          }
          return [Integer[0], self2];
        }
        if (n.isSmall) {
          if (b === 1) return [self2, Integer[0]];
          if (b == -1) return [self2.negate(), Integer[0]];
          var abs2 = Math.abs(b);
          if (abs2 < BASE) {
            value = divModSmall(a, abs2);
            quotient = arrayToSmall(value[0]);
            var remainder = value[1];
            if (self2.sign) remainder = -remainder;
            if (typeof quotient === "number") {
              if (self2.sign !== n.sign) quotient = -quotient;
              return [new SmallInteger(quotient), new SmallInteger(remainder)];
            }
            return [new BigInteger2(quotient, self2.sign !== n.sign), new SmallInteger(remainder)];
          }
          b = smallToArray(abs2);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self2];
        if (comparison === 0) return [Integer[self2.sign === n.sign ? 1 : -1], Integer[0]];
        if (a.length + b.length <= 200)
          value = divMod1(a, b);
        else value = divMod2(a, b);
        quotient = value[0];
        var qSign = self2.sign !== n.sign, mod = value[1], mSign = self2.sign;
        if (typeof quotient === "number") {
          if (qSign) quotient = -quotient;
          quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger2(quotient, qSign);
        if (typeof mod === "number") {
          if (mSign) mod = -mod;
          mod = new SmallInteger(mod);
        } else mod = new BigInteger2(mod, mSign);
        return [quotient, mod];
      }
      BigInteger2.prototype.divmod = function(v) {
        var result = divModAny(this, v);
        return {
          quotient: result[0],
          remainder: result[1]
        };
      };
      NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger2.prototype.divmod;
      BigInteger2.prototype.divide = function(v) {
        return divModAny(this, v)[0];
      };
      NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function(v) {
        return new NativeBigInt(this.value / parseValue(v).value);
      };
      SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger2.prototype.over = BigInteger2.prototype.divide;
      BigInteger2.prototype.mod = function(v) {
        return divModAny(this, v)[1];
      };
      NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function(v) {
        return new NativeBigInt(this.value % parseValue(v).value);
      };
      SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger2.prototype.remainder = BigInteger2.prototype.mod;
      BigInteger2.prototype.pow = function(v) {
        var n = parseValue(v), a = this.value, b = n.value, value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
          return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
          if (isPrecise(value = Math.pow(a, b)))
            return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
          if (b & true) {
            y = y.times(x);
            --b;
          }
          if (b === 0) break;
          b /= 2;
          x = x.square();
        }
        return y;
      };
      SmallInteger.prototype.pow = BigInteger2.prototype.pow;
      NativeBigInt.prototype.pow = function(v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
          if ((b & _1) === _1) {
            y = y.times(x);
            --b;
          }
          if (b === _0) break;
          b /= _2;
          x = x.square();
        }
        return y;
      };
      BigInteger2.prototype.modPow = function(exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1], base = this.mod(mod);
        if (exp.isNegative()) {
          exp = exp.multiply(Integer[-1]);
          base = base.modInv(mod);
        }
        while (exp.isPositive()) {
          if (base.isZero()) return Integer[0];
          if (exp.isOdd()) r = r.multiply(base).mod(mod);
          exp = exp.divide(2);
          base = base.square().mod(mod);
        }
        return r;
      };
      NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger2.prototype.modPow;
      function compareAbs(a, b) {
        if (a.length !== b.length) {
          return a.length > b.length ? 1 : -1;
        }
        for (var i2 = a.length - 1; i2 >= 0; i2--) {
          if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
        }
        return 0;
      }
      BigInteger2.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
      };
      SmallInteger.prototype.compareAbs = function(v) {
        var n = parseValue(v), a = Math.abs(this.value), b = n.value;
        if (n.isSmall) {
          b = Math.abs(b);
          return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
      };
      NativeBigInt.prototype.compareAbs = function(v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      BigInteger2.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (this.sign !== n.sign) {
          return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
          return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
      };
      BigInteger2.prototype.compareTo = BigInteger2.prototype.compare;
      SmallInteger.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var n = parseValue(v), a = this.value, b = n.value;
        if (n.isSmall) {
          return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
          return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
      };
      SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
      NativeBigInt.prototype.compare = function(v) {
        if (v === Infinity) {
          return -1;
        }
        if (v === -Infinity) {
          return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
      };
      NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;
      BigInteger2.prototype.equals = function(v) {
        return this.compare(v) === 0;
      };
      NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger2.prototype.eq = BigInteger2.prototype.equals;
      BigInteger2.prototype.notEquals = function(v) {
        return this.compare(v) !== 0;
      };
      NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger2.prototype.neq = BigInteger2.prototype.notEquals;
      BigInteger2.prototype.greater = function(v) {
        return this.compare(v) > 0;
      };
      NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger2.prototype.gt = BigInteger2.prototype.greater;
      BigInteger2.prototype.lesser = function(v) {
        return this.compare(v) < 0;
      };
      NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger2.prototype.lt = BigInteger2.prototype.lesser;
      BigInteger2.prototype.greaterOrEquals = function(v) {
        return this.compare(v) >= 0;
      };
      NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger2.prototype.geq = BigInteger2.prototype.greaterOrEquals;
      BigInteger2.prototype.lesserOrEquals = function(v) {
        return this.compare(v) <= 0;
      };
      NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger2.prototype.leq = BigInteger2.prototype.lesserOrEquals;
      BigInteger2.prototype.isEven = function() {
        return (this.value[0] & 1) === 0;
      };
      SmallInteger.prototype.isEven = function() {
        return (this.value & 1) === 0;
      };
      NativeBigInt.prototype.isEven = function() {
        return (this.value & BigInt(1)) === BigInt(0);
      };
      BigInteger2.prototype.isOdd = function() {
        return (this.value[0] & 1) === 1;
      };
      SmallInteger.prototype.isOdd = function() {
        return (this.value & 1) === 1;
      };
      NativeBigInt.prototype.isOdd = function() {
        return (this.value & BigInt(1)) === BigInt(1);
      };
      BigInteger2.prototype.isPositive = function() {
        return !this.sign;
      };
      SmallInteger.prototype.isPositive = function() {
        return this.value > 0;
      };
      NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;
      BigInteger2.prototype.isNegative = function() {
        return this.sign;
      };
      SmallInteger.prototype.isNegative = function() {
        return this.value < 0;
      };
      NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;
      BigInteger2.prototype.isUnit = function() {
        return false;
      };
      SmallInteger.prototype.isUnit = function() {
        return Math.abs(this.value) === 1;
      };
      NativeBigInt.prototype.isUnit = function() {
        return this.abs().value === BigInt(1);
      };
      BigInteger2.prototype.isZero = function() {
        return false;
      };
      SmallInteger.prototype.isZero = function() {
        return this.value === 0;
      };
      NativeBigInt.prototype.isZero = function() {
        return this.value === BigInt(0);
      };
      BigInteger2.prototype.isDivisibleBy = function(v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
      };
      NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger2.prototype.isDivisibleBy;
      function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
      }
      function millerRabinTest(n, a) {
        var nPrev = n.prev(), b = nPrev, r = 0, d, i2, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i2 = 0; i2 < a.length; i2++) {
          if (n.lesser(a[i2])) continue;
          x = bigInt(a[i2]).modPow(b, n);
          if (x.isUnit() || x.equals(nPrev)) continue;
          for (d = r - 1; d != 0; d--) {
            x = x.square().mod(n);
            if (x.isUnit()) return false;
            if (x.equals(nPrev)) continue next;
          }
          return false;
        }
        return true;
      }
      BigInteger2.prototype.isPrime = function(strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
          return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt(i2 + 2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger2.prototype.isPrime;
      BigInteger2.prototype.isProbablePrime = function(iterations, rng2) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var t = iterations === undefined$1 ? 5 : iterations;
        for (var a = [], i2 = 0; i2 < t; i2++) {
          a.push(bigInt.randBetween(2, n.minus(2), rng2));
        }
        return millerRabinTest(n, a);
      };
      NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger2.prototype.isProbablePrime;
      BigInteger2.prototype.modInv = function(n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
          q = r.divide(newR);
          lastT = t;
          lastR = r;
          t = newT;
          r = newR;
          newT = lastT.subtract(q.multiply(newT));
          newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
          t = t.add(n);
        }
        if (this.isNegative()) {
          return t.negate();
        }
        return t;
      };
      NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger2.prototype.modInv;
      BigInteger2.prototype.next = function() {
        var value = this.value;
        if (this.sign) {
          return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger2(addSmall(value, 1), this.sign);
      };
      SmallInteger.prototype.next = function() {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger2(MAX_INT_ARR, false);
      };
      NativeBigInt.prototype.next = function() {
        return new NativeBigInt(this.value + BigInt(1));
      };
      BigInteger2.prototype.prev = function() {
        var value = this.value;
        if (this.sign) {
          return new BigInteger2(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
      };
      SmallInteger.prototype.prev = function() {
        var value = this.value;
        if (value - 1 > -9007199254740992) return new SmallInteger(value - 1);
        return new BigInteger2(MAX_INT_ARR, true);
      };
      NativeBigInt.prototype.prev = function() {
        return new NativeBigInt(this.value - BigInt(1));
      };
      var powersOfTwo = [1];
      while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
      var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
      function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
      }
      BigInteger2.prototype.shiftLeft = function(v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
          result = result.multiply(highestPower2);
          n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
      };
      NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger2.prototype.shiftLeft;
      BigInteger2.prototype.shiftRight = function(v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
          throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
          if (result.isZero() || result.isNegative() && result.isUnit()) return result;
          remQuo = divModAny(result, highestPower2);
          result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
      };
      NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger2.prototype.shiftRight;
      function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
          xDivMod = divModAny(xRem, highestPower2);
          xDigit = xDivMod[1].toJSNumber();
          if (xSign) {
            xDigit = highestPower2 - 1 - xDigit;
          }
          yDivMod = divModAny(yRem, highestPower2);
          yDigit = yDivMod[1].toJSNumber();
          if (ySign) {
            yDigit = highestPower2 - 1 - yDigit;
          }
          xRem = xDivMod[0];
          yRem = yDivMod[0];
          result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
          sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
        }
        return sum;
      }
      BigInteger2.prototype.not = function() {
        return this.negate().prev();
      };
      NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger2.prototype.not;
      BigInteger2.prototype.and = function(n) {
        return bitwise(this, n, function(a, b) {
          return a & b;
        });
      };
      NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger2.prototype.and;
      BigInteger2.prototype.or = function(n) {
        return bitwise(this, n, function(a, b) {
          return a | b;
        });
      };
      NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger2.prototype.or;
      BigInteger2.prototype.xor = function(n) {
        return bitwise(this, n, function(a, b) {
          return a ^ b;
        });
      };
      NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger2.prototype.xor;
      var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -1e7) * (BASE & -1e7) | LOBMASK_I;
      function roughLOB(n) {
        var v = n.value, x = typeof v === "number" ? v | LOBMASK_I : typeof v === "bigint" ? v | BigInt(LOBMASK_I) : v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
      }
      function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
          var tmp2 = integerLogarithm(value, base.square(base));
          var p = tmp2.p;
          var e = tmp2.e;
          var t = p.multiply(base);
          return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
      }
      BigInteger2.prototype.bitLength = function() {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
          n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
          return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
      };
      NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger2.prototype.bitLength;
      function max2(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
      }
      function min2(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
      }
      function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
          d = min2(roughLOB(a), roughLOB(b));
          a = a.divide(d);
          b = b.divide(d);
          c = c.multiply(d);
        }
        while (a.isEven()) {
          a = a.divide(roughLOB(a));
        }
        do {
          while (b.isEven()) {
            b = b.divide(roughLOB(b));
          }
          if (a.greater(b)) {
            t = b;
            b = a;
            a = t;
          }
          b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
      }
      function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
      }
      function randBetween(a, b, rng2) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng2 || Math.random;
        var low = min2(a, b), high = max2(a, b);
        var range2 = high.subtract(low).add(1);
        if (range2.isSmall) return low.add(Math.floor(usedRNG() * range2));
        var digits = toBase(range2, BASE).value;
        var result = [], restricted = true;
        for (var i2 = 0; i2 < digits.length; i2++) {
          var top = restricted ? digits[i2] + (i2 + 1 < digits.length ? digits[i2 + 1] / BASE : 0) : BASE;
          var digit = truncate(usedRNG() * top);
          result.push(digit);
          if (digit < digits[i2]) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
      }
      var parseBase = function(text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
          text = text.toLowerCase();
          alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i2;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i2 = 0; i2 < alphabet.length; i2++) {
          alphabetValues[alphabet[i2]] = i2;
        }
        for (i2 = 0; i2 < length; i2++) {
          var c = text[i2];
          if (c === "-") continue;
          if (c in alphabetValues) {
            if (alphabetValues[c] >= absBase) {
              if (c === "1" && absBase === 1) continue;
              throw new Error(c + " is not a valid digit in base " + base + ".");
            }
          }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
          var c = text[i2];
          if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
          else if (c === "<") {
            var start = i2;
            do {
              i2++;
            } while (text[i2] !== ">" && i2 < text.length);
            digits.push(parseValue(text.slice(start + 1, i2)));
          } else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
      };
      function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow2 = Integer[1], i2;
        for (i2 = digits.length - 1; i2 >= 0; i2--) {
          val = val.add(digits[i2].times(pow2));
          pow2 = pow2.times(base);
        }
        return isNegative ? val.negate() : val;
      }
      function stringify2(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
          return alphabet[digit];
        }
        return "<" + digit + ">";
      }
      function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
          if (n.isZero()) return { value: [0], isNegative: false };
          if (n.isNegative())
            return {
              value: [].concat.apply(
                [],
                Array.apply(null, Array(-n.toJSNumber())).map(Array.prototype.valueOf, [1, 0])
              ),
              isNegative: false
            };
          var arr = Array.apply(null, Array(n.toJSNumber() - 1)).map(Array.prototype.valueOf, [0, 1]);
          arr.unshift([1]);
          return {
            value: [].concat.apply([], arr),
            isNegative: false
          };
        }
        var neg = false;
        if (n.isNegative() && base.isPositive()) {
          neg = true;
          n = n.abs();
        }
        if (base.isUnit()) {
          if (n.isZero()) return { value: [0], isNegative: false };
          return {
            value: Array.apply(null, Array(n.toJSNumber())).map(Number.prototype.valueOf, 1),
            isNegative: neg
          };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
          divmod = left.divmod(base);
          left = divmod.quotient;
          var digit = divmod.remainder;
          if (digit.isNegative()) {
            digit = base.minus(digit).abs();
            left = left.next();
          }
          out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
      }
      function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function(x) {
          return stringify2(x, alphabet);
        }).join("");
      }
      BigInteger2.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      SmallInteger.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      NativeBigInt.prototype.toArray = function(radix) {
        return toBase(this, radix);
      };
      BigInteger2.prototype.toString = function(radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix !== 10 || alphabet) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
          digit = String(v[l]);
          str += zeros.slice(digit.length) + digit;
        }
        var sign2 = this.sign ? "-" : "";
        return sign2 + str;
      };
      SmallInteger.prototype.toString = function(radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix != 10 || alphabet) return toBaseString(this, radix, alphabet);
        return String(this.value);
      };
      NativeBigInt.prototype.toString = SmallInteger.prototype.toString;
      NativeBigInt.prototype.toJSON = BigInteger2.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
        return this.toString();
      };
      BigInteger2.prototype.valueOf = function() {
        return parseInt(this.toString(), 10);
      };
      BigInteger2.prototype.toJSNumber = BigInteger2.prototype.valueOf;
      SmallInteger.prototype.valueOf = function() {
        return this.value;
      };
      SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
      NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function() {
        return parseInt(this.toString(), 10);
      };
      function parseStringValue(v) {
        if (isPrecise(+v)) {
          var x = +v;
          if (x === truncate(x))
            return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
          throw new Error("Invalid integer: " + v);
        }
        var sign2 = v[0] === "-";
        if (sign2) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
          var exp = split[1];
          if (exp[0] === "+") exp = exp.slice(1);
          exp = +exp;
          if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
          var text = split[0];
          var decimalPlace = text.indexOf(".");
          if (decimalPlace >= 0) {
            exp -= text.length - decimalPlace - 1;
            text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
          }
          if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
          text += new Array(exp + 1).join("0");
          v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(sign2 ? "-" + v : v));
        }
        var r = [], max3 = v.length, l = LOG_BASE, min3 = max3 - l;
        while (max3 > 0) {
          r.push(+v.slice(min3, max3));
          min3 -= l;
          if (min3 < 0) min3 = 0;
          max3 -= l;
        }
        trim2(r);
        return new BigInteger2(r, sign2);
      }
      function parseNumberValue(v) {
        if (supportsNativeBigInt) {
          return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
          if (v !== truncate(v)) throw new Error(v + " is not an integer.");
          return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
      }
      function parseValue(v) {
        if (typeof v === "number") {
          return parseNumberValue(v);
        }
        if (typeof v === "string") {
          return parseStringValue(v);
        }
        if (typeof v === "bigint") {
          return new NativeBigInt(v);
        }
        return v;
      }
      for (var i = 0; i < 1e3; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
      }
      Integer.one = Integer[1];
      Integer.zero = Integer[0];
      Integer.minusOne = Integer[-1];
      Integer.max = max2;
      Integer.min = min2;
      Integer.gcd = gcd;
      Integer.lcm = lcm;
      Integer.isInstance = function(x) {
        return x instanceof BigInteger2 || x instanceof SmallInteger || x instanceof NativeBigInt;
      };
      Integer.randBetween = randBetween;
      Integer.fromArray = function(digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
      };
      return Integer;
    }();
    if (module.hasOwnProperty("exports")) {
      module.exports = bigInt;
    }
  })(BigInteger);
  return BigInteger.exports;
}
var Decrypt_1;
var hasRequiredDecrypt;
function requireDecrypt() {
  if (hasRequiredDecrypt) return Decrypt_1;
  hasRequiredDecrypt = 1;
  var bigInt = requireBigInteger();
  var Stream = require$$0$1;
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  var table2;
  function generateTable() {
    var poly = 3988292384, c, n, k;
    table2 = [];
    for (n = 0; n < 256; n++) {
      c = n;
      for (k = 0; k < 8; k++)
        c = c & 1 ? poly ^ c >>> 1 : c = c >>> 1;
      table2[n] = c >>> 0;
    }
  }
  function crc(ch, crc2) {
    if (!table2)
      generateTable();
    if (ch.charCodeAt)
      ch = ch.charCodeAt(0);
    return bigInt(crc2).shiftRight(8).and(16777215).xor(table2[bigInt(crc2).xor(ch).and(255)]).value;
  }
  function Decrypt() {
    if (!(this instanceof Decrypt))
      return new Decrypt();
    this.key0 = 305419896;
    this.key1 = 591751049;
    this.key2 = 878082192;
  }
  Decrypt.prototype.update = function(h) {
    this.key0 = crc(h, this.key0);
    this.key1 = bigInt(this.key0).and(255).and(4294967295).add(this.key1);
    this.key1 = bigInt(this.key1).multiply(134775813).add(1).and(4294967295).value;
    this.key2 = crc(bigInt(this.key1).shiftRight(24).and(255), this.key2);
  };
  Decrypt.prototype.decryptByte = function(c) {
    var k = bigInt(this.key2).or(2);
    c = c ^ bigInt(k).multiply(bigInt(k ^ 1)).shiftRight(8).and(255);
    this.update(c);
    return c;
  };
  Decrypt.prototype.stream = function() {
    var stream2 = Stream.Transform(), self2 = this;
    stream2._transform = function(d, e, cb) {
      for (var i = 0; i < d.length; i++) {
        d[i] = self2.decryptByte(d[i]);
      }
      this.push(d);
      cb();
    };
    return stream2;
  };
  Decrypt_1 = Decrypt;
  return Decrypt_1;
}
var unzip;
var hasRequiredUnzip$1;
function requireUnzip$1() {
  if (hasRequiredUnzip$1) return unzip;
  hasRequiredUnzip$1 = 1;
  var Promise2 = requireBluebird();
  var Decrypt = requireDecrypt();
  var PullStream = requirePullStream();
  var Stream = require$$0$1;
  var binary2 = requireBinary();
  var zlib$1 = zlib;
  var parseExtraField2 = requireParseExtraField();
  var Buffer2 = requireBuffer();
  var parseDateTime2 = requireParseDateTime();
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  unzip = function unzip2(source, offset, _password, directoryVars) {
    var file2 = PullStream(), entry = Stream.PassThrough();
    var req = source.stream(offset);
    req.pipe(file2).on("error", function(e) {
      entry.emit("error", e);
    });
    entry.vars = file2.pull(30).then(function(data2) {
      var vars2 = binary2.parse(data2).word32lu("signature").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").vars;
      vars2.lastModifiedDateTime = parseDateTime2(vars2.lastModifiedDate, vars2.lastModifiedTime);
      return file2.pull(vars2.fileNameLength).then(function(fileName) {
        vars2.fileName = fileName.toString("utf8");
        return file2.pull(vars2.extraFieldLength);
      }).then(function(extraField) {
        var checkEncryption;
        vars2.extra = parseExtraField2(extraField, vars2);
        if (directoryVars && directoryVars.compressedSize) vars2 = directoryVars;
        if (vars2.flags & 1) checkEncryption = file2.pull(12).then(function(header) {
          if (!_password)
            throw new Error("MISSING_PASSWORD");
          var decrypt = Decrypt();
          String(_password).split("").forEach(function(d) {
            decrypt.update(d);
          });
          for (var i = 0; i < header.length; i++)
            header[i] = decrypt.decryptByte(header[i]);
          vars2.decrypt = decrypt;
          vars2.compressedSize -= 12;
          var check = vars2.flags & 8 ? vars2.lastModifiedTime >> 8 & 255 : vars2.crc32 >> 24 & 255;
          if (header[11] !== check)
            throw new Error("BAD_PASSWORD");
          return vars2;
        });
        return Promise2.resolve(checkEncryption).then(function() {
          entry.emit("vars", vars2);
          return vars2;
        });
      });
    });
    entry.vars.then(function(vars2) {
      var fileSizeKnown = !(vars2.flags & 8) || vars2.compressedSize > 0, eof;
      var inflater = vars2.compressionMethod ? zlib$1.createInflateRaw() : Stream.PassThrough();
      if (fileSizeKnown) {
        entry.size = vars2.uncompressedSize;
        eof = vars2.compressedSize;
      } else {
        eof = Buffer2.alloc(4);
        eof.writeUInt32LE(134695760, 0);
      }
      var stream2 = file2.stream(eof);
      if (vars2.decrypt)
        stream2 = stream2.pipe(vars2.decrypt.stream());
      stream2.pipe(inflater).on("error", function(err) {
        entry.emit("error", err);
      }).pipe(entry).on("finish", function() {
        if (req.destroy)
          req.destroy();
        else if (req.abort)
          req.abort();
        else if (req.close)
          req.close();
        else if (req.push)
          req.push();
        else
          console.log("warning - unable to close stream");
      });
    }).catch(function(e) {
      entry.emit("error", e);
    });
    return entry;
  };
  return unzip;
}
var directory;
var hasRequiredDirectory;
function requireDirectory() {
  if (hasRequiredDirectory) return directory;
  hasRequiredDirectory = 1;
  var binary2 = requireBinary();
  var PullStream = requirePullStream();
  var unzip2 = requireUnzip$1();
  var Promise2 = requireBluebird();
  var BufferStream2 = requireBufferStream();
  var parseExtraField2 = requireParseExtraField();
  var Buffer2 = requireBuffer();
  var path2 = require$$1;
  var Writer = requireFstream().Writer;
  var parseDateTime2 = requireParseDateTime();
  var signature2 = Buffer2.alloc(4);
  signature2.writeUInt32LE(101010256, 0);
  function getCrxHeader(source) {
    var sourceStream = source.stream(0).pipe(PullStream());
    return sourceStream.pull(4).then(function(data2) {
      var signature3 = data2.readUInt32LE(0);
      if (signature3 === 875721283) {
        var crxHeader;
        return sourceStream.pull(12).then(function(data3) {
          crxHeader = binary2.parse(data3).word32lu("version").word32lu("pubKeyLength").word32lu("signatureLength").vars;
        }).then(function() {
          return sourceStream.pull(crxHeader.pubKeyLength + crxHeader.signatureLength);
        }).then(function(data3) {
          crxHeader.publicKey = data3.slice(0, crxHeader.pubKeyLength);
          crxHeader.signature = data3.slice(crxHeader.pubKeyLength);
          crxHeader.size = 16 + crxHeader.pubKeyLength + crxHeader.signatureLength;
          return crxHeader;
        });
      }
    });
  }
  function getZip64CentralDirectory(source, zip64CDL) {
    var d64loc = binary2.parse(zip64CDL).word32lu("signature").word32lu("diskNumber").word64lu("offsetToStartOfCentralDirectory").word32lu("numberOfDisks").vars;
    if (d64loc.signature != 117853008) {
      throw new Error("invalid zip64 end of central dir locator signature (0x07064b50): 0x" + d64loc.signature.toString(16));
    }
    var dir64 = PullStream();
    source.stream(d64loc.offsetToStartOfCentralDirectory).pipe(dir64);
    return dir64.pull(56);
  }
  function parseZip64DirRecord(dir64record) {
    var vars2 = binary2.parse(dir64record).word32lu("signature").word64lu("sizeOfCentralDirectory").word16lu("version").word16lu("versionsNeededToExtract").word32lu("diskNumber").word32lu("diskStart").word64lu("numberOfRecordsOnDisk").word64lu("numberOfRecords").word64lu("sizeOfCentralDirectory").word64lu("offsetToStartOfCentralDirectory").vars;
    if (vars2.signature != 101075792) {
      throw new Error("invalid zip64 end of central dir locator signature (0x06064b50): 0x0" + vars2.signature.toString(16));
    }
    return vars2;
  }
  directory = function centralDirectory(source, options) {
    var endDir = PullStream(), records = PullStream(), tailSize = options && options.tailSize || 80, sourceSize, crxHeader, startOffset, vars2;
    if (options && options.crx)
      crxHeader = getCrxHeader(source);
    return source.size().then(function(size) {
      sourceSize = size;
      source.stream(Math.max(0, size - tailSize)).on("error", function(error2) {
        endDir.emit("error", error2);
      }).pipe(endDir);
      return endDir.pull(signature2);
    }).then(function() {
      return Promise2.props({ directory: endDir.pull(22), crxHeader });
    }).then(function(d) {
      var data2 = d.directory;
      startOffset = d.crxHeader && d.crxHeader.size || 0;
      vars2 = binary2.parse(data2).word32lu("signature").word16lu("diskNumber").word16lu("diskStart").word16lu("numberOfRecordsOnDisk").word16lu("numberOfRecords").word32lu("sizeOfCentralDirectory").word32lu("offsetToStartOfCentralDirectory").word16lu("commentLength").vars;
      if (vars2.numberOfRecords == 65535 || vars2.numberOfRecords == 65535 || vars2.offsetToStartOfCentralDirectory == 4294967295) {
        const zip64CDLSize = 20;
        const zip64CDLOffset = sourceSize - (tailSize - endDir.match + zip64CDLSize);
        const zip64CDLStream = PullStream();
        source.stream(zip64CDLOffset).pipe(zip64CDLStream);
        return zip64CDLStream.pull(zip64CDLSize).then(function(d2) {
          return getZip64CentralDirectory(source, d2);
        }).then(function(dir64record) {
          vars2 = parseZip64DirRecord(dir64record);
        });
      } else {
        vars2.offsetToStartOfCentralDirectory += startOffset;
      }
    }).then(function() {
      if (vars2.commentLength) return endDir.pull(vars2.commentLength).then(function(comment) {
        vars2.comment = comment.toString("utf8");
      });
    }).then(function() {
      source.stream(vars2.offsetToStartOfCentralDirectory).pipe(records);
      vars2.extract = function(opts) {
        if (!opts || !opts.path) throw new Error("PATH_MISSING");
        opts.path = path2.resolve(path2.normalize(opts.path));
        return vars2.files.then(function(files) {
          return Promise2.map(files, function(entry) {
            if (entry.type == "Directory") return;
            var extractPath = path2.join(opts.path, entry.path);
            if (extractPath.indexOf(opts.path) != 0) {
              return;
            }
            var writer2 = opts.getWriter ? opts.getWriter({ path: extractPath }) : Writer({ path: extractPath });
            return new Promise2(function(resolve, reject2) {
              entry.stream(opts.password).on("error", reject2).pipe(writer2).on("close", resolve).on("error", reject2);
            });
          }, { concurrency: opts.concurrency > 1 ? opts.concurrency : 1 });
        });
      };
      vars2.files = Promise2.mapSeries(Array(vars2.numberOfRecords), function() {
        return records.pull(46).then(function(data2) {
          var vars3 = binary2.parse(data2).word32lu("signature").word16lu("versionMadeBy").word16lu("versionsNeededToExtract").word16lu("flags").word16lu("compressionMethod").word16lu("lastModifiedTime").word16lu("lastModifiedDate").word32lu("crc32").word32lu("compressedSize").word32lu("uncompressedSize").word16lu("fileNameLength").word16lu("extraFieldLength").word16lu("fileCommentLength").word16lu("diskNumber").word16lu("internalFileAttributes").word32lu("externalFileAttributes").word32lu("offsetToLocalFileHeader").vars;
          vars3.offsetToLocalFileHeader += startOffset;
          vars3.lastModifiedDateTime = parseDateTime2(vars3.lastModifiedDate, vars3.lastModifiedTime);
          return records.pull(vars3.fileNameLength).then(function(fileNameBuffer) {
            vars3.pathBuffer = fileNameBuffer;
            vars3.path = fileNameBuffer.toString("utf8");
            vars3.isUnicode = (vars3.flags & 2048) != 0;
            return records.pull(vars3.extraFieldLength);
          }).then(function(extraField) {
            vars3.extra = parseExtraField2(extraField, vars3);
            return records.pull(vars3.fileCommentLength);
          }).then(function(comment) {
            vars3.comment = comment;
            vars3.type = vars3.uncompressedSize === 0 && /[\/\\]$/.test(vars3.path) ? "Directory" : "File";
            vars3.stream = function(_password) {
              return unzip2(source, vars3.offsetToLocalFileHeader, _password, vars3);
            };
            vars3.buffer = function(_password) {
              return BufferStream2(vars3.stream(_password));
            };
            return vars3;
          });
        });
      });
      return Promise2.props(vars2);
    });
  };
  return directory;
}
var Open;
var hasRequiredOpen;
function requireOpen() {
  if (hasRequiredOpen) return Open;
  hasRequiredOpen = 1;
  var fs2 = requireGracefulFs();
  var Promise2 = requireBluebird();
  var directory2 = requireDirectory();
  var Stream = require$$0$1;
  if (!Stream.Writable || !Stream.Writable.prototype.destroy)
    Stream = requireReadable$1();
  Open = {
    buffer: function(buffer, options) {
      var source = {
        stream: function(offset, length) {
          var stream2 = Stream.PassThrough();
          stream2.end(buffer.slice(offset, length));
          return stream2;
        },
        size: function() {
          return Promise2.resolve(buffer.length);
        }
      };
      return directory2(source, options);
    },
    file: function(filename, options) {
      var source = {
        stream: function(offset, length) {
          return fs2.createReadStream(filename, { start: offset, end: length && offset + length });
        },
        size: function() {
          return new Promise2(function(resolve, reject2) {
            fs2.stat(filename, function(err, d) {
              if (err)
                reject2(err);
              else
                resolve(d.size);
            });
          });
        }
      };
      return directory2(source, options);
    },
    url: function(request, params, options) {
      if (typeof params === "string")
        params = { url: params };
      if (!params.url)
        throw "URL missing";
      params.headers = params.headers || {};
      var source = {
        stream: function(offset, length) {
          var options2 = Object.create(params);
          options2.headers = Object.create(params.headers);
          options2.headers.range = "bytes=" + offset + "-" + (length ? length : "");
          return request(options2);
        },
        size: function() {
          return new Promise2(function(resolve, reject2) {
            var req = request(params);
            req.on("response", function(d) {
              req.abort();
              if (!d.headers["content-length"])
                reject2(new Error("Missing content length header"));
              else
                resolve(d.headers["content-length"]);
            }).on("error", reject2);
          });
        }
      };
      return directory2(source, options);
    },
    s3: function(client, params, options) {
      var source = {
        size: function() {
          return new Promise2(function(resolve, reject2) {
            client.headObject(params, function(err, d) {
              if (err)
                reject2(err);
              else
                resolve(d.ContentLength);
            });
          });
        },
        stream: function(offset, length) {
          var d = {};
          for (var key in params)
            d[key] = params[key];
          d.Range = "bytes=" + offset + "-" + (length ? length : "");
          return client.getObject(d).createReadStream();
        }
      };
      return directory2(source, options);
    },
    custom: function(source, options) {
      return directory2(source, options);
    }
  };
  return Open;
}
var hasRequiredUnzip;
function requireUnzip() {
  if (hasRequiredUnzip) return unzip$1;
  hasRequiredUnzip = 1;
  requireListenercount();
  requireBufferIndexofPolyfill();
  requireSetImmediate();
  unzip$1.Parse = requireParse();
  unzip$1.ParseOne = requireParseOne();
  unzip$1.Extract = requireExtract();
  unzip$1.Open = requireOpen();
  return unzip$1;
}
var tmp = { exports: {} };
/*!
 * Tmp
 *
 * Copyright (c) 2011-2017 KARASZI Istvan <github@spam.raszi.hu>
 *
 * MIT Licensed
 */
var hasRequiredTmp;
function requireTmp() {
  if (hasRequiredTmp) return tmp.exports;
  hasRequiredTmp = 1;
  (function(module) {
    const fs2 = require$$0$4;
    const os = require$$0$6;
    const path2 = require$$1;
    const crypto = require$$0$5;
    const _c = { fs: fs2.constants, os: os.constants };
    const RANDOM_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", TEMPLATE_PATTERN = /XXXXXX/, DEFAULT_TRIES = 3, CREATE_FLAGS = (_c.O_CREAT || _c.fs.O_CREAT) | (_c.O_EXCL || _c.fs.O_EXCL) | (_c.O_RDWR || _c.fs.O_RDWR), IS_WIN32 = os.platform() === "win32", EBADF = _c.EBADF || _c.os.errno.EBADF, ENOENT = _c.ENOENT || _c.os.errno.ENOENT, DIR_MODE = 448, FILE_MODE = 384, EXIT = "exit", _removeObjects = [], FN_RMDIR_SYNC = fs2.rmdirSync.bind(fs2);
    let _gracefulCleanup = false;
    function rimraf(dirPath, callback) {
      return fs2.rm(dirPath, { recursive: true }, callback);
    }
    function FN_RIMRAF_SYNC(dirPath) {
      return fs2.rmSync(dirPath, { recursive: true });
    }
    function tmpName(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      try {
        _assertAndSanitizeOptions(opts);
      } catch (err) {
        return cb(err);
      }
      let tries = opts.tries;
      (function _getUniqueName() {
        try {
          const name = _generateTmpName(opts);
          fs2.stat(name, function(err) {
            if (!err) {
              if (tries-- > 0) return _getUniqueName();
              return cb(new Error("Could not get a unique tmp filename, max tries reached " + name));
            }
            cb(null, name);
          });
        } catch (err) {
          cb(err);
        }
      })();
    }
    function tmpNameSync(options) {
      const args = _parseArguments(options), opts = args[0];
      _assertAndSanitizeOptions(opts);
      let tries = opts.tries;
      do {
        const name = _generateTmpName(opts);
        try {
          fs2.statSync(name);
        } catch (e) {
          return name;
        }
      } while (tries-- > 0);
      throw new Error("Could not get a unique tmp filename, max tries reached");
    }
    function file2(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err) return cb(err);
        fs2.open(name, CREATE_FLAGS, opts.mode || FILE_MODE, function _fileCreated(err2, fd) {
          if (err2) return cb(err2);
          if (opts.discardDescriptor) {
            return fs2.close(fd, function _discardCallback(possibleErr) {
              return cb(possibleErr, name, void 0, _prepareTmpFileRemoveCallback(name, -1, opts, false));
            });
          } else {
            const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
            cb(null, name, fd, _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, false));
          }
        });
      });
    }
    function fileSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const discardOrDetachDescriptor = opts.discardDescriptor || opts.detachDescriptor;
      const name = tmpNameSync(opts);
      var fd = fs2.openSync(name, CREATE_FLAGS, opts.mode || FILE_MODE);
      if (opts.discardDescriptor) {
        fs2.closeSync(fd);
        fd = void 0;
      }
      return {
        name,
        fd,
        removeCallback: _prepareTmpFileRemoveCallback(name, discardOrDetachDescriptor ? -1 : fd, opts, true)
      };
    }
    function dir2(options, callback) {
      const args = _parseArguments(options, callback), opts = args[0], cb = args[1];
      tmpName(opts, function _tmpNameCreated(err, name) {
        if (err) return cb(err);
        fs2.mkdir(name, opts.mode || DIR_MODE, function _dirCreated(err2) {
          if (err2) return cb(err2);
          cb(null, name, _prepareTmpDirRemoveCallback(name, opts, false));
        });
      });
    }
    function dirSync(options) {
      const args = _parseArguments(options), opts = args[0];
      const name = tmpNameSync(opts);
      fs2.mkdirSync(name, opts.mode || DIR_MODE);
      return {
        name,
        removeCallback: _prepareTmpDirRemoveCallback(name, opts, true)
      };
    }
    function _removeFileAsync(fdPath, next) {
      const _handler = function(err) {
        if (err && !_isENOENT(err)) {
          return next(err);
        }
        next();
      };
      if (0 <= fdPath[0])
        fs2.close(fdPath[0], function() {
          fs2.unlink(fdPath[1], _handler);
        });
      else fs2.unlink(fdPath[1], _handler);
    }
    function _removeFileSync(fdPath) {
      let rethrownException = null;
      try {
        if (0 <= fdPath[0]) fs2.closeSync(fdPath[0]);
      } catch (e) {
        if (!_isEBADF(e) && !_isENOENT(e)) throw e;
      } finally {
        try {
          fs2.unlinkSync(fdPath[1]);
        } catch (e) {
          if (!_isENOENT(e)) rethrownException = e;
        }
      }
      if (rethrownException !== null) {
        throw rethrownException;
      }
    }
    function _prepareTmpFileRemoveCallback(name, fd, opts, sync2) {
      const removeCallbackSync = _prepareRemoveCallback(_removeFileSync, [fd, name], sync2);
      const removeCallback = _prepareRemoveCallback(_removeFileAsync, [fd, name], sync2, removeCallbackSync);
      if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
      return sync2 ? removeCallbackSync : removeCallback;
    }
    function _prepareTmpDirRemoveCallback(name, opts, sync2) {
      const removeFunction = opts.unsafeCleanup ? rimraf : fs2.rmdir.bind(fs2);
      const removeFunctionSync = opts.unsafeCleanup ? FN_RIMRAF_SYNC : FN_RMDIR_SYNC;
      const removeCallbackSync = _prepareRemoveCallback(removeFunctionSync, name, sync2);
      const removeCallback = _prepareRemoveCallback(removeFunction, name, sync2, removeCallbackSync);
      if (!opts.keep) _removeObjects.unshift(removeCallbackSync);
      return sync2 ? removeCallbackSync : removeCallback;
    }
    function _prepareRemoveCallback(removeFunction, fileOrDirName, sync2, cleanupCallbackSync) {
      let called = false;
      return function _cleanupCallback(next) {
        if (!called) {
          const toRemove = cleanupCallbackSync || _cleanupCallback;
          const index2 = _removeObjects.indexOf(toRemove);
          if (index2 >= 0) _removeObjects.splice(index2, 1);
          called = true;
          if (sync2 || removeFunction === FN_RMDIR_SYNC || removeFunction === FN_RIMRAF_SYNC) {
            return removeFunction(fileOrDirName);
          } else {
            return removeFunction(fileOrDirName, next || function() {
            });
          }
        }
      };
    }
    function _garbageCollector() {
      if (!_gracefulCleanup) return;
      while (_removeObjects.length) {
        try {
          _removeObjects[0]();
        } catch (e) {
        }
      }
    }
    function _randomChars(howMany) {
      let value = [], rnd = null;
      try {
        rnd = crypto.randomBytes(howMany);
      } catch (e) {
        rnd = crypto.pseudoRandomBytes(howMany);
      }
      for (var i = 0; i < howMany; i++) {
        value.push(RANDOM_CHARS[rnd[i] % RANDOM_CHARS.length]);
      }
      return value.join("");
    }
    function _isBlank(s) {
      return s === null || _isUndefined(s) || !s.trim();
    }
    function _isUndefined(obj) {
      return typeof obj === "undefined";
    }
    function _parseArguments(options, callback) {
      if (typeof options === "function") {
        return [{}, options];
      }
      if (_isUndefined(options)) {
        return [{}, callback];
      }
      const actualOptions = {};
      for (const key of Object.getOwnPropertyNames(options)) {
        actualOptions[key] = options[key];
      }
      return [actualOptions, callback];
    }
    function _generateTmpName(opts) {
      const tmpDir = opts.tmpdir;
      if (!_isUndefined(opts.name))
        return path2.join(tmpDir, opts.dir, opts.name);
      if (!_isUndefined(opts.template))
        return path2.join(tmpDir, opts.dir, opts.template).replace(TEMPLATE_PATTERN, _randomChars(6));
      const name = [
        opts.prefix ? opts.prefix : "tmp",
        "-",
        process.pid,
        "-",
        _randomChars(12),
        opts.postfix ? "-" + opts.postfix : ""
      ].join("");
      return path2.join(tmpDir, opts.dir, name);
    }
    function _assertAndSanitizeOptions(options) {
      options.tmpdir = _getTmpDir(options);
      const tmpDir = options.tmpdir;
      if (!_isUndefined(options.name))
        _assertIsRelative(options.name, "name", tmpDir);
      if (!_isUndefined(options.dir))
        _assertIsRelative(options.dir, "dir", tmpDir);
      if (!_isUndefined(options.template)) {
        _assertIsRelative(options.template, "template", tmpDir);
        if (!options.template.match(TEMPLATE_PATTERN))
          throw new Error(`Invalid template, found "${options.template}".`);
      }
      if (!_isUndefined(options.tries) && isNaN(options.tries) || options.tries < 0)
        throw new Error(`Invalid tries, found "${options.tries}".`);
      options.tries = _isUndefined(options.name) ? options.tries || DEFAULT_TRIES : 1;
      options.keep = !!options.keep;
      options.detachDescriptor = !!options.detachDescriptor;
      options.discardDescriptor = !!options.discardDescriptor;
      options.unsafeCleanup = !!options.unsafeCleanup;
      options.dir = _isUndefined(options.dir) ? "" : path2.relative(tmpDir, _resolvePath(options.dir, tmpDir));
      options.template = _isUndefined(options.template) ? void 0 : path2.relative(tmpDir, _resolvePath(options.template, tmpDir));
      options.template = _isBlank(options.template) ? void 0 : path2.relative(options.dir, options.template);
      options.name = _isUndefined(options.name) ? void 0 : options.name;
      options.prefix = _isUndefined(options.prefix) ? "" : options.prefix;
      options.postfix = _isUndefined(options.postfix) ? "" : options.postfix;
    }
    function _resolvePath(name, tmpDir) {
      if (name.startsWith(tmpDir)) {
        return path2.resolve(name);
      } else {
        return path2.resolve(path2.join(tmpDir, name));
      }
    }
    function _assertIsRelative(name, option, tmpDir) {
      if (option === "name") {
        if (path2.isAbsolute(name))
          throw new Error(`${option} option must not contain an absolute path, found "${name}".`);
        let basename = path2.basename(name);
        if (basename === ".." || basename === "." || basename !== name)
          throw new Error(`${option} option must not contain a path, found "${name}".`);
      } else {
        if (path2.isAbsolute(name) && !name.startsWith(tmpDir)) {
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${name}".`);
        }
        let resolvedPath = _resolvePath(name, tmpDir);
        if (!resolvedPath.startsWith(tmpDir))
          throw new Error(`${option} option must be relative to "${tmpDir}", found "${resolvedPath}".`);
      }
    }
    function _isEBADF(error2) {
      return _isExpectedError(error2, -EBADF, "EBADF");
    }
    function _isENOENT(error2) {
      return _isExpectedError(error2, -ENOENT, "ENOENT");
    }
    function _isExpectedError(error2, errno, code) {
      return IS_WIN32 ? error2.code === code : error2.code === code && error2.errno === errno;
    }
    function setGracefulCleanup() {
      _gracefulCleanup = true;
    }
    function _getTmpDir(options) {
      return path2.resolve(options && options.tmpdir || os.tmpdir());
    }
    process.addListener(EXIT, _garbageCollector);
    Object.defineProperty(module.exports, "tmpdir", {
      enumerable: true,
      configurable: false,
      get: function() {
        return _getTmpDir();
      }
    });
    module.exports.dir = dir2;
    module.exports.dirSync = dirSync;
    module.exports.file = file2;
    module.exports.fileSync = fileSync;
    module.exports.tmpName = tmpName;
    module.exports.tmpNameSync = tmpNameSync;
    module.exports.setGracefulCleanup = setGracefulCleanup;
  })(tmp);
  return tmp.exports;
}
var iterateStream;
var hasRequiredIterateStream;
function requireIterateStream() {
  if (hasRequiredIterateStream) return iterateStream;
  hasRequiredIterateStream = 1;
  iterateStream = async function* iterateStream2(stream2) {
    const contents = [];
    stream2.on("data", (data2) => contents.push(data2));
    let resolveStreamEndedPromise;
    const streamEndedPromise = new Promise((resolve) => resolveStreamEndedPromise = resolve);
    let ended = false;
    stream2.on("end", () => {
      ended = true;
      resolveStreamEndedPromise();
    });
    let error2 = false;
    stream2.on("error", (err) => {
      error2 = err;
      resolveStreamEndedPromise();
    });
    while (!ended || contents.length > 0) {
      if (contents.length === 0) {
        stream2.resume();
        await Promise.race([once2(stream2, "data"), streamEndedPromise]);
      } else {
        stream2.pause();
        const data2 = contents.shift();
        yield data2;
      }
      if (error2) throw error2;
    }
    resolveStreamEndedPromise();
  };
  function once2(eventEmitter, type2) {
    return new Promise((resolve) => {
      let fired = false;
      const handler = () => {
        if (!fired) {
          fired = true;
          eventEmitter.removeListener(type2, handler);
          resolve();
        }
      };
      eventEmitter.addListener(type2, handler);
    });
  }
  return iterateStream;
}
var worksheetReader;
var hasRequiredWorksheetReader;
function requireWorksheetReader() {
  if (hasRequiredWorksheetReader) return worksheetReader;
  hasRequiredWorksheetReader = 1;
  const { EventEmitter: EventEmitter2 } = require$$2$1;
  const parseSax2 = requireParseSax();
  const _2 = requireUnderDash();
  const utils2 = requireUtils();
  const colCache = requireColCache();
  const Dimensions = requireRange();
  const Row = requireRow();
  const Column = requireColumn$1();
  class WorksheetReader extends EventEmitter2 {
    constructor({ workbook: workbook2, id, iterator: iterator2, options }) {
      super();
      this.workbook = workbook2;
      this.id = id;
      this.iterator = iterator2;
      this.options = options || {};
      this.name = `Sheet${this.id}`;
      this._columns = null;
      this._keys = {};
      this._dimensions = new Dimensions();
    }
    // destroy - not a valid operation for a streaming writer
    // even though some streamers might be able to, it's a bad idea.
    destroy() {
      throw new Error("Invalid Operation: destroy");
    }
    // return the current dimensions of the writer
    get dimensions() {
      return this._dimensions;
    }
    // =========================================================================
    // Columns
    // get the current columns array.
    get columns() {
      return this._columns;
    }
    // get a single column by col number. If it doesn't exist, it and any gaps before it
    // are created.
    getColumn(c) {
      if (typeof c === "string") {
        const col = this._keys[c];
        if (col) {
          return col;
        }
        c = colCache.l2n(c);
      }
      if (!this._columns) {
        this._columns = [];
      }
      if (c > this._columns.length) {
        let n = this._columns.length + 1;
        while (n <= c) {
          this._columns.push(new Column(this, n++));
        }
      }
      return this._columns[c - 1];
    }
    getColumnKey(key) {
      return this._keys[key];
    }
    setColumnKey(key, value) {
      this._keys[key] = value;
    }
    deleteColumnKey(key) {
      delete this._keys[key];
    }
    eachColumnKey(f) {
      _2.each(this._keys, f);
    }
    async read() {
      try {
        for await (const events of this.parse()) {
          for (const { eventType, value } of events) {
            this.emit(eventType, value);
          }
        }
        this.emit("finished");
      } catch (error2) {
        this.emit("error", error2);
      }
    }
    async *[Symbol.asyncIterator]() {
      for await (const events of this.parse()) {
        for (const { eventType, value } of events) {
          if (eventType === "row") {
            yield value;
          }
        }
      }
    }
    async *parse() {
      const { iterator: iterator2, options } = this;
      let emitSheet = false;
      let emitHyperlinks = false;
      let hyperlinks = null;
      switch (options.worksheets) {
        case "emit":
          emitSheet = true;
          break;
      }
      switch (options.hyperlinks) {
        case "emit":
          emitHyperlinks = true;
          break;
        case "cache":
          this.hyperlinks = hyperlinks = {};
          break;
      }
      if (!emitSheet && !emitHyperlinks && !hyperlinks) {
        return;
      }
      const { sharedStrings: sharedStrings2, styles, properties } = this.workbook;
      let inCols = false;
      let inRows = false;
      let inHyperlinks = false;
      let cols = null;
      let row2 = null;
      let c = null;
      let current = null;
      for await (const events of parseSax2(iterator2)) {
        const worksheetEvents = [];
        for (const { eventType, value } of events) {
          if (eventType === "opentag") {
            const node2 = value;
            if (emitSheet) {
              switch (node2.name) {
                case "cols":
                  inCols = true;
                  cols = [];
                  break;
                case "sheetData":
                  inRows = true;
                  break;
                case "col":
                  if (inCols) {
                    cols.push({
                      min: parseInt(node2.attributes.min, 10),
                      max: parseInt(node2.attributes.max, 10),
                      width: parseFloat(node2.attributes.width),
                      styleId: parseInt(node2.attributes.style || "0", 10)
                    });
                  }
                  break;
                case "row":
                  if (inRows) {
                    const r = parseInt(node2.attributes.r, 10);
                    row2 = new Row(this, r);
                    if (node2.attributes.ht) {
                      row2.height = parseFloat(node2.attributes.ht);
                    }
                    if (node2.attributes.s) {
                      const styleId = parseInt(node2.attributes.s, 10);
                      const style = styles.getStyleModel(styleId);
                      if (style) {
                        row2.style = style;
                      }
                    }
                  }
                  break;
                case "c":
                  if (row2) {
                    c = {
                      ref: node2.attributes.r,
                      s: parseInt(node2.attributes.s, 10),
                      t: node2.attributes.t
                    };
                  }
                  break;
                case "f":
                  if (c) {
                    current = c.f = { text: "" };
                  }
                  break;
                case "v":
                  if (c) {
                    current = c.v = { text: "" };
                  }
                  break;
                case "is":
                case "t":
                  if (c) {
                    current = c.v = { text: "" };
                  }
                  break;
              }
            }
            if (emitHyperlinks || hyperlinks) {
              switch (node2.name) {
                case "hyperlinks":
                  inHyperlinks = true;
                  break;
                case "hyperlink":
                  if (inHyperlinks) {
                    const hyperlink = {
                      ref: node2.attributes.ref,
                      rId: node2.attributes["r:id"]
                    };
                    if (emitHyperlinks) {
                      worksheetEvents.push({ eventType: "hyperlink", value: hyperlink });
                    } else {
                      hyperlinks[hyperlink.ref] = hyperlink;
                    }
                  }
                  break;
              }
            }
          } else if (eventType === "text") {
            if (emitSheet) {
              if (current) {
                current.text += value;
              }
            }
          } else if (eventType === "closetag") {
            const node2 = value;
            if (emitSheet) {
              switch (node2.name) {
                case "cols":
                  inCols = false;
                  this._columns = Column.fromModel(cols);
                  break;
                case "sheetData":
                  inRows = false;
                  break;
                case "row":
                  this._dimensions.expandRow(row2);
                  worksheetEvents.push({ eventType: "row", value: row2 });
                  row2 = null;
                  break;
                case "c":
                  if (row2 && c) {
                    const address = colCache.decodeAddress(c.ref);
                    const cell2 = row2.getCell(address.col);
                    if (c.s) {
                      const style = styles.getStyleModel(c.s);
                      if (style) {
                        cell2.style = style;
                      }
                    }
                    if (c.f) {
                      const cellValue = {
                        formula: c.f.text
                      };
                      if (c.v) {
                        if (c.t === "str") {
                          cellValue.result = utils2.xmlDecode(c.v.text);
                        } else {
                          cellValue.result = parseFloat(c.v.text);
                        }
                      }
                      cell2.value = cellValue;
                    } else if (c.v) {
                      switch (c.t) {
                        case "s": {
                          const index2 = parseInt(c.v.text, 10);
                          if (sharedStrings2) {
                            cell2.value = sharedStrings2[index2];
                          } else {
                            cell2.value = {
                              sharedString: index2
                            };
                          }
                          break;
                        }
                        case "inlineStr":
                        case "str":
                          cell2.value = utils2.xmlDecode(c.v.text);
                          break;
                        case "e":
                          cell2.value = { error: c.v.text };
                          break;
                        case "b":
                          cell2.value = parseInt(c.v.text, 10) !== 0;
                          break;
                        default:
                          if (utils2.isDateFmt(cell2.numFmt)) {
                            cell2.value = utils2.excelToDate(
                              parseFloat(c.v.text),
                              properties.model && properties.model.date1904
                            );
                          } else {
                            cell2.value = parseFloat(c.v.text);
                          }
                          break;
                      }
                    }
                    if (hyperlinks) {
                      const hyperlink = hyperlinks[c.ref];
                      if (hyperlink) {
                        cell2.text = cell2.value;
                        cell2.value = void 0;
                        cell2.hyperlink = hyperlink;
                      }
                    }
                    c = null;
                  }
                  break;
              }
            }
            if (emitHyperlinks || hyperlinks) {
              switch (node2.name) {
                case "hyperlinks":
                  inHyperlinks = false;
                  break;
              }
            }
          }
        }
        if (worksheetEvents.length > 0) {
          yield worksheetEvents;
        }
      }
    }
  }
  worksheetReader = WorksheetReader;
  return worksheetReader;
}
var hyperlinkReader;
var hasRequiredHyperlinkReader;
function requireHyperlinkReader() {
  if (hasRequiredHyperlinkReader) return hyperlinkReader;
  hasRequiredHyperlinkReader = 1;
  const { EventEmitter: EventEmitter2 } = require$$2$1;
  const parseSax2 = requireParseSax();
  const Enums = requireEnums();
  const RelType = requireRelType();
  class HyperlinkReader extends EventEmitter2 {
    constructor({ workbook: workbook2, id, iterator: iterator2, options }) {
      super();
      this.workbook = workbook2;
      this.id = id;
      this.iterator = iterator2;
      this.options = options;
    }
    get count() {
      return this.hyperlinks && this.hyperlinks.length || 0;
    }
    each(fn) {
      return this.hyperlinks.forEach(fn);
    }
    async read() {
      const { iterator: iterator2, options } = this;
      let emitHyperlinks = false;
      let hyperlinks = null;
      switch (options.hyperlinks) {
        case "emit":
          emitHyperlinks = true;
          break;
        case "cache":
          this.hyperlinks = hyperlinks = {};
          break;
      }
      if (!emitHyperlinks && !hyperlinks) {
        this.emit("finished");
        return;
      }
      try {
        for await (const events of parseSax2(iterator2)) {
          for (const { eventType, value } of events) {
            if (eventType === "opentag") {
              const node2 = value;
              if (node2.name === "Relationship") {
                const rId = node2.attributes.Id;
                switch (node2.attributes.Type) {
                  case RelType.Hyperlink:
                    {
                      const relationship = {
                        type: Enums.RelationshipType.Styles,
                        rId,
                        target: node2.attributes.Target,
                        targetMode: node2.attributes.TargetMode
                      };
                      if (emitHyperlinks) {
                        this.emit("hyperlink", relationship);
                      } else {
                        hyperlinks[relationship.rId] = relationship;
                      }
                    }
                    break;
                  default:
                    break;
                }
              }
            }
          }
        }
        this.emit("finished");
      } catch (error2) {
        this.emit("error", error2);
      }
    }
  }
  hyperlinkReader = HyperlinkReader;
  return hyperlinkReader;
}
var workbookReader;
var hasRequiredWorkbookReader;
function requireWorkbookReader() {
  if (hasRequiredWorkbookReader) return workbookReader;
  hasRequiredWorkbookReader = 1;
  const fs2 = require$$0$4;
  const { EventEmitter: EventEmitter2 } = require$$2$1;
  const { PassThrough, Readable: Readable2 } = requireReadable$4();
  const nodeStream = require$$0$1;
  const unzip2 = requireUnzip();
  const tmp2 = requireTmp();
  const iterateStream2 = requireIterateStream();
  const parseSax2 = requireParseSax();
  const StyleManager = requireStylesXform();
  const WorkbookXform = requireWorkbookXform();
  const RelationshipsXform = requireRelationshipsXform();
  const WorksheetReader = requireWorksheetReader();
  const HyperlinkReader = requireHyperlinkReader();
  tmp2.setGracefulCleanup();
  class WorkbookReader extends EventEmitter2 {
    constructor(input, options = {}) {
      super();
      this.input = input;
      this.options = {
        worksheets: "emit",
        sharedStrings: "cache",
        hyperlinks: "ignore",
        styles: "ignore",
        entries: "ignore",
        ...options
      };
      this.styles = new StyleManager();
      this.styles.init();
    }
    _getStream(input) {
      if (input instanceof nodeStream.Readable || input instanceof Readable2) {
        return input;
      }
      if (typeof input === "string") {
        return fs2.createReadStream(input);
      }
      throw new Error(`Could not recognise input: ${input}`);
    }
    async read(input, options) {
      try {
        for await (const { eventType, value } of this.parse(input, options)) {
          switch (eventType) {
            case "shared-strings":
              this.emit(eventType, value);
              break;
            case "worksheet":
              this.emit(eventType, value);
              await value.read();
              break;
            case "hyperlinks":
              this.emit(eventType, value);
              break;
          }
        }
        this.emit("end");
        this.emit("finished");
      } catch (error2) {
        this.emit("error", error2);
      }
    }
    async *[Symbol.asyncIterator]() {
      for await (const { eventType, value } of this.parse()) {
        if (eventType === "worksheet") {
          yield value;
        }
      }
    }
    async *parse(input, options) {
      if (options) this.options = options;
      const stream2 = this.stream = this._getStream(input || this.input);
      const zip2 = unzip2.Parse({ forceStream: true });
      stream2.pipe(zip2);
      const waitingWorkSheets = [];
      for await (const entry of iterateStream2(zip2)) {
        let match;
        let sheetNo;
        switch (entry.path) {
          case "_rels/.rels":
            break;
          case "xl/_rels/workbook.xml.rels":
            await this._parseRels(entry);
            break;
          case "xl/workbook.xml":
            await this._parseWorkbook(entry);
            break;
          case "xl/sharedStrings.xml":
            yield* this._parseSharedStrings(entry);
            break;
          case "xl/styles.xml":
            await this._parseStyles(entry);
            break;
          default:
            if (entry.path.match(/xl\/worksheets\/sheet\d+[.]xml/)) {
              match = entry.path.match(/xl\/worksheets\/sheet(\d+)[.]xml/);
              sheetNo = match[1];
              if (this.sharedStrings && this.workbookRels) {
                yield* this._parseWorksheet(iterateStream2(entry), sheetNo);
              } else {
                await new Promise((resolve, reject2) => {
                  tmp2.file((err, path2, fd, tempFileCleanupCallback) => {
                    if (err) {
                      return reject2(err);
                    }
                    waitingWorkSheets.push({ sheetNo, path: path2, tempFileCleanupCallback });
                    const tempStream = fs2.createWriteStream(path2);
                    tempStream.on("error", reject2);
                    entry.pipe(tempStream);
                    return tempStream.on("finish", () => {
                      return resolve();
                    });
                  });
                });
              }
            } else if (entry.path.match(/xl\/worksheets\/_rels\/sheet\d+[.]xml.rels/)) {
              match = entry.path.match(/xl\/worksheets\/_rels\/sheet(\d+)[.]xml.rels/);
              sheetNo = match[1];
              yield* this._parseHyperlinks(iterateStream2(entry), sheetNo);
            }
            break;
        }
        entry.autodrain();
      }
      for (const { sheetNo, path: path2, tempFileCleanupCallback } of waitingWorkSheets) {
        let fileStream = fs2.createReadStream(path2);
        if (!fileStream[Symbol.asyncIterator]) {
          fileStream = fileStream.pipe(new PassThrough());
        }
        yield* this._parseWorksheet(fileStream, sheetNo);
        tempFileCleanupCallback();
      }
    }
    _emitEntry(payload) {
      if (this.options.entries === "emit") {
        this.emit("entry", payload);
      }
    }
    async _parseRels(entry) {
      const xform = new RelationshipsXform();
      this.workbookRels = await xform.parseStream(iterateStream2(entry));
    }
    async _parseWorkbook(entry) {
      this._emitEntry({ type: "workbook" });
      const workbook2 = new WorkbookXform();
      await workbook2.parseStream(iterateStream2(entry));
      this.properties = workbook2.map.workbookPr;
      this.model = workbook2.model;
    }
    async *_parseSharedStrings(entry) {
      this._emitEntry({ type: "shared-strings" });
      switch (this.options.sharedStrings) {
        case "cache":
          this.sharedStrings = [];
          break;
        case "emit":
          break;
        default:
          return;
      }
      let text = null;
      let richText = [];
      let index2 = 0;
      let font = null;
      for await (const events of parseSax2(iterateStream2(entry))) {
        for (const { eventType, value } of events) {
          if (eventType === "opentag") {
            const node2 = value;
            switch (node2.name) {
              case "b":
                font = font || {};
                font.bold = true;
                break;
              case "charset":
                font = font || {};
                font.charset = parseInt(node2.attributes.charset, 10);
                break;
              case "color":
                font = font || {};
                font.color = {};
                if (node2.attributes.rgb) {
                  font.color.argb = node2.attributes.argb;
                }
                if (node2.attributes.val) {
                  font.color.argb = node2.attributes.val;
                }
                if (node2.attributes.theme) {
                  font.color.theme = node2.attributes.theme;
                }
                break;
              case "family":
                font = font || {};
                font.family = parseInt(node2.attributes.val, 10);
                break;
              case "i":
                font = font || {};
                font.italic = true;
                break;
              case "outline":
                font = font || {};
                font.outline = true;
                break;
              case "rFont":
                font = font || {};
                font.name = node2.value;
                break;
              case "si":
                font = null;
                richText = [];
                text = null;
                break;
              case "sz":
                font = font || {};
                font.size = parseInt(node2.attributes.val, 10);
                break;
              case "strike":
                break;
              case "t":
                text = null;
                break;
              case "u":
                font = font || {};
                font.underline = true;
                break;
              case "vertAlign":
                font = font || {};
                font.vertAlign = node2.attributes.val;
                break;
            }
          } else if (eventType === "text") {
            text = text ? text + value : value;
          } else if (eventType === "closetag") {
            const node2 = value;
            switch (node2.name) {
              case "r":
                richText.push({
                  font,
                  text
                });
                font = null;
                text = null;
                break;
              case "si":
                if (this.options.sharedStrings === "cache") {
                  this.sharedStrings.push(richText.length ? { richText } : text);
                } else if (this.options.sharedStrings === "emit") {
                  yield { index: index2++, text: richText.length ? { richText } : text };
                }
                richText = [];
                font = null;
                text = null;
                break;
            }
          }
        }
      }
    }
    async _parseStyles(entry) {
      this._emitEntry({ type: "styles" });
      if (this.options.styles === "cache") {
        this.styles = new StyleManager();
        await this.styles.parseStream(iterateStream2(entry));
      }
    }
    *_parseWorksheet(iterator2, sheetNo) {
      this._emitEntry({ type: "worksheet", id: sheetNo });
      const worksheetReader2 = new WorksheetReader({
        workbook: this,
        id: sheetNo,
        iterator: iterator2,
        options: this.options
      });
      const matchingRel = (this.workbookRels || []).find((rel) => rel.Target === `worksheets/sheet${sheetNo}.xml`);
      const matchingSheet = matchingRel && (this.model.sheets || []).find((sheet) => sheet.rId === matchingRel.Id);
      if (matchingSheet) {
        worksheetReader2.id = matchingSheet.id;
        worksheetReader2.name = matchingSheet.name;
        worksheetReader2.state = matchingSheet.state;
      }
      if (this.options.worksheets === "emit") {
        yield { eventType: "worksheet", value: worksheetReader2 };
      }
    }
    *_parseHyperlinks(iterator2, sheetNo) {
      this._emitEntry({ type: "hyperlinks", id: sheetNo });
      const hyperlinksReader = new HyperlinkReader({
        workbook: this,
        id: sheetNo,
        iterator: iterator2,
        options: this.options
      });
      if (this.options.hyperlinks === "emit") {
        yield { eventType: "hyperlinks", value: hyperlinksReader };
      }
    }
  }
  WorkbookReader.Options = {
    worksheets: ["emit", "ignore"],
    sharedStrings: ["cache", "emit", "ignore"],
    hyperlinks: ["cache", "emit", "ignore"],
    styles: ["cache", "ignore"],
    entries: ["emit", "ignore"]
  };
  workbookReader = WorkbookReader;
  return workbookReader;
}
var exceljs_nodejs;
var hasRequiredExceljs_nodejs;
function requireExceljs_nodejs() {
  if (hasRequiredExceljs_nodejs) return exceljs_nodejs;
  hasRequiredExceljs_nodejs = 1;
  const ExcelJS2 = {
    Workbook: requireWorkbook(),
    ModelContainer: requireModelcontainer(),
    stream: {
      xlsx: {
        WorkbookWriter: requireWorkbookWriter(),
        WorkbookReader: requireWorkbookReader()
      }
    }
  };
  Object.assign(ExcelJS2, requireEnums());
  exceljs_nodejs = ExcelJS2;
  return exceljs_nodejs;
}
var excel;
var hasRequiredExcel;
function requireExcel() {
  if (hasRequiredExcel) return excel;
  hasRequiredExcel = 1;
  if (parseInt(process.versions.node.split(".")[0], 10) < 10) {
    throw new Error(
      "For node versions older than 10, please use the ES5 Import: https://github.com/exceljs/exceljs#es5-imports"
    );
  }
  excel = requireExceljs_nodejs();
  return excel;
}
var excelExports = requireExcel();
const ExcelJS = /* @__PURE__ */ getDefaultExportFromCjs(excelExports);
let accessToken = "";
const __dirname = path$1.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$1.join(__dirname, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$1.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$1.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$1.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  win = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      preload: path$1.join(__dirname, "preload.mjs"),
      nodeIntegration: true,
      contextIsolation: false,
      webSecurity: false,
      allowRunningInsecureContent: false
    },
    title: "Dermaview"
  });
  win.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        "Content-Security-Policy": [
          "default-src 'self' 'unsafe-inline'; img-src 'self' data: file: local-image:"
        ]
      }
    });
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  win.webContents.on("before-input-event", (event, input) => {
    if (input.control && input.key.toLowerCase() === "r") {
      event.preventDefault();
    }
  });
  win.reload = () => {
  };
  win.webContents.reload = () => {
  };
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$1.join(RENDERER_DIST, "index.html"));
  }
}
ipcMain.on("console-log", (event, message) => {
  console.log("From Renderer:", message);
});
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.whenReady().then(() => {
  createWindow();
  app.name = "Dermaview";
  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
  const settingsPath = path$1.join(app.getPath("userData"), "settings.json");
  ipcMain.handle("load-settings", (event, _2) => {
    if (!fs.existsSync(settingsPath)) {
      return {};
    }
    const data2 = fs.readFileSync(settingsPath, "utf-8");
    return JSON.parse(data2);
  });
  ipcMain.handle("update-settings", (event, data2) => {
    fs.writeFileSync(settingsPath, JSON.stringify(data2, null, 2));
    console.log("Settings updated", data2);
    if (data2 == null ? void 0 : data2.rootDirPath) {
      const databaseFilePath = path$1.join(data2.rootDirPath, "database.db");
      if (databaseFilePath) {
        setConnection(databaseFilePath);
        ensureAllTableExists();
      }
    }
  });
  protocol.handle("local-image", (request) => {
    const url = request.url.replace("local-image://", "");
    let filePath = decodeURIComponent(url);
    if (!filePath.startsWith("/")) {
      filePath = "/" + filePath;
    }
    if (filePath.includes("/thumb_")) {
      const parts = filePath.split("/");
      const fileName = parts[parts.length - 1];
      if (parts.length > 2 && parts[parts.length - 2].includes(fileName.split(".")[0])) {
        const parentDir = parts.slice(0, parts.length - 1).join("/");
        filePath = parentDir;
      }
    }
    try {
      let contentType = "image/jpeg";
      if (filePath.toLowerCase().endsWith(".png")) {
        contentType = "image/png";
      } else if (filePath.toLowerCase().endsWith(".gif")) {
        contentType = "image/gif";
      }
      return new Response(fs.readFileSync(filePath), {
        headers: {
          "Content-Type": contentType
        }
      });
    } catch (error2) {
      console.error("  :", error2, filePath);
      const emptyImage = Buffer.from("R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", "base64");
      return new Response(emptyImage, {
        headers: {
          "Content-Type": "image/gif"
        }
      });
    }
  });
});
ipcMain.handle("http-request", async (event, options) => {
  var _a, _b, _c;
  try {
    console.log("  HTTP  :", options);
    const response = await axios(options);
    console.log("  HTTP :", response.status);
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers
    };
  } catch (error2) {
    console.error("  HTTP  :", error2);
    if (axios.isAxiosError(error2)) {
      return {
        error: true,
        status: (_a = error2.response) == null ? void 0 : _a.status,
        statusText: (_b = error2.response) == null ? void 0 : _b.statusText,
        data: (_c = error2.response) == null ? void 0 : _c.data,
        message: error2.message
      };
    }
    return {
      error: true,
      message: error2 instanceof Error ? error2.message : String(error2)
    };
  }
});
ipcMain.handle("file-upload", async (event, options) => {
  var _a, _b;
  try {
    console.log("    :", options.url);
    console.log("  :", options.files.length);
    console.log(" :", options.imgUploadDate);
    const formData = new FormData$1();
    if (options.imgUploadDate) {
      formData.append("imgUploadDate", options.imgUploadDate);
    }
    if (options.imgCluster) {
      formData.append("imgCluster", options.imgCluster);
    }
    if (options.regUserId) {
      formData.append("regUserId", options.regUserId);
      formData.append("reg_user_id", options.regUserId);
      formData.append("REG_USER_ID", options.regUserId);
      formData.append("userId", options.regUserId);
      formData.append("user_id", options.regUserId);
      console.log(" ID   :", options.regUserId);
    } else {
      formData.append("regUserId", "system");
      formData.append("reg_user_id", "system");
      formData.append("REG_USER_ID", "system");
      formData.append("userId", "system");
      formData.append("user_id", "system");
      console.log(" ID (system)   ");
    }
    for (const fileInfo of options.files) {
      try {
        const fileBuffer = fs.readFileSync(fileInfo.path);
        formData.append("files", fileBuffer, {
          filename: fileInfo.name,
          contentType: fileInfo.type || "application/octet-stream",
          knownLength: fileBuffer.length
        });
        console.log(` '${fileInfo.name}'  , : ${fileBuffer.length} `);
      } catch (error2) {
        console.error("  :", error2);
        throw new Error(` ${fileInfo == null ? void 0 : fileInfo.name}  : ${error2}`);
      }
    }
    const tokenToUse = accessToken || options.token || "";
    console.log("   :", tokenToUse ? " " : " ");
    if (!tokenToUse) {
      throw new Error("  .    .");
    }
    console.log("   ,   ");
    console.log("===    ===");
    console.log(" URL:", options.url);
    console.log(" : POST");
    console.log(" :", {
      ...formData.getHeaders(),
      "Authorization": `Bearer ${tokenToUse.substring(0, 10)}...`
      //    
    });
    console.log("FormData :", formData.getLengthSync() + " bytes");
    console.log("  :", (/* @__PURE__ */ new Date()).toISOString());
    const response = await axios.post(options.url, formData, {
      headers: {
        ...formData.getHeaders(),
        // form-data  getHeaders 
        "Authorization": `Bearer ${tokenToUse}`
      },
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      timeout: 3e4
      // 30  
    });
    console.log("===    ===");
    console.log("  :", response.status);
    console.log("  :", response.statusText);
    console.log(" :", response.headers);
    console.log(" :", response.data);
    console.log("  :", (/* @__PURE__ */ new Date()).toISOString());
    console.log("  ");
    if (options.imgUploadDate && response.status === 200) {
      try {
        console.log(` ,     (: ${options.imgUploadDate})`);
        const clusterResponse = await axios.post(
          `${options.url.split("/file/")[0]}/file/setRandomCluster?uploadDate=${options.imgUploadDate}`,
          {},
          {
            headers: {
              "Authorization": `Bearer ${tokenToUse}`
            }
          }
        );
        console.log("  :", clusterResponse.data);
      } catch (clusterError) {
        console.error("   :", clusterError);
      }
    }
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers
    };
  } catch (error2) {
    console.error("===    ===");
    console.error(" :", error2 == null ? void 0 : error2.message);
    if (axios.isAxiosError(error2)) {
      console.error("Axios  :", error2 == null ? void 0 : error2.code);
      console.error("Axios  :", (_a = error2 == null ? void 0 : error2.response) == null ? void 0 : _a.data);
      console.error("Axios  :", (_b = error2 == null ? void 0 : error2.response) == null ? void 0 : _b.status);
    }
    console.error("  :", (/* @__PURE__ */ new Date()).toISOString());
    console.error(" :", error2 == null ? void 0 : error2.stack);
    return {
      error: true,
      message: (error2 == null ? void 0 : error2.message) || "   "
    };
  }
});
ipcMain.on("set-access-token", (event, data2) => {
  accessToken = (data2 == null ? void 0 : data2.token) || "";
  console.log("  ");
});
ipcMain.on("get-access-token", (event) => {
  event.returnValue = { token: accessToken };
});
ipcMain.handle("select-folder", async () => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"]
  });
  if (result.canceled) return null;
  const folderPath = result.filePaths[0];
  return folderPath;
});
ipcMain.handle("get-images", (event, folderPath) => {
  const files = fs.readdirSync(folderPath);
  const images = files.filter((file2) => {
    const ext = path$1.extname(file2).toLowerCase();
    return [".jpg", ".jpeg", ".png", ".gif"].includes(ext);
  });
  return images.map((file2) => path$1.join(folderPath, file2));
});
ipcMain.handle("validate-path", async (event, folderPath) => {
  try {
    const exists = fs.existsSync(folderPath);
    const isDirectory = fs.lstatSync(folderPath).isDirectory();
    return exists && isDirectory;
  } catch (error2) {
    return false;
  }
});
ipcMain.handle("file-exists", async (event, folderPath) => {
  try {
    const exists = fs.existsSync(folderPath);
    const isFile2 = fs.lstatSync(folderPath).isFile();
    return exists && isFile2;
  } catch (error2) {
    return false;
  }
});
ipcMain.handle("fetch-database-root", (event, rootDirPath) => {
  if (!fs.existsSync(rootDirPath)) {
    fs.mkdirSync(rootDirPath, { recursive: true });
  }
  const dbPath = path$1.join(rootDirPath, "database.db");
  const isNewDatabase = !fs.existsSync(dbPath);
  if (!conn) {
    setConnection(dbPath);
  }
  return [isNewDatabase, dbPath];
});
ipcMain.handle("get-creation-time", async (_2, filePath) => {
  try {
    const creationTime = await getCreationTime(filePath);
    return creationTime || "Unknown";
  } catch (error2) {
    console.error("Error reading file metadata:", error2);
    return "Error";
  }
});
ipcMain.handle("get-image-metadata", async (_2, imagePath) => {
  try {
    const stats = fs.statSync(imagePath);
    const creationTime = await getCreationTime(imagePath);
    return {
      creationTime: creationTime || stats.birthtime.toISOString(),
      //   
      modificationTime: stats.mtime.toISOString(),
      //   
      size: stats.size
      //  
    };
  } catch (error2) {
    console.error(`Error getting metadata for ${imagePath}:`, error2);
    return {
      creationTime: (/* @__PURE__ */ new Date()).toISOString(),
      modificationTime: (/* @__PURE__ */ new Date()).toISOString(),
      size: 0
    };
  }
});
ipcMain.handle("search-images-by-criteria", async (_2, field, query) => {
  try {
    const settingsPath = path$1.join(app.getPath("userData"), "settings.json");
    const settingsData = fs.readFileSync(settingsPath, "utf-8");
    const settings = JSON.parse(settingsData);
    const baseDir = `${settings == null ? void 0 : settings.rootDirPath}/dermaview-server/upload` || "";
    const files = fs.readdirSync(baseDir);
    const imageFiles = files.filter((file2) => {
      const ext = path$1.extname(file2).toLowerCase();
      return [".jpg", ".jpeg", ".png", ".gif"].includes(ext);
    });
    const allImages = imageFiles.map((file2) => path$1.join(baseDir, file2));
    if (!query || query.trim() === "") {
      return allImages;
    }
    if (field === "") {
      return allImages.filter(
        (imagePath) => path$1.basename(imagePath).toLowerCase().includes(query.toLowerCase())
      );
    } else if (field === "") {
      const imagesWithMetadata = await Promise.all(
        allImages.map(async (imagePath) => {
          const metadata = await getCreationTime(imagePath);
          return { path: imagePath, creationTime: metadata };
        })
      );
      return imagesWithMetadata.filter((item) => {
        if (!item.creationTime) return false;
        const date = new Date(item.creationTime);
        const dateStr = date.toISOString().split("T")[0];
        return dateStr.includes(query);
      }).map((item) => item.path);
    }
    return allImages;
  } catch (error2) {
    console.error("Error searching images:", error2);
    return [];
  }
});
ipcMain.handle("select-download-folder", async () => {
  const result = await dialog.showOpenDialog({
    properties: ["openDirectory"],
    title: "  ",
    buttonLabel: ""
  });
  if (result.canceled) return null;
  return result.filePaths[0];
});
ipcMain.handle("download-image", async (_2, options) => {
  try {
    const { sourcePath, targetDir, fileName } = options;
    const targetPath = path$1.join(targetDir, fileName);
    fs.copyFileSync(sourcePath, targetPath);
    return { success: true, path: targetPath };
  } catch (error2) {
    console.error(" ()   :", error2);
    throw error2;
  }
});
ipcMain.handle("update-image-info", async (_2, options) => {
  try {
    console.log("   :", options);
    const tokenToUse = accessToken || options.token || "";
    if (!tokenToUse) {
      throw new Error("  .    .");
    }
    const response = await axios.post(
      `${options.url || "http://localhost:8080"}/file/updateImageInfo`,
      {
        imgId: options.imgId,
        imgRemark: options.imgRemark || "",
        imgModality: options.imgModality || "",
        imgBodyPart: options.imgBodyPart || "",
        imgCluster: options.imgCluster || "",
        modUserId: options.modUserId || "system"
      },
      {
        headers: {
          "Authorization": `Bearer ${tokenToUse}`,
          "Content-Type": "application/json"
        }
      }
    );
    return {
      status: response.status,
      data: response.data
    };
  } catch (error2) {
    console.error("     :", error2);
    return {
      error: true,
      message: error2 instanceof Error ? error2.message : "   "
    };
  }
});
ipcMain.handle("patient-image-download", async (_2, options) => {
  try {
    console.log("   :", options);
    const { imagePath, fileName } = options;
    if (!imagePath) {
      throw new Error("    .");
    }
    const result = await dialog.showOpenDialog({
      properties: ["openDirectory"],
      title: "   ",
      buttonLabel: ""
    });
    if (result.canceled) {
      console.log("   .");
      return { cancelled: true };
    }
    const downloadDir = result.filePaths[0];
    const saveFileName = fileName || path$1.basename(imagePath);
    const savePath = path$1.join(downloadDir, saveFileName);
    fs.copyFileSync(imagePath, savePath);
    console.log(`  .  : ${savePath}`);
    return {
      success: true,
      path: savePath
    };
  } catch (error2) {
    console.error("    :", error2);
    return {
      error: true,
      message: error2 instanceof Error ? error2.message : "   "
    };
  }
});
ipcMain.handle("set-representative-image", async (_2, options) => {
  try {
    console.log("   :", options);
    const { patientInfoId, imageId } = options;
    if (!patientInfoId || !imageId) {
      throw new Error(" ID   ID  .");
    }
    const tokenToUse = accessToken || options.token || "";
    if (!tokenToUse) {
      throw new Error("  .    .");
    }
    return {
      success: true,
      message: "  ."
    };
  } catch (error2) {
    console.error("     :", error2);
    return {
      error: true,
      message: error2 instanceof Error ? error2.message : "   "
    };
  }
});
ipcMain.handle("export-excel", async (_2, options) => {
  try {
    console.log("   :", options);
    const { data: data2 } = options;
    if (!data2 || !Array.isArray(data2) || data2.length === 0) {
      throw new Error("  .");
    }
    const cleanedData = data2.map((row2) => {
      const cleanRow = { ...row2 };
      Object.keys(cleanRow).forEach((key) => {
        if (cleanRow[key] === void 0 || cleanRow[key] === null || typeof cleanRow[key] === "string" && (cleanRow[key].includes("NaN") || cleanRow[key].includes("undefined"))) {
          cleanRow[key] = "-";
        }
      });
      return cleanRow;
    });
    const currentDate = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10).replace(/-/g, "");
    const defaultFileName = `_${currentDate}.xlsx`;
    const saveResult = await dialog.showSaveDialog({
      title: "  ",
      defaultPath: defaultFileName,
      filters: [
        { name: "Excel ", extensions: ["xlsx"] },
        { name: "CSV ", extensions: ["csv"] },
        { name: " ", extensions: ["*"] }
      ],
      properties: ["createDirectory", "showOverwriteConfirmation"]
    });
    if (saveResult.canceled || !saveResult.filePath) {
      console.log("  .");
      return { cancelled: true };
    }
    const savePath = saveResult.filePath;
    const isExcel = savePath.toLowerCase().endsWith(".xlsx");
    if (isExcel) {
      const workbook2 = new ExcelJS.Workbook();
      workbook2.creator = "Dermaview";
      workbook2.lastModifiedBy = "Dermaview Application";
      workbook2.created = /* @__PURE__ */ new Date();
      workbook2.modified = /* @__PURE__ */ new Date();
      const worksheet2 = workbook2.addWorksheet("");
      const headers2 = Object.keys(cleanedData[0]);
      worksheet2.addRow(headers2);
      const headerRow = worksheet2.getRow(1);
      headerRow.font = { bold: true, size: 12 };
      headerRow.fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "FFE0E0E0" }
      };
      headerRow.alignment = { vertical: "middle", horizontal: "center" };
      headerRow.eachCell((cell2) => {
        cell2.border = {
          top: { style: "thin" },
          left: { style: "thin" },
          bottom: { style: "thin" },
          right: { style: "thin" }
        };
      });
      cleanedData.forEach((item) => {
        const values = Object.values(item);
        worksheet2.addRow(values);
      });
      for (let i = 2; i <= cleanedData.length + 1; i++) {
        const row2 = worksheet2.getRow(i);
        row2.eachCell((cell2) => {
          cell2.border = {
            top: { style: "thin" },
            left: { style: "thin" },
            bottom: { style: "thin" },
            right: { style: "thin" }
          };
        });
      }
      worksheet2.columns.forEach((column2) => {
        let maxLength = 0;
        column2.eachCell({ includeEmpty: true }, (cell2) => {
          const columnLength = cell2.value ? cell2.value.toString().length : 10;
          if (columnLength > maxLength) {
            maxLength = columnLength;
          }
        });
        column2.width = maxLength < 10 ? 10 : maxLength + 2;
      });
      try {
        await workbook2.xlsx.writeFile(savePath);
        console.log(`Excel   .  : ${savePath}`);
        dialog.showMessageBox({
          type: "info",
          title: "  ",
          message: `  Excel  .
 : ${savePath}`
        });
        return {
          success: true,
          path: savePath,
          format: "excel"
        };
      } catch (error2) {
        console.error("Excel    :", error2);
        throw error2;
      }
    } else {
      const headers2 = Object.keys(cleanedData[0]).join(",");
      const rows = cleanedData.map(
        (row2) => Object.values(row2).map((val) => typeof val === "string" ? `"${val.replace(/"/g, '""')}"` : val).join(",")
      );
      const csvContent = [headers2, ...rows].join("\n");
      fs.writeFileSync(savePath, csvContent, "utf8");
      console.log(`CSV   .  : ${savePath}`);
      dialog.showMessageBox({
        type: "info",
        title: "  ",
        message: `  CSV  .
 : ${savePath}`
      });
      return {
        success: true,
        path: savePath,
        format: "csv"
      };
    }
  } catch (error2) {
    console.error("    :", error2);
    try {
      const currentDate = (/* @__PURE__ */ new Date()).toISOString().slice(0, 10).replace(/-/g, "");
      const csvPath = path$1.join(app.getPath("downloads"), `_${currentDate}.csv`);
      const cleanedData = data.map((row2) => {
        const cleanRow = { ...row2 };
        Object.keys(cleanRow).forEach((key) => {
          if (cleanRow[key] === void 0 || cleanRow[key] === null || typeof cleanRow[key] === "string" && (cleanRow[key].includes("NaN") || cleanRow[key].includes("undefined"))) {
            cleanRow[key] = "-";
          }
        });
        return cleanRow;
      });
      const headers2 = Object.keys(cleanedData[0]).join(",");
      const rows = cleanedData.map(
        (row2) => Object.values(row2).map((val) => typeof val === "string" ? `"${val.replace(/"/g, '""')}"` : val).join(",")
      );
      const csvContent = [headers2, ...rows].join("\n");
      fs.writeFileSync(csvPath, csvContent, "utf8");
      console.log(` : CSV   .  : ${csvPath}`);
      dialog.showMessageBox({
        type: "info",
        title: "   (CSV )",
        message: `      CSV  .
 : ${csvPath}`
      });
      return {
        success: true,
        path: csvPath,
        format: "csv",
        recovered: true
      };
    } catch (csvError) {
      console.error("CSV     :", csvError);
      dialog.showMessageBox({
        type: "error",
        title: "",
        message: `    .
${error2 instanceof Error ? error2.message : "   "}`
      });
      return {
        error: true,
        message: error2 instanceof Error ? error2.message : "   "
      };
    }
  }
});
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
